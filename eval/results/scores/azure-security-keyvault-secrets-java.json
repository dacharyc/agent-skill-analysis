{
  "skill_name": "azure-security-keyvault-secrets-java",
  "scored_at": "2026-02-16T09:31:23.552734+00:00",
  "model_judge": "claude-opus-4-6",
  "model_generation": "claude-sonnet-4-5-20250929",
  "contamination_score": 0.52,
  "risk_level": "high",
  "test_category": "sdk_cross_lang",
  "tasks": [
    {
      "task_id": "azure-security-keyvault-secrets-java-01",
      "task_type": "direct_target",
      "target_language": "java",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure Key Vault SDK usage (SecretClient, SecretClientBuilder, DefaultAzureCredentialBuilder, KeyVaultSecret, SecretProperties). The API usage is idiomatic for the Java Azure SDK, with proper use of builders and exception types. However, the code is truncated mid-function \u2014 it cuts off inside getCurrentSecret() and is missing the implementations of createNewSecretVersion(), disableOldVersion(), verifyNewVersion(), the RotationResult class, the SecretRotationException class, and the validateInputs() method. The overall structure and approach are well-designed with proper logging, DI-friendly constructors, and correct error handling for ResourceNotFoundException and HttpResponseException, but the incompleteness significantly impacts functional correctness.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "SecretClient",
                  "matched": true
                },
                {
                  "pattern": "DefaultAzureCredentialBuilder",
                  "matched": true
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "updateSecretProperties\\(",
                  "matched": true
                },
                {
                  "pattern": "setEnabled\\(false\\)",
                  "matched": true
                },
                {
                  "pattern": "ResourceNotFoundException",
                  "matched": true
                },
                {
                  "pattern": "HttpResponseException",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretClientBuilder",
                "SecretClient",
                "DefaultAzureCredentialBuilder",
                "setSecret\\(",
                "getSecret\\(",
                "updateSecretProperties\\(",
                "setEnabled\\(false\\)",
                "ResourceNotFoundException",
                "HttpResponseException"
              ],
              "expected_misses": [],
              "expected_hit_count": 9,
              "expected_total": 9,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient\\(",
                  "matched": false
                },
                {
                  "pattern": "from azure\\.keyvault",
                  "matched": false
                },
                {
                  "pattern": "require.*@azure/keyvault-secrets",
                  "matched": false
                },
                {
                  "pattern": "secret_client\\.set_secret",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.setSecret\\(.*\\{",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret\\.new",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct syntax and idiomatic use of the Azure Key Vault Secrets SDK for Java (SecretClient, SecretClientBuilder, DefaultAzureCredentialBuilder, KeyVaultSecret, SecretProperties, ResourceNotFoundException, HttpResponseException). The API usage is correct and idiomatic. However, the code is clearly truncated mid-line in the rotateSecretWithTags method, and several referenced helper methods (getCurrentSecret, disableSecretVersion, createNewSecretVersion, verifyNewVersion, handleHttpResponseException, validateInputs) and inner classes (RotationResult, SecretRotationException) are not shown. The core rotation logic in rotateSecret follows the correct pattern (get, disable, create, verify), but the incomplete output means significant portions of the implementation are missing.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "SecretClient",
                  "matched": true
                },
                {
                  "pattern": "DefaultAzureCredentialBuilder",
                  "matched": true
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "updateSecretProperties\\(",
                  "matched": true
                },
                {
                  "pattern": "setEnabled\\(false\\)",
                  "matched": true
                },
                {
                  "pattern": "ResourceNotFoundException",
                  "matched": true
                },
                {
                  "pattern": "HttpResponseException",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretClientBuilder",
                "SecretClient",
                "DefaultAzureCredentialBuilder",
                "setSecret\\(",
                "getSecret\\(",
                "updateSecretProperties\\(",
                "setEnabled\\(false\\)",
                "ResourceNotFoundException",
                "HttpResponseException"
              ],
              "expected_misses": [],
              "expected_hit_count": 9,
              "expected_total": 9,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.keyvault",
                  "matched": false
                },
                {
                  "pattern": "require.*@azure/keyvault-secrets",
                  "matched": false
                },
                {
                  "pattern": "secret_client\\.set_secret",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.setSecret\\(.*\\{",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret\\.new",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [
                "SecretClient\\("
              ],
              "anti_pattern_hit_count": 1,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.16666666666666666,
              "contamination_detected": true
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Java with correct Azure Key Vault SDK usage (SecretClient, DefaultAzureCredentialBuilder, KeyVaultSecret, SecretProperties). The API calls like secretClient.getSecret(), secretClient.setSecret(), and secretClient.updateSecretProperties() are idiomatic for the Java SDK. However, the code is truncated mid-method \u2014 the rotateSecretWithExpiration method, helper methods (getCurrentSecret, disableSecretVersion, createNewSecretVersion, verifySecretActive, handleHttpError), and the custom SecretRotationException class are all missing. The rotateSecretWithTags method has a minor API issue: creating a new KeyVaultSecret and then setting SecretProperties on it that way may not work correctly since setProperties expects the full properties object. The core rotation pattern (get, disable, create, verify) is well-structured for the portion that is complete, but significant implementation is missing due to truncation.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "SecretClient",
                  "matched": true
                },
                {
                  "pattern": "DefaultAzureCredentialBuilder",
                  "matched": true
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "updateSecretProperties\\(",
                  "matched": true
                },
                {
                  "pattern": "setEnabled\\(false\\)",
                  "matched": true
                },
                {
                  "pattern": "ResourceNotFoundException",
                  "matched": true
                },
                {
                  "pattern": "HttpResponseException",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretClientBuilder",
                "SecretClient",
                "DefaultAzureCredentialBuilder",
                "setSecret\\(",
                "getSecret\\(",
                "updateSecretProperties\\(",
                "setEnabled\\(false\\)",
                "ResourceNotFoundException",
                "HttpResponseException"
              ],
              "expected_misses": [],
              "expected_hit_count": 9,
              "expected_total": 9,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient\\(",
                  "matched": false
                },
                {
                  "pattern": "from azure\\.keyvault",
                  "matched": false
                },
                {
                  "pattern": "require.*@azure/keyvault-secrets",
                  "matched": false
                },
                {
                  "pattern": "secret_client\\.set_secret",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.setSecret\\(.*\\{",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret\\.new",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 3,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure Key Vault SDK usage (SecretClient, DefaultAzureCredentialBuilder, KeyVaultSecret, SecretProperties). The API usage is idiomatic for the Java Azure SDK, including proper use of setSecret to create new versions and updateSecretProperties to disable old ones. However, the code is clearly truncated mid-method (cut off at 'updateSecre'), leaving createNewSecretVersion, disableOldVersions, verifySecretVersion, and the custom exception class incomplete. The implemented portions demonstrate good patterns including proper logging, Spring integration, and error handling with the requested exception types.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "SecretClient",
                  "matched": true
                },
                {
                  "pattern": "DefaultAzureCredentialBuilder",
                  "matched": true
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "updateSecretProperties\\(",
                  "matched": true
                },
                {
                  "pattern": "setEnabled\\(false\\)",
                  "matched": true
                },
                {
                  "pattern": "ResourceNotFoundException",
                  "matched": true
                },
                {
                  "pattern": "HttpResponseException",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretClientBuilder",
                "SecretClient",
                "DefaultAzureCredentialBuilder",
                "setSecret\\(",
                "getSecret\\(",
                "updateSecretProperties\\(",
                "setEnabled\\(false\\)",
                "ResourceNotFoundException",
                "HttpResponseException"
              ],
              "expected_misses": [],
              "expected_hit_count": 9,
              "expected_total": 9,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient\\(",
                  "matched": false
                },
                {
                  "pattern": "from azure\\.keyvault",
                  "matched": false
                },
                {
                  "pattern": "require.*@azure/keyvault-secrets",
                  "matched": false
                },
                {
                  "pattern": "secret_client\\.set_secret",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.setSecret\\(.*\\{",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret\\.new",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in correct Java with idiomatic use of the Azure Key Vault Secrets SDK for Java (SecretClient, SecretClientBuilder, DefaultAzureCredentialBuilder, KeyVaultSecret, SecretProperties). The API usage aligns precisely with the azure-security-keyvault-secrets Java SDK. However, the code is clearly truncated mid-function \u2014 helper methods (getCurrentSecret, disableOldVersion, createNewVersion, verifyNewVersion), the RotationResult class, SecretMetadata class, and the custom SecretRotationException are all missing, which means significant portions of the task implementation are absent. What is present is well-structured with good error handling patterns, logging, input validation, and a testability-friendly constructor.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "SecretClient",
                  "matched": true
                },
                {
                  "pattern": "DefaultAzureCredentialBuilder",
                  "matched": true
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "updateSecretProperties\\(",
                  "matched": true
                },
                {
                  "pattern": "setEnabled\\(false\\)",
                  "matched": true
                },
                {
                  "pattern": "ResourceNotFoundException",
                  "matched": true
                },
                {
                  "pattern": "HttpResponseException",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretClientBuilder",
                "SecretClient",
                "DefaultAzureCredentialBuilder",
                "setSecret\\(",
                "getSecret\\(",
                "updateSecretProperties\\(",
                "setEnabled\\(false\\)",
                "ResourceNotFoundException",
                "HttpResponseException"
              ],
              "expected_misses": [],
              "expected_hit_count": 9,
              "expected_total": 9,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient\\(",
                  "matched": false
                },
                {
                  "pattern": "from azure\\.keyvault",
                  "matched": false
                },
                {
                  "pattern": "require.*@azure/keyvault-secrets",
                  "matched": false
                },
                {
                  "pattern": "secret_client\\.set_secret",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.setSecret\\(.*\\{",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret\\.new",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [
                "SecretProperties constructor used incorrectly with setExpiresOn/setContentType/setTags chaining on a new SecretProperties() - in the Java SDK, properties are typically retrieved from the secret and modified, not constructed fresh and set on a new KeyVaultSecret via setProperties()",
                "KeyVaultSecret does not have a setProperties() method in the Java SDK; properties are accessed via getProperties() and mutated in place",
                "new KeyVaultSecret(secretName, newValue).setProperties(...) pattern does not match the actual Java SDK API - this may be confused with the .NET SDK pattern where properties can be set more freely"
              ],
              "brief_assessment": "The code is entirely in Java with proper structure, logging, and Spring integration. However, it is truncated mid-method, missing the implementations of getCurrentSecret(), disableSecretVersion(), createNewSecretVersion(), verifySecretActive(), and the custom exception class. The rotateSecretWithMetadata method uses an incorrect API pattern \u2014 KeyVaultSecret.setProperties() does not exist in the Java SDK, and constructing a new SecretProperties() to chain setExpiresOn/setTags/setContentType on it reflects .NET SDK contamination. The core rotateSecret flow is logically sound but incomplete due to truncation.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "SecretClient",
                  "matched": true
                },
                {
                  "pattern": "DefaultAzureCredentialBuilder",
                  "matched": true
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "updateSecretProperties\\(",
                  "matched": true
                },
                {
                  "pattern": "setEnabled\\(false\\)",
                  "matched": true
                },
                {
                  "pattern": "ResourceNotFoundException",
                  "matched": true
                },
                {
                  "pattern": "HttpResponseException",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretClientBuilder",
                "SecretClient",
                "DefaultAzureCredentialBuilder",
                "setSecret\\(",
                "getSecret\\(",
                "updateSecretProperties\\(",
                "setEnabled\\(false\\)",
                "ResourceNotFoundException",
                "HttpResponseException"
              ],
              "expected_misses": [],
              "expected_hit_count": 9,
              "expected_total": 9,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient\\(",
                  "matched": false
                },
                {
                  "pattern": "from azure\\.keyvault",
                  "matched": false
                },
                {
                  "pattern": "require.*@azure/keyvault-secrets",
                  "matched": false
                },
                {
                  "pattern": "secret_client\\.set_secret",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.setSecret\\(.*\\{",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret\\.new",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Java with correct Azure Key Vault SDK usage (SecretClient, DefaultAzureCredentialBuilder, KeyVaultSecret, SecretProperties). The API usage is idiomatic for the Java SDK \u2014 vaultUrl(), credential(), buildClient(), getSecret(), setSecret(), and proper exception types (ResourceNotFoundException, HttpResponseException) are all correct. However, the code is clearly truncated mid-function (cut off at 'cat' in a catch block), meaning the getCurrentSecret, disableSecretVersion, verifySecretVersion, createNewSecretVersion helper methods and the RotationResult/SecretRotationException classes are missing. The main rotateSecret method logic is complete and well-structured, but the incomplete helper methods significantly impact functional completeness.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "SecretClient",
                  "matched": true
                },
                {
                  "pattern": "DefaultAzureCredentialBuilder",
                  "matched": true
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "updateSecretProperties\\(",
                  "matched": true
                },
                {
                  "pattern": "setEnabled\\(false\\)",
                  "matched": true
                },
                {
                  "pattern": "ResourceNotFoundException",
                  "matched": true
                },
                {
                  "pattern": "HttpResponseException",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretClientBuilder",
                "SecretClient",
                "DefaultAzureCredentialBuilder",
                "setSecret\\(",
                "getSecret\\(",
                "updateSecretProperties\\(",
                "setEnabled\\(false\\)",
                "ResourceNotFoundException",
                "HttpResponseException"
              ],
              "expected_misses": [],
              "expected_hit_count": 9,
              "expected_total": 9,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient\\(",
                  "matched": false
                },
                {
                  "pattern": "from azure\\.keyvault",
                  "matched": false
                },
                {
                  "pattern": "require.*@azure/keyvault-secrets",
                  "matched": false
                },
                {
                  "pattern": "secret_client\\.set_secret",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.setSecret\\(.*\\{",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret\\.new",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 3,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Java with correct Azure SDK imports and idiomatic use of SecretClient, DefaultAzureCredentialBuilder, and related classes. However, the code is truncated mid-method \u2014 it cuts off inside getCurrentSecret(), meaning the critical implementations of disableSecretVersion, createNewSecretVersion, verifyNewVersion, and all supporting classes (RotationResult, SecretMetadata, SecretRotationException) are missing. The builder-style RotationResult usage suggests a Lombok or custom builder pattern that is never defined. What is present shows good structure, proper error handling setup, and clean Java conventions.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "SecretClient",
                  "matched": true
                },
                {
                  "pattern": "DefaultAzureCredentialBuilder",
                  "matched": true
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "updateSecretProperties\\(",
                  "matched": true
                },
                {
                  "pattern": "setEnabled\\(false\\)",
                  "matched": true
                },
                {
                  "pattern": "ResourceNotFoundException",
                  "matched": true
                },
                {
                  "pattern": "HttpResponseException",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretClientBuilder",
                "SecretClient",
                "DefaultAzureCredentialBuilder",
                "setSecret\\(",
                "getSecret\\(",
                "updateSecretProperties\\(",
                "setEnabled\\(false\\)",
                "ResourceNotFoundException",
                "HttpResponseException"
              ],
              "expected_misses": [],
              "expected_hit_count": 9,
              "expected_total": 9,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient\\(",
                  "matched": false
                },
                {
                  "pattern": "from azure\\.keyvault",
                  "matched": false
                },
                {
                  "pattern": "require.*@azure/keyvault-secrets",
                  "matched": false
                },
                {
                  "pattern": "secret_client\\.set_secret",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.setSecret\\(.*\\{",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret\\.new",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure Key Vault Secrets SDK usage. The SecretClient, DefaultAzureCredentialBuilder, SecretProperties, and KeyVaultSecret APIs are used idiomatically matching the Java SDK. The core rotation logic (get current, disable old, create new, verify) is properly implemented with correct error handling for ResourceNotFoundException and HttpResponseException. However, the code is truncated mid-method in rotateSecretWithMetadata, which prevents full completeness. The main rotateSecret method is fully implemented and well-structured with proper logging and exception handling.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "SecretClient",
                  "matched": true
                },
                {
                  "pattern": "DefaultAzureCredentialBuilder",
                  "matched": true
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "updateSecretProperties\\(",
                  "matched": true
                },
                {
                  "pattern": "setEnabled\\(false\\)",
                  "matched": true
                },
                {
                  "pattern": "ResourceNotFoundException",
                  "matched": true
                },
                {
                  "pattern": "HttpResponseException",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretClientBuilder",
                "SecretClient",
                "DefaultAzureCredentialBuilder",
                "setSecret\\(",
                "getSecret\\(",
                "updateSecretProperties\\(",
                "setEnabled\\(false\\)",
                "ResourceNotFoundException",
                "HttpResponseException"
              ],
              "expected_misses": [],
              "expected_hit_count": 9,
              "expected_total": 9,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient\\(",
                  "matched": false
                },
                {
                  "pattern": "from azure\\.keyvault",
                  "matched": false
                },
                {
                  "pattern": "require.*@azure/keyvault-secrets",
                  "matched": false
                },
                {
                  "pattern": "secret_client\\.set_secret",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.setSecret\\(.*\\{",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret\\.new",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "azure-security-keyvault-secrets-java-02",
      "task_type": "cross_language",
      "target_language": "python",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python with idiomatic use of the azure-keyvault-secrets SDK \u2014 it properly uses DefaultAzureCredential, SecretClient, list_properties_of_secrets(), checks the enabled property, and retrieves values with get_secret(). The code is well-structured with type hints, docstrings, and proper error handling. However, it is truncated at the end (the create_gitignore_entry function and likely a main block are cut off), which slightly impacts functional completeness but the core task (list secrets, retrieve enabled values, write .env file) is fully implemented.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from azure\\.keyvault\\.secrets import SecretClient",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.identity import DefaultAzureCredential",
                  "matched": true
                },
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "vault_url=",
                  "matched": true
                },
                {
                  "pattern": "list_properties_of_secrets",
                  "matched": true
                },
                {
                  "pattern": "get_secret\\(",
                  "matched": true
                },
                {
                  "pattern": "\\.value",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from azure\\.keyvault\\.secrets import SecretClient",
                "from azure\\.identity import DefaultAzureCredential",
                "SecretClient\\(",
                "vault_url=",
                "list_properties_of_secrets",
                "get_secret\\(",
                "\\.value"
              ],
              "expected_misses": [],
              "expected_hit_count": 7,
              "expected_total": 7,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "\\.buildClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "import com\\.azure",
                  "matched": false
                },
                {
                  "pattern": "new SecretClientBuilder\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "listPropertiesOfSecrets\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python with idiomatic use of the azure-keyvault-secrets SDK (DefaultAzureCredential, SecretClient, list_properties_of_secrets, get_secret, properties.enabled, etc.). However, the code is truncated mid-function \u2014 the export_to_env_file method is cut off, meaning the critical .env file writing logic is missing, which is a core part of the task. The implemented portions demonstrate good error handling, clear structure, and thoughtful features like expiration/not-before checks and environment variable name sanitization.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from azure\\.keyvault\\.secrets import SecretClient",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.identity import DefaultAzureCredential",
                  "matched": true
                },
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "vault_url=",
                  "matched": true
                },
                {
                  "pattern": "list_properties_of_secrets",
                  "matched": true
                },
                {
                  "pattern": "get_secret\\(",
                  "matched": true
                },
                {
                  "pattern": "\\.value",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from azure\\.keyvault\\.secrets import SecretClient",
                "from azure\\.identity import DefaultAzureCredential",
                "SecretClient\\(",
                "vault_url=",
                "list_properties_of_secrets",
                "get_secret\\(",
                "\\.value"
              ],
              "expected_misses": [],
              "expected_hit_count": 7,
              "expected_total": 7,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "\\.buildClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "import com\\.azure",
                  "matched": false
                },
                {
                  "pattern": "new SecretClientBuilder\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "listPropertiesOfSecrets\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Python code that correctly uses the azure-keyvault-secrets SDK. It properly uses DefaultAzureCredential for authentication, SecretClient with vault_url parameter, list_properties_of_secrets() to iterate secret properties, checks the enabled flag, and retrieves values with get_secret(). The code is well-structured with proper error handling, logging, value escaping for the .env format, and secret name sanitization. No cross-language contamination detected.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from azure\\.keyvault\\.secrets import SecretClient",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.identity import DefaultAzureCredential",
                  "matched": true
                },
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "vault_url=",
                  "matched": true
                },
                {
                  "pattern": "list_properties_of_secrets",
                  "matched": true
                },
                {
                  "pattern": "get_secret\\(",
                  "matched": true
                },
                {
                  "pattern": "\\.value",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from azure\\.keyvault\\.secrets import SecretClient",
                "from azure\\.identity import DefaultAzureCredential",
                "SecretClient\\(",
                "vault_url=",
                "list_properties_of_secrets",
                "get_secret\\(",
                "\\.value"
              ],
              "expected_misses": [],
              "expected_hit_count": 7,
              "expected_total": 7,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "\\.buildClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "import com\\.azure",
                  "matched": false
                },
                {
                  "pattern": "new SecretClientBuilder\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "listPropertiesOfSecrets\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python with idiomatic use of the azure-keyvault-secrets SDK: DefaultAzureCredential, SecretClient, list_properties_of_secrets(), checking secret_property.enabled, and get_secret() are all correct API patterns. The code is well-structured with type hints, docstrings, error handling, and thoughtful features like .gitignore management and value escaping. However, the code is truncated (create_gitignore_entry is cut off, and there's no main block showing vault_url being defined, which is also referenced as a free variable in export_to_env_file), and the export_to_env_file function references an undefined `vault_url` variable in its f-string header comment, which is a bug.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from azure\\.keyvault\\.secrets import SecretClient",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.identity import DefaultAzureCredential",
                  "matched": true
                },
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "vault_url=",
                  "matched": true
                },
                {
                  "pattern": "list_properties_of_secrets",
                  "matched": true
                },
                {
                  "pattern": "get_secret\\(",
                  "matched": true
                },
                {
                  "pattern": "\\.value",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from azure\\.keyvault\\.secrets import SecretClient",
                "from azure\\.identity import DefaultAzureCredential",
                "SecretClient\\(",
                "vault_url=",
                "list_properties_of_secrets",
                "get_secret\\(",
                "\\.value"
              ],
              "expected_misses": [],
              "expected_hit_count": 7,
              "expected_total": 7,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "\\.buildClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "import com\\.azure",
                  "matched": false
                },
                {
                  "pattern": "new SecretClientBuilder\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "listPropertiesOfSecrets\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with correct, idiomatic usage of the azure-keyvault-secrets and azure-identity SDKs (DefaultAzureCredential, SecretClient, list_properties_of_secrets, get_secret, SecretProperties). However, the code is truncated mid-function \u2014 the critical export_to_env_file method that actually writes the .env file is cut off, and presumably the main/argparse entry point is also missing. This means the core deliverable (exporting to .env) is not fully implemented. The portions that exist are well-structured with good error handling, documentation, and thoughtful features like expiration checking and name sanitization.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from azure\\.keyvault\\.secrets import SecretClient",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.identity import DefaultAzureCredential",
                  "matched": true
                },
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "vault_url=",
                  "matched": true
                },
                {
                  "pattern": "list_properties_of_secrets",
                  "matched": true
                },
                {
                  "pattern": "get_secret\\(",
                  "matched": true
                },
                {
                  "pattern": "\\.value",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from azure\\.keyvault\\.secrets import SecretClient",
                "from azure\\.identity import DefaultAzureCredential",
                "SecretClient\\(",
                "vault_url=",
                "list_properties_of_secrets",
                "get_secret\\(",
                "\\.value"
              ],
              "expected_misses": [],
              "expected_hit_count": 7,
              "expected_total": 7,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "\\.buildClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "import com\\.azure",
                  "matched": false
                },
                {
                  "pattern": "new SecretClientBuilder\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "listPropertiesOfSecrets\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Python with correct, idiomatic use of the azure-keyvault-secrets SDK (SecretClient, list_properties_of_secrets, get_secret, checking secret_properties.enabled) and DefaultAzureCredential. It accomplishes the core task\u2014listing secrets, retrieving enabled ones, and writing a .env file\u2014but is truncated at the end of main(), missing the final lines that call export_secrets_to_env and the if __name__ block. The backup rename logic has a minor bug (output_path.with_suffix('.env.backup') on a file named '.env' produces '.env.backup', but the original is moved so it works). Overall, well-structured with good error handling and logging, just incomplete due to truncation.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from azure\\.keyvault\\.secrets import SecretClient",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.identity import DefaultAzureCredential",
                  "matched": true
                },
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "vault_url=",
                  "matched": true
                },
                {
                  "pattern": "list_properties_of_secrets",
                  "matched": true
                },
                {
                  "pattern": "get_secret\\(",
                  "matched": true
                },
                {
                  "pattern": "\\.value",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from azure\\.keyvault\\.secrets import SecretClient",
                "from azure\\.identity import DefaultAzureCredential",
                "SecretClient\\(",
                "vault_url=",
                "list_properties_of_secrets",
                "get_secret\\(",
                "\\.value"
              ],
              "expected_misses": [],
              "expected_hit_count": 7,
              "expected_total": 7,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "\\.buildClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "import com\\.azure",
                  "matched": false
                },
                {
                  "pattern": "new SecretClientBuilder\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "listPropertiesOfSecrets\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with correct, idiomatic usage of the azure-keyvault-secrets SDK (SecretClient, list_properties_of_secrets, get_secret, DefaultAzureCredential). It correctly checks secret_property.enabled to filter secrets and retrieves values for enabled ones. However, the main() function is truncated \u2014 it sets up configuration but is cut off before actually calling the helper functions (creating the client, listing secrets, retrieving values, and writing the .env file), so the script as written would not fully execute the task. The code quality is good with proper docstrings, type hints, error handling, and thoughtful extras like .gitignore management and name sanitization.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from azure\\.keyvault\\.secrets import SecretClient",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.identity import DefaultAzureCredential",
                  "matched": true
                },
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "vault_url=",
                  "matched": true
                },
                {
                  "pattern": "list_properties_of_secrets",
                  "matched": true
                },
                {
                  "pattern": "get_secret\\(",
                  "matched": true
                },
                {
                  "pattern": "\\.value",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from azure\\.keyvault\\.secrets import SecretClient",
                "from azure\\.identity import DefaultAzureCredential",
                "SecretClient\\(",
                "vault_url=",
                "list_properties_of_secrets",
                "get_secret\\(",
                "\\.value"
              ],
              "expected_misses": [],
              "expected_hit_count": 7,
              "expected_total": 7,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "\\.buildClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "import com\\.azure",
                  "matched": false
                },
                {
                  "pattern": "new SecretClientBuilder\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "listPropertiesOfSecrets\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with correct, idiomatic use of the azure-keyvault-secrets SDK (SecretClient, list_properties_of_secrets, get_secret, DefaultAzureCredential). However, the code is truncated mid-function \u2014 the _should_skip_secret method, _write_env_file, _print_summary, _to_env_var_name helper methods, and the main entry point are all missing. The core logic for listing secrets, checking enabled status, retrieving values, and writing to .env is well-structured in the completed portions, but the incomplete state means it would not run as-is and several task requirements (actually writing the .env file) are not fully implemented.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from azure\\.keyvault\\.secrets import SecretClient",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.identity import DefaultAzureCredential",
                  "matched": true
                },
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "vault_url=",
                  "matched": true
                },
                {
                  "pattern": "list_properties_of_secrets",
                  "matched": true
                },
                {
                  "pattern": "get_secret\\(",
                  "matched": true
                },
                {
                  "pattern": "\\.value",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from azure\\.keyvault\\.secrets import SecretClient",
                "from azure\\.identity import DefaultAzureCredential",
                "SecretClient\\(",
                "vault_url=",
                "list_properties_of_secrets",
                "get_secret\\(",
                "\\.value"
              ],
              "expected_misses": [],
              "expected_hit_count": 7,
              "expected_total": 7,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "\\.buildClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "import com\\.azure",
                  "matched": false
                },
                {
                  "pattern": "new SecretClientBuilder\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "listPropertiesOfSecrets\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Python code that correctly uses the azure-keyvault-secrets SDK. It properly uses DefaultAzureCredential, client.list_properties_of_secrets() to enumerate secrets, checks props.enabled to skip disabled secrets, and retrieves values with client.get_secret(). The code includes thorough error handling, proper escaping for .env file values, name sanitization (hyphens to underscores), secure file permissions, and well-structured logging. No cross-language contamination detected.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from azure\\.keyvault\\.secrets import SecretClient",
                  "matched": true
                },
                {
                  "pattern": "from azure\\.identity import DefaultAzureCredential",
                  "matched": true
                },
                {
                  "pattern": "SecretClient\\(",
                  "matched": true
                },
                {
                  "pattern": "vault_url=",
                  "matched": true
                },
                {
                  "pattern": "list_properties_of_secrets",
                  "matched": true
                },
                {
                  "pattern": "get_secret\\(",
                  "matched": true
                },
                {
                  "pattern": "\\.value",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from azure\\.keyvault\\.secrets import SecretClient",
                "from azure\\.identity import DefaultAzureCredential",
                "SecretClient\\(",
                "vault_url=",
                "list_properties_of_secrets",
                "get_secret\\(",
                "\\.value"
              ],
              "expected_misses": [],
              "expected_hit_count": 7,
              "expected_total": 7,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "\\.buildClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "import com\\.azure",
                  "matched": false
                },
                {
                  "pattern": "new SecretClientBuilder\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "listPropertiesOfSecrets\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "azure-security-keyvault-secrets-java-03",
      "task_type": "similar_syntax",
      "target_language": "java",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 2,
              "code_quality": 3,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Java with correct Azure Key Vault SecretAsyncClient API usage and proper Reactor/Project Reactor patterns. The Azure SDK classes (SecretAsyncClient, DefaultAzureCredentialBuilder, KeyVaultSecret) are used idiomatically. However, the code is severely truncated \u2014 it cuts off mid-method in SecretResult.java, meaning the core service classes (SecretRetrievalService, ConfigurationService) that would implement the concurrent retrieval, error handling, and configuration map assembly are completely missing. This means the primary task requirements are not actually implemented in the provided code.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretAsyncClient",
                  "matched": true
                },
                {
                  "pattern": "buildAsyncClient\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "subscribe\\(",
                  "matched": false
                },
                {
                  "pattern": "Mono|Flux|reactor",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "onError|doOnError|onErrorResume",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretAsyncClient",
                "buildAsyncClient\\(\\)",
                "Mono|Flux|reactor",
                "getSecret\\(",
                "onError|doOnError|onErrorResume"
              ],
              "expected_misses": [
                "subscribe\\("
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "buildClient\\(\\)(?!.*Async)",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.getSecret(?!.*subscribe)",
                  "matched": false
                },
                {
                  "pattern": "CompletableFuture",
                  "matched": false
                },
                {
                  "pattern": "async def|await ",
                  "matched": false
                },
                {
                  "pattern": "asyncio",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 2,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct syntax and idiomatic use of the Azure Key Vault SecretAsyncClient and Project Reactor patterns. The API usage follows proper Azure SDK conventions (SecretAsyncClient, DefaultAzureCredentialBuilder, reactive Mono/Flux patterns). However, the code is severely truncated \u2014 it cuts off mid-class in SecretResult.java, and the critical AsyncConfigLoader.java, ConfigurationManager.java, and KeyVaultConfigDemo.java files that would contain the core concurrent retrieval logic, configuration map assembly, and error handling are never shown. Only supporting/enum classes and project setup are complete, meaning less than half the task is actually implemented.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretAsyncClient",
                  "matched": true
                },
                {
                  "pattern": "buildAsyncClient\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "subscribe\\(",
                  "matched": false
                },
                {
                  "pattern": "Mono|Flux|reactor",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "onError|doOnError|onErrorResume",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretAsyncClient",
                "buildAsyncClient\\(\\)",
                "Mono|Flux|reactor",
                "getSecret\\(",
                "onError|doOnError|onErrorResume"
              ],
              "expected_misses": [
                "subscribe\\("
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "buildClient\\(\\)(?!.*Async)",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.getSecret(?!.*subscribe)",
                  "matched": false
                },
                {
                  "pattern": "CompletableFuture",
                  "matched": false
                },
                {
                  "pattern": "async def|await ",
                  "matched": false
                },
                {
                  "pattern": "asyncio",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Java using idiomatic Azure Key Vault SecretAsyncClient with Project Reactor patterns. It correctly uses Flux.fromIterable/flatMap for concurrent retrieval, onErrorResume for individual failure handling, and ConcurrentHashMap for thread-safe aggregation. The code is truncated at the end (getSecretValueAsync is cut off), and the retry logic uses simple .retry() rather than true exponential backoff despite the Javadoc claiming otherwise, but the core task of concurrent retrieval with per-secret error handling is well implemented. No cross-language contamination detected.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretAsyncClient",
                  "matched": true
                },
                {
                  "pattern": "buildAsyncClient\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "subscribe\\(",
                  "matched": true
                },
                {
                  "pattern": "Mono|Flux|reactor",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "onError|doOnError|onErrorResume",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretAsyncClient",
                "buildAsyncClient\\(\\)",
                "subscribe\\(",
                "Mono|Flux|reactor",
                "getSecret\\(",
                "onError|doOnError|onErrorResume"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "buildClient\\(\\)(?!.*Async)",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.getSecret(?!.*subscribe)",
                  "matched": false
                },
                {
                  "pattern": "CompletableFuture",
                  "matched": false
                },
                {
                  "pattern": "async def|await ",
                  "matched": false
                },
                {
                  "pattern": "asyncio",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 2,
              "code_quality": 3,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct syntax and uses the appropriate Azure SDK for Java (azure-security-keyvault-secrets, azure-identity) and Project Reactor patterns. The API usage appears idiomatic for the Azure Java SDK. However, the code is severely truncated \u2014 it cuts off mid-class in the SecretResult model, and the core service classes (SecretRetrievalService, ConfigurationService) and the main application class that would implement the actual concurrent retrieval, error handling, and configuration map assembly are never shown. This means less than half of the actual task is implemented. The project structure and pom.xml are well-organized but the essential functionality is missing.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretAsyncClient",
                  "matched": true
                },
                {
                  "pattern": "buildAsyncClient\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "subscribe\\(",
                  "matched": false
                },
                {
                  "pattern": "Mono|Flux|reactor",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "onError|doOnError|onErrorResume",
                  "matched": false
                }
              ],
              "expected_hits": [
                "SecretAsyncClient",
                "buildAsyncClient\\(\\)",
                "Mono|Flux|reactor",
                "getSecret\\("
              ],
              "expected_misses": [
                "subscribe\\(",
                "onError|doOnError|onErrorResume"
              ],
              "expected_hit_count": 4,
              "expected_total": 6,
              "expected_hit_rate": 0.6666666666666666,
              "anti_results": [
                {
                  "pattern": "buildClient\\(\\)(?!.*Async)",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.getSecret(?!.*subscribe)",
                  "matched": false
                },
                {
                  "pattern": "CompletableFuture",
                  "matched": false
                },
                {
                  "pattern": "async def|await ",
                  "matched": false
                },
                {
                  "pattern": "asyncio",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 2,
              "code_quality": 3,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure Key Vault SDK API usage and idiomatic reactive patterns using Project Reactor. However, the code is severely truncated - it cuts off mid-constructor in the SecretConfig.java builder pattern, leaving the majority of the application unimplemented (the core SecretRetriever, ConfigurationService, and main application classes are missing). While the project structure, pom.xml, and initial model class show good quality and proper API awareness, less than half of the actual task functionality is present.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretAsyncClient",
                  "matched": false
                },
                {
                  "pattern": "buildAsyncClient\\(\\)",
                  "matched": false
                },
                {
                  "pattern": "subscribe\\(",
                  "matched": false
                },
                {
                  "pattern": "Mono|Flux|reactor",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "onError|doOnError|onErrorResume",
                  "matched": false
                }
              ],
              "expected_hits": [
                "Mono|Flux|reactor"
              ],
              "expected_misses": [
                "SecretAsyncClient",
                "buildAsyncClient\\(\\)",
                "subscribe\\(",
                "getSecret\\(",
                "onError|doOnError|onErrorResume"
              ],
              "expected_hit_count": 1,
              "expected_total": 6,
              "expected_hit_rate": 0.16666666666666666,
              "anti_results": [
                {
                  "pattern": "buildClient\\(\\)(?!.*Async)",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.getSecret(?!.*subscribe)",
                  "matched": false
                },
                {
                  "pattern": "CompletableFuture",
                  "matched": false
                },
                {
                  "pattern": "async def|await ",
                  "matched": false
                },
                {
                  "pattern": "asyncio",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Java using the correct Azure Key Vault SecretAsyncClient API with proper reactive patterns (Reactor's Mono/Flux). It correctly uses flatMap for concurrent retrieval, onErrorResume for per-secret error handling, and ConcurrentHashMap for thread safety. The code is truncated at the end (logResults method is cut off), which slightly impacts completeness, and the onErrorReturn at the end of loadSecrets would return a potentially stale snapshot rather than the fully populated map if a timeout occurs after partial completion. No cross-language contamination is detected.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretAsyncClient",
                  "matched": true
                },
                {
                  "pattern": "buildAsyncClient\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "subscribe\\(",
                  "matched": true
                },
                {
                  "pattern": "Mono|Flux|reactor",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "onError|doOnError|onErrorResume",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretAsyncClient",
                "buildAsyncClient\\(\\)",
                "subscribe\\(",
                "Mono|Flux|reactor",
                "getSecret\\(",
                "onError|doOnError|onErrorResume"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "buildClient\\(\\)(?!.*Async)",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.getSecret(?!.*subscribe)",
                  "matched": false
                },
                {
                  "pattern": "CompletableFuture",
                  "matched": false
                },
                {
                  "pattern": "async def|await ",
                  "matched": false
                },
                {
                  "pattern": "asyncio",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 2,
              "code_quality": 3,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct syntax and uses the appropriate Azure SDK for Java (com.azure.security.keyvault.secrets) with Project Reactor patterns. The API usage is idiomatic for the Azure Java SDK, including SecretAsyncClient and reactive Mono/Flux patterns. However, the code is severely truncated \u2014 it cuts off mid-method in SecretResult.java, and critical classes like SecretRetriever (which would contain the core concurrent retrieval logic), ConfigurationManager, KeyVaultAsyncApp, and SecretErrorHandler are never shown. Since the actual reactive concurrent retrieval and error-handling logic is missing, the code accomplishes less than half the stated task.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretAsyncClient",
                  "matched": true
                },
                {
                  "pattern": "buildAsyncClient\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "subscribe\\(",
                  "matched": false
                },
                {
                  "pattern": "Mono|Flux|reactor",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "onError|doOnError|onErrorResume",
                  "matched": false
                }
              ],
              "expected_hits": [
                "SecretAsyncClient",
                "buildAsyncClient\\(\\)",
                "Mono|Flux|reactor"
              ],
              "expected_misses": [
                "subscribe\\(",
                "getSecret\\(",
                "onError|doOnError|onErrorResume"
              ],
              "expected_hit_count": 3,
              "expected_total": 6,
              "expected_hit_rate": 0.5,
              "anti_results": [
                {
                  "pattern": "buildClient\\(\\)(?!.*Async)",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.getSecret(?!.*subscribe)",
                  "matched": false
                },
                {
                  "pattern": "CompletableFuture",
                  "matched": false
                },
                {
                  "pattern": "async def|await ",
                  "matched": false
                },
                {
                  "pattern": "asyncio",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 2,
              "code_quality": 3,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct syntax and uses the appropriate Azure SDK for Java (azure-security-keyvault-secrets with SecretAsyncClient and Project Reactor). However, the code is severely truncated \u2014 it cuts off mid-file in SecretResult.java, and the critical classes (AsyncConfigurationLoader, ConfigurationService, KeyVaultAsyncDemo) that would implement the core concurrent retrieval logic, configuration map assembly, and per-secret error handling are entirely missing. The pom.xml and SecretResult class are well-structured, but without the main logic, the task is far from accomplished.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretAsyncClient",
                  "matched": true
                },
                {
                  "pattern": "buildAsyncClient\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "subscribe\\(",
                  "matched": false
                },
                {
                  "pattern": "Mono|Flux|reactor",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "onError|doOnError|onErrorResume",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretAsyncClient",
                "buildAsyncClient\\(\\)",
                "Mono|Flux|reactor",
                "getSecret\\(",
                "onError|doOnError|onErrorResume"
              ],
              "expected_misses": [
                "subscribe\\("
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "buildClient\\(\\)(?!.*Async)",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.getSecret(?!.*subscribe)",
                  "matched": false
                },
                {
                  "pattern": "CompletableFuture",
                  "matched": false
                },
                {
                  "pattern": "async def|await ",
                  "matched": false
                },
                {
                  "pattern": "asyncio",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure Key Vault SecretAsyncClient API usage and idiomatic Project Reactor patterns (Flux, Mono, flatMap, onErrorResume, collectMap). The reactive error handling strategy of using Mono.empty() and onErrorResume to skip individual failures is well-designed. However, the code is clearly truncated mid-method \u2014 the fetchSecretWithResult method, helper classes (SecretResult, SecretFetchResult, ConfigLoadResult), and utility methods (logSecretError, getErrorMessage) are all missing, which significantly impacts completeness. The implemented portions demonstrate production-quality patterns including logging, timeouts, and concurrent retrieval.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "SecretAsyncClient",
                  "matched": true
                },
                {
                  "pattern": "buildAsyncClient\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "subscribe\\(",
                  "matched": false
                },
                {
                  "pattern": "Mono|Flux|reactor",
                  "matched": true
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "onError|doOnError|onErrorResume",
                  "matched": true
                }
              ],
              "expected_hits": [
                "SecretAsyncClient",
                "buildAsyncClient\\(\\)",
                "Mono|Flux|reactor",
                "getSecret\\(",
                "onError|doOnError|onErrorResume"
              ],
              "expected_misses": [
                "subscribe\\("
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "buildClient\\(\\)(?!.*Async)",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.getSecret(?!.*subscribe)",
                  "matched": false
                },
                {
                  "pattern": "CompletableFuture",
                  "matched": false
                },
                {
                  "pattern": "async def|await ",
                  "matched": false
                },
                {
                  "pattern": "asyncio",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "azure-security-keyvault-secrets-java-04",
      "task_type": "grounded",
      "target_language": "java",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 3,
              "code_quality": 3,
              "contamination_signals": [
                "SyncPoller<DeletedSecret, Void> \u2014 the Azure Key Vault Java SDK uses SyncPoller<DeletedSecret, Void> which is correct, but the manual poll() loop with Thread.sleep instead of using waitForCompletion() or waitUntil() suggests possible confusion with polling patterns from other SDKs",
                "listDeletedSecrets() returns PagedIterable<DeletedSecret> in the Java SDK, but the code treats the items as full DeletedSecret objects when the list operation actually returns properties-level objects (similar to how the .NET SDK returns them)",
                "The code's manual polling loop pattern (poll() + Thread.sleep) is unidiomatic for the Azure Java SDK where waitForCompletion() or pollUntilDone() are the standard approaches"
              ],
              "brief_assessment": "The code is entirely valid Java syntax and uses mostly correct Azure Key Vault Java SDK APIs. However, it is truncated \u2014 the recoverDeletedSecret method is cut off mid-declaration, leaving a key piece of the requested functionality unimplemented. The manual polling loop with Thread.sleep is unidiomatic when SyncPoller provides waitForCompletion() directly (which the code even acknowledges in a comment). The listDeletedSecrets usage is reasonable but the return type handling may not perfectly match the SDK's PagedIterable behavior.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "beginDeleteSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "SyncPoller",
                  "matched": true
                },
                {
                  "pattern": "DeletedSecret",
                  "matched": true
                },
                {
                  "pattern": "waitForCompletion\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "listDeletedSecrets\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "beginRecoverDeletedSecret\\(",
                  "matched": true
                }
              ],
              "expected_hits": [
                "beginDeleteSecret\\(",
                "SyncPoller",
                "DeletedSecret",
                "waitForCompletion\\(\\)",
                "listDeletedSecrets\\(\\)",
                "beginRecoverDeletedSecret\\("
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "begin_delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "list_deleted_secrets\\(",
                  "matched": false
                },
                {
                  "pattern": "recover_deleted_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.delete\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 4,
              "code_quality": 3,
              "contamination_signals": [
                "SyncPoller<DeletedSecret, Void> - the actual Azure SDK Java API signature is SyncPoller<DeletedSecret, Void> which is correct for beginDeleteSecret, but beginRecoverDeletedSecret returns SyncPoller<KeyVaultSecret, Void> which is incorrect - the actual return type is SyncPoller<KeyVaultSecret, Void> but the intermediate poll type should be KeyVaultSecret",
                "recoverPoller.getFinalResult() returns Void in the actual API, not KeyVaultSecret - the final result type of beginRecoverDeletedSecret is Void, so getFinalResult() would return null",
                "DeletedSecretInfo is a custom class that is referenced but never defined - incomplete code",
                "The code is cut off at the end of getDeletedSecret method"
              ],
              "brief_assessment": "The code is entirely in Java with correct syntax and demonstrates good understanding of the Azure Key Vault SDK pattern. However, there are API accuracy issues: `beginRecoverDeletedSecret` returns `SyncPoller<KeyVaultSecret, Void>` where `getFinalResult()` returns `Void` (null), not a `KeyVaultSecret`, so the recovery method's return logic is flawed. The code is also truncated at the `getDeletedSecret` method and references an undefined `DeletedSecretInfo` class. The three main requested features (soft-delete, list deleted, recover) are mostly implemented but with these correctness gaps.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "beginDeleteSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "SyncPoller",
                  "matched": true
                },
                {
                  "pattern": "DeletedSecret",
                  "matched": true
                },
                {
                  "pattern": "waitForCompletion\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "listDeletedSecrets\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "beginRecoverDeletedSecret\\(",
                  "matched": true
                }
              ],
              "expected_hits": [
                "beginDeleteSecret\\(",
                "SyncPoller",
                "DeletedSecret",
                "waitForCompletion\\(\\)",
                "listDeletedSecrets\\(\\)",
                "beginRecoverDeletedSecret\\("
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "begin_delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "list_deleted_secrets\\(",
                  "matched": false
                },
                {
                  "pattern": "recover_deleted_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.delete\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Java and uses the Azure Key Vault SDK idiomatically. All three requested features (soft-delete with polling, listing deleted secrets, and recovering deleted secrets) are fully implemented, plus bonus helper methods. The SyncPoller generic type for beginRecoverDeletedSecret should be SyncPoller<KeyVaultSecret, Void> which matches some SDK versions but in the most common Azure SDK documentation it's also KeyVaultSecret \u2014 this is a minor concern. The print statements in library-level code are not ideal for production, and calling both poll() and then waitForCompletion() is slightly redundant (waitForCompletion() alone or waitUntil(LongRunningOperationStatus.COMPLETED) would suffice), but overall the implementation is solid and well-documented.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "beginDeleteSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "SyncPoller",
                  "matched": true
                },
                {
                  "pattern": "DeletedSecret",
                  "matched": true
                },
                {
                  "pattern": "waitForCompletion\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "listDeletedSecrets\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "beginRecoverDeletedSecret\\(",
                  "matched": true
                }
              ],
              "expected_hits": [
                "beginDeleteSecret\\(",
                "SyncPoller",
                "DeletedSecret",
                "waitForCompletion\\(\\)",
                "listDeletedSecrets\\(\\)",
                "beginRecoverDeletedSecret\\("
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "begin_delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "list_deleted_secrets\\(",
                  "matched": false
                },
                {
                  "pattern": "recover_deleted_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.delete\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure Key Vault SDK usage. The SyncPoller generic types are correct (SyncPoller<DeletedSecret, Void>), and API calls like beginDeleteSecret, listDeletedSecrets, and getDeletedSecret are idiomatic. The manual polling loop is unnecessary when waitForCompletion exists (shown in alternative methods), and the code is truncated\u2014the recoverDeletedSecret method is cut off mid-implementation, leaving that required feature incomplete. The listDeletedSecrets return type should technically iterate over DeletedSecret properties rather than full DeletedSecret objects, but this is a minor deviation.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "beginDeleteSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "SyncPoller",
                  "matched": true
                },
                {
                  "pattern": "DeletedSecret",
                  "matched": true
                },
                {
                  "pattern": "waitForCompletion\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "listDeletedSecrets\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "beginRecoverDeletedSecret\\(",
                  "matched": true
                }
              ],
              "expected_hits": [
                "beginDeleteSecret\\(",
                "SyncPoller",
                "DeletedSecret",
                "waitForCompletion\\(\\)",
                "listDeletedSecrets\\(\\)",
                "beginRecoverDeletedSecret\\("
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "begin_delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "list_deleted_secrets\\(",
                  "matched": false
                },
                {
                  "pattern": "recover_deleted_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.delete\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Java and uses the Azure Key Vault SDK correctly. The SyncPoller usage for beginDeleteSecret is accurate (SyncPoller<DeletedSecret, Void>), and beginRecoverDeletedSecret is also correctly handled (SyncPoller<KeyVaultSecret, Void>). The code is truncated at the end of getDeletedSecret, losing that helper method, but the three core requested features (soft-delete with polling, list deleted secrets, recover deleted secret) are all implemented. Minor note: calling poll() before waitForCompletion() is redundant but not incorrect.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "beginDeleteSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "SyncPoller",
                  "matched": true
                },
                {
                  "pattern": "DeletedSecret",
                  "matched": true
                },
                {
                  "pattern": "waitForCompletion\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "listDeletedSecrets\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "beginRecoverDeletedSecret\\(",
                  "matched": true
                }
              ],
              "expected_hits": [
                "beginDeleteSecret\\(",
                "SyncPoller",
                "DeletedSecret",
                "waitForCompletion\\(\\)",
                "listDeletedSecrets\\(\\)",
                "beginRecoverDeletedSecret\\("
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "begin_delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "list_deleted_secrets\\(",
                  "matched": false
                },
                {
                  "pattern": "recover_deleted_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.delete\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "The SyncPoller generic type for beginRecoverDeletedSecret should be SyncPoller<KeyVaultSecret, KeyVaultSecret> not SyncPoller<KeyVaultSecret, Void> \u2014 the Azure SDK Java API returns the recovered secret as the final result type. Similarly, beginDeleteSecret returns SyncPoller<DeletedSecret, Void> which is correct."
              ],
              "brief_assessment": "The code is entirely in Java and uses the Azure Key Vault SDK correctly for most operations. The three core requested features (beginDeleteSecret with polling, listDeletedSecrets, and beginRecoverDeletedSecret) are all implemented. The SyncPoller generic type for beginRecoverDeletedSecret is slightly incorrect \u2014 the Azure Java SDK signature is `SyncPoller<KeyVaultSecret, KeyVaultSecret>` rather than `SyncPoller<KeyVaultSecret, Void>`. The code is also truncated in the main method, cutting off the example usage, but the actual functional methods are complete. Additional helper methods (getDeletedSecret, purgeDeletedSecret) are a nice bonus.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "beginDeleteSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "SyncPoller",
                  "matched": true
                },
                {
                  "pattern": "DeletedSecret",
                  "matched": true
                },
                {
                  "pattern": "waitForCompletion\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "listDeletedSecrets\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "beginRecoverDeletedSecret\\(",
                  "matched": true
                }
              ],
              "expected_hits": [
                "beginDeleteSecret\\(",
                "SyncPoller",
                "DeletedSecret",
                "waitForCompletion\\(\\)",
                "listDeletedSecrets\\(\\)",
                "beginRecoverDeletedSecret\\("
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "begin_delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "list_deleted_secrets\\(",
                  "matched": false
                },
                {
                  "pattern": "recover_deleted_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.delete\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 3,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct syntax and uses the Azure Key Vault SDK APIs idiomatically. The SyncPoller usage with beginDeleteSecret is correct, though the manual poll loop with Thread.sleep is unnecessary when waitForCompletion() exists (which they also show). However, the code is truncated mid-method \u2014 getDeletedSecret and the recover method are cut off, meaning the 'recover a specific deleted secret' requirement is not fully implemented. The getFinalResult() on a SyncPoller<DeletedSecret, Void> returns Void, not DeletedSecret \u2014 the intermediate poll value should be used instead via poller.waitForCompletion() then pollResponse.getValue().",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "beginDeleteSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "SyncPoller",
                  "matched": true
                },
                {
                  "pattern": "DeletedSecret",
                  "matched": true
                },
                {
                  "pattern": "waitForCompletion\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "listDeletedSecrets\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "beginRecoverDeletedSecret\\(",
                  "matched": true
                }
              ],
              "expected_hits": [
                "beginDeleteSecret\\(",
                "SyncPoller",
                "DeletedSecret",
                "waitForCompletion\\(\\)",
                "listDeletedSecrets\\(\\)",
                "beginRecoverDeletedSecret\\("
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "begin_delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "list_deleted_secrets\\(",
                  "matched": false
                },
                {
                  "pattern": "recover_deleted_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.delete\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure Key Vault SDK usage. The API calls (beginDeleteSecret, listDeletedSecrets, getDeletedSecret, beginRecoverDeletedSecret) are idiomatic for the Java Azure SDK. The SyncPoller type parameter for beginRecoverDeletedSecret should be SyncPoller<KeyVaultSecret, Void> which matches the SDK. The code is truncated at the end of recoverDeletedSecret, losing the final portion of that method, but the core functionality for soft-delete, listing deleted secrets, and recovery is substantially implemented. Minor note: calling poll() before waitForCompletion() is slightly redundant in deleteSecretAndWait but not incorrect.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "beginDeleteSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "SyncPoller",
                  "matched": true
                },
                {
                  "pattern": "DeletedSecret",
                  "matched": true
                },
                {
                  "pattern": "waitForCompletion\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "listDeletedSecrets\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "beginRecoverDeletedSecret\\(",
                  "matched": true
                }
              ],
              "expected_hits": [
                "beginDeleteSecret\\(",
                "SyncPoller",
                "DeletedSecret",
                "waitForCompletion\\(\\)",
                "listDeletedSecrets\\(\\)",
                "beginRecoverDeletedSecret\\("
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "begin_delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "list_deleted_secrets\\(",
                  "matched": false
                },
                {
                  "pattern": "recover_deleted_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.delete\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Java and uses the Azure Key Vault SDK idiomatically. It correctly implements soft-delete with SyncPoller, lists deleted secrets, and recovers deleted secrets. Minor issues: the SyncPoller generic for beginRecoverDeletedSecret should be SyncPoller<KeyVaultSecret, Void> which matches the actual SDK, but calling poll() right after beginDeleteSecret (which already does an initial poll internally) is slightly redundant\u2014waitForCompletion() alone would suffice. The code is truncated at the end of main(), but all requested methods are fully implemented. Additional methods like getDeletedSecret and purgeDeletedSecret go beyond requirements, which is a plus.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "beginDeleteSecret\\(",
                  "matched": true
                },
                {
                  "pattern": "SyncPoller",
                  "matched": true
                },
                {
                  "pattern": "DeletedSecret",
                  "matched": true
                },
                {
                  "pattern": "waitForCompletion\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "listDeletedSecrets\\(\\)",
                  "matched": true
                },
                {
                  "pattern": "beginRecoverDeletedSecret\\(",
                  "matched": true
                }
              ],
              "expected_hits": [
                "beginDeleteSecret\\(",
                "SyncPoller",
                "DeletedSecret",
                "waitForCompletion\\(\\)",
                "listDeletedSecrets\\(\\)",
                "beginRecoverDeletedSecret\\("
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "begin_delete_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "list_deleted_secrets\\(",
                  "matched": false
                },
                {
                  "pattern": "recover_deleted_secret\\(",
                  "matched": false
                },
                {
                  "pattern": "secretClient\\.delete\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "azure-security-keyvault-secrets-java-05",
      "task_type": "adjacent_domain",
      "target_language": "java",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct, idiomatic use of the Azure Key Vault Keys SDK (KeyClient, CryptographyClient, CreateRsaKeyOptions, SignatureAlgorithm, etc.). All imports and API calls align with the azure-security-keyvault-keys Java package. However, the code is truncated mid-function \u2014 the SHA-256 digest computation, signing, verification, and result display methods are cut off, meaning roughly half the task's implementation is missing. What is present is well-structured and production-quality.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "KeyClient|KeyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "CryptographyClient|CryptographyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "createRsaKey|CreateRsaKeyOptions",
                  "matched": true
                },
                {
                  "pattern": "sign\\(|SignResult",
                  "matched": true
                },
                {
                  "pattern": "verify\\(|VerifyResult",
                  "matched": true
                },
                {
                  "pattern": "azure-security-keyvault-keys|keyvault\\.keys",
                  "matched": true
                }
              ],
              "expected_hits": [
                "KeyClient|KeyClientBuilder",
                "CryptographyClient|CryptographyClientBuilder",
                "createRsaKey|CreateRsaKeyOptions",
                "sign\\(|SignResult",
                "verify\\(|VerifyResult",
                "azure-security-keyvault-keys|keyvault\\.keys"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient|SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "azure-security-keyvault-secrets|keyvault\\.secrets",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure Key Vault Keys SDK API usage, using the proper KeyClient, CryptographyClient, SignatureAlgorithm, CreateRsaKeyOptions, and related classes from azure-security-keyvault-keys. However, the code is truncated mid-file \u2014 SignatureService.java is cut off at the SLF4J import, and the main demo class (KeyVaultKeysDemo.java) is never shown. While the completed portions demonstrate correct API idioms and good project structure, the actual signing and verification logic is missing, meaning the task is only partially accomplished.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "KeyClient|KeyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "CryptographyClient|CryptographyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "createRsaKey|CreateRsaKeyOptions",
                  "matched": true
                },
                {
                  "pattern": "sign\\(|SignResult",
                  "matched": true
                },
                {
                  "pattern": "verify\\(|VerifyResult",
                  "matched": true
                },
                {
                  "pattern": "azure-security-keyvault-keys|keyvault\\.keys",
                  "matched": true
                }
              ],
              "expected_hits": [
                "KeyClient|KeyClientBuilder",
                "CryptographyClient|CryptographyClientBuilder",
                "createRsaKey|CreateRsaKeyOptions",
                "sign\\(|SignResult",
                "verify\\(|VerifyResult",
                "azure-security-keyvault-keys|keyvault\\.keys"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient|SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "azure-security-keyvault-secrets|keyvault\\.secrets",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct syntax and uses the proper Azure SDK classes (KeyClient, CryptographyClient, CreateRsaKeyOptions, SignatureAlgorithm, etc.) from the azure-security-keyvault-keys package. The API usage is largely idiomatic, though constructing the key identifier manually via string concatenation rather than using the KeyVaultKey's getId() method is a minor deviation from best practice. The code is truncated at the end of the demonstrateSignatureWorkflow method (missing closing braces and the main method), which slightly impacts functional completeness, but the core task\u2014create key, sign digest, verify signature\u2014is fully implemented in the methods shown.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "KeyClient|KeyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "CryptographyClient|CryptographyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "createRsaKey|CreateRsaKeyOptions",
                  "matched": true
                },
                {
                  "pattern": "sign\\(|SignResult",
                  "matched": true
                },
                {
                  "pattern": "verify\\(|VerifyResult",
                  "matched": true
                },
                {
                  "pattern": "azure-security-keyvault-keys|keyvault\\.keys",
                  "matched": true
                }
              ],
              "expected_hits": [
                "KeyClient|KeyClientBuilder",
                "CryptographyClient|CryptographyClientBuilder",
                "createRsaKey|CreateRsaKeyOptions",
                "sign\\(|SignResult",
                "verify\\(|VerifyResult",
                "azure-security-keyvault-keys|keyvault\\.keys"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient|SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "azure-security-keyvault-secrets|keyvault\\.secrets",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct, idiomatic use of the Azure Key Vault Keys SDK (KeyClient, CryptographyClient, CreateRsaKeyOptions, SignatureAlgorithm, SignResult, VerifyResult). It correctly demonstrates creating an RSA key, computing a SHA-256 digest, signing with RS256, and verifying the signature. However, the code is truncated \u2014 the createOrGetRsaKey method is cut off mid-construction of CreateRsaKeyOptions, and likely several helper methods (signDigest, verifySignature, computeSha256Digest) are missing. This incompleteness prevents a full functional correctness score. No cross-language contamination signals were detected.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "KeyClient|KeyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "CryptographyClient|CryptographyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "createRsaKey|CreateRsaKeyOptions",
                  "matched": true
                },
                {
                  "pattern": "sign\\(|SignResult",
                  "matched": true
                },
                {
                  "pattern": "verify\\(|VerifyResult",
                  "matched": true
                },
                {
                  "pattern": "azure-security-keyvault-keys|keyvault\\.keys",
                  "matched": true
                }
              ],
              "expected_hits": [
                "KeyClient|KeyClientBuilder",
                "CryptographyClient|CryptographyClientBuilder",
                "createRsaKey|CreateRsaKeyOptions",
                "sign\\(|SignResult",
                "verify\\(|VerifyResult",
                "azure-security-keyvault-keys|keyvault\\.keys"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient|SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "azure-security-keyvault-secrets|keyvault\\.secrets",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure Key Vault Keys SDK usage, including proper use of KeyClient, KeyClientBuilder, CreateRsaKeyOptions, and DefaultAzureCredentialBuilder. The API patterns are fully idiomatic for the Java Azure SDK. However, the code is truncated mid-file (KeyManager.java cuts off), and the critical SignatureService.java containing the CryptographyClient sign/verify logic is missing entirely, meaning the core task of signing a digest and verifying a signature is not demonstrated. The project structure, pom.xml, and config class are well done.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "KeyClient|KeyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "CryptographyClient|CryptographyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "createRsaKey|CreateRsaKeyOptions",
                  "matched": true
                },
                {
                  "pattern": "sign\\(|SignResult",
                  "matched": true
                },
                {
                  "pattern": "verify\\(|VerifyResult",
                  "matched": true
                },
                {
                  "pattern": "azure-security-keyvault-keys|keyvault\\.keys",
                  "matched": true
                }
              ],
              "expected_hits": [
                "KeyClient|KeyClientBuilder",
                "CryptographyClient|CryptographyClientBuilder",
                "createRsaKey|CreateRsaKeyOptions",
                "sign\\(|SignResult",
                "verify\\(|VerifyResult",
                "azure-security-keyvault-keys|keyvault\\.keys"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient|SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "azure-security-keyvault-secrets|keyvault\\.secrets",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Java with proper use of the Azure Key Vault Keys SDK. It correctly uses KeyClient, KeyClientBuilder, CryptographyClient, CryptographyClientBuilder, CreateRsaKeyOptions, SignatureAlgorithm.RS256, and the sign/verify methods with the right signatures. The code is truncated \u2014 the demonstrateSignAndVerify method and likely a main method are cut off, so the full workflow is not shown, but all three core operations (create key, sign, verify) are implemented in separate methods. Minor concern: creating a new CryptographyClient (and DefaultAzureCredential) for each sign/verify call is inefficient but not incorrect.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "KeyClient|KeyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "CryptographyClient|CryptographyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "createRsaKey|CreateRsaKeyOptions",
                  "matched": true
                },
                {
                  "pattern": "sign\\(|SignResult",
                  "matched": true
                },
                {
                  "pattern": "verify\\(|VerifyResult",
                  "matched": true
                },
                {
                  "pattern": "azure-security-keyvault-keys|keyvault\\.keys",
                  "matched": true
                }
              ],
              "expected_hits": [
                "KeyClient|KeyClientBuilder",
                "CryptographyClient|CryptographyClientBuilder",
                "createRsaKey|CreateRsaKeyOptions",
                "sign\\(|SignResult",
                "verify\\(|VerifyResult",
                "azure-security-keyvault-keys|keyvault\\.keys"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient|SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "azure-security-keyvault-secrets|keyvault\\.secrets",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct, idiomatic usage of the Azure Key Vault Keys SDK (KeyClient, CryptographyClient, CreateRsaKeyOptions, SignatureAlgorithm, etc.). The imports, class structure, and API calls all align with the official azure-security-keyvault-keys Java SDK. However, the code is truncated mid-method \u2014 the createCryptographyClient method, signDigest, verifySignature, testTamperedData, and cleanUp methods are missing, which means roughly half the functional implementation (the actual sign/verify logic) is absent. No cross-language contamination is detected.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "KeyClient|KeyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "CryptographyClient|CryptographyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "createRsaKey|CreateRsaKeyOptions",
                  "matched": true
                },
                {
                  "pattern": "sign\\(|SignResult",
                  "matched": true
                },
                {
                  "pattern": "verify\\(|VerifyResult",
                  "matched": true
                },
                {
                  "pattern": "azure-security-keyvault-keys|keyvault\\.keys",
                  "matched": true
                }
              ],
              "expected_hits": [
                "KeyClient|KeyClientBuilder",
                "CryptographyClient|CryptographyClientBuilder",
                "createRsaKey|CreateRsaKeyOptions",
                "sign\\(|SignResult",
                "verify\\(|VerifyResult",
                "azure-security-keyvault-keys|keyvault\\.keys"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient|SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "azure-security-keyvault-secrets|keyvault\\.secrets",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 2,
              "code_quality": 3,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct language syntax and uses the proper Azure Key Vault Keys SDK classes (KeyClient, KeyClientBuilder, CryptographyClient, CryptographyClientBuilder, CreateRsaKeyOptions, KeyVaultKey) idiomatically. However, the code is severely truncated \u2014 the KeyVaultKeyManager class is cut off mid-constructor, the SignatureVerifier class is missing entirely, and the main KeyVaultKeysDemo class is absent. Only key creation setup is partially shown; the signing and verification logic (the core of the task) is not present. The pom.xml and project structure are well-organized but the incomplete implementation means most of the requested task is unimplemented.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "KeyClient|KeyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "CryptographyClient|CryptographyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "createRsaKey|CreateRsaKeyOptions",
                  "matched": true
                },
                {
                  "pattern": "sign\\(|SignResult",
                  "matched": true
                },
                {
                  "pattern": "verify\\(|VerifyResult",
                  "matched": true
                },
                {
                  "pattern": "azure-security-keyvault-keys|keyvault\\.keys",
                  "matched": true
                }
              ],
              "expected_hits": [
                "KeyClient|KeyClientBuilder",
                "CryptographyClient|CryptographyClientBuilder",
                "createRsaKey|CreateRsaKeyOptions",
                "sign\\(|SignResult",
                "verify\\(|VerifyResult",
                "azure-security-keyvault-keys|keyvault\\.keys"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient|SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "azure-security-keyvault-secrets|keyvault\\.secrets",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": null,
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Java with correct Azure SDK API usage. It properly uses KeyClient, CryptographyClient, CreateRsaKeyOptions, SignatureAlgorithm.RS256, and the sign/verify methods with correct signatures. The code is truncated at the end (the demonstrateSignatureFlow method and presumably a main method are cut off), which means it's missing the final orchestration/demo portion, but all three core operations (create RSA key, sign digest, verify signature) are fully implemented as separate methods. The keyIdentifier construction by manually concatenating the vault URL is slightly non-idiomatic \u2014 typically one would use the key's ID from the KeyVaultKey object \u2014 but it is functionally correct.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "KeyClient|KeyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "CryptographyClient|CryptographyClientBuilder",
                  "matched": true
                },
                {
                  "pattern": "createRsaKey|CreateRsaKeyOptions",
                  "matched": true
                },
                {
                  "pattern": "sign\\(|SignResult",
                  "matched": true
                },
                {
                  "pattern": "verify\\(|VerifyResult",
                  "matched": true
                },
                {
                  "pattern": "azure-security-keyvault-keys|keyvault\\.keys",
                  "matched": true
                }
              ],
              "expected_hits": [
                "KeyClient|KeyClientBuilder",
                "CryptographyClient|CryptographyClientBuilder",
                "createRsaKey|CreateRsaKeyOptions",
                "sign\\(|SignResult",
                "verify\\(|VerifyResult",
                "azure-security-keyvault-keys|keyvault\\.keys"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "SecretClient|SecretClientBuilder",
                  "matched": false
                },
                {
                  "pattern": "setSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "getSecret\\(",
                  "matched": false
                },
                {
                  "pattern": "azure-security-keyvault-secrets|keyvault\\.secrets",
                  "matched": false
                },
                {
                  "pattern": "KeyVaultSecret",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 5,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    }
  ]
}