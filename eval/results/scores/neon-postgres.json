{
  "skill_name": "neon-postgres",
  "scored_at": "2026-02-16T19:52:51.901502+00:00",
  "model_judge": "claude-opus-4-6",
  "model_generation": "claude-sonnet-4-5-20250929",
  "contamination_score": 0.0,
  "risk_level": "medium",
  "test_category": "hidden_contamination",
  "tasks": [
    {
      "task_id": "neon-postgres-01",
      "task_type": "direct_target",
      "target_language": "typescript",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct TypeScript with no foreign language contamination. It uses the @neondatabase/serverless driver's `neon()` function and tagged template literal syntax idiomatically, correctly employs parameterized queries via template interpolation, and properly types the User interface. The code covers all requested features: connection via DATABASE_URL, parameterized SELECT by email domain, typed return objects, and comprehensive error handling. Providing both Pages Router and App Router versions is a nice touch. The only very minor nitpick is that the App Router version appears slightly truncated at the end, but the logic is complete enough to function correctly.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript using the Next.js App Router pattern correctly. The Neon serverless driver usage with tagged template literals is idiomatic, though the generic type parameter `sql<User[]>` may not exactly match the driver's actual type signature (the return type from the tagged template is already an array, so `sql<User>` would be more precise in some versions of the driver \u2014 this is a minor API nuance rather than contamination). The code fully accomplishes all requested features: typed User interface, parameterized query, error handling, DATABASE_URL usage, and proper Next.js API route exports. Code quality is excellent with thorough validation, clear documentation, and good error handling patterns.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [
                "The generic type parameter `sql<User[]>` on the tagged template literal may not match the exact Neon driver API signature \u2014 the Neon `neon()` function's tagged template returns `NeonQueryFunction` which uses `rows` typing slightly differently, though the pattern shown is commonly documented and accepted"
              ],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js conventions for both App Router and Pages Router. It correctly uses the `neon()` function from `@neondatabase/serverless` with tagged template literals for parameterized queries, includes comprehensive error handling, proper TypeScript interfaces, input validation, and environment variable checks. The generic type parameter on the tagged template (`sql<User[]>`) is a minor question regarding exact API shape \u2014 the Neon driver's tagged template actually returns `NeonQueryPromise` and the generic typing may not work exactly as shown \u2014 but the overall pattern is well-documented and functionally sound. The code is production-quality with excellent structure and completeness.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js App Router conventions and correct usage of @neondatabase/serverless's tagged template literal API. The generic type parameter `sql<User[]>` may not exactly match the neon driver's actual generic signature (it typically returns `NeonQueryFunction` rows without a generic on the tagged template), but this is a minor deviation rather than cross-language contamination. The LIKE pattern concatenation within the template literal works correctly with neon's parameterization. All requested features \u2014 typed User interface, parameterized query, error handling, and async export \u2014 are present and well-implemented.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js API route patterns for both Pages Router and App Router. The Neon serverless driver usage is correct \u2014 neon() returns a query function and the parameterized query syntax with $1 and an array of parameters is idiomatic. One minor note: the generic type parameter `sql<User[]>` may not perfectly match the Neon driver's actual generic signature (the neon function returns `NeonQueryFunction` which resolves to an array of rows, so `sql<User>` might be more precise than `sql<User[]>`), but this is a trivial deviation. The code comprehensively addresses all requirements: typed User interface, parameterized queries, error handling, environment variable validation, and properly typed responses.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "sql<User[]>` tagged template returns NeonQueryFunctionResult (which is already an array of rows), not a generic typed as User[] \u2014 the generic parameter should be User or a row type, not User[]",
                "sql.query<User>() method doesn't exist on the neon() tagged template function \u2014 this resembles the pg/node-postgres Client.query() API pattern or a conflation with the neon Pool/Client interface",
                "The .query() alternative returns rows directly rather than a QueryResult object with a .rows property, suggesting confusion with pg driver patterns"
              ],
              "brief_assessment": "The code is entirely valid TypeScript and follows Next.js App Router conventions correctly (GET export, NextRequest/NextResponse). However, the Neon serverless driver API usage has notable issues: the tagged template generic should be `sql<User>` not `sql<User[]>`, and the alternative `sql.query()` method doesn't exist on the `neon()` function (it exists on `Pool` or `Client` from the same package, which is a different interface). The tagged template approach is approximately correct but the generic typing is wrong. Overall the code is well-structured with good error handling and documentation, but the API contamination from pg-style patterns reduces idiomaticity.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [
                "neon() generic type parameter `neon<User[]>()` is not part of the actual @neondatabase/serverless API - the generic is typically applied at the query call level or the return is simply typed/cast after the fact"
              ],
              "brief_assessment": "The code is entirely valid TypeScript with no cross-language contamination. It correctly uses the @neondatabase/serverless driver's `neon()` function with tagged template or parameterized query syntax, proper Next.js App Router and Pages Router patterns, comprehensive error handling, and well-defined TypeScript interfaces. The one minor API idiomaticity issue is the use of `neon<User[]>(process.env.DATABASE_URL)` \u2014 the `neon()` constructor doesn't actually accept a generic type parameter in the real SDK; results would typically need to be cast or typed separately. Otherwise the code is thorough, production-quality, and covers both Next.js router patterns.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [
                "neon\\("
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js App Router conventions and correct usage of the @neondatabase/serverless driver's tagged template literal syntax. The neon() function's generic type parameter `sql<User[]>` is a minor note \u2014 the actual return type from tagged template queries is `NeonQueryFunction` which returns rows directly, and the generic typing works but isn't perfectly documented in all versions. Overall, the code covers all requested features: User interface, parameterized query, typed results, error handling, and environment variable validation. Production-quality code with clean structure.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct TypeScript with proper Next.js API route patterns and idiomatic usage of the @neondatabase/serverless driver. The neon() function is correctly used to create a query function, parameterized queries use the correct $1 placeholder syntax, and the result is properly typed. The code fully accomplishes all requested features: User interface, neon() connection with DATABASE_URL, parameterized SELECT query for email domain filtering, typed return objects, and comprehensive error handling. The inclusion of both a standalone function and a repository pattern alternative, along with well-structured response types and JSDoc comments, demonstrates production-quality code.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 5,
              "contamination_signals": [
                "The `sql.query()` method in `getUsersByDomainManual` is not part of the @neondatabase/serverless neon() HTTP query function API \u2014 neon() returns a tagged template function, not an object with a .query() method. This pattern resembles node-postgres (pg) Pool/Client .query() API.",
                "The generic type parameter `sql<User[]>` on the tagged template is not the documented API pattern for @neondatabase/serverless; the neon driver's tagged template returns NeonQueryPromise which resolves to an array of row objects, and generic typing is not officially supported this way.",
                "The generic on `sql.query<User>` also borrows from pg-typed or similar patterns rather than the actual neon() API."
              ],
              "brief_assessment": "The code is entirely valid TypeScript with excellent structure, comprehensive error handling, input validation, and clear documentation. However, there are API idiomaticity issues: the `sql.query()` method used in the alternative implementation does not exist on the neon() HTTP query function (this is a node-postgres contamination pattern), and the generic type parameters on the tagged template literal are not part of the official @neondatabase/serverless API. The primary tagged template approach is mostly correct in usage pattern, though the return type would need a cast in practice. Overall it's well-written and would mostly accomplish the task with minor API corrections needed.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper typing throughout. It correctly uses the @neondatabase/serverless driver's tagged template literal syntax (`sql<User[]>`...) for parameterized queries, creates the connection via `neon()` with `DATABASE_URL`, returns typed User objects, and handles errors comprehensively. The generic type parameter `sql<User[]>` on the tagged template is a minor deviation \u2014 the neon driver actually returns `NeonQueryFunction` results where the generic is applied differently (the actual return type from the tagged template is already an array), but this is a very minor point. The code provides both App Router and Pages Router versions, includes input validation, domain format checking, and proper error handling \u2014 going well beyond the minimum requirements. Production-quality code with excellent documentation.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct TypeScript using Next.js App Router conventions and the @neondatabase/serverless driver idiomatically via tagged template literals. The generic type parameter `sql<User[]>` may not match the exact Neon driver API signature (the driver's tagged template returns `NeonQueryFunction` results where the generic is typically the row type, not an array \u2014 i.e., `sql<User>` rather than `sql<User[]>`), which is a minor API idiomaticity issue. Otherwise, the code handles all requested features: typed User interface, parameterized query, error handling, and environment variable usage. Domain validation and structured responses demonstrate production-quality practices.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-02",
      "task_type": "cross_language",
      "target_language": "python",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with idiomatic FastAPI and asyncpg usage, including proper lifespan management, connection pooling, Pydantic models, and async/await patterns. However, the code is truncated mid-function \u2014 the GET /products endpoint is cut off at 'page_siz', and the GET /products/{id} and POST /products endpoints are missing entirely, meaning only a portion of the required task is implemented. The implemented portions demonstrate good quality with validation, pagination, search functionality, and proper schema initialization.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with correct FastAPI and asyncpg idioms, including proper async/await patterns, connection pooling via asyncpg.create_pool, Pydantic v2 models, and FastAPI's lifespan context manager. The use of get_connection as an async generator dependency is a reasonable pattern, though using it with Depends requires it to be structured as an async generator (which it is). However, the code is truncated mid-function \u2014 the GET /products/{id} endpoint is cut off and the POST /products endpoint is missing entirely, so only about 60% of the required functionality is implemented. The implemented portions are well-structured with good pagination, proper validation, and database schema initialization.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python using idiomatic FastAPI and asyncpg patterns \u2014 lifespan context manager, Pydantic models, asyncpg connection pooling with pool.acquire(), parameterized queries with $1/$2 syntax, and proper async/await throughout. The GET /products (with pagination), GET /products/{id}, and POST /products endpoints are all present, though the POST endpoint is truncated mid-docstring, meaning the create logic is incomplete. Everything that is present is well-structured and production-quality, with no cross-language contamination detected.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 4,
              "api_idiomaticity": 3,
              "functional_correctness": 3,
              "code_quality": 3,
              "contamination_signals": [
                "The task explicitly requests asyncpg as the database driver, but the code uses SQLAlchemy ORM (with AsyncSession) instead of raw asyncpg",
                "The code references a BaseService class and SQLAlchemy models rather than using asyncpg connection pooling directly as requested",
                "The code appears to be generated by a tool-use agent (contains XML-like function_calls and invoke tags), suggesting it was not cleanly produced as standalone code",
                "Code is truncated mid-function in the update_product method"
              ],
              "brief_assessment": "The code is written in valid Python and uses FastAPI-related patterns (Pydantic schemas, async patterns), but it fundamentally ignores the core requirement of using asyncpg directly as the database driver, instead opting for SQLAlchemy's async ORM layer. The connection pooling setup with asyncpg (e.g., asyncpg.create_pool) is entirely absent. Additionally, the code is truncated \u2014 the update_product method is cut off, the actual FastAPI router/endpoint definitions are never shown, and the referenced BaseService class is undefined. The output also contains tool-call XML artifacts rather than clean code, reducing its usability.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [
                "import asyncpg|from asyncpg"
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": true
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [
                "const\\s+|let\\s+|var\\s+"
              ],
              "anti_pattern_hit_count": 1,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.16666666666666666,
              "contamination_detected": true
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Python with proper use of FastAPI, asyncpg, and Pydantic. It demonstrates idiomatic async/await patterns, connection pooling via asyncpg.create_pool, the modern lifespan context manager, and proper dependency injection with Depends. However, the code is truncated mid-function \u2014 the list_products endpoint is cut off during the total_pages calculation, and we never see the completion of that endpoint nor the GET /products/{id} endpoint or POST /products endpoint, so roughly only half the task is implemented. The use of a global pool with a dependency that yields from `pool.acquire()` is idiomatic asyncpg/FastAPI usage. Minor note: `decimal_places` is not a valid Field parameter in Pydantic v2, but this is a small issue.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with correct FastAPI and asyncpg usage patterns. Connection pooling is properly set up with asyncpg.create_pool, and the lifespan context manager pattern is idiomatic modern FastAPI. The code is truncated\u2014the GET /products/{id} endpoint is cut off mid-docstring, and the POST /products endpoint is missing entirely, preventing full task completion. The implemented portions (pagination, database class, schema definitions) are well-structured and production-oriented.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python using idiomatic FastAPI patterns (lifespan context manager, Pydantic models, Query parameters) and proper asyncpg usage (create_pool, acquire, fetch/fetchrow/fetchval with $N placeholders). All three endpoints are implemented with pagination, proper error handling, and connection pooling. The only issue is that the POST /products endpoint is truncated mid-function \u2014 the INSERT query's parameter list and the return statement are cut off. This prevents full functional correctness but the vast majority of the task is implemented correctly.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [
                "Task explicitly requests asyncpg as the database driver, but code uses SQLAlchemy async ORM with asyncpg only as a backend driver via 'postgresql+asyncpg://' connection string",
                "The implementation uses SQLAlchemy ORM patterns (declarative_base, Column definitions, session management) rather than direct asyncpg connection pooling and raw SQL queries as requested"
              ],
              "brief_assessment": "The code is well-structured Python with proper async/await patterns, Pydantic schemas, and a service layer. However, it diverges significantly from the task requirement to 'use asyncpg as the database driver' \u2014 instead wrapping asyncpg behind SQLAlchemy's async ORM, which is a different API paradigm than direct asyncpg pool/connection usage. Additionally, the code is clearly truncated mid-line in the router file (cuts off at 'HTTPE'), meaning the actual REST endpoints (the core deliverable) are never implemented, leaving the task substantially incomplete.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": false
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "async def",
                "await.*fetch|await.*execute",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [
                "import asyncpg|from asyncpg",
                "create_pool|Pool"
              ],
              "expected_hit_count": 4,
              "expected_total": 6,
              "expected_hit_rate": 0.6666666666666666,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": true
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [
                "const\\s+|let\\s+|var\\s+"
              ],
              "anti_pattern_hit_count": 1,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.16666666666666666,
              "contamination_detected": true
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with idiomatic FastAPI and asyncpg usage, including proper lifespan management, Pydantic models, connection pooling, and async/await patterns. However, the code is truncated mid-function \u2014 the list_products endpoint is cut off during the search query construction, and the GET /products/{id} and POST /products endpoints are completely missing. This means roughly half of the requested functionality (single product retrieval and creation) is absent. The implemented portions demonstrate production-quality patterns including proper validation, pagination response models, schema initialization, and error handling setup.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with correct syntax and idiomatic usage of FastAPI, asyncpg, and Pydantic. It demonstrates proper connection pooling setup, async/await patterns, and well-structured Pydantic schemas. However, the code is truncated \u2014 it cuts off mid-function in models.py and never shows the main.py file containing the actual FastAPI endpoint definitions (routes for GET /products, GET /products/{id}, POST /products), which is a significant completeness gap. The database layer and schemas that are present are well-designed with proper pagination logic, search functionality, and parameterized queries.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python using idiomatic FastAPI and asyncpg patterns, including proper lifespan context manager, connection pooling, Pydantic models, and async/await throughout. All three required endpoints (GET /products with pagination, GET /products/{id}, POST /products) are implemented. The code is truncated at the very end of the POST handler \u2014 the last line is cut off mid-expression (`stock=r`), but the logic is clear and only a closing parenthesis and return are missing. The variable shadowing of the global `pool` in `list_products` is a minor concern but works in practice. Overall this is high-quality, well-structured code with only the truncation issue preventing a perfect functional score.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [
                "Uses SQLAlchemy ORM instead of asyncpg directly as specified in the task requirements",
                "The task explicitly requested asyncpg as the database driver but code uses SQLAlchemy async ORM layer on top of asyncpg"
              ],
              "brief_assessment": "The code is entirely valid Python with proper async/await patterns and good structural organization (models, schemas, services). However, the task explicitly requested using asyncpg as the database driver directly, but the code uses SQLAlchemy's async ORM with asyncpg as a backend\u2014this is a significant deviation from the API requirement. Additionally, the code is truncated mid-function (create_product is cut off at 'await self.session.fl'), the actual FastAPI router/endpoint file is missing entirely, and the lifespan_context doesn't match FastAPI's lifespan signature. Despite good code quality in what's present, the incompleteness and wrong library choice are notable issues.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": false
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "async def",
                "await.*fetch|await.*execute",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [
                "import asyncpg|from asyncpg",
                "create_pool|Pool"
              ],
              "expected_hit_count": 4,
              "expected_total": 6,
              "expected_hit_rate": 0.6666666666666666,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-03",
      "task_type": "similar_syntax",
      "target_language": "javascript",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using idiomatic Express.js middleware patterns and correct node-postgres (pg) Pool API usage. All requested features are implemented: shared Pool instance attached to req, /db/health endpoint handler, SIGTERM graceful shutdown, and configuration for max pool size, idle timeout, and connection timeout. The usage example is truncated but the core middleware module is complete. Minor quality concerns include verbose logging in production middleware (connect/acquire events), calling process.exit() inside uncaughtException handler, and the shutdown timeout that logs a warning but doesn't actually force termination. Overall it's well-structured and functional.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct JavaScript using idiomatic Express.js middleware patterns and the 'pg' library's Pool API correctly (pool.connect(), pool.query(), pool.end(), pool events, pool stats properties). It covers most requested features \u2014 shared pool, request attachment, health check endpoint, and pool configuration \u2014 but the graceful shutdown handler (setupGracefulShutdown) is truncated/cut off, leaving that feature incomplete. The overwriting of req.query with a custom function shadows Express's built-in req.query (query string parameters), which is a notable design concern but not a cross-language contamination issue.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 4,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "req.query is overwritten, which shadows Express's built-in req.query (parsed query string parameters) \u2014 this is a significant idiomatic issue in Express.js"
              ],
              "brief_assessment": "The code is well-structured JavaScript using idiomatic Express.js middleware patterns and correct pg (node-postgres) Pool API usage. It implements all requested features: shared Pool instance, request attachment, /db/health endpoint, SIGTERM graceful shutdown, and pool configuration (max, idle timeout, connection timeout). The major issue is overwriting req.query, which shadows Express's built-in query string parser \u2014 a notable Express anti-pattern. The code is truncated at the end (unhandledRejection handler is cut off), but the vast majority of functionality is present and correct.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct JavaScript using idiomatic Express.js middleware patterns and the node-postgres (pg) library API. All requested features are fully implemented: a shared Pool instance with configurable max pool size, idle timeout, and connection timeout; middleware attaching the pool to req.db; a /db/health endpoint that tests the connection and returns pool statistics; and graceful shutdown on SIGTERM (plus SIGINT as a bonus). The code is production-quality with proper error handling, pool event listeners, transaction examples with client.release() in finally blocks, parameterized queries, and clear modular structure. No cross-language contamination detected.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": false
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [
                "pool\\.connect"
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "Overriding req.query (which is Express's built-in query string property) with a custom database query function is a significant design issue, though not cross-language contamination per se"
              ],
              "brief_assessment": "The code is entirely valid JavaScript using the correct pg and Express.js APIs idiomatically. It implements pool creation with configurable max size, idle timeout, and connection timeout, attaches the pool to the request object, provides a health check handler, and includes graceful shutdown logic. However, the code is truncated at the end (the setupSignalHandlers function and the full SIGTERM setup are cut off), and overriding req.query is a notable design flaw. No cross-language contamination is detected; the patterns are all idiomatic Node.js/Express.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using ES module syntax with correct, idiomatic usage of both Express.js and the 'pg' (node-postgres) library. All requested features are implemented: shared Pool with configurable max size, idle timeout, and connection timeout; middleware attaching pool to req; /db/health endpoint; and graceful shutdown via exported function. The code is truncated at the end \u2014 the server startup (`app.listen`) and the `process.on('SIGTERM', gracefulShutdown)` registration are cut off, which means the SIGTERM handler is not actually wired up in the visible code, costing it on functional completeness. Otherwise the code is well-structured with good error handling, pool event listeners, and example routes demonstrating transactions.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": false
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [
                "pool\\.connect"
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using correct Express.js middleware patterns and the pg library's Pool API idiomatically. It implements all requested features: shared pool creation with configurable max size, idle timeout, and connection timeout; middleware attaching the pool to req; a /db/health handler that tests the connection and reports pool stats; and SIGTERM graceful shutdown. However, the code is truncated at the end (the unhandledRejection handler is cut off), and overriding req.query (which is Express's built-in query string property) is a notable design flaw. The helper methods on req (transaction, getDbClient) go beyond what was asked but are reasonable additions. No cross-language contamination was detected.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent JavaScript/Node.js code that correctly implements all requested features: shared Pool instance with configurable max pool size, idle timeout, and connection timeout; middleware attaching pool to request object; /db/health endpoint with connection testing and pool statistics; and graceful SIGTERM shutdown. The code uses idiomatic Express.js middleware patterns and correct node-postgres (pg) API usage throughout, including proper client.release() in a finally block, pool event listeners, and pool statistics properties (totalCount, idleCount, waitingCount). The code is well-structured, documented, and production-ready with comprehensive error handling.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using correct Express.js middleware patterns and idiomatic node-postgres (pg) Pool API including pool events (connect, acquire, release, error, remove), pool properties (totalCount, idleCount, waitingCount), and proper client.release() in transactions. It implements all requested features: shared Pool instance, request attachment, /db/health endpoint, SIGTERM handling, and pool configuration. However, the code appears truncated at the health check handler (cut off mid-assignment of result.rows), so the full implementation is incomplete \u2014 likely missing the closing of the healthCheckHandler, the router setup for /db/health, and possibly an app integration example. The 'release' event callback signature `(err, client)` is incorrect per pg docs (it should just be `(client)`), which is a minor API inaccuracy.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent, idiomatic JavaScript/Node.js code that fully accomplishes the stated task. It correctly uses the 'pg' Pool API with proper configuration (max pool size, idleTimeoutMillis, connectionTimeoutMillis), attaches the pool to the request object via Express middleware, implements a comprehensive /db/health endpoint with pool statistics, and handles SIGTERM graceful shutdown via pool.end(). The code goes beyond requirements with additional features like SIGINT handling, pool event listeners, helper methods for client acquisition, and detailed health check responses. No cross-language contamination detected \u2014 all patterns are idiomatic Node.js/Express. The usage example is truncated but the core implementation is complete.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct JavaScript with proper use of Express.js middleware patterns and the pg library's Pool API. Pool configuration, event handlers, health check endpoint, and SIGTERM graceful shutdown are all implemented as requested. Minor issues: the `initializeDatabase` function appears truncated (missing closing brace and return statement), overriding `req.query` shadows Express's built-in `req.query` (query string parameters), and `query_timeout`/`statement_timeout` use snake_case which is the pg convention but mixed with camelCase config inputs. Overall well-structured and functional.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct JavaScript using ES module syntax with Express.js and the 'pg' library. All APIs are used idiomatically \u2014 Pool configuration with `max`, `idleTimeoutMillis`, `connectionTimeoutMillis`, pool events (`error`, `connect`, `remove`), `pool.query()`, `pool.connect()`, `client.release()`, and pool statistics (`totalCount`, `idleCount`, `waitingCount`) all match the node-postgres API precisely. All requested features are implemented: shared Pool instance, middleware attaching pool to `req`, `/db/health` endpoint, SIGTERM graceful shutdown, and configurable pool size/idle timeout/connection timeout. The code is production-quality with proper error handling, pool statistics in health checks, transaction helpers, and environment-based configuration.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-04",
      "task_type": "grounded",
      "target_language": "typescript",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "memberExists function chains multiple .where() calls instead of using drizzle-orm's and() combinator, which is not idiomatic Drizzle ORM \u2014 the second .where() would overwrite the first rather than combining them"
              ],
              "brief_assessment": "The code is well-structured TypeScript with correct Drizzle ORM schema definitions, proper relations, and typed query functions covering all three requested operations (listing members, adding a member, org details with member count). The schema accurately mirrors the SQL with proper foreign keys, unique constraints, and defaults. The main issue is in `memberExists` where two `.where()` calls are chained \u2014 Drizzle ORM's query builder replaces the previous where rather than ANDing them, so `and(eq(...), eq(...))` should be used instead. The code also provides bonus utility functions beyond what was requested, which is nice but the usage example comment is truncated.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definition correctly uses pgTable, serial, varchar, timestamp with timezone, integer references with cascade, composite unique constraints, and proper relations. The query functions are fully idiomatic\u2014using eq, count, leftJoin, groupBy, .returning(), and the relational query API (db.query.organizations.findFirst with 'with'). All three requested query functions (list members, add member, get org with member count) are implemented correctly, plus bonus functions like slug-based lookups and relation-based queries. Error handling for unique constraint violations and proper type inference exports round out a production-quality implementation.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definition correctly maps the SQL schema using proper Drizzle pg-core primitives (serial, varchar, timestamp with timezone, integer with cascade references, composite unique constraint). The relations are properly defined, and all three required query functions are implemented idiomatically: listOrgMembers uses select/from/where, addMember uses insert/values/returning, and getOrgWithMemberCount uses a left join with groupBy and count aggregation. The code also provides bonus features like an alternative relational query approach, helper queries, type exports, and proper project structure. The only trivial note is the output appears slightly truncated at the very end of the markdown, but all code is complete.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definitions correctly use pgTable, serial, varchar, integer, and timestamp with timezone \u2014 all matching the SQL schema precisely. The relations are properly defined using Drizzle's relations API, and the query functions use idiomatic Drizzle patterns including select/from/where chains, .returning(), count() aggregation with groupBy, and the relational query API (db.query.organizations.findFirst with 'with'). All three requested query functions are implemented plus bonus variants (by slug, relational queries). The code is well-organized across multiple files with proper type exports and JSDoc comments.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definitions correctly use pgTable, serial, varchar, integer, and timestamp with proper options (withTimezone, length, notNull, unique, references with onDelete). Relations are properly defined using the Drizzle relations API. All three required query functions are implemented correctly (listOrgMembers, addMember, getOrgWithMemberCount), plus several useful bonus functions. The code uses idiomatic Drizzle patterns including .returning(), sql template literals for aggregates, InferSelectModel/InferInsertModel for type inference, and the relational query API. The only minor note is the truncated usage example comment at the end, but this doesn't affect functionality.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent, idiomatic Drizzle ORM TypeScript code. The schema definition correctly uses pgTable, serial, varchar, integer, and timestamp with proper options (withTimezone, length, notNull, unique, default, references with onDelete). Relations are properly defined using Drizzle's relations API. All three required query functions are implemented correctly: listing members via select/where/eq, adding a member via insert/values/returning with proper error handling for unique constraint violations, and getting org details with member count via leftJoin/groupBy/count. The code goes beyond requirements by providing additional utility functions (by-slug variants, relational query). Type inference using $inferSelect and $inferInsert is idiomatic. No foreign language patterns or API contamination detected.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definition correctly uses pgTable, serial, varchar, timestamp with timezone, unique constraints, cascading deletes, and relations. The query functions idiomatically use Drizzle's select/insert/returning API, eq/count operators, leftJoin with groupBy for member counts, and the relational query API (db.query.organizations.findFirst with 'with'). All three requested query functions are implemented plus bonus functions. Type exports using $inferSelect/$inferInsert are idiomatic. The only very minor note is the output appears slightly truncated at the end (Key Features section), but all code is complete.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "getMemberByEmail uses chained .where() calls instead of drizzle-orm's `and()` combinator \u2014 chaining .where() twice overwrites the first condition rather than combining them"
              ],
              "brief_assessment": "The code is entirely valid TypeScript with proper Drizzle ORM usage for schema definition, relations, type inference, and most query functions. The schema correctly maps the SQL with proper column types, foreign keys, and unique constraints (though the composite unique on (org_id, email) is missing from the Drizzle schema). A notable bug exists in `getMemberByEmail` where two `.where()` calls are chained instead of using `and(eq(...), eq(...))`, which would cause incorrect filtering. The code goes beyond the three requested functions with useful extras, and the overall structure and typing are clean and production-oriented.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent TypeScript code using Drizzle ORM with fully idiomatic API usage. The schema definitions correctly map the SQL schema with proper types, constraints (unique composite key, foreign key with cascade, default values), and relations. All three requested query functions are implemented correctly\u2014listing org members, adding a member, and getting org details with member count\u2014plus several useful bonus functions like duplicate-safe member addition and slug-based lookup. The code demonstrates strong TypeScript practices with proper type inference, return type annotations, and clean organization.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definition correctly uses pgTable, serial, varchar, integer, and timestamp with proper constraints (unique, notNull, references with onDelete cascade). Relations are properly defined using Drizzle's relations API. The query functions are fully idiomatic\u2014using eq, count, leftJoin, groupBy, .returning(), and the relational query API (db.query.organizations.findFirst with 'with'). The code goes beyond the requirements by providing additional useful variants (by slug, with relations). Error handling for constraint violations is thoughtful. The only minor issue is the truncated usage example at the end, but all required functionality is fully implemented.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [
                "The `unique()` import is missing \u2014 should be imported from 'drizzle-orm/pg-core'; this is a minor omission rather than contamination"
              ],
              "brief_assessment": "The code is entirely valid TypeScript with idiomatic Drizzle ORM usage throughout. Schema definitions, relations, type exports, and all three requested query functions (listOrgMembers, addMember, getOrgWithMemberCount) are correctly implemented. The composite unique constraint uses the correct Drizzle API pattern but omits the `unique` import from 'drizzle-orm/pg-core'. The code goes above and beyond with alternative query approaches, bonus functions, config setup, and usage examples, demonstrating strong production-quality practices.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definition correctly uses pgTable, serial, varchar, integer, and timestamp with timezone. Relations are properly defined using Drizzle's relations API. The query functions are idiomatic \u2014 using eq(), count(), leftJoin, groupBy, .returning(), and the relational query API (db.query.organizations.findFirst with 'with'). All three requested query functions are implemented plus bonus utilities. The only minor issue is the final example route is truncated mid-catch block, but all core task requirements are fully met.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-05",
      "task_type": "adjacent_domain",
      "target_language": "typescript",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, correct ioredis API usage (get, setex, set, del, connect, event handlers), and idiomatic patterns. However, the code is truncated mid-function \u2014 the delete method is cut off and the invalidatePattern method is completely missing, which means a significant portion of the requested functionality is absent. The implemented portions (get, set, partial delete) are well-structured with proper error handling, custom error class, serialization/deserialization, connection management, and logging.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, and uses the ioredis API idiomatically (Redis constructor, get, setex, set, del, scanStream, keys, pipeline). It implements get, set, and partially implements the module, but the code is truncated mid-method \u2014 the set method's closing brace is cut off and the delete() and invalidatePattern() methods are missing, which means about 60-70% of the required functionality is present. The code quality is good with proper error handling via a custom CacheError class, connection management with lazyConnect, key prefixing, and JSON serialization, but the incompleteness and use of console.log for logging (rather than a configurable logger) slightly detract.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper use of ioredis APIs, generics, and idiomatic patterns. However, the code is clearly truncated mid-implementation \u2014 the set() method is cut off, and the delete() and invalidatePattern() methods are missing entirely, meaning only about half the requested functionality is present. What is implemented demonstrates high quality with good error handling, custom error classes, connection management, serialization wrapping, and debug logging.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, and uses ioredis APIs idiomatically (get, setex, del, pipeline). It implements get, set, delete, and invalidatePattern as requested, plus bonus methods like getOrSet. However, the code is truncated mid-function (exists method is cut off), and the scanKeys helper method referenced by invalidatePattern is never defined, which means invalidatePattern would fail at runtime. The connection-state tracking via isConnected is a reasonable but imperfect approach since the Redis ready event isn't used (connect fires before the connection is fully ready). Overall good quality but incomplete.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, error handling, and idiomatic ioredis API usage (get, setex, ping, event handlers). However, the code is truncated mid-function \u2014 the set method is cut off, and the delete and invalidatePattern methods are completely missing, meaning roughly half the required functionality is absent. What is present is well-structured with good patterns like custom error classes, serialization wrappers, connection management, and logging.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper use of generics, interfaces, and type annotations. The ioredis API usage is idiomatic and correct, including Redis constructor patterns, event handling, and RedisOptions. However, the code is truncated mid-function \u2014 the deserialize method is cut off, and the core public methods (get, set, delete, invalidatePattern) are missing entirely, which significantly impacts functional completeness. The implemented portions demonstrate production-quality patterns including custom error classes, connection management, retry strategies, and debug logging.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with correct ioredis API usage, proper generics, and idiomatic patterns. However, the code is truncated mid-function \u2014 the set() method is cut off, and the delete() and invalidatePattern() methods are completely missing, meaning only about half the required functionality is implemented. What is present is well-structured with good error handling, connection management, serialization wrappers, and debug logging.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, ioredis API usage, and comprehensive error handling. The ioredis API is used idiomatically (get, setex, del, scan via scanStream or manual SCAN). The code is truncated \u2014 it cuts off mid-method (ttl) and likely misses the scanKeys helper method, serialize/deserialize methods, getPrefixedKey, and disconnect, so it doesn't fully implement all pieces, though the core requested methods (get, set, delete, invalidatePattern) appear complete. The retryStrategy returning `null` instead of `undefined` for stopping retries is a minor issue with ioredis typing. Overall it's well-structured with good patterns like batch deletion, key prefixing, and connection state management.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper use of generics, async/await, and ioredis APIs. The ioredis API usage is idiomatic, including correct use of `setex`, `get`, `del`, `keys`, and event handlers, though importing `Redis as RedisClient` from ioredis is slightly unusual. However, the code is truncated \u2014 it cuts off mid-method (`setSafe`), and critically the `delete` and `invalidatePattern` methods are not visible, meaning at least two of the four required methods are missing from the output. The implemented portions demonstrate good quality with custom error classes, serialization wrappers, and connection management.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper use of ioredis APIs, generics, and idiomatic patterns like discriminated unions for CacheResult. However, the code is clearly truncated mid-function \u2014 the get method is cut off, and the set, delete, and invalidatePattern methods are missing entirely, meaning only roughly half the requested functionality is actually implemented. What is present demonstrates high quality with good error handling, connection retry logic, JSDoc documentation, and proper configuration management.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": false
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [
                "JSON\\.parse|JSON\\.stringify"
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, type annotations, and idiomatic ioredis API usage (lazyConnect, retryStrategy, reconnectOnError, event handlers). However, the code is truncated mid-implementation \u2014 the set() method is cut off, and the delete() and invalidatePattern() methods are completely missing, meaning only about half of the required functionality is present. What is implemented demonstrates high quality with good error handling, serialization wrapping, connection management, and a custom CacheError class.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, and uses the ioredis API idiomatically (scanStream, pipeline, setex, etc.). All four required methods (get, set, delete, invalidatePattern) are implemented with correct JSON serialization/deserialization and connection error handling. However, the code is truncated mid-function (the `exists` method is cut off at `catch`), which slightly impacts completeness and quality. The `isConnected` flag tracking via events is a reasonable but imperfect approach to connection state management. The use of a result-object pattern rather than throwing exceptions is a deliberate design choice that works well for a caching layer.",
              "cached": false
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    }
  ]
}