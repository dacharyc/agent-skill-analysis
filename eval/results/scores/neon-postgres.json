{
  "skill_name": "neon-postgres",
  "scored_at": "2026-02-16T10:37:50.888510+00:00",
  "model_judge": "claude-opus-4-6",
  "model_generation": "claude-sonnet-4-5-20250929",
  "contamination_score": 0.0,
  "risk_level": "medium",
  "test_category": "hidden_contamination",
  "tasks": [
    {
      "task_id": "neon-postgres-01",
      "task_type": "direct_target",
      "target_language": "typescript",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct TypeScript with no foreign language patterns. It uses the @neondatabase/serverless driver's neon() function idiomatically with parameterized queries, correctly typing NeonQueryFunction. The code fully accomplishes the task: creates a connection via neon() with DATABASE_URL, runs a parameterized SELECT query filtering by email domain, returns typed User objects, and handles connection errors. Providing both Pages Router and App Router versions is a nice touch. The minor truncation in the example usage snippet doesn't affect the completeness of the actual module. Code quality is production-grade with proper validation, error handling, JSDoc comments, and typed API responses.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 5,
              "contamination_signals": [
                "The generic type parameter in the tagged template `sql<User[]>` may not be supported by the actual @neondatabase/serverless neon() function \u2014 the tagged template returns a NeonQueryFunction result typed as rows array, not accepting a generic in that way",
                "The alternative `.query()` method on the neon() HTTP function may not exist \u2014 `.query()` is a method on the Pool/Client objects from @neondatabase/serverless, not on the neon() tagged template function itself"
              ],
              "brief_assessment": "The code is well-structured, entirely valid TypeScript, and follows Next.js App Router conventions correctly. It demonstrates good practices including input validation, error handling, environment variable checking, and parameterized queries. However, there are minor API idiomaticity issues: the `sql<User[]>` generic on the tagged template literal may not be the correct typing API for `neon()`, and the alternative version's `sql.query()` method doesn't exist on the neon() HTTP function (it exists on Pool/Client instead). These are relatively subtle API misuses but don't constitute cross-language contamination \u2014 they're within-ecosystem confusion between the neon() HTTP wrapper and the Pool/Client interfaces.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [
                "The generic type parameter `neon<User[]>()` is not a real feature of the @neondatabase/serverless driver \u2014 the `neon()` function does not accept a generic type parameter for return type inference. This suggests a slight misunderstanding or fabrication of the API, though it's a minor issue rather than cross-language contamination."
              ],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js App Router conventions and comprehensive error handling. It correctly uses the `neon()` function with tagged template literals / parameterized queries and covers all task requirements: User interface, parameterized SELECT by email domain, typed return, and error handling. The only notable issue is the use of `neon<User[]>()` which is not a real generic overload in the @neondatabase/serverless API \u2014 the driver returns `Record<string, unknown>[]` and requires manual casting. Otherwise, the code is production-quality with thorough input validation, clear documentation, and even includes a commented Pages Router alternative.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js App Router conventions and correct usage of the @neondatabase/serverless driver's tagged template literal API. The generic type parameter `sql<User[]>` is a minor idiom concern \u2014 the neon() tagged template returns `NeonQueryFunction` whose generic works slightly differently (it returns rows directly, and the generic annotation style varies by version), but this is a common and generally accepted pattern. The code fully accomplishes all requested features: User interface, parameterized queries, typed results, error handling, and DATABASE_URL usage. The additional reusable client module and extra query functions go beyond requirements, demonstrating production-quality organization.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [
                "The generic type parameter `sql<User[]>(...)` may not exactly match the Neon driver's actual type signature \u2014 `neon()` returns `NeonQueryFunction` whose generic typically represents the row type, not an array type; the correct usage would be `sql<User>(...)` or simply casting the result, though this is a minor API usage issue rather than cross-language contamination"
              ],
              "brief_assessment": "The code is entirely valid TypeScript with no cross-language contamination. It correctly implements all requested features: neon() connection, parameterized query, typed User interface, and comprehensive error handling. Both Pages Router and App Router versions are provided with idiomatic Next.js patterns. The only minor issue is the generic type parameter usage with `sql<User[]>()` \u2014 the Neon driver's `NeonQueryFunction` generic typically takes the row type rather than an array type, so `sql<User>()` would be more accurate, but this is a subtle API detail rather than a foreign pattern.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js App Router conventions. The neon() tagged template literal usage is idiomatic, though the generic type parameter `sql<User[]>` is slightly off \u2014 the neon driver's tagged template returns `NeonQueryFunction` results where the generic should be the row type (e.g., `sql<User>`) not an array. The `created_at` field typed as `Date` won't actually be a Date object since the HTTP-based neon driver returns strings for timestamps. Overall the code is well-structured with good error handling, input validation, and proper parameterized queries preventing SQL injection.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [
                "The generic type parameter `neon<User[]>(...)` is not part of the actual @neondatabase/serverless API - the `neon()` function doesn't accept a generic type parameter in this way; the return type is inferred from the tagged template literal usage, though the rows are untyped `Record` objects by default"
              ],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js patterns for both App Router and Pages Router. It correctly uses the neon() tagged template literal for parameterized queries, handles errors comprehensively, includes proper input validation, and defines clean TypeScript interfaces. The only notable issue is the `neon<User[]>()` generic parameter which doesn't match the actual @neondatabase/serverless API signature \u2014 the function returns `NeonQueryFunction` and rows come back as generic row objects, not typed via a generic parameter. Despite this minor API inaccuracy, the overall code quality is excellent with good error handling, security considerations, and thorough documentation.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [
                "neon\\("
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js App Router conventions and correct usage of the @neondatabase/serverless driver's tagged template literal API. One minor concern: the generic type parameter `sql<User[]>` may not work exactly as shown \u2014 the neon() tagged template returns `NeonQueryFunction` which returns rows as an array, and the generic typing might need to be `sql<User>` (rows of User) rather than `sql<User[]>`. The LIKE pattern `'%' + domain` without escaping the `@` or trailing characters could match unintended rows, but functionally it accomplishes the stated task. Overall this is high-quality, well-structured code with proper error handling, input validation, and a bonus client component.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct TypeScript with no foreign language patterns. It correctly uses the @neondatabase/serverless driver's neon() function with parameterized queries, proper Next.js API route patterns for both Pages Router and App Router, and well-defined TypeScript interfaces. All requested features are present: connection via DATABASE_URL, parameterized SELECT query filtering by email domain, typed User interface, and comprehensive error handling. The code is production-quality with thorough validation, discriminated union response types, proper HTTP method checking, and clear documentation. The only minor note is the App Router version is slightly truncated at the end, but the logic is complete enough to be fully functional.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 5,
              "contamination_signals": [
                "The generic type parameter on the tagged template literal `sql<User[]>` is not the documented API for @neondatabase/serverless's neon() function \u2014 the return type of the tagged template is `NeonQueryPromise<FullQueryResults<Record<string, unknown>>>` by default, not a generic you parameterize with `<User[]>`. This is a minor misuse but reflects possible confusion with other DB libraries like slonik or pg-typed.",
                "The alternative `.query()` method shown does not exist on the function returned by `neon()`. The neon() HTTP function is a tagged template function, not an object with a `.query()` method. The `.query()` pattern resembles node-postgres (`pg`) Pool/Client API, which is a cross-library contamination."
              ],
              "brief_assessment": "The code is well-structured, entirely in TypeScript, and demonstrates solid Next.js App Router patterns with good error handling and input validation. The primary tagged-template usage of neon() is close to correct, though the generic type parameter `sql<User[]>` is not part of the actual @neondatabase/serverless API \u2014 results are plain row arrays that would need to be cast. The alternative `.query()` method does not exist on the neon() function and is a contamination from the node-postgres (pg) API. Overall the code would mostly work after minor corrections but has notable API idiom issues in the alternative section.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct TypeScript with proper Next.js App Router patterns and idiomatic use of the @neondatabase/serverless driver's tagged template literal syntax. The generic type parameter `sql<User[]>` may not perfectly match the Neon driver's actual type signature (the driver returns `NeonQueryFunction` results that are already array-like, so `User[]` as generic might be slightly off \u2014 some versions expect the row type, not an array type), but this is a minor deviation. The module fully accomplishes all requested features: User interface, parameterized query, error handling, typed return values, and DATABASE_URL usage. Code quality is excellent with input validation, domain format checking, comprehensive error handling, and both App Router and Pages Router examples provided.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "sql<User[]>`` tagged template generic syntax - the neon() tagged template function returns rows typed as NeonQueryFunction, and the generic parameter should be Record<string, unknown>[] or similar, not User[]. The actual return type from the tagged template is already an array of rows, so User[] as generic would produce User[][] effectively.",
                "sql.query<User>() - the neon() function returned by the serverless driver does not have a .query() method. This pattern resembles node-postgres (pg) Pool/Client .query() API, not the @neondatabase/serverless neon() HTTP function.",
                "The .query() method returns a result object with .rows property in pg, not directly an array - the code treats the return as User[] directly, mixing pg conventions incorrectly."
              ],
              "brief_assessment": "The code is entirely valid TypeScript with proper Next.js App Router conventions (route.ts, NextRequest/NextResponse). However, there are notable API contamination issues: the tagged template generic `sql<User[]>` is not how the neon() function's generics work (it should be applied per-row, not as the full array type), and the `sql.query()` method does not exist on the neon() HTTP query function \u2014 this appears borrowed from node-postgres's Client/Pool API. The first module covers all requested features (connection, parameterized query, typed results, error handling), but the second module's 'manual query' approach would fail at runtime.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*@neondatabase/serverless|neon.*serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": true
                },
                {
                  "pattern": "process\\.env\\.DATABASE_URL|DATABASE_URL",
                  "matched": true
                },
                {
                  "pattern": "interface\\s+User|type\\s+User",
                  "matched": true
                },
                {
                  "pattern": "async\\s+function|async\\s+\\(",
                  "matched": true
                },
                {
                  "pattern": "export",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*@neondatabase/serverless|neon.*serverless",
                "neon\\(",
                "process\\.env\\.DATABASE_URL|DATABASE_URL",
                "interface\\s+User|type\\s+User",
                "async\\s+function|async\\s+\\(",
                "export"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import psycopg|import asyncpg",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "pip install",
                  "matched": false
                },
                {
                  "pattern": "def\\s+\\w+\\(",
                  "matched": false
                },
                {
                  "pattern": "class\\s+.*Model",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-02",
      "task_type": "cross_language",
      "target_language": "python",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with idiomatic FastAPI and asyncpg usage, including proper lifespan management, connection pooling, Pydantic models, and async/await patterns. However, the code is truncated mid-function \u2014 the GET /products endpoint is cut off at 'page_siz', and the GET /products/{id} and POST /products endpoints are missing entirely, meaning only a portion of the required task is implemented. The implemented portions demonstrate good quality with validation, pagination, search functionality, and proper schema initialization.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python with idiomatic FastAPI and asyncpg usage, including proper connection pooling via asyncpg.create_pool, async context managers, Pydantic v2 models, and parameterized queries. However, the code is truncated mid-function in the products router \u2014 the list_products endpoint is cut off at the conversion step, and the GET /products/{id} and POST /products endpoints are missing entirely, meaning only a fraction of the required task is implemented. The architecture (config, database module, models, router separation) is well-structured and production-oriented.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python using idiomatic FastAPI and asyncpg patterns. It properly implements the lifespan context manager for connection pool management, uses asyncpg's parameterized queries ($1, $2...), Pydantic models, and async/await throughout. All three requested endpoints (GET /products with pagination, GET /products/{id}, POST /products) are fully implemented. The code is truncated at the end (the PUT endpoint is cut off mid-string), but this only affects bonus functionality beyond the requirements. Minor concern: the `price` field uses Python `float` but the DB column is `DECIMAL`, which could cause type mismatch issues with asyncpg; using `Decimal` would be more robust.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 3,
              "code_quality": 3,
              "contamination_signals": [
                "Uses SQLAlchemy ORM instead of raw asyncpg as explicitly requested",
                "References undefined BaseService class suggesting Java/C#-style service layer pattern",
                "Code is truncated mid-function (check_sku_exists)",
                "Missing the actual FastAPI endpoint/router code entirely"
              ],
              "brief_assessment": "The code is syntactically valid Python throughout, with proper async/await patterns and modern Python type hints. However, it fundamentally deviates from the task requirements by using SQLAlchemy ORM instead of raw asyncpg as the database driver, which was explicitly requested. The code also references an undefined BaseService generic class (a pattern more common in Java/C# enterprise architectures), is truncated mid-function, and critically never includes the actual FastAPI router/endpoint definitions \u2014 the core deliverable of the task. The schemas and model definitions are well-structured but the overall submission is incomplete.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": false
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "async def",
                "await.*fetch|await.*execute",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [
                "import asyncpg|from asyncpg",
                "create_pool|Pool"
              ],
              "expected_hit_count": 4,
              "expected_total": 6,
              "expected_hit_rate": 0.6666666666666666,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": true
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [
                "const\\s+|let\\s+|var\\s+"
              ],
              "anti_pattern_hit_count": 1,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.16666666666666666,
              "contamination_detected": true
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid Python with proper use of FastAPI, asyncpg, and Pydantic. It demonstrates idiomatic async/await patterns, connection pooling via asyncpg.create_pool, the modern lifespan context manager, and proper dependency injection with Depends. However, the code is truncated mid-function \u2014 the list_products endpoint is cut off during the total_pages calculation, and we never see the completion of that endpoint nor the GET /products/{id} endpoint or POST /products endpoint, so roughly only half the task is implemented. The use of a global pool with a dependency that yields from `pool.acquire()` is idiomatic asyncpg/FastAPI usage. Minor note: `decimal_places` is not a valid Field parameter in Pydantic v2, but this is a small issue.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python with idiomatic use of FastAPI, asyncpg, and Pydantic. It implements all three requested endpoints (GET /products with pagination, GET /products/{id}, POST /products) plus connection pooling via asyncpg.create_pool and proper async/await patterns throughout. The code is truncated at the very end (uvicorn.run call is incomplete), which is a minor completeness issue. The price field uses Python float in the Pydantic model but DECIMAL in Postgres, which could cause precision issues \u2014 using Decimal would be more robust. The Database class pattern with class methods is functional but using FastAPI's dependency injection would be more idiomatic for production code.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with idiomatic use of FastAPI, asyncpg, and Pydantic v2 patterns (lifespan context manager, ConfigDict, Query parameters). The connection pooling setup, async/await patterns, and model definitions are well-structured. However, the code is truncated mid-function \u2014 the GET /products/{id} endpoint is cut off and the POST /products endpoint is missing entirely, meaning only about 60% of the requested functionality is actually implemented. The implemented portions (connection pooling, table creation, pagination, models) are high quality.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 3,
              "code_quality": 3,
              "contamination_signals": [
                "Task explicitly requests asyncpg as the database driver, but the code uses SQLAlchemy async ORM (AsyncSession, select, scalars) instead of raw asyncpg connection pool and queries",
                "No asyncpg.create_pool() or any asyncpg usage whatsoever \u2014 the entire database layer is SQLAlchemy-based",
                "References undefined BaseService generic class (src/services/base), suggesting this is scaffolded from a template rather than self-contained",
                "References src/database.py get_db dependency that is never defined in the provided code"
              ],
              "brief_assessment": "The code is syntactically valid Python and uses FastAPI idiomatically for routing, Pydantic schemas, and dependency injection. However, the task explicitly requires asyncpg as the database driver with connection pooling setup, yet the implementation uses SQLAlchemy's async ORM throughout, completely ignoring asyncpg. Critical pieces are missing: the database connection setup (get_db, engine creation), the BaseService class, and the main.py is truncated. The code would partially work if all missing dependencies existed, but it fails to meet the core requirement of using asyncpg directly.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [
                "import asyncpg|from asyncpg"
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": true
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [
                "const\\s+|let\\s+|var\\s+"
              ],
              "anti_pattern_hit_count": 1,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.16666666666666666,
              "contamination_detected": true
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely in Python with idiomatic FastAPI and asyncpg usage, including proper lifespan management, Pydantic models, connection pooling, and async/await patterns. However, the code is truncated mid-function \u2014 the list_products endpoint is cut off during the search query construction, and the GET /products/{id} and POST /products endpoints are completely missing. This means roughly half of the requested functionality (single product retrieval and creation) is absent. The implemented portions demonstrate production-quality patterns including proper validation, pagination response models, schema initialization, and error handling setup.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python with idiomatic FastAPI and asyncpg usage, including proper lifespan management, Pydantic models, connection pooling, and async/await patterns. However, the code is truncated mid-way through the POST /products endpoint \u2014 the create_product function body is cut off, so one of the three required endpoints is incomplete. The implemented portions (GET /products with pagination/search, GET /products/{id}) are well-structured and production-quality with proper error handling and parameterized queries.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct Python using idiomatic FastAPI and asyncpg patterns, including proper lifespan context manager, connection pooling, Pydantic models, and async/await throughout. All three required endpoints (GET /products with pagination, GET /products/{id}, POST /products) are implemented. The code is truncated at the very end of the POST handler \u2014 the last line is cut off mid-expression (`stock=r`), but the logic is clear and only a closing parenthesis and return are missing. The variable shadowing of the global `pool` in `list_products` is a minor concern but works in practice. Overall this is high-quality, well-structured code with only the truncation issue preventing a perfect functional score.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": true
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": true
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "import asyncpg|from asyncpg",
                "async def",
                "await.*fetch|await.*execute",
                "create_pool|Pool",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": false
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 3,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [
                "Task explicitly requests asyncpg as the database driver, but code uses SQLAlchemy ORM with asyncpg as the SQLAlchemy backend driver (postgresql+asyncpg), which is a different architectural pattern than direct asyncpg usage",
                "References a non-existent BaseService base class (src.services.base) suggesting template/boilerplate contamination",
                "Code is truncated mid-function in create_product, and the actual FastAPI router/endpoint file is never shown"
              ],
              "brief_assessment": "The code is valid Python with proper async/await patterns, good Pydantic v2 schemas, and well-structured SQLAlchemy async models. However, the task explicitly asked for asyncpg as the database driver, and the code wraps it behind SQLAlchemy ORM instead of using asyncpg directly \u2014 this is a significant deviation from the requirements. The code is also incomplete: it cuts off mid-function in the service layer and never provides the actual FastAPI router with the requested GET /products, GET /products/{id}, and POST /products endpoints, leaving the core deliverable missing.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "from fastapi|import fastapi",
                  "matched": true
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                },
                {
                  "pattern": "async def",
                  "matched": true
                },
                {
                  "pattern": "await.*fetch|await.*execute",
                  "matched": true
                },
                {
                  "pattern": "create_pool|Pool",
                  "matched": false
                },
                {
                  "pattern": "@app\\.get|@router\\.get",
                  "matched": true
                }
              ],
              "expected_hits": [
                "from fastapi|import fastapi",
                "async def",
                "await.*fetch|await.*execute",
                "@app\\.get|@router\\.get"
              ],
              "expected_misses": [
                "import asyncpg|from asyncpg",
                "create_pool|Pool"
              ],
              "expected_hit_count": 4,
              "expected_total": 6,
              "expected_hit_rate": 0.6666666666666666,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*drizzle",
                  "matched": false
                },
                {
                  "pattern": "import.*prisma",
                  "matched": false
                },
                {
                  "pattern": "const\\s+|let\\s+|var\\s+",
                  "matched": true
                },
                {
                  "pattern": "require\\(",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [
                "const\\s+|let\\s+|var\\s+"
              ],
              "anti_pattern_hit_count": 1,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.16666666666666666,
              "contamination_detected": true
            }
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-03",
      "task_type": "similar_syntax",
      "target_language": "javascript",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using idiomatic Express.js middleware patterns and correct node-postgres (pg) Pool API usage. All requested features are implemented: shared Pool instance attached to req, /db/health endpoint handler, SIGTERM graceful shutdown, and configuration for max pool size, idle timeout, and connection timeout. The usage example is truncated but the core middleware module is complete. Minor quality concerns include verbose logging in production middleware (connect/acquire events), calling process.exit() inside uncaughtException handler, and the shutdown timeout that logs a warning but doesn't actually force termination. Overall it's well-structured and functional.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using correct Express.js and node-postgres (pg) APIs. All requested features are implemented: shared Pool instance, request attachment via middleware, /db/health endpoint, SIGTERM graceful shutdown, and configuration for max pool size, idle timeout, and connection timeout. One concern is that `req.query` is overwritten, shadowing Express's built-in `req.query` (query string parameters), which could cause subtle bugs in production \u2014 this is a design issue rather than a contamination or language issue. The usage example is slightly truncated but the core middleware module is complete.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 4,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "req.query is overwritten, which shadows Express's built-in req.query (parsed query string parameters) \u2014 this is a significant idiomatic issue in Express.js"
              ],
              "brief_assessment": "The code is well-structured JavaScript using idiomatic Express.js middleware patterns and correct pg (node-postgres) Pool API usage. It implements all requested features: shared Pool instance, request attachment, /db/health endpoint, SIGTERM graceful shutdown, and pool configuration (max, idle timeout, connection timeout). The major issue is overwriting req.query, which shadows Express's built-in query string parser \u2014 a notable Express anti-pattern. The code is truncated at the end (unhandledRejection handler is cut off), but the vast majority of functionality is present and correct.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent JavaScript/Node.js code with no cross-language contamination. The code correctly uses the 'pg' library's Pool class with idiomatic patterns (pool.connect(), client.release(), pool.end(), pool event handlers like 'error', 'connect', 'acquire', 'remove'). All requested features are fully implemented: shared Pool instance, req.db attachment middleware, /db/health endpoint with connection testing and pool statistics, SIGTERM graceful shutdown, and configuration for max pool size, idle timeout, and connection timeout. The code is production-quality with proper error handling, environment variable configuration with defaults, and clean modular structure. The only minor note is the truncated example at the end, but all core middleware functionality is complete.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "Overriding req.query (which is Express's built-in query string property) with a custom database query function is a significant design issue, though not cross-language contamination per se"
              ],
              "brief_assessment": "The code is entirely valid JavaScript using the correct pg and Express.js APIs idiomatically. It implements pool creation with configurable max size, idle timeout, and connection timeout, attaches the pool to the request object, provides a health check handler, and includes graceful shutdown logic. However, the code is truncated at the end (the setupSignalHandlers function and the full SIGTERM setup are cut off), and overriding req.query is a notable design flaw. No cross-language contamination is detected; the patterns are all idiomatic Node.js/Express.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct JavaScript using idiomatic Express.js middleware patterns and the node-postgres (pg) library API. All requested features are implemented: shared Pool instance creation with configurable max pool size, idle timeout, and connection timeout; pool attachment to the request object; a /db/health endpoint that tests the connection and returns pool statistics; and graceful shutdown on SIGTERM (plus SIGINT as a bonus). The code is well-structured with JSDoc comments, proper error handling, pool event monitoring, and comprehensive usage examples including parameterized queries and transactions. The only minor note is that the POST /users example appears truncated at the end, but this is in the example usage section and all core middleware functionality is complete.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": false
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [
                "pool\\.connect"
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": true
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [
                "@neondatabase/serverless"
              ],
              "anti_pattern_hit_count": 1,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.16666666666666666,
              "contamination_detected": true
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using correct Express.js middleware patterns and the pg library's Pool API idiomatically. It implements all requested features: shared pool creation with configurable max size, idle timeout, and connection timeout; middleware attaching the pool to req; a /db/health handler that tests the connection and reports pool stats; and SIGTERM graceful shutdown. However, the code is truncated at the end (the unhandledRejection handler is cut off), and overriding req.query (which is Express's built-in query string property) is a notable design flaw. The helper methods on req (transaction, getDbClient) go beyond what was asked but are reasonable additions. No cross-language contamination was detected.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using ES module syntax. It correctly uses the 'pg' library's Pool class with idiomatic configuration (max, idleTimeoutMillis, connectionTimeoutMillis), pool events (error, connect, remove), and pool statistics (totalCount, idleCount, waitingCount). All requested features are fully implemented: shared pool instance, middleware attaching pool to req, /db/health endpoint, SIGTERM graceful shutdown, and configurable pool parameters. The code is well-structured, well-documented, and production-quality with proper error handling, environment variable configuration, and a clean separation of concerns.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": false
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [
                "pool\\.connect"
              ],
              "expected_hit_count": 5,
              "expected_total": 6,
              "expected_hit_rate": 0.8333333333333334,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using correct Express.js middleware patterns and idiomatic node-postgres (pg) Pool API including pool events (connect, acquire, release, error, remove), pool properties (totalCount, idleCount, waitingCount), and proper client.release() in transactions. It implements all requested features: shared Pool instance, request attachment, /db/health endpoint, SIGTERM handling, and pool configuration. However, the code appears truncated at the health check handler (cut off mid-assignment of result.rows), so the full implementation is incomplete \u2014 likely missing the closing of the healthCheckHandler, the router setup for /db/health, and possibly an app integration example. The 'release' event callback signature `(err, client)` is incorrect per pg docs (it should just be `(client)`), which is a minor API inaccuracy.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using correct Express.js middleware patterns and idiomatic pg (node-postgres) Pool API. It implements all requested features: shared Pool instance with configurable max pool size, idle timeout, and connection timeout; middleware attaching pool to req; health check handler at /db/health; and graceful SIGTERM shutdown. However, the code is truncated at the end (cut off mid-function in unhandledRejection handler), and the healthCheckHandler returns an async function from an async function (unnecessary double wrapping). The overriding of req.query (which Express uses for query string parameters) is a notable design concern but not a language contamination issue.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct JavaScript with proper use of Express.js middleware patterns and the pg library's Pool API. Pool configuration, event handlers, health check endpoint, and SIGTERM graceful shutdown are all implemented as requested. Minor issues: the `initializeDatabase` function appears truncated (missing closing brace and return statement), overriding `req.query` shadows Express's built-in `req.query` (query string parameters), and `query_timeout`/`statement_timeout` use snake_case which is the pg convention but mixed with camelCase config inputs. Overall well-structured and functional.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid JavaScript using correct Express.js and node-postgres (pg) APIs idiomatically. It implements all requested features: shared Pool instance, attachment to request object, /db/health endpoint, pool configuration (max, idle timeout, connection timeout), and SIGTERM graceful shutdown. The code is well-structured with good error handling, pool event logging, and helpful utilities (transaction helper, query wrapper). The only issue is that the app.js file is truncated \u2014 the gracefulShutdown function and SIGTERM signal handler are cut off mid-implementation, leaving the shutdown registration incomplete, which slightly impacts functional correctness and overall quality.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "require.*pg|import.*pg|Pool",
                  "matched": true
                },
                {
                  "pattern": "new Pool\\(",
                  "matched": true
                },
                {
                  "pattern": "pool\\.query|client\\.query",
                  "matched": true
                },
                {
                  "pattern": "pool\\.connect",
                  "matched": true
                },
                {
                  "pattern": "max:|connectionTimeoutMillis|idleTimeoutMillis",
                  "matched": true
                },
                {
                  "pattern": "SIGTERM|process\\.on",
                  "matched": true
                }
              ],
              "expected_hits": [
                "require.*pg|import.*pg|Pool",
                "new Pool\\(",
                "pool\\.query|client\\.query",
                "pool\\.connect",
                "max:|connectionTimeoutMillis|idleTimeoutMillis",
                "SIGTERM|process\\.on"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase/serverless",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "import.*neon",
                  "matched": false
                },
                {
                  "pattern": "drizzle\\(",
                  "matched": false
                },
                {
                  "pattern": "neonConfig",
                  "matched": false
                },
                {
                  "pattern": "import asyncpg|from asyncpg",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-04",
      "task_type": "grounded",
      "target_language": "typescript",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [
                "memberExists function chains multiple .where() calls instead of using drizzle-orm's and() combinator, which is not idiomatic Drizzle ORM \u2014 the second .where() would overwrite the first rather than combining them"
              ],
              "brief_assessment": "The code is well-structured TypeScript with correct Drizzle ORM schema definitions, proper relations, and typed query functions covering all three requested operations (listing members, adding a member, org details with member count). The schema accurately mirrors the SQL with proper foreign keys, unique constraints, and defaults. The main issue is in `memberExists` where two `.where()` calls are chained \u2014 Drizzle ORM's query builder replaces the previous where rather than ANDing them, so `and(eq(...), eq(...))` should be used instead. The code also provides bonus utility functions beyond what was requested, which is nice but the usage example comment is truncated.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent TypeScript code using Drizzle ORM with fully idiomatic API usage. The schema definition correctly maps all SQL constructs including serial, varchar with lengths, timestamp with timezone, foreign keys with cascade, and composite unique constraints. All three required query functions are implemented correctly (listOrgMembers, addOrgMember, getOrgWithMemberCount), plus bonus functions like a subquery variant and a relational query example. The code demonstrates proper use of Drizzle's relations API, type inference ($inferSelect/$inferInsert), and both the SQL-like query builder and relational query APIs. Error handling for unique constraint violations and the overall code organization are production-quality.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definition correctly uses pgTable, serial, varchar, integer, and timestamp with withTimezone, matching the SQL schema precisely. Relations are properly defined using Drizzle's relations API. All three required query functions are implemented correctly (listOrgMembers, addMember, getOrgWithMemberCount), plus bonus functions like slug-based lookups and relation-based queries. The code uses idiomatic Drizzle patterns including .returning(), count(), leftJoin with groupBy, and the relational query API (db.query.organizations.findFirst with 'with'). The usage example is slightly truncated but all core functionality is complete.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 5,
              "contamination_signals": [
                "getMemberByEmail uses chained .where() calls instead of drizzle-orm's and() combinator, which may not work as expected \u2014 the second .where() would override the first in Drizzle's select query builder"
              ],
              "brief_assessment": "The code is entirely valid TypeScript with no foreign language contamination. The Drizzle ORM API usage is largely idiomatic and correct \u2014 schema definitions, relations, inferred types, and query patterns all follow Drizzle conventions well. One notable issue is in getMemberByEmail where two .where() calls are chained instead of using and() to combine conditions, which would likely only apply the second filter. The code goes beyond the requirements by including a drizzle config, an extra query function, and a Next.js API route example, all of which are well-structured and production-quality.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definitions correctly use pgTable, serial, varchar, timestamp with timezone, references with onDelete cascade, and composite unique constraints. The relations are properly defined, and all three requested query functions (listOrgMembers, addMember, getOrgWithMemberCount) are implemented correctly using idiomatic Drizzle API patterns including .select(), .insert().values().returning(), leftJoin with sql template literals for count, and the relational query API. The code goes beyond requirements with bonus functions like removeMember and updateMemberRole, and includes proper TypeScript typing throughout.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent TypeScript code using Drizzle ORM idiomatically. The schema definition correctly maps the SQL tables with proper types, relations, unique constraints, and foreign key cascades. All three requested query functions (listOrgMembers, addMember, getOrgWithMemberCount) are implemented correctly using idiomatic Drizzle API patterns including select builders, insert with returning, left joins with groupBy, and the relational query API. The code goes above and beyond with alternative implementations (subquery approach, slug-based query with relations), proper type exports, and error handling. The only minor issue is the final error handling section is truncated, but all core requirements are fully met.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definition correctly uses pgTable, serial, varchar, timestamp with timezone, relations, and composite unique constraints matching the SQL schema exactly. The query functions are fully idiomatic Drizzle \u2014 using both the select builder API (listOrgMembers, getOrgWithMemberCount) and the relational query API (getOrgBySlugWithMembers), with proper use of eq, count, leftJoin, groupBy, returning(), and findFirst with 'with' clauses. All three requested query functions are implemented, plus bonus alternatives. Type exports using $inferSelect/$inferInsert are idiomatic. The code is well-structured, production-quality, and complete.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definition correctly uses pgTable, serial, varchar, timestamp with timezone, integer references with onDelete cascade, and composite unique constraints \u2014 all idiomatic Drizzle pg-core API. The query functions use proper Drizzle patterns: select/from/where chains, insert with returning, sql template literals for aggregates, leftJoin with groupBy, and relational queries via db.query with findFirst and `with`. The code goes beyond requirements by adding a slug-based query, relational query variant, error handling for constraint violations, type exports, drizzle config, and usage examples. The return type union in addMember is a minor design choice that could be debated, but overall this is production-quality code.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent TypeScript code using Drizzle ORM with fully idiomatic API usage. The schema definitions correctly map the SQL schema with proper types, constraints (unique composite key, foreign key with cascade, default values), and relations. All three requested query functions are implemented correctly\u2014listing org members, adding a member, and getting org details with member count\u2014plus several useful bonus functions like duplicate-safe member addition and slug-based lookup. The code demonstrates strong TypeScript practices with proper type inference, return type annotations, and clean organization.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with no foreign language patterns. It uses Drizzle ORM's API idiomatically\u2014pgTable definitions, relations, typed inserts/selects, the query builder with joins/groupBy, and the relational query API (db.query.organizations.findFirst with `with`). All three requested functions are implemented (listOrgMembers, addMember, getOrgWithMemberCount), plus useful extras like slug-based lookup, conflict handling, and relational queries. The schema accurately mirrors the SQL with proper types, constraints, cascading deletes, and inferred types. The only minor issue is the truncated usage example at the end, but all functional code is complete.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 5,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "This is excellent Drizzle ORM TypeScript code with no cross-language contamination. The schema definition correctly maps the SQL tables using proper Drizzle pg-core primitives (serial, varchar, timestamp with timezone, integer with references and cascade). Relations are properly defined, type inference exports are idiomatic ($inferSelect/$inferInsert), and all three requested query functions are implemented correctly using both the select API and relational query API. The code goes above and beyond with bonus functions (upsert, slug lookup, list all orgs) and includes proper typing throughout.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 4,
              "code_quality": 5,
              "contamination_signals": [
                "getMemberByEmail uses chained .where() calls instead of using `and()` from drizzle-orm to combine conditions \u2014 this is a subtle API misuse where the second .where() overwrites the first rather than combining them"
              ],
              "brief_assessment": "The code is entirely valid TypeScript with idiomatic Drizzle ORM usage throughout. The schema definition, relations, type inference, and most query functions are correctly implemented. One notable bug: `getMemberByEmail` chains two `.where()` calls, which in Drizzle ORM means the second overwrites the first \u2014 it should use `and(eq(members.orgId, orgId), eq(members.email, email))`. The code goes beyond requirements with bonus functions, a config file, and a full Next.js API route example, all well-structured and production-quality.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*drizzle-orm|from.*drizzle",
                  "matched": true
                },
                {
                  "pattern": "pgTable|serial|varchar|timestamp",
                  "matched": true
                },
                {
                  "pattern": "relations\\(|one\\(|many\\(",
                  "matched": true
                },
                {
                  "pattern": "eq\\(|and\\(",
                  "matched": true
                },
                {
                  "pattern": "export\\s+const",
                  "matched": true
                },
                {
                  "pattern": "InferSelectModel|InferInsertModel|typeof",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*drizzle-orm|from.*drizzle",
                "pgTable|serial|varchar|timestamp",
                "relations\\(|one\\(|many\\(",
                "eq\\(|and\\(",
                "export\\s+const",
                "InferSelectModel|InferInsertModel|typeof"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "import.*prisma|@prisma",
                  "matched": false
                },
                {
                  "pattern": "neon_api|NeonAPI",
                  "matched": false
                },
                {
                  "pattern": "from neon_api",
                  "matched": false
                },
                {
                  "pattern": "import psycopg",
                  "matched": false
                },
                {
                  "pattern": "class.*Model.*:",
                  "matched": false
                },
                {
                  "pattern": "def\\s+",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-05",
      "task_type": "adjacent_domain",
      "target_language": "typescript",
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, correct ioredis API usage (get, setex, set, del, connect, event handlers), and idiomatic patterns. However, the code is truncated mid-function \u2014 the delete method is cut off and the invalidatePattern method is completely missing, which means a significant portion of the requested functionality is absent. The implemented portions (get, set, partial delete) are well-structured with proper error handling, custom error class, serialization/deserialization, connection management, and logging.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 5,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely correct TypeScript with proper generics, idiomatic ioredis API usage (get, setex, set, del, event handlers, SCAN-based pattern matching would be expected), and excellent error handling with a custom CacheError class. The code is truncated mid-function in the invalidatePattern method, so it doesn't fully implement all requested features \u2014 specifically the pattern invalidation logic is missing. Everything else (get, set, delete, serialization, connection handling, key prefixing) is well-implemented and production-quality.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper use of ioredis APIs, generics, and idiomatic patterns. However, the code is clearly truncated mid-implementation \u2014 the set() method is cut off, and the delete() and invalidatePattern() methods are missing entirely, meaning only about half the requested functionality is present. What is implemented demonstrates high quality with good error handling, custom error classes, connection management, serialization wrapping, and debug logging.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, and uses ioredis APIs idiomatically (get, setex, del, scan with MATCH/COUNT). All four requested methods (get, set, delete, invalidatePattern) are fully implemented with JSON serialization/deserialization and connection error handling. The code is cut off mid-function in the `exists` method (a bonus method beyond requirements), so the core task is complete but the file is truncated. Minor issues: the `isConnected` flag-based connection check is a simplistic approach that could race with actual Redis state, and the `CacheError` uses a `cause` property that shadows the ES2022 Error cause option, but these are minor design concerns rather than correctness problems.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, error handling, and idiomatic ioredis API usage (get, setex, ping, event handlers). However, the code is truncated mid-function \u2014 the set method is cut off, and the delete and invalidatePattern methods are completely missing, meaning roughly half the required functionality is absent. What is present is well-structured with good patterns like custom error classes, serialization wrappers, connection management, and logging.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper use of ioredis APIs (get, setex, set, connect, event handlers) and idiomatic TypeScript generics. The ioredis client instantiation, event handling, and command usage are all correct. However, the code is clearly truncated mid-method \u2014 the delete() method is cut off, and the invalidatePattern() method is completely missing, meaning roughly half the required API surface is absent. The implemented portions demonstrate good quality with custom error classes, JSON serialization wrapper, connection management, key prefixing, and debug logging.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with correct ioredis API usage, proper generics, and idiomatic patterns. However, the code is truncated mid-function \u2014 the set() method is cut off, and the delete() and invalidatePattern() methods are completely missing, meaning only about half the required functionality is implemented. What is present is well-structured with good error handling, connection management, serialization wrappers, and debug logging.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, interfaces, and async/await patterns. The ioredis API is used idiomatically (get, setex, set, del, exists, ttl, scanKeys). All four requested methods (get, set, delete, invalidatePattern) are implemented with proper JSON serialization/deserialization and connection failure handling. The code appears truncated \u2014 the closing brace and the `scanKeys` helper method (referenced in `invalidatePattern`) along with `buildKey` are missing, and there's no `disconnect` method, which slightly impacts functional correctness and quality. The use of SCAN-based key iteration for pattern invalidation is a good practice over KEYS. Overall it's well-structured with bonus utility methods (exists, getTTL).",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 4,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper use of generics, async/await, and ioredis APIs. The ioredis API usage is idiomatic, including correct use of `setex`, `get`, `del`, `keys`, and event handlers, though importing `Redis as RedisClient` from ioredis is slightly unusual. However, the code is truncated \u2014 it cuts off mid-method (`setSafe`), and critically the `delete` and `invalidatePattern` methods are not visible, meaning at least two of the four required methods are missing from the output. The implemented portions demonstrate good quality with custom error classes, serialization wrappers, and connection management.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "with_skill": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, correct ioredis API usage (get, setex, set, del, event handlers, status checks), and idiomatic patterns. However, the code is truncated mid-function \u2014 the invalidatePattern method is cut off during the SCAN-based key iteration, meaning one of the four required methods is incomplete. The implemented portions (get, set, delete) are well-structured with good error handling, serialization, configuration options, and a custom CacheError class. The truncation significantly impacts functional completeness.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "skill_md_only": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 3,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper generics, type annotations, and idiomatic ioredis API usage (lazyConnect, retryStrategy, reconnectOnError, event handlers). However, the code is truncated mid-implementation \u2014 the set() method is cut off, and the delete() and invalidatePattern() methods are completely missing, meaning only about half of the required functionality is present. What is implemented demonstrates high quality with good error handling, serialization wrapping, connection management, and a custom CacheError class.",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          },
          "realistic": {
            "judge": {
              "language_correctness": 5,
              "api_idiomaticity": 5,
              "functional_correctness": 4,
              "code_quality": 4,
              "contamination_signals": [],
              "brief_assessment": "The code is entirely valid TypeScript with proper use of generics, async/await, and ioredis API patterns (get, setex, set, del, keys, pipeline). All four required methods (get, set, delete, invalidatePattern) are fully implemented with correct JSON serialization/deserialization and comprehensive error handling via a custom CacheError class. The code is truncated near the end (cutting off mid-comment in a TTL method and likely missing disconnect/stats methods), which slightly impacts completeness but all core requested functionality is present. The use of pipeline for batch deletions in invalidatePattern and the key prefix system demonstrate good design, though using KEYS in production could be a concern (SCAN would be preferable).",
              "cached": true
            },
            "patterns": {
              "expected_results": [
                {
                  "pattern": "import.*ioredis|import.*Redis",
                  "matched": true
                },
                {
                  "pattern": "class Cache|export class Cache",
                  "matched": true
                },
                {
                  "pattern": "<T>|generic",
                  "matched": true
                },
                {
                  "pattern": "JSON\\.parse|JSON\\.stringify",
                  "matched": true
                },
                {
                  "pattern": "get\\(|set\\(",
                  "matched": true
                },
                {
                  "pattern": "async\\s+",
                  "matched": true
                }
              ],
              "expected_hits": [
                "import.*ioredis|import.*Redis",
                "class Cache|export class Cache",
                "<T>|generic",
                "JSON\\.parse|JSON\\.stringify",
                "get\\(|set\\(",
                "async\\s+"
              ],
              "expected_misses": [],
              "expected_hit_count": 6,
              "expected_total": 6,
              "expected_hit_rate": 1.0,
              "anti_results": [
                {
                  "pattern": "@neondatabase",
                  "matched": false
                },
                {
                  "pattern": "neon\\(",
                  "matched": false
                },
                {
                  "pattern": "DATABASE_URL",
                  "matched": false
                },
                {
                  "pattern": "postgres|pg\\b|sql`",
                  "matched": false
                },
                {
                  "pattern": "drizzle|prisma",
                  "matched": false
                },
                {
                  "pattern": "SELECT|INSERT|CREATE TABLE",
                  "matched": false
                }
              ],
              "anti_pattern_hits": [],
              "anti_pattern_hit_count": 0,
              "anti_pattern_total": 6,
              "anti_pattern_hit_rate": 0.0,
              "contamination_detected": false
            }
          }
        }
      ]
    }
  ]
}