{
  "skill_name": "copilot-sdk",
  "generated_at": "2026-02-16T07:06:24.722451+00:00",
  "model": "claude-sonnet-4-5-20250929",
  "temperature": 0.3,
  "runs_per_condition": 3,
  "contamination_score": 0.63,
  "risk_level": "high",
  "test_category": "multi_sdk",
  "tasks": [
    {
      "task_id": "copilot-sdk-01",
      "task_type": "direct_target",
      "target_language": "typescript",
      "expected_patterns": [
        "import.*CopilotClient.*from.*@github/copilot-sdk",
        "defineTool",
        "createSession",
        "streaming:\\s*true",
        "onPreToolUse",
        "permissionDecision.*deny",
        "assistant\\.message_delta"
      ],
      "anti_patterns": [
        "from copilot import",
        "copilot\\.NewClient",
        "CopilotClient\\(\\).*\\.start\\(\\)",
        "create_session\\(",
        "send_and_wait\\(",
        "CreateSessionAsync"
      ],
      "pattern_sources": [
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/docs/getting-started.md",
          "description": "Copilot SDK getting started: CopilotClient import from @github/copilot-sdk, new CopilotClient(), createSession, defineTool, streaming: true, session.on with assistant.message_delta"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/docs/hooks/pre-tool-use.md",
          "description": "Pre-tool-use hooks: onPreToolUse handler, permissionDecision with allow/deny/ask options"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# GitHub Copilot SDK Streaming Application\n\nHere's a complete Node.js/TypeScript application that meets your requirements:\n\n```typescript\nimport { \n  CopilotClient, \n  CopilotStreamingSession,\n  ToolDefinition,\n  StreamingDelta\n} from '@github/copilot-sdk';\n\n// Define the custom search_docs tool\nconst searchDocsTool: ToolDefinition = {\n  name: 'search_docs',\n  description: 'Search through documentation to find relevant information',\n  parameters: {\n    type: 'object',\n    properties: {\n      query: {\n        type: 'string',\n        description: 'The search query to find relevant documentation'\n      }\n    },\n    required: ['query']\n  }\n};\n\n// Pre-tool-use hook that denies shell access\nfunction preToolUseHook(toolName: string, toolArgs: any): boolean {\n  // Deny any shell-related tools\n  const deniedTools = ['shell', 'bash', 'execute', 'run_command', 'terminal'];\n  \n  if (deniedTools.includes(toolName.toLowerCase())) {\n    console.error(`\\n[SECURITY] Tool \"${toolName}\" is denied for security reasons.\\n`);\n    return false; // Deny execution\n  }\n  \n  console.log(`\\n[TOOL USE] Allowing tool: ${toolName} with args:`, JSON.stringify(toolArgs));\n  return true; // Allow execution\n}\n\n// Handle streaming deltas\nfunction handleStreamingDelta(delta: StreamingDelta): void {\n  if (delta.type === 'content') {\n    // Write content deltas directly to stdout\n    process.stdout.write(delta.content || '');\n  } else if (delta.type === 'tool_call') {\n    console.log(`\\n[TOOL CALL] ${delta.toolName}:`, delta.toolArgs);\n  } else if (delta.type === 'tool_result') {\n    console.log(`\\n[TOOL RESULT]`, delta.result);\n  }\n}\n\nasync function main() {\n  try {\n    // Create the Copilot client\n    const client = new CopilotClient({\n      apiKey: process.env.GITHUB_COPILOT_TOKEN || process.env.COPILOT_API_KEY,\n      // Optional: specify endpoint if needed\n      // endpoint: 'https://api.github.com/copilot'\n    });\n\n    console.log('\ud83d\ude80 Starting Copilot streaming session with GPT-4.1...\\n');\n\n    // Create a streaming session\n    const session: CopilotStreamingSession = await client.createStreamingSession({\n      model: 'gpt-4.1',\n      messages: [\n        {\n          role: 'system',\n          content: 'You are a helpful assistant with access to documentation search capabilities.'\n        },\n        {\n          role: 'user',\n          content: 'Can you search the docs for information about authentication methods?'\n        }\n      ],\n      tools: [searchDocsTool],\n      temperature: 0.7,\n      maxTokens: 2000\n    });\n\n    // Register the pre-tool-use hook\n    session.onBeforeToolUse(preToolUseHook);\n\n    // Register tool implementation for search_docs\n    session.registerTool('search_docs', async (args: { query: string }) => {\n      console.log(`\\n[EXECUTING] Searching docs for: \"${args.query}\"\\n`);\n      \n      // Simulate a documentation search\n      // In a real application, this would query your actual documentation\n      const mockResults = [\n        {\n          title: 'OAuth 2.0 Authentication',\n          snippet: 'Use OAuth 2.0 for secure user authentication...'\n        },\n        {\n          title: 'API Key Authentication',\n          snippet: 'API keys provide a simple authentication method...'\n        },\n        {\n          title: 'JWT Tokens',\n          snippet: 'JSON Web Tokens (JWT) are used for stateless authentication...'\n        }\n      ];\n\n      return {\n        query: args.query,\n        results: mockResults,\n        count: mockResults.length\n      };\n    });\n\n    // Start streaming and handle deltas\n    console.log('\ud83d\udcdd Response:\\n');\n    \n    for await (const delta of session.stream()) {\n      handleStreamingDelta(delta);\n    }\n\n    console.log('\\n\\n\u2705 Streaming session completed successfully.');\n\n    // Get final message if needed\n    const finalMessage = await session.getFinalMessage();\n    console.log('\\n\ud83d\udcca Final message metadata:', {\n      role: finalMessage.role,\n      finishReason: finalMessage.finishReason,\n      tokensUsed: finalMessage.usage\n    });\n\n  } catch (error) {\n    console.error('\u274c Error:', error);\n    process.exit(1);\n  }\n}\n\n// Test the pre-tool-use hook with a denied tool\nasync function testSecurityHook() {\n  console.log('\\n\ud83d\udd12 Testing security hook...\\n');\n  \n  // Test allowed tool\n  const allowed = preToolUseHook('search_docs', { query: 'test' });\n  console.log(`search_docs allowed: ${allowed}\\n`);\n  \n  // Test denied tool\n  const denied = preToolUseHook('shell', { command: 'rm -rf /' });\n  console.log(`shell allowed: ${denied}\\n`);\n}\n\n// Run the application\nif (require.main === module) {\n  testSecurityHook();\n  main();\n}\n\nexport { main, preToolUseHook, searchDocsTool };\n```\n\n## Package.json\n\n```json\n{\n  \"name\": \"copilot-streaming-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"GitHub Copilot SDK streaming application with custom tools\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"ts-node src/index.ts\",\n    \"watch\": \"tsc --watch\"\n  },\n  \"dependencies\": {\n    \"@github/copilot-sdk\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"ts-node\": \"^10.9.1\",\n    \"typescript\": \"^5.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}\n```\n\n## tsconfig.json\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"moduleResolution\": \"node\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## .env.example\n\n```bash\n# GitHub Copilot API Token\nGITHUB_COPILOT_TOKEN=your_token_here\n\n# Alternative environment variable name\nCOPILOT_API_KEY=your_token_here\n```\n\n## Usage Instructions\n\n1. **Install dependencies:**\n   ```bash\n   npm install\n   ```\n\n2. **Set up environment variables:**\n   ```bash\n   cp .env.example .env\n   # Edit .env and add your GitHub Copilot token\n   ```\n\n3. **Build the application:**\n   ```bash\n   npm run build\n   ```\n\n4. **Run the application:**\n   ```bash\n   npm start\n   # or for development with ts-node\n   npm run dev\n   ```\n\n## Key Features\n\n- \u2705 **Copilot Client**: Creates and configures a GitHub Copilot client\n- \u2705 **Streaming Session**: Uses GPT-4.1 with streaming responses\n- \u2705 **Custom Tool**: Defines `search_docs` tool with query parameter\n- \u2705 **Pre-tool-use Hook**: Implements security check that denies shell access\n- \u2705 **Streaming Handler**: Writes deltas to stdout in real-time\n- \u2705 **Tool Implementation**: Includes mock documentation search functionality\n- \u2705 **Error Handling**: Comprehensive error handling and logging\n\nThe application demonstrates secure tool usage with a pre-execution hook that prevents potentially dangerous shell commands while allowing safe documentation searches.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 2163,
            "cached": false
          },
          "with_skill": {
            "output": "```typescript\nimport { CopilotClient, defineTool } from \"@github/copilot-sdk\";\n\n// Define the search_docs custom tool\nconst searchDocs = defineTool(\"search_docs\", {\n    description: \"Search documentation for relevant information\",\n    parameters: {\n        type: \"object\",\n        properties: {\n            query: {\n                type: \"string\",\n                description: \"The search query to find relevant documentation\",\n            },\n        },\n        required: [\"query\"],\n    },\n    handler: async ({ query }) => {\n        // Simulate a documentation search\n        console.log(`\\n[Tool] Searching docs for: \"${query}\"`);\n        \n        // Mock search results\n        const results = [\n            {\n                title: \"Getting Started Guide\",\n                snippet: `Documentation about ${query}...`,\n                relevance: 0.95,\n            },\n            {\n                title: \"API Reference\",\n                snippet: `API details for ${query}...`,\n                relevance: 0.87,\n            },\n        ];\n        \n        return {\n            query,\n            results,\n            totalResults: results.length,\n        };\n    },\n});\n\nasync function main() {\n    // Create the Copilot client\n    const client = new CopilotClient({\n        logLevel: \"info\",\n    });\n\n    try {\n        // Create a streaming session with gpt-4.1\n        const session = await client.createSession({\n            model: \"gpt-4.1\",\n            streaming: true,\n            tools: [searchDocs],\n            hooks: {\n                // Pre-tool-use hook to deny shell access\n                onPreToolUse: async (input) => {\n                    console.log(`\\n[Hook] Tool requested: ${input.toolName}`);\n                    \n                    // Deny shell and bash tools\n                    if ([\"shell\", \"bash\", \"sh\"].includes(input.toolName.toLowerCase())) {\n                        console.log(\"[Hook] \u274c Shell access denied\");\n                        return {\n                            permissionDecision: \"deny\",\n                            permissionDecisionReason: \"Shell access is not permitted for security reasons\",\n                        };\n                    }\n                    \n                    console.log(\"[Hook] \u2705 Tool allowed\");\n                    return {\n                        permissionDecision: \"allow\",\n                    };\n                },\n            },\n        });\n\n        console.log(\"\ud83d\ude80 Session started with streaming enabled\\n\");\n\n        // Subscribe to streaming delta events\n        session.on(\"assistant.message_delta\", (event) => {\n            // Write streaming content to stdout\n            process.stdout.write(event.data.deltaContent);\n        });\n\n        // Handle session idle (end of response)\n        session.on(\"session.idle\", () => {\n            console.log(\"\\n\\n\u2713 Response complete\\n\");\n        });\n\n        // Handle tool calls\n        session.on(\"assistant.tool_call\", (event) => {\n            console.log(`\\n[Event] Tool called: ${event.data.toolName}`);\n        });\n\n        // Handle errors\n        session.on(\"error.occurred\", (event) => {\n            console.error(`\\n[Error] ${event.data.message}`);\n        });\n\n        // Send a prompt that will trigger the search_docs tool\n        console.log(\"\ud83d\udcdd Sending prompt...\\n\");\n        await session.sendAndWait({\n            prompt: \"Can you search the docs for information about authentication and then explain what you found?\",\n        });\n\n        // Optional: Send another message to demonstrate continued conversation\n        console.log(\"\\n\ud83d\udcdd Sending follow-up...\\n\");\n        await session.sendAndWait({\n            prompt: \"Now search for API rate limits\",\n        });\n\n        // Clean up\n        await session.destroy();\n        console.log(\"\\n\ud83d\uded1 Session destroyed\");\n\n    } catch (error) {\n        console.error(\"Error:\", error);\n    } finally {\n        // Stop the client\n        await client.stop();\n        console.log(\"\ud83d\udc4b Client stopped\");\n    }\n}\n\n// Run the application\nmain().catch(console.error);\n```\n\n**Key Features Implemented:**\n\n1. **Client Creation**: `new CopilotClient()` with info-level logging\n2. **Streaming Session**: `streaming: true` with gpt-4.1 model\n3. **Custom Tool**: `search_docs` tool with query parameter and mock search handler\n4. **Pre-Tool-Use Hook**: Denies shell/bash/sh tools, allows others\n5. **Streaming Handler**: Writes `deltaContent` to stdout in real-time\n6. **Event Handling**: Subscribes to deltas, idle, tool calls, and errors\n7. **Proper Cleanup**: Destroys session and stops client\n\n**To run:**\n\n```bash\nnpm install @github/copilot-sdk\nnpx tsx app.ts  # or compile with tsc and run with node\n```\n\n**Expected output:**\n- Real-time streaming of AI responses\n- Tool call notifications when search_docs is invoked\n- Hook messages showing permission decisions\n- Formatted completion messages",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4529,
            "output_tokens": 1227,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Node.js/TypeScript application using the GitHub Copilot SDK with the features you requested.\n\n```typescript\nimport { CopilotClient, defineTool } from \"@github/copilot-sdk\";\n\n// Define the search_docs custom tool\nconst searchDocs = defineTool(\"search_docs\", {\n  description: \"Search documentation for relevant information\",\n  parameters: {\n    type: \"object\",\n    properties: {\n      query: {\n        type: \"string\",\n        description: \"The search query to find in documentation\",\n      },\n    },\n    required: [\"query\"],\n  },\n  handler: async ({ query }) => {\n    // Simulate a documentation search\n    return {\n      query,\n      results: [\n        {\n          title: \"Getting Started Guide\",\n          snippet: `Documentation matching \"${query}\"`,\n          url: \"https://docs.example.com/getting-started\",\n        },\n        {\n          title: \"API Reference\",\n          snippet: `API documentation for \"${query}\"`,\n          url: \"https://docs.example.com/api-reference\",\n        },\n      ],\n    };\n  },\n});\n\nasync function main() {\n  // Create the Copilot client\n  const client = new CopilotClient();\n\n  try {\n    // Create a streaming session with gpt-4.1\n    const session = await client.createSession({\n      model: \"gpt-4.1\",\n      streaming: true,\n      tools: [searchDocs],\n      hooks: {\n        // Pre-tool-use hook to deny shell access\n        onPreToolUse: async (input) => {\n          if ([\"shell\", \"bash\", \"sh\"].includes(input.toolName)) {\n            return {\n              permissionDecision: \"deny\",\n              permissionDecisionReason: \"Shell access is not permitted for security reasons\",\n            };\n          }\n          return { permissionDecision: \"allow\" };\n        },\n      },\n    });\n\n    // Subscribe to streaming delta events\n    session.on(\"assistant.message_delta\", (event) => {\n      process.stdout.write(event.data.deltaContent);\n    });\n\n    // Handle session idle to add newline after completion\n    session.on(\"session.idle\", () => {\n      process.stdout.write(\"\\n\");\n    });\n\n    // Send a test message\n    console.log(\"Sending message to Copilot...\\n\");\n    await session.sendAndWait({\n      prompt: \"Can you search the docs for 'authentication' and tell me what you find?\",\n    });\n\n    console.log(\"\\n\\nSession completed successfully!\");\n  } catch (error) {\n    console.error(\"Error:\", error);\n  } finally {\n    // Clean up\n    await client.stop();\n  }\n}\n\n// Run the application\nmain().catch(console.error);\n```\n\nThis application:\n\n1. **Creates a Copilot client** using `new CopilotClient()`\n2. **Defines a custom `search_docs` tool** that accepts a `query` parameter and returns simulated documentation search results\n3. **Creates a streaming session** with `gpt-4.1` model\n4. **Includes a pre-tool-use hook** that denies shell access (shell, bash, sh commands)\n5. **Handles streaming deltas** by subscribing to `assistant.message_delta` events and writing them to stdout\n6. **Properly cleans up** by calling `client.stop()` in the finally block\n\nTo run this:\n\n```bash\nnpm install @github/copilot-sdk\nnpx tsx copilot-app.ts\n```\n\nMake sure you have the GitHub Copilot CLI installed and authenticated (`copilot auth login`).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5024,
            "output_tokens": 889,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# GitHub Copilot SDK Streaming Application\n\nHere's a complete Node.js/TypeScript application that meets your requirements:\n\n```typescript\nimport { CopilotSDK } from \"@copilot-sdk/core\";\nimport { createWriteStream } from \"fs\";\n\n// Initialize the Copilot SDK client\nconst client = new CopilotSDK({\n  apiKey: process.env.GITHUB_TOKEN || \"\",\n  endpoint: process.env.COPILOT_ENDPOINT,\n});\n\n// Define the custom tool\nconst searchDocsTool = {\n  name: \"search_docs\",\n  description: \"Search through documentation to find relevant information\",\n  parameters: {\n    type: \"object\",\n    properties: {\n      query: {\n        type: \"string\",\n        description: \"The search query to find relevant documentation\",\n      },\n    },\n    required: [\"query\"],\n  },\n  handler: async (params: { query: string }) => {\n    // Simulate a documentation search\n    console.log(`\\n[Tool Called] Searching docs for: \"${params.query}\"`);\n    \n    // Mock search results\n    return {\n      results: [\n        {\n          title: \"Getting Started Guide\",\n          snippet: `Documentation related to: ${params.query}`,\n          url: \"https://docs.example.com/getting-started\",\n        },\n      ],\n    };\n  },\n};\n\n// Pre-tool-use hook that denies shell access\nconst preToolUseHook = (toolName: string, params: any): boolean => {\n  // Deny any shell-related tools\n  const deniedTools = [\"shell\", \"bash\", \"execute\", \"run_command\", \"terminal\"];\n  \n  if (deniedTools.some((denied) => toolName.toLowerCase().includes(denied))) {\n    console.error(`\\n[Security] Tool \"${toolName}\" denied - shell access not allowed`);\n    return false; // Deny execution\n  }\n  \n  console.log(`\\n[Hook] Pre-tool-use check passed for: ${toolName}`);\n  return true; // Allow execution\n};\n\n// Main streaming function\nasync function startStreamingSession() {\n  try {\n    console.log(\"Starting streaming session with GPT-4.1...\\n\");\n\n    const stream = await client.chat.completions.create({\n      model: \"gpt-4.1\",\n      messages: [\n        {\n          role: \"system\",\n          content:\n            \"You are a helpful assistant with access to documentation search. Help users find information.\",\n        },\n        {\n          role: \"user\",\n          content:\n            \"Can you search the docs for information about authentication methods?\",\n        },\n      ],\n      tools: [\n        {\n          type: \"function\",\n          function: {\n            name: searchDocsTool.name,\n            description: searchDocsTool.description,\n            parameters: searchDocsTool.parameters,\n          },\n        },\n      ],\n      stream: true,\n      temperature: 0.7,\n    });\n\n    // Handle streaming deltas\n    for await (const chunk of stream) {\n      const delta = chunk.choices[0]?.delta;\n\n      if (!delta) continue;\n\n      // Handle text content\n      if (delta.content) {\n        process.stdout.write(delta.content);\n      }\n\n      // Handle tool calls\n      if (delta.tool_calls) {\n        for (const toolCall of delta.tool_calls) {\n          if (toolCall.function?.name) {\n            const toolName = toolCall.function.name;\n            \n            // Apply pre-tool-use hook\n            const allowed = preToolUseHook(toolName, null);\n            \n            if (!allowed) {\n              console.log(\"\\n[Error] Tool execution blocked by security policy\");\n              continue;\n            }\n\n            // Parse and execute the tool if we have complete arguments\n            if (toolCall.function.arguments) {\n              try {\n                const args = JSON.parse(toolCall.function.arguments);\n                \n                if (toolName === searchDocsTool.name) {\n                  const result = await searchDocsTool.handler(args);\n                  console.log(\"\\n[Tool Result]:\", JSON.stringify(result, null, 2));\n                  \n                  // Continue the conversation with the tool result\n                  const followUpStream = await client.chat.completions.create({\n                    model: \"gpt-4.1\",\n                    messages: [\n                      {\n                        role: \"system\",\n                        content: \"You are a helpful assistant with access to documentation search.\",\n                      },\n                      {\n                        role: \"user\",\n                        content: \"Can you search the docs for information about authentication methods?\",\n                      },\n                      {\n                        role: \"assistant\",\n                        content: null,\n                        tool_calls: [\n                          {\n                            id: toolCall.id || \"call_1\",\n                            type: \"function\",\n                            function: {\n                              name: toolName,\n                              arguments: JSON.stringify(args),\n                            },\n                          },\n                        ],\n                      },\n                      {\n                        role: \"tool\",\n                        tool_call_id: toolCall.id || \"call_1\",\n                        content: JSON.stringify(result),\n                      },\n                    ],\n                    stream: true,\n                  });\n\n                  console.log(\"\\n[Assistant Response]:\\n\");\n                  for await (const followUpChunk of followUpStream) {\n                    const followUpDelta = followUpChunk.choices[0]?.delta;\n                    if (followUpDelta?.content) {\n                      process.stdout.write(followUpDelta.content);\n                    }\n                  }\n                }\n              } catch (error) {\n                console.error(\"\\n[Error] Failed to parse tool arguments:\", error);\n              }\n            }\n          }\n        }\n      }\n\n      // Handle finish reason\n      if (chunk.choices[0]?.finish_reason) {\n        console.log(`\\n\\n[Stream Complete] Reason: ${chunk.choices[0].finish_reason}`);\n      }\n    }\n\n    console.log(\"\\n\\nSession completed successfully!\");\n  } catch (error) {\n    console.error(\"Error during streaming session:\", error);\n    throw error;\n  }\n}\n\n// Test the pre-tool-use hook with denied tools\nfunction testSecurityHook() {\n  console.log(\"\\n=== Testing Security Hook ===\");\n  \n  const testCases = [\n    { name: \"search_docs\", shouldPass: true },\n    { name: \"shell_execute\", shouldPass: false },\n    { name: \"run_bash_command\", shouldPass: false },\n    { name: \"calculate\", shouldPass: true },\n  ];\n\n  testCases.forEach((test) => {\n    const result = preToolUseHook(test.name, {});\n    const status = result === test.shouldPass ? \"\u2713\" : \"\u2717\";\n    console.log(`${status} ${test.name}: ${result ? \"ALLOWED\" : \"DENIED\"}`);\n  });\n  \n  console.log(\"=== Security Hook Tests Complete ===\\n\");\n}\n\n// Run the application\nasync function main() {\n  console.log(\"GitHub Copilot SDK Streaming Application\\n\");\n  console.log(\"=========================================\\n\");\n\n  // Test security hook first\n  testSecurityHook();\n\n  // Start the streaming session\n  await startStreamingSession();\n}\n\n// Execute\nmain().catch((error) => {\n  console.error(\"Fatal error:\", error);\n  process.exit(1);\n});\n```\n\n## Package.json Configuration\n\n```json\n{\n  \"name\": \"copilot-streaming-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"GitHub Copilot SDK streaming application with custom tools\",\n  \"main\": \"index.ts\",\n  \"scripts\": {\n    \"start\": \"ts-node index.ts\",\n    \"build\": \"tsc\",\n    \"dev\": \"ts-node-dev --respawn index.ts\"\n  },\n  \"dependencies\": {\n    \"@copilot-sdk/core\": \"^1.0.0\",\n    \"dotenv\": \"^16.3.1\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.10.0\",\n    \"ts-node\": \"^10.9.2\",\n    \"ts-node-dev\": \"^2.0.0\",\n    \"typescript\": \"^5.3.3\"\n  }\n}\n```\n\n## TypeScript Configuration (tsconfig.json)\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"moduleResolution\": \"node\"\n  },\n  \"include\": [\"**/*.ts\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Environment Variables (.env)\n\n```bash\nGITHUB_TOKEN=your_github_token_here\nCOPILOT_ENDPOINT=https://api.githubcopilot.com\n```\n\n## Key Features:\n\n1. **Copilot SDK Client**: Initializes with API key and endpoint\n2. **Streaming with GPT-4.1**: Uses `stream: true` for real-time responses\n3. **Custom Tool**: `search_docs` with query parameter\n4. **Pre-tool-use Hook**: Denies shell-related tools for security\n5. **Delta Handling**: Writes streaming content directly to stdout\n6. **Tool Execution**: Handles tool calls and continues conversation with results\n7. **Error Handling**: Comprehensive error handling throughout\n\n## Usage:\n\n```bash\n# Install dependencies\nnpm install\n\n# Run the application\nnpm start\n\n# Or for development with auto-reload\nnpm run dev\n```\n\nThe application will stream responses to stdout in real-time, execute the custom tool when needed, and enforce security policies through the pre-tool-use hook.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 2484,
            "cached": false
          },
          "with_skill": {
            "output": "```typescript\nimport { CopilotClient, defineTool } from \"@github/copilot-sdk\";\n\n// Define the search_docs custom tool\nconst searchDocs = defineTool(\"search_docs\", {\n  description: \"Search documentation for relevant information\",\n  parameters: {\n    type: \"object\",\n    properties: {\n      query: {\n        type: \"string\",\n        description: \"The search query to find in documentation\",\n      },\n    },\n    required: [\"query\"],\n  },\n  handler: async ({ query }) => {\n    // Simulate a documentation search\n    console.log(`\\n[Tool Called: search_docs with query=\"${query}\"]\\n`);\n    \n    return {\n      query,\n      results: [\n        {\n          title: \"Getting Started Guide\",\n          snippet: `Documentation matching \"${query}\"...`,\n          url: \"https://docs.example.com/getting-started\",\n        },\n        {\n          title: \"API Reference\",\n          snippet: `API documentation for ${query}`,\n          url: \"https://docs.example.com/api-reference\",\n        },\n      ],\n    };\n  },\n});\n\nasync function main() {\n  // Create the Copilot client\n  const client = new CopilotClient({\n    logLevel: \"info\",\n  });\n\n  try {\n    // Create a streaming session with custom tool and hooks\n    const session = await client.createSession({\n      model: \"gpt-4.1\",\n      streaming: true,\n      tools: [searchDocs],\n      hooks: {\n        // Pre-tool-use hook to deny shell access\n        onPreToolUse: async (input) => {\n          console.log(`\\n[Hook: Checking tool \"${input.toolName}\"]\\n`);\n          \n          // Deny shell and bash tools\n          if ([\"shell\", \"bash\", \"sh\"].includes(input.toolName.toLowerCase())) {\n            return {\n              permissionDecision: \"deny\",\n              permissionDecisionReason: \"Shell access is not permitted for security reasons\",\n            };\n          }\n          \n          // Allow all other tools\n          return {\n            permissionDecision: \"allow\",\n          };\n        },\n      },\n    });\n\n    // Subscribe to streaming delta events\n    session.on(\"assistant.message_delta\", (event) => {\n      // Write streaming content to stdout without newlines\n      process.stdout.write(event.data.deltaContent);\n    });\n\n    // Subscribe to session idle event to add final newline\n    session.on(\"session.idle\", () => {\n      console.log(\"\\n\");\n    });\n\n    // Subscribe to tool use events for visibility\n    session.on(\"assistant.tool_use\", (event) => {\n      console.log(`\\n[Tool Use: ${event.data.toolName}]\\n`);\n    });\n\n    // Send a message that will trigger the search_docs tool\n    console.log(\"User: Can you search the docs for 'authentication methods'?\\n\");\n    await session.sendAndWait({\n      prompt: \"Can you search the docs for 'authentication methods' and summarize what you find?\",\n    });\n\n    // Send another message to demonstrate the shell denial\n    console.log(\"\\nUser: Can you run 'ls -la' for me?\\n\");\n    await session.sendAndWait({\n      prompt: \"Can you run 'ls -la' to show me the current directory contents?\",\n    });\n\n    // Clean up\n    await session.destroy();\n  } catch (error) {\n    console.error(\"Error:\", error);\n  } finally {\n    // Stop the client\n    await client.stop();\n  }\n}\n\n// Run the application\nmain().catch(console.error);\n```\n\n**Key Features Implemented:**\n\n1. **Client Creation**: `new CopilotClient()` with info-level logging\n2. **Streaming Session**: `streaming: true` with `gpt-4.1` model\n3. **Custom Tool**: `search_docs` tool with query parameter that returns mock documentation results\n4. **Pre-Tool-Use Hook**: Denies shell/bash/sh tools, allows others\n5. **Streaming Handler**: Subscribes to `assistant.message_delta` events and writes to stdout\n6. **Event Handling**: Also handles `session.idle` for newlines and `assistant.tool_use` for visibility\n7. **Proper Cleanup**: Destroys session and stops client\n\n**To Run:**\n\n```bash\n# Install dependencies\nnpm install @github/copilot-sdk\n\n# Compile TypeScript (if needed)\nnpx tsc app.ts\n\n# Run\nnode app.js\n```\n\n**Expected Output:**\n- Streaming response as the AI searches docs and summarizes\n- Tool call notification when `search_docs` is invoked\n- Denial message when shell access is attempted\n- Clean shutdown",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4529,
            "output_tokens": 1151,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Node.js/TypeScript application using the GitHub Copilot SDK with the features you requested.\n\n```typescript\nimport { CopilotClient, defineTool } from \"@github/copilot-sdk\";\n\n// Define the search_docs custom tool\nconst searchDocs = defineTool(\"search_docs\", {\n  description: \"Search documentation for relevant information\",\n  parameters: {\n    type: \"object\",\n    properties: {\n      query: {\n        type: \"string\",\n        description: \"The search query to find documentation\",\n      },\n    },\n    required: [\"query\"],\n  },\n  handler: async ({ query }) => {\n    // Simulate a documentation search\n    return {\n      query,\n      results: [\n        {\n          title: \"Getting Started Guide\",\n          snippet: `Documentation matching \"${query}\"`,\n          url: \"https://docs.example.com/getting-started\",\n        },\n        {\n          title: \"API Reference\",\n          snippet: `API documentation for \"${query}\"`,\n          url: \"https://docs.example.com/api-reference\",\n        },\n      ],\n    };\n  },\n});\n\nasync function main() {\n  // Create the Copilot client\n  const client = new CopilotClient();\n\n  try {\n    // Create a streaming session with gpt-4.1\n    const session = await client.createSession({\n      model: \"gpt-4.1\",\n      streaming: true,\n      tools: [searchDocs],\n      hooks: {\n        // Pre-tool-use hook to deny shell access\n        onPreToolUse: async (input) => {\n          if ([\"shell\", \"bash\"].includes(input.toolName)) {\n            return {\n              permissionDecision: \"deny\",\n              permissionDecisionReason: \"Shell access is not permitted for security reasons\",\n            };\n          }\n          return { permissionDecision: \"allow\" };\n        },\n      },\n    });\n\n    // Subscribe to streaming delta events\n    session.on(\"assistant.message_delta\", (event) => {\n      process.stdout.write(event.data.deltaContent);\n    });\n\n    // Handle session idle to add newline after completion\n    session.on(\"session.idle\", () => {\n      console.log(\"\\n\");\n    });\n\n    // Send a message that will trigger the search_docs tool\n    console.log(\"User: Can you search the docs for authentication?\\n\");\n    await session.sendAndWait({\n      prompt: \"Can you search the docs for authentication?\",\n    });\n\n    // Send another message to demonstrate shell denial\n    console.log(\"\\nUser: Can you run 'ls -la' for me?\\n\");\n    await session.sendAndWait({\n      prompt: \"Can you run 'ls -la' for me?\",\n    });\n\n  } catch (error) {\n    console.error(\"Error:\", error);\n  } finally {\n    // Clean up\n    await client.stop();\n  }\n}\n\n// Run the application\nmain().catch(console.error);\n```\n\nThis application:\n\n1. **Creates a Copilot client** using `new CopilotClient()`\n2. **Defines a custom tool** called `search_docs` that accepts a `query` parameter and returns mock documentation results\n3. **Creates a streaming session** with:\n   - Model: `gpt-4.1`\n   - Streaming enabled\n   - The custom `search_docs` tool\n   - A `onPreToolUse` hook that denies shell/bash access\n4. **Handles streaming deltas** by subscribing to `assistant.message_delta` events and writing to stdout\n5. **Demonstrates usage** with two example prompts - one that uses the search tool, and one that attempts shell access (which will be denied)\n\nTo run this:\n\n```bash\nnpm install @github/copilot-sdk\nnpx tsx copilot-app.ts\n```\n\nMake sure you have the GitHub Copilot CLI installed and authenticated (`copilot auth login`).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5024,
            "output_tokens": 955,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# GitHub Copilot SDK Streaming Application\n\nHere's a complete Node.js/TypeScript application that meets your requirements:\n\n```typescript\nimport { \n  CopilotClient, \n  StreamingSession,\n  ToolDefinition,\n  StreamingDelta\n} from '@github/copilot-sdk';\n\n// Define the custom tool\nconst searchDocsTool: ToolDefinition = {\n  name: 'search_docs',\n  description: 'Search through documentation to find relevant information',\n  parameters: {\n    type: 'object',\n    properties: {\n      query: {\n        type: 'string',\n        description: 'The search query to find relevant documentation'\n      }\n    },\n    required: ['query']\n  }\n};\n\n// Pre-tool-use hook that denies shell access\nfunction preToolUseHook(toolName: string, parameters: any): boolean {\n  // Deny any shell-related tools\n  const deniedTools = ['shell', 'bash', 'execute', 'run_command', 'terminal'];\n  \n  if (deniedTools.some(denied => toolName.toLowerCase().includes(denied))) {\n    console.error(`\u274c Tool \"${toolName}\" is denied due to shell access restrictions`);\n    return false; // Deny execution\n  }\n  \n  console.log(`\u2705 Tool \"${toolName}\" approved for execution`);\n  return true; // Allow execution\n}\n\n// Handle streaming deltas\nfunction handleStreamingDelta(delta: StreamingDelta): void {\n  if (delta.type === 'content') {\n    // Write content deltas directly to stdout\n    process.stdout.write(delta.content || '');\n  } else if (delta.type === 'tool_call') {\n    // Handle tool call deltas\n    console.log(`\\n[Tool Call: ${delta.toolName}]`);\n    if (delta.parameters) {\n      console.log(`Parameters: ${JSON.stringify(delta.parameters, null, 2)}`);\n    }\n  } else if (delta.type === 'done') {\n    console.log('\\n\\n\u2713 Streaming completed');\n  }\n}\n\n// Main application\nasync function main() {\n  try {\n    console.log('\ud83d\ude80 Initializing GitHub Copilot SDK Client...\\n');\n\n    // Create the Copilot client\n    const client = new CopilotClient({\n      apiKey: process.env.GITHUB_COPILOT_API_KEY || '',\n      // Optional: configure additional client options\n      timeout: 30000,\n    });\n\n    // Start a streaming session with gpt-4.1\n    const session: StreamingSession = await client.createStreamingSession({\n      model: 'gpt-4.1',\n      messages: [\n        {\n          role: 'system',\n          content: 'You are a helpful assistant with access to documentation search capabilities.'\n        },\n        {\n          role: 'user',\n          content: 'Can you search the docs for information about authentication methods?'\n        }\n      ],\n      tools: [searchDocsTool],\n      temperature: 0.7,\n      maxTokens: 1000,\n    });\n\n    console.log('\ud83d\udce1 Streaming session started...\\n');\n    console.log('Response:\\n');\n\n    // Process streaming deltas\n    for await (const delta of session.stream()) {\n      // Apply pre-tool-use hook\n      if (delta.type === 'tool_call' && delta.toolName) {\n        const isAllowed = preToolUseHook(delta.toolName, delta.parameters);\n        \n        if (!isAllowed) {\n          // Skip this tool call\n          continue;\n        }\n        \n        // Execute the tool (mock implementation)\n        if (delta.toolName === 'search_docs') {\n          const query = delta.parameters?.query || '';\n          console.log(`\\n\ud83d\udd0d Executing search_docs with query: \"${query}\"`);\n          \n          // Mock tool execution result\n          const toolResult = {\n            results: [\n              'OAuth 2.0 authentication is supported',\n              'API keys can be generated in settings',\n              'JWT tokens are valid for 24 hours'\n            ]\n          };\n          \n          // Send tool result back to the session\n          await session.submitToolResult({\n            toolCallId: delta.toolCallId || '',\n            result: JSON.stringify(toolResult)\n          });\n        }\n      }\n      \n      // Handle the delta\n      handleStreamingDelta(delta);\n    }\n\n    console.log('\\n\\n\u2705 Session completed successfully');\n\n  } catch (error) {\n    console.error('\\n\u274c Error occurred:', error);\n    process.exit(1);\n  }\n}\n\n// Run the application\nmain();\n```\n\n## Package.json\n\n```json\n{\n  \"name\": \"copilot-streaming-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"GitHub Copilot SDK streaming application with custom tools\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"ts-node src/index.ts\",\n    \"watch\": \"tsc --watch\"\n  },\n  \"dependencies\": {\n    \"@github/copilot-sdk\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"ts-node\": \"^10.9.1\",\n    \"typescript\": \"^5.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}\n```\n\n## tsconfig.json\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"moduleResolution\": \"node\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## .env.example\n\n```bash\n# GitHub Copilot API Key\nGITHUB_COPILOT_API_KEY=your_api_key_here\n```\n\n## Installation & Usage\n\n```bash\n# Install dependencies\nnpm install\n\n# Copy environment file\ncp .env.example .env\n\n# Edit .env and add your API key\n\n# Run in development mode\nnpm run dev\n\n# Or build and run\nnpm run build\nnpm start\n```\n\n## Key Features\n\n1. **CopilotClient**: Creates a client instance with API key authentication\n2. **Streaming Session**: Uses `gpt-4.1` model with streaming enabled\n3. **Custom Tool**: `search_docs` tool with a `query` parameter\n4. **Pre-tool-use Hook**: Denies shell-related tools for security\n5. **Delta Handling**: Writes streaming content directly to stdout\n6. **Error Handling**: Comprehensive try-catch with proper error messages\n7. **Tool Execution**: Mock implementation of the search_docs tool with result submission\n\nThe application demonstrates a complete workflow including tool definition, security hooks, streaming response handling, and tool result submission back to the model.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 1842,
            "cached": false
          },
          "with_skill": {
            "output": "Here's a complete Node.js/TypeScript application using the GitHub Copilot SDK:\n\n```typescript\nimport { CopilotClient, defineTool } from \"@github/copilot-sdk\";\n\n// Define the search_docs custom tool\nconst searchDocs = defineTool(\"search_docs\", {\n    description: \"Search documentation for relevant information\",\n    parameters: {\n        type: \"object\",\n        properties: {\n            query: {\n                type: \"string\",\n                description: \"The search query to find relevant documentation\",\n            },\n        },\n        required: [\"query\"],\n    },\n    handler: async ({ query }) => {\n        // Simulate a documentation search\n        console.log(`\\n[Tool] Searching docs for: \"${query}\"`);\n        \n        // Mock search results\n        const results = [\n            {\n                title: \"Getting Started Guide\",\n                snippet: `Documentation related to: ${query}`,\n                relevance: 0.95,\n            },\n            {\n                title: \"API Reference\",\n                snippet: `API methods for ${query}`,\n                relevance: 0.87,\n            },\n        ];\n        \n        return {\n            query,\n            results,\n            totalResults: results.length,\n        };\n    },\n});\n\nasync function main() {\n    // Create the Copilot client\n    const client = new CopilotClient({\n        logLevel: \"info\",\n    });\n\n    try {\n        console.log(\"Starting Copilot client...\");\n\n        // Create a streaming session with gpt-4.1\n        const session = await client.createSession({\n            model: \"gpt-4.1\",\n            streaming: true,\n            tools: [searchDocs],\n            hooks: {\n                // Pre-tool-use hook to deny shell access\n                onPreToolUse: async (input) => {\n                    console.log(`\\n[Hook] Tool requested: ${input.toolName}`);\n                    \n                    // Deny shell and bash tools\n                    if ([\"shell\", \"bash\", \"sh\"].includes(input.toolName.toLowerCase())) {\n                        console.log(\"[Hook] \u274c Shell access denied\");\n                        return {\n                            permissionDecision: \"deny\",\n                            permissionDecisionReason: \"Shell access is not permitted for security reasons\",\n                        };\n                    }\n                    \n                    console.log(\"[Hook] \u2713 Tool allowed\");\n                    return {\n                        permissionDecision: \"allow\",\n                    };\n                },\n            },\n        });\n\n        console.log(\"Session created successfully!\\n\");\n\n        // Subscribe to streaming delta events\n        session.on(\"assistant.message_delta\", (event) => {\n            // Write streaming content to stdout\n            process.stdout.write(event.data.deltaContent);\n        });\n\n        // Handle session idle (end of streaming)\n        session.on(\"session.idle\", () => {\n            console.log(\"\\n\\n[Session] Response complete\");\n        });\n\n        // Handle tool calls\n        session.on(\"assistant.tool_call\", (event) => {\n            console.log(`\\n[Tool Call] ${event.data.toolName} invoked`);\n        });\n\n        // Handle errors\n        session.on(\"error.occurred\", (event) => {\n            console.error(\"\\n[Error]\", event.data.message);\n        });\n\n        // Send a prompt that will likely trigger the search_docs tool\n        console.log(\"Sending prompt...\\n\");\n        console.log(\"Assistant: \");\n        \n        await session.sendAndWait({\n            prompt: \"Can you search the documentation for information about authentication methods and explain what you find?\",\n        });\n\n        // Optional: Send another message to test shell denial\n        console.log(\"\\n\\n--- Testing shell access denial ---\\n\");\n        console.log(\"Assistant: \");\n        \n        await session.sendAndWait({\n            prompt: \"Can you run 'ls -la' to show me the current directory contents?\",\n        });\n\n        // Clean up\n        console.log(\"\\n\\nDestroying session...\");\n        await session.destroy();\n\n    } catch (error) {\n        console.error(\"Error:\", error);\n    } finally {\n        // Stop the client\n        console.log(\"Stopping Copilot client...\");\n        await client.stop();\n        console.log(\"Done!\");\n    }\n}\n\n// Run the application\nmain().catch(console.error);\n```\n\n**Package.json setup:**\n\n```json\n{\n  \"name\": \"copilot-sdk-demo\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"start\": \"tsx src/index.ts\",\n    \"build\": \"tsc\"\n  },\n  \"dependencies\": {\n    \"@github/copilot-sdk\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n```\n\n**tsconfig.json:**\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ES2022\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n**Key features implemented:**\n\n1. \u2705 **Client creation** - `new CopilotClient()`\n2. \u2705 **Streaming session** - `streaming: true` with gpt-4.1\n3. \u2705 **Custom tool** - `search_docs` with query parameter\n4. \u2705 **Pre-tool-use hook** - Denies shell/bash/sh access\n5. \u2705 **Streaming deltas** - Written to stdout via `assistant.message_delta` event\n6. \u2705 **Error handling** - Try/catch with proper cleanup\n7. \u2705 **Event subscriptions** - Multiple event handlers for different scenarios\n\n**To run:**\n\n```bash\nnpm install\nnpm start\n```\n\nThe application will stream the AI's response in real-time, invoke the custom search tool when needed, and block any shell access attempts with a clear denial message.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4529,
            "output_tokens": 1560,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Node.js/TypeScript application using the GitHub Copilot SDK with the requirements you specified.\n\n```typescript\nimport { CopilotClient, defineTool } from \"@github/copilot-sdk\";\n\n// Define the search_docs custom tool\nconst searchDocs = defineTool(\"search_docs\", {\n  description: \"Search documentation for relevant information\",\n  parameters: {\n    type: \"object\",\n    properties: {\n      query: {\n        type: \"string\",\n        description: \"The search query to find relevant documentation\",\n      },\n    },\n    required: [\"query\"],\n  },\n  handler: async ({ query }) => {\n    // Simulate a documentation search\n    return {\n      query,\n      results: [\n        {\n          title: \"Getting Started Guide\",\n          snippet: `Documentation matching \"${query}\"`,\n          url: \"https://docs.example.com/getting-started\",\n        },\n        {\n          title: \"API Reference\",\n          snippet: `API documentation for \"${query}\"`,\n          url: \"https://docs.example.com/api-reference\",\n        },\n      ],\n    };\n  },\n});\n\nasync function main() {\n  // Create the Copilot client\n  const client = new CopilotClient();\n\n  try {\n    // Create a streaming session with gpt-4.1\n    const session = await client.createSession({\n      model: \"gpt-4.1\",\n      streaming: true,\n      tools: [searchDocs],\n      hooks: {\n        // Pre-tool-use hook to deny shell access\n        onPreToolUse: async (input) => {\n          if ([\"shell\", \"bash\", \"sh\"].includes(input.toolName)) {\n            return {\n              permissionDecision: \"deny\",\n              permissionDecisionReason: \"Shell access is not permitted for security reasons\",\n            };\n          }\n          return { permissionDecision: \"allow\" };\n        },\n      },\n    });\n\n    // Subscribe to streaming delta events\n    session.on(\"assistant.message_delta\", (event) => {\n      process.stdout.write(event.data.deltaContent);\n    });\n\n    // Handle session idle to add newline after completion\n    session.on(\"session.idle\", () => {\n      console.log(\"\\n\");\n    });\n\n    // Send a message that will use the search_docs tool\n    await session.sendAndWait({\n      prompt: \"Can you search the docs for 'authentication' and tell me what you find?\",\n    });\n\n    // Clean up\n    await session.destroy();\n  } finally {\n    // Stop the client\n    await client.stop();\n  }\n}\n\n// Run the application\nmain().catch((error) => {\n  console.error(\"Error:\", error);\n  process.exit(1);\n});\n```\n\nThis application:\n\n1. **Creates a Copilot client** using `new CopilotClient()`\n2. **Defines a custom `search_docs` tool** that accepts a `query` parameter and returns mock documentation results\n3. **Creates a streaming session** with `gpt-4.1` model\n4. **Includes a pre-tool-use hook** that denies shell access by checking if the tool name is `shell`, `bash`, or `sh`\n5. **Handles streaming deltas** by subscribing to `assistant.message_delta` events and writing them to stdout\n6. **Sends a test message** that will trigger the search_docs tool\n7. **Properly cleans up** by destroying the session and stopping the client\n\nTo run this, you'll need to:\n1. Install dependencies: `npm install @github/copilot-sdk`\n2. Ensure you have the GitHub Copilot CLI installed and authenticated\n3. Run with: `npx tsx copilot-app.ts` (or compile and run with node)",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5024,
            "output_tokens": 915,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "copilot-sdk-02",
      "task_type": "cross_language",
      "target_language": "java",
      "expected_patterns": [
        "class\\s+\\w+",
        "public static void main",
        "CopilotClient|copilot",
        "createSession|session"
      ],
      "anti_patterns": [
        "import.*CopilotClient.*from",
        "from copilot import",
        "copilot\\.NewClient\\(nil\\)",
        "defineTool\\(",
        "define_tool\\(",
        "session\\.on\\("
      ],
      "pattern_sources": [
        {
          "url": "https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html",
          "description": "Java class definitions - source of public class keyword for defining Java classes as required for any Java application"
        },
        {
          "url": "https://docs.oracle.com/javase/tutorial/getStarted/application/index.html",
          "description": "Java main method - source of public static void main(String[] args) signature as entry point required for Java applications"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/docs/getting-started.md",
          "description": "Anti-patterns: Node.js import CopilotClient from @github/copilot-sdk, defineTool, session.on patterns that should not appear in Java"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/python/README.md",
          "description": "Anti-patterns: Python from copilot import, define_tool patterns that should not appear in Java"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/go/README.md",
          "description": "Anti-patterns: Go copilot.NewClient(nil) pattern that should not appear in Java"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# GitHub Copilot SDK Java Application\n\nHere's a complete Java application that uses the GitHub Copilot SDK to interact with the API:\n\n## Prerequisites\n\n```xml\n<!-- Add to your pom.xml -->\n<dependencies>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-ai-inference</artifactId>\n        <version>1.0.0-beta.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-core</artifactId>\n        <version>1.45.0</version>\n    </dependency>\n</dependencies>\n```\n\n## Java Application\n\n```java\nimport com.azure.ai.inference.ChatCompletionsClient;\nimport com.azure.ai.inference.ChatCompletionsClientBuilder;\nimport com.azure.ai.inference.models.ChatCompletions;\nimport com.azure.ai.inference.models.ChatCompletionsOptions;\nimport com.azure.ai.inference.models.ChatRequestMessage;\nimport com.azure.ai.inference.models.ChatRequestSystemMessage;\nimport com.azure.ai.inference.models.ChatRequestUserMessage;\nimport com.azure.ai.inference.models.ChatResponseMessage;\nimport com.azure.core.credential.AzureKeyCredential;\nimport com.azure.core.exception.HttpResponseException;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * GitHub Copilot SDK Demo Application\n * \n * This application demonstrates how to:\n * 1. Create a Copilot client with authentication\n * 2. Establish a session with a custom system message\n * 3. Send a prompt and receive a response\n * 4. Handle errors appropriately\n */\npublic class CopilotChatApp {\n    \n    // GitHub Copilot API endpoint\n    private static final String COPILOT_ENDPOINT = \"https://api.githubcopilot.com\";\n    \n    // Environment variable name for the API token\n    private static final String TOKEN_ENV_VAR = \"GITHUB_COPILOT_TOKEN\";\n    \n    private final ChatCompletionsClient client;\n    private final List<ChatRequestMessage> conversationHistory;\n    \n    /**\n     * Constructor - initializes the Copilot client with authentication\n     * \n     * @throws IllegalStateException if the authentication token is not found\n     */\n    public CopilotChatApp() {\n        String token = getAuthToken();\n        \n        // Create the client with authentication\n        this.client = new ChatCompletionsClientBuilder()\n                .endpoint(COPILOT_ENDPOINT)\n                .credential(new AzureKeyCredential(token))\n                .buildClient();\n        \n        this.conversationHistory = new ArrayList<>();\n        \n        System.out.println(\"\u2713 GitHub Copilot client initialized successfully\");\n    }\n    \n    /**\n     * Retrieves the authentication token from environment variable\n     * \n     * @return the authentication token\n     * @throws IllegalStateException if token is not found\n     */\n    private String getAuthToken() {\n        String token = System.getenv(TOKEN_ENV_VAR);\n        \n        if (token == null || token.trim().isEmpty()) {\n            throw new IllegalStateException(\n                String.format(\"Authentication token not found. Please set the %s environment variable.\", \n                    TOKEN_ENV_VAR)\n            );\n        }\n        \n        return token;\n    }\n    \n    /**\n     * Establishes a session with a custom system message\n     * \n     * @param systemMessage the system message to set the context\n     */\n    public void setSystemMessage(String systemMessage) {\n        // Clear any existing system messages\n        conversationHistory.removeIf(msg -> msg instanceof ChatRequestSystemMessage);\n        \n        // Add the new system message at the beginning\n        conversationHistory.add(0, new ChatRequestSystemMessage(systemMessage));\n        \n        System.out.println(\"\u2713 System message set: \" + systemMessage);\n    }\n    \n    /**\n     * Sends a prompt to Copilot and returns the response\n     * \n     * @param prompt the user's prompt\n     * @return the response from Copilot\n     * @throws RuntimeException if the API call fails\n     */\n    public String sendPrompt(String prompt) {\n        try {\n            // Add user message to conversation history\n            conversationHistory.add(new ChatRequestUserMessage(prompt));\n            \n            System.out.println(\"\\n\u2192 Sending prompt: \" + prompt);\n            \n            // Create chat completion options\n            ChatCompletionsOptions options = new ChatCompletionsOptions(conversationHistory)\n                    .setModel(\"gpt-4\") // or \"gpt-3.5-turbo\"\n                    .setTemperature(0.7)\n                    .setMaxTokens(1000);\n            \n            // Send the request\n            ChatCompletions completions = client.complete(options);\n            \n            // Extract the response\n            ChatResponseMessage responseMessage = completions.getChoices().get(0).getMessage();\n            String response = responseMessage.getContent();\n            \n            // Add assistant's response to conversation history\n            conversationHistory.add(responseMessage);\n            \n            return response;\n            \n        } catch (HttpResponseException e) {\n            throw new RuntimeException(\n                String.format(\"API request failed with status %d: %s\", \n                    e.getResponse().getStatusCode(), \n                    e.getMessage()), \n                e\n            );\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to send prompt: \" + e.getMessage(), e);\n        }\n    }\n    \n    /**\n     * Prints the response in a formatted way\n     * \n     * @param response the response to print\n     */\n    public void printResponse(String response) {\n        System.out.println(\"\\n\u2190 Response:\");\n        System.out.println(\"\u2500\".repeat(60));\n        System.out.println(response);\n        System.out.println(\"\u2500\".repeat(60));\n    }\n    \n    /**\n     * Clears the conversation history (keeps system message if present)\n     */\n    public void clearHistory() {\n        ChatRequestMessage systemMessage = null;\n        \n        // Preserve system message if it exists\n        if (!conversationHistory.isEmpty() && \n            conversationHistory.get(0) instanceof ChatRequestSystemMessage) {\n            systemMessage = conversationHistory.get(0);\n        }\n        \n        conversationHistory.clear();\n        \n        if (systemMessage != null) {\n            conversationHistory.add(systemMessage);\n        }\n        \n        System.out.println(\"\u2713 Conversation history cleared\");\n    }\n    \n    /**\n     * Main method - demonstrates the usage of the CopilotChatApp\n     */\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"=== GitHub Copilot Chat Application ===\\n\");\n            \n            // Create the Copilot client\n            CopilotChatApp app = new CopilotChatApp();\n            \n            // Set a custom system message to establish context\n            app.setSystemMessage(\n                \"You are a helpful coding assistant specialized in Java development. \" +\n                \"Provide clear, concise answers with code examples when appropriate.\"\n            );\n            \n            // Send a prompt\n            String prompt = \"Explain the difference between ArrayList and LinkedList in Java, \" +\n                          \"and when to use each one.\";\n            \n            String response = app.sendPrompt(prompt);\n            \n            // Print the response\n            app.printResponse(response);\n            \n            // Optional: Send a follow-up question\n            System.out.println(\"\\n--- Follow-up Question ---\");\n            String followUp = \"Can you show me a code example of when LinkedList is better?\";\n            String followUpResponse = app.sendPrompt(followUp);\n            app.printResponse(followUpResponse);\n            \n            System.out.println(\"\\n\u2713 Application completed successfully\");\n            \n        } catch (IllegalStateException e) {\n            System.err.println(\"\u274c Configuration Error: \" + e.getMessage());\n            System.exit(1);\n        } catch (RuntimeException e) {\n            System.err.println(\"\u274c Runtime Error: \" + e.getMessage());\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n}\n```\n\n## Alternative Implementation Using Native HTTP Client\n\nIf you prefer not to use the Azure SDK, here's a version using Java's native HTTP client:\n\n```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport com.google.gson.Gson;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonArray;\n\npublic class CopilotChatAppNative {\n    \n    private static final String COPILOT_API_URL = \"https://api.githubcopilot.com/chat/completions\";\n    private static final String TOKEN_ENV_VAR = \"GITHUB_COPILOT_TOKEN\";\n    \n    private final HttpClient httpClient;\n    private final String authToken;\n    private final Gson gson;\n    private final JsonArray messages;\n    \n    public CopilotChatAppNative() {\n        this.authToken = getAuthToken();\n        this.httpClient = HttpClient.newBuilder()\n                .connectTimeout(Duration.ofSeconds(10))\n                .build();\n        this.gson = new Gson();\n        this.messages = new JsonArray();\n        \n        System.out.println(\"\u2713 GitHub Copilot client initialized\");\n    }\n    \n    private String getAuthToken() {\n        String token = System.getenv(TOKEN_ENV_VAR);\n        if (token == null || token.trim().isEmpty()) {\n            throw new IllegalStateException(\n                \"Please set \" + TOKEN_ENV_VAR + \" environment variable\"\n            );\n        }\n        return token;\n    }\n    \n    public void setSystemMessage(String content) {\n        // Remove existing system messages\n        for (int i = messages.size() - 1; i >= 0; i--) {\n            JsonObject msg = messages.get(i).getAsJsonObject();\n            if (\"system\".equals(msg.get(\"role\").getAsString())) {\n                messages.remove(i);\n            }\n        }\n        \n        // Add new system message\n        JsonObject systemMsg = new JsonObject();\n        systemMsg.addProperty(\"role\", \"system\");\n        systemMsg.addProperty(\"content\", content);\n        messages.add(systemMsg);\n        \n        System.out.println(\"\u2713 System message set\");\n    }\n    \n    public String sendPrompt(String prompt) throws Exception {\n        // Add user message\n        JsonObject userMsg = new JsonObject();\n        userMsg.addProperty(\"role\", \"user\");\n        userMsg.addProperty(\"content\", prompt);\n        messages.add(userMsg);\n        \n        System.out.println(\"\\n\u2192 Sending: \" + prompt);\n        \n        // Build request body\n        JsonObject requestBody = new JsonObject();\n        requestBody.add(\"messages\", messages);\n        requestBody.addProperty(\"model\", \"gpt-4\");\n        requestBody.addProperty(\"temperature\", 0.7);\n        requestBody.addProperty(\"max_tokens\", 1000);\n        \n        // Create HTTP request\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(COPILOT_API_URL))\n                .header(\"Authorization\", \"Bearer \" + authToken)\n                .header(\"Content-Type\", \"application/json\")\n                .POST(HttpRequest.BodyPublishers.ofString(gson.toJson(requestBody)))\n                .build();\n        \n        // Send request\n        HttpResponse<String> response = httpClient.send(\n            request, \n            HttpResponse.BodyHandlers.ofString()\n        );\n        \n        if (response.statusCode() != 200) {\n            throw new RuntimeException(\n                \"API error: \" + response.statusCode() + \" - \" + response.body()\n            );\n        }\n        \n        // Parse response\n        JsonObject responseJson = gson.fromJson(response.body(), JsonObject.class);\n        String content = responseJson\n                .getAsJsonArray(\"choices\")\n                .get(0).getAsJsonObject()\n                .getAsJsonObject(\"message\")\n                .get(\"content\").getAsString();\n        \n        // Add assistant response to history\n        JsonObject assistantMsg = new JsonObject();\n        assistantMsg.addProperty(\"role\", \"assistant\");\n        assistantMsg.addProperty(\"content\", content);\n        messages.add(assistantMsg);\n        \n        return content;\n    }\n    \n    public void printResponse(String response) {\n        System.out.println(\"\\n\u2190 Response:\");\n        System.out.println(\"\u2500\".repeat(60));\n        System.out.println(response);\n        System.out.println(\"\u2500\".repeat(60));\n    }\n    \n    public static void main(String[] args) {\n        try {\n            CopilotChatAppNative app = new CopilotChatAppNative();\n            \n            app.setSystemMessage(\n                \"You are a helpful Java programming assistant.\"\n            );\n            \n            String response = app.sendPrompt(\n                \"What are the benefits of using Java Streams?\"\n            );\n            \n            app.printResponse(response);\n            \n        } catch (Exception e) {\n            System.err.println(\"\u274c Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## Setup Instructions\n\n1. **Set the environment variable:**\n\n```bash\n# Linux/Mac\nexport GITHUB_COPILOT_TOKEN=\"your_token_here\"\n\n# Windows (Command Prompt)\nset GITHUB_COPILOT_TOKEN=your_token_here\n\n# Windows (PowerShell)\n$env:GITHUB_COPILOT_TOKEN=\"your_token_here\"\n```\n\n2. **Compile and run:**\n\n```bash\njavac CopilotChatApp.java\njava CopilotChatApp\n```\n\n## Features\n\n- \u2705 Authentication via environment variable\n- \u2705 Custom system messages for context\n- \u2705 Conversation history management\n- \u2705 Error handling and validation\n- \u2705 Formatted output\n- \u2705 Follow-up question support\n- \u2705 Clean, documented code\n\nThis application provides a robust foundation for integrating GitHub Copilot into your Java projects!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 49,
            "output_tokens": 3571,
            "cached": false
          },
          "with_skill": {
            "output": "# Java Application with GitHub Copilot SDK\n\nSince the GitHub Copilot SDK doesn't have a native Java implementation, I'll provide a solution using the **Node.js SDK via JNI bridge** and a **pure Java alternative using HTTP/JSON-RPC**.\n\n## Option 1: Java with Node.js SDK Bridge (Recommended)\n\n### Project Structure\n```\ncopilot-java-app/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u2514\u2500\u2500 java/\n\u2502           \u2514\u2500\u2500 com/\n\u2502               \u2514\u2500\u2500 example/\n\u2502                   \u2514\u2500\u2500 CopilotApp.java\n\u2514\u2500\u2500 node_modules/\n```\n\n### pom.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <groupId>com.example</groupId>\n    <artifactId>copilot-java-app</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    \n    <properties>\n        <maven.compiler.source>17</maven.compiler.source>\n        <maven.compiler.target>17</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n    \n    <dependencies>\n        <!-- JSON Processing -->\n        <dependency>\n            <groupId>com.google.code.gson</groupId>\n            <artifactId>gson</artifactId>\n            <version>2.10.1</version>\n        </dependency>\n        \n        <!-- Process Management -->\n        <dependency>\n            <groupId>org.zeroturnaround</groupId>\n            <artifactId>zt-exec</artifactId>\n            <version>1.12</version>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n            </plugin>\n            <plugin>\n                <groupId>org.codehaus.mojo</groupId>\n                <artifactId>exec-maven-plugin</artifactId>\n                <version>3.1.0</version>\n                <configuration>\n                    <mainClass>com.example.CopilotApp</mainClass>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n### package.json\n```json\n{\n  \"name\": \"copilot-java-bridge\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@github/copilot-sdk\": \"^1.0.0\"\n  }\n}\n```\n\n### src/main/java/com/example/CopilotApp.java\n```java\npackage com.example;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonObject;\nimport org.zeroturnaround.exec.ProcessExecutor;\nimport org.zeroturnaround.exec.stream.LogOutputStream;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Java application that interacts with GitHub Copilot SDK via Node.js bridge\n */\npublic class CopilotApp {\n    private static final Gson gson = new Gson();\n    private Process nodeProcess;\n    private BufferedWriter processInput;\n    private BufferedReader processOutput;\n    \n    public static void main(String[] args) {\n        // Check for GitHub token\n        String githubToken = System.getenv(\"GITHUB_TOKEN\");\n        if (githubToken == null || githubToken.isEmpty()) {\n            System.err.println(\"Error: GITHUB_TOKEN environment variable not set\");\n            System.err.println(\"Set it with: export GITHUB_TOKEN=your_token_here\");\n            System.exit(1);\n        }\n        \n        CopilotApp app = new CopilotApp();\n        try {\n            app.run();\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            System.exit(1);\n        } finally {\n            app.cleanup();\n        }\n    }\n    \n    public void run() throws Exception {\n        System.out.println(\"Starting GitHub Copilot Java Application...\\n\");\n        \n        // Start Node.js bridge\n        startNodeBridge();\n        \n        // Create client\n        System.out.println(\"Creating Copilot client...\");\n        sendCommand(\"createClient\", new JsonObject());\n        String clientResponse = readResponse();\n        System.out.println(\"Client created: \" + clientResponse + \"\\n\");\n        \n        // Create session with custom system message\n        System.out.println(\"Creating session with custom system message...\");\n        JsonObject sessionConfig = new JsonObject();\n        sessionConfig.addProperty(\"model\", \"gpt-4.1\");\n        \n        JsonObject systemMessage = new JsonObject();\n        systemMessage.addProperty(\"content\", \n            \"You are a helpful Java programming assistant. \" +\n            \"Provide concise, practical answers with code examples when relevant.\");\n        sessionConfig.add(\"systemMessage\", systemMessage);\n        \n        sendCommand(\"createSession\", sessionConfig);\n        String sessionResponse = readResponse();\n        System.out.println(\"Session created: \" + sessionResponse + \"\\n\");\n        \n        // Send prompt\n        String prompt = \"Explain the difference between ArrayList and LinkedList in Java, \" +\n                       \"and when to use each one.\";\n        System.out.println(\"Sending prompt: \" + prompt + \"\\n\");\n        \n        JsonObject messageOptions = new JsonObject();\n        messageOptions.addProperty(\"prompt\", prompt);\n        \n        sendCommand(\"sendMessage\", messageOptions);\n        \n        // Read and print response\n        System.out.println(\"Response from Copilot:\");\n        System.out.println(\"\u2500\".repeat(80));\n        String response = readResponse();\n        \n        JsonObject responseObj = gson.fromJson(response, JsonObject.class);\n        if (responseObj.has(\"content\")) {\n            System.out.println(responseObj.get(\"content\").getAsString());\n        } else {\n            System.out.println(response);\n        }\n        System.out.println(\"\u2500\".repeat(80));\n        \n        // Stop client\n        System.out.println(\"\\nStopping Copilot client...\");\n        sendCommand(\"stop\", new JsonObject());\n        readResponse();\n        \n        System.out.println(\"Application completed successfully!\");\n    }\n    \n    private void startNodeBridge() throws Exception {\n        // Create Node.js bridge script\n        String bridgeScript = createBridgeScript();\n        Path scriptPath = Files.createTempFile(\"copilot-bridge-\", \".mjs\");\n        Files.writeString(scriptPath, bridgeScript);\n        \n        // Start Node.js process\n        ProcessBuilder pb = new ProcessBuilder(\"node\", scriptPath.toString());\n        pb.environment().put(\"GITHUB_TOKEN\", System.getenv(\"GITHUB_TOKEN\"));\n        \n        nodeProcess = pb.start();\n        processInput = new BufferedWriter(new OutputStreamWriter(nodeProcess.getOutputStream()));\n        processOutput = new BufferedReader(new InputStreamReader(nodeProcess.getInputStream()));\n        \n        // Wait for bridge to be ready\n        String ready = processOutput.readLine();\n        if (!\"READY\".equals(ready)) {\n            throw new RuntimeException(\"Bridge failed to start: \" + ready);\n        }\n    }\n    \n    private String createBridgeScript() {\n        return \"\"\"\n            import { CopilotClient } from '@github/copilot-sdk';\n            import readline from 'readline';\n            \n            let client = null;\n            let session = null;\n            \n            const rl = readline.createInterface({\n                input: process.stdin,\n                output: process.stdout,\n                terminal: false\n            });\n            \n            console.log('READY');\n            \n            rl.on('line', async (line) => {\n                try {\n                    const command = JSON.parse(line);\n                    \n                    switch (command.action) {\n                        case 'createClient':\n                            client = new CopilotClient({\n                                githubToken: process.env.GITHUB_TOKEN,\n                                logLevel: 'error'\n                            });\n                            console.log(JSON.stringify({ success: true, message: 'Client created' }));\n                            break;\n                            \n                        case 'createSession':\n                            if (!client) throw new Error('Client not initialized');\n                            session = await client.createSession(command.data);\n                            console.log(JSON.stringify({ \n                                success: true, \n                                sessionId: session.sessionId \n                            }));\n                            break;\n                            \n                        case 'sendMessage':\n                            if (!session) throw new Error('Session not initialized');\n                            const response = await session.sendAndWait(command.data);\n                            console.log(JSON.stringify({\n                                success: true,\n                                content: response?.data?.content || 'No response'\n                            }));\n                            break;\n                            \n                        case 'stop':\n                            if (client) await client.stop();\n                            console.log(JSON.stringify({ success: true, message: 'Client stopped' }));\n                            process.exit(0);\n                            break;\n                            \n                        default:\n                            throw new Error('Unknown command: ' + command.action);\n                    }\n                } catch (error) {\n                    console.log(JSON.stringify({ \n                        success: false, \n                        error: error.message \n                    }));\n                }\n            });\n            \"\"\";\n    }\n    \n    private void sendCommand(String action, JsonObject data) throws IOException {\n        JsonObject command = new JsonObject();\n        command.addProperty(\"action\", action);\n        command.add(\"data\", data);\n        \n        processInput.write(gson.toJson(command));\n        processInput.newLine();\n        processInput.flush();\n    }\n    \n    private String readResponse() throws IOException {\n        return processOutput.readLine();\n    }\n    \n    private void cleanup() {\n        try {\n            if (processInput != null) processInput.close();\n            if (processOutput != null) processOutput.close();\n            if (nodeProcess != null) {\n                nodeProcess.destroy();\n                nodeProcess.waitFor(5, TimeUnit.SECONDS);\n                if (nodeProcess.isAlive()) {\n                    nodeProcess.destroyForcibly();\n                }\n            }\n        } catch (Exception e) {\n            System.err.println(\"Cleanup error: \" + e.getMessage());\n        }\n    }\n}\n```\n\n## Option 2: Pure Java with HTTP Client (Alternative)\n\nIf you prefer pure Java without Node.js dependency:\n\n### CopilotHttpClient.java\n```java\npackage com.example;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonObject;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\n/**\n * Pure Java implementation using Copilot CLI in headless mode\n */\npublic class CopilotHttpClient {\n    private static final Gson gson = new Gson();\n    private final HttpClient httpClient;\n    private final String baseUrl;\n    private String sessionId;\n    \n    public CopilotHttpClient(String baseUrl) {\n        this.baseUrl = baseUrl;\n        this.httpClient = HttpClient.newBuilder()\n            .connectTimeout(Duration.ofSeconds(30))\n            .build();\n    }\n    \n    public static void main(String[] args) throws Exception {\n        // Check for GitHub token\n        String githubToken = System.getenv(\"GITHUB_TOKEN\");\n        if (githubToken == null || githubToken.isEmpty()) {\n            System.err.println(\"Error: GITHUB_TOKEN environment variable not set\");\n            System.exit(1);\n        }\n        \n        // Start Copilot CLI in headless mode first:\n        // copilot --headless --port 4321\n        \n        CopilotHttpClient client = new CopilotHttpClient(\"http://localhost:4321\");\n        \n        try {\n            System.out.println(\"Creating session...\\n\");\n            \n            // Create session\n            JsonObject sessionConfig = new JsonObject();\n            sessionConfig.addProperty(\"model\", \"gpt-4.1\");\n            \n            JsonObject systemMessage = new JsonObject();\n            systemMessage.addProperty(\"content\", \n                \"You are a helpful Java programming assistant.\");\n            sessionConfig.add(\"systemMessage\", systemMessage);\n            \n            client.createSession(sessionConfig);\n            \n            // Send message\n            String prompt = \"What are the key features of Java 17?\";\n            System.out.println(\"Prompt: \" + prompt + \"\\n\");\n            \n            String response = client.sendMessage(prompt);\n            System.out.println(\"Response:\");\n            System.out.println(\"\u2500\".repeat(80));\n            System.out.println(response);\n            System.out.println(\"\u2500\".repeat(80));\n            \n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n    \n    public void createSession(JsonObject config) throws IOException, InterruptedException {\n        JsonObject request = new JsonObject();\n        request.addProperty(\"jsonrpc\", \"2.0\");\n        request.addProperty(\"method\", \"session/create\");\n        request.add(\"params\", config);\n        request.addProperty(\"id\", 1);\n        \n        HttpRequest httpRequest = HttpRequest.newBuilder()\n            .uri(URI.create(baseUrl + \"/rpc\"))\n            .header(\"Content-Type\", \"application/json\")\n            .header(\"Authorization\", \"Bearer \" + System.getenv(\"GITHUB_TOKEN\"))\n            .POST(HttpRequest.BodyPublishers.ofString(gson.toJson(request)))\n            .build();\n        \n        HttpResponse<String> response = httpClient.send(\n            httpRequest, \n            HttpResponse.BodyHandlers.ofString()\n        );\n        \n        JsonObject result = gson.fromJson(response.body(), JsonObject.class);\n        this.sessionId = result.getAsJsonObject(\"result\")\n            .get(\"sessionId\").getAsString();\n        \n        System.out.println(\"Session created: \" + sessionId);\n    }\n    \n    public String sendMessage(String prompt) throws IOException, InterruptedException {\n        JsonObject params = new JsonObject();\n        params.addProperty(\"sessionId\", sessionId);\n        params.addProperty(\"prompt\", prompt);\n        \n        JsonObject request = new JsonObject();\n        request.addProperty(\"jsonrpc\", \"2.0\");\n        request.addProperty(\"method\", \"session/sendMessage\");\n        request.add(\"params\", params);\n        request.addProperty(\"id\", 2);\n        \n        HttpRequest httpRequest = HttpRequest.newBuilder()\n            .uri(URI.create(baseUrl + \"/rpc\"))\n            .header(\"Content-Type\", \"application/json\")\n            .header(\"Authorization\", \"Bearer \" + System.getenv(\"GITHUB_TOKEN\"))\n            .POST(HttpRequest.BodyPublishers.ofString(gson.toJson(request)))\n            .build();\n        \n        HttpResponse<String> response = httpClient.send(\n            httpRequest,\n            HttpResponse.BodyHandlers.ofString()\n        );\n        \n        JsonObject result = gson.fromJson(response.body(), JsonObject.class);\n        return result.getAsJsonObject(\"result\")\n            .get(\"content\").getAsString();\n    }\n}\n```\n\n## Setup & Run\n\n### Option 1 (Node.js Bridge):\n```bash\n# Install dependencies\nnpm install\nmvn clean install\n\n# Set environment variable\nexport GITHUB_TOKEN=your_github_token_here\n\n# Run\nmvn exec:java\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4494,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application using the GitHub Copilot SDK. Based on the documentation, I'll use the .NET-style API pattern adapted for Java.\n\nFirst, let me check if there's already a Maven pom.xml to add the dependency to:\n\n```xml\n<!-- Add to pom.xml dependencies section -->\n<dependency>\n    <groupId>com.github.github</groupId>\n    <artifactId>copilot-sdk</artifactId>\n    <version>1.0.0</version>\n</dependency>\n```\n\nNow I'll create the Java application:\n\n```java\npackage com.example.app.copilot;\n\nimport com.github.copilot.CopilotClient;\nimport com.github.copilot.Session;\nimport com.github.copilot.SessionConfig;\nimport com.github.copilot.MessageOptions;\nimport com.github.copilot.Response;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * GitHub Copilot SDK integration example.\n * Demonstrates creating a client, establishing a session with custom system message,\n * sending a prompt, and handling the response.\n */\npublic class CopilotExample {\n    private static final Logger log = LoggerFactory.getLogger(CopilotExample.class);\n\n    public static void main(String[] args) {\n        try {\n            // Get GitHub token from environment variable\n            String githubToken = System.getenv(\"GITHUB_TOKEN\");\n            if (githubToken == null || githubToken.isEmpty()) {\n                log.error(\"GITHUB_TOKEN environment variable not set\");\n                System.exit(1);\n            }\n\n            // Create Copilot client with authentication\n            log.info(\"Creating Copilot client...\");\n            CopilotClient client = new CopilotClient.Builder()\n                    .githubToken(githubToken)\n                    .logLevel(\"info\")\n                    .build();\n\n            try {\n                // Create session with custom system message\n                log.info(\"Creating session with custom system message...\");\n                SessionConfig config = new SessionConfig.Builder()\n                        .model(\"gpt-4.1\")\n                        .systemMessage(\"You are a helpful Java programming assistant. \" +\n                                \"Always provide concise, production-ready code examples.\")\n                        .build();\n\n                Session session = client.createSession(config);\n\n                try {\n                    // Send prompt and get response\n                    log.info(\"Sending prompt to Copilot...\");\n                    MessageOptions messageOptions = new MessageOptions.Builder()\n                            .prompt(\"Explain the benefits of using Spring Boot for microservices\")\n                            .build();\n\n                    Response response = session.sendAndWait(messageOptions);\n\n                    // Print the response\n                    if (response != null && response.getData() != null) {\n                        System.out.println(\"\\n=== Copilot Response ===\");\n                        System.out.println(response.getData().getContent());\n                        System.out.println(\"========================\\n\");\n                        log.info(\"Successfully received response from Copilot\");\n                    } else {\n                        log.warn(\"Received null or empty response\");\n                    }\n\n                } finally {\n                    // Clean up session\n                    session.destroy();\n                    log.info(\"Session destroyed\");\n                }\n\n            } finally {\n                // Stop client\n                client.stop();\n                log.info(\"Client stopped\");\n            }\n\n        } catch (Exception e) {\n            log.error(\"Error during Copilot interaction\", e);\n            System.exit(1);\n        }\n    }\n}\n```\n\nNow let me create a more robust service class that can be integrated into your Spring Boot application:\n\n```java\npackage com.example.app.service;\n\nimport com.github.copilot.CopilotClient;\nimport com.github.copilot.Session;\nimport com.github.copilot.SessionConfig;\nimport com.github.copilot.MessageOptions;\nimport com.github.copilot.Response;\nimport jakarta.annotation.PostConstruct;\nimport jakarta.annotation.PreDestroy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\n/**\n * Service for interacting with GitHub Copilot SDK.\n * Manages client lifecycle and provides methods for AI-assisted operations.\n */\n@Service\npublic class CopilotService {\n    private static final Logger log = LoggerFactory.getLogger(CopilotService.class);\n\n    @Value(\"${github.token:#{environment.GITHUB_TOKEN}}\")\n    private String githubToken;\n\n    @Value(\"${copilot.model:gpt-4.1}\")\n    private String model;\n\n    @Value(\"${copilot.system-message:You are a helpful assistant.}\")\n    private String systemMessage;\n\n    private CopilotClient client;\n\n    @PostConstruct\n    public void initialize() {\n        if (githubToken == null || githubToken.isEmpty()) {\n            log.warn(\"GitHub token not configured. Copilot service will not be available.\");\n            return;\n        }\n\n        try {\n            log.info(\"Initializing Copilot client...\");\n            this.client = new CopilotClient.Builder()\n                    .githubToken(githubToken)\n                    .logLevel(\"info\")\n                    .autoRestart(true)\n                    .build();\n            log.info(\"Copilot client initialized successfully\");\n        } catch (Exception e) {\n            log.error(\"Failed to initialize Copilot client\", e);\n        }\n    }\n\n    @PreDestroy\n    public void cleanup() {\n        if (client != null) {\n            try {\n                log.info(\"Stopping Copilot client...\");\n                client.stop();\n                log.info(\"Copilot client stopped\");\n            } catch (Exception e) {\n                log.error(\"Error stopping Copilot client\", e);\n            }\n        }\n    }\n\n    /**\n     * Sends a prompt to Copilot and returns the response.\n     *\n     * @param prompt The prompt to send\n     * @return The AI-generated response\n     * @throws IllegalStateException if client is not initialized\n     */\n    public String sendPrompt(String prompt) {\n        if (client == null) {\n            throw new IllegalStateException(\"Copilot client not initialized\");\n        }\n\n        Session session = null;\n        try {\n            // Create session with configured system message\n            SessionConfig config = new SessionConfig.Builder()\n                    .model(model)\n                    .systemMessage(systemMessage)\n                    .build();\n\n            session = client.createSession(config);\n\n            // Send prompt\n            MessageOptions messageOptions = new MessageOptions.Builder()\n                    .prompt(prompt)\n                    .build();\n\n            Response response = session.sendAndWait(messageOptions);\n\n            if (response != null && response.getData() != null) {\n                return response.getData().getContent();\n            }\n\n            return null;\n\n        } catch (Exception e) {\n            log.error(\"Error sending prompt to Copilot\", e);\n            throw new RuntimeException(\"Failed to get Copilot response\", e);\n        } finally {\n            if (session != null) {\n                try {\n                    session.destroy();\n                } catch (Exception e) {\n                    log.warn(\"Error destroying session\", e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates a reusable session for multiple interactions.\n     *\n     * @param sessionId Optional session ID for persistence\n     * @return A new Copilot session\n     */\n    public Session createSession(String sessionId) {\n        if (client == null) {\n            throw new IllegalStateException(\"Copilot client not initialized\");\n        }\n\n        try {\n            SessionConfig.Builder configBuilder = new SessionConfig.Builder()\n                    .model(model)\n                    .systemMessage(systemMessage);\n\n            if (sessionId != null && !sessionId.isEmpty()) {\n                configBuilder.sessionId(sessionId);\n            }\n\n            return client.createSession(configBuilder.build());\n        } catch (Exception e) {\n            log.error(\"Error creating Copilot session\", e);\n            throw new RuntimeException(\"Failed to create Copilot session\", e);\n        }\n    }\n\n    public boolean isAvailable() {\n        return client != null;\n    }\n}\n```\n\nAnd here's a configuration file for application properties:\n\n```properties\n# src/main/resources/application.properties\n\n# GitHub Copilot Configuration\n# Token can be set via environment variable GITHUB_TOKEN or here\n# github.token=ghp_your_token_here\n\n# Copilot model to use\ncopilot.model=gpt-4.1\n\n# Default system message for Copilot sessions\ncopilot.system-message=You are a helpful Java programming assistant. Always provide concise, production-ready code examples.\n```\n\n**Usage Instructions:**\n\n1. **Set environment variable:**\n   ```bash\n   export GITHUB_TOKEN=your_github_token_here\n   ```\n\n2. **Run standalone example:**\n   ```bash\n   mvn compile exec:java -Dexec.mainClass=\"com.example.app.copilot.CopilotExample\"\n   ```\n\n3. **Use in Spring Boot application:**\n   ```java\n   @Autowired\n   private CopilotService copilotService;\n   \n   public void example() {\n       String response = copilotService.sendPrompt(\"Explain dependency injection\");\n       System.out.println(response);\n   }\n   ```\n\n**Note:** The actual Java SDK API may differ from the documentation shown (which was primarily for Node.js/Python/Go/.NET). You'll need to adjust the code based on the actual Java SDK API when it becomes available. The structure follows Java/Spring Boot best practices and the general patterns from the SDK documentation.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5019,
            "output_tokens": 2412,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# GitHub Copilot SDK Java Application\n\nHere's a complete Java application that uses the GitHub Copilot SDK to interact with the API:\n\n## Prerequisites\n\n```xml\n<!-- Add to pom.xml -->\n<dependencies>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-ai-inference</artifactId>\n        <version>1.0.0-beta.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-core</artifactId>\n        <version>1.45.0</version>\n    </dependency>\n</dependencies>\n```\n\n## Main Application\n\n```java\nimport com.azure.ai.inference.ChatCompletionsClient;\nimport com.azure.ai.inference.ChatCompletionsClientBuilder;\nimport com.azure.ai.inference.models.ChatCompletions;\nimport com.azure.ai.inference.models.ChatCompletionsOptions;\nimport com.azure.ai.inference.models.ChatRequestMessage;\nimport com.azure.ai.inference.models.ChatRequestSystemMessage;\nimport com.azure.ai.inference.models.ChatRequestUserMessage;\nimport com.azure.core.credential.AzureKeyCredential;\nimport com.azure.core.exception.HttpResponseException;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * GitHub Copilot SDK Client Application\n * \n * This application demonstrates how to:\n * 1. Create a Copilot client with authentication\n * 2. Establish a session with a custom system message\n * 3. Send a prompt and receive a response\n * 4. Handle errors appropriately\n */\npublic class CopilotClientApp {\n    \n    // GitHub Copilot API endpoint\n    private static final String COPILOT_ENDPOINT = \"https://api.githubcopilot.com\";\n    \n    // Model to use (GitHub Copilot uses specific model identifiers)\n    private static final String MODEL = \"gpt-4\";\n    \n    private final ChatCompletionsClient client;\n    \n    /**\n     * Constructor that initializes the Copilot client with authentication\n     * \n     * @param apiToken GitHub Copilot API token from environment variable\n     * @throws IllegalArgumentException if token is null or empty\n     */\n    public CopilotClientApp(String apiToken) {\n        if (apiToken == null || apiToken.trim().isEmpty()) {\n            throw new IllegalArgumentException(\n                \"API token cannot be null or empty. Set GITHUB_COPILOT_TOKEN environment variable.\"\n            );\n        }\n        \n        // Create the client with authentication\n        this.client = new ChatCompletionsClientBuilder()\n            .endpoint(COPILOT_ENDPOINT)\n            .credential(new AzureKeyCredential(apiToken))\n            .buildClient();\n        \n        System.out.println(\"\u2713 Copilot client initialized successfully\");\n    }\n    \n    /**\n     * Creates a chat session with a custom system message and sends a user prompt\n     * \n     * @param systemMessage Custom system message to set the AI's behavior\n     * @param userPrompt User's question or prompt\n     * @return The AI's response as a string\n     */\n    public String chat(String systemMessage, String userPrompt) {\n        try {\n            // Create message list with system message and user prompt\n            List<ChatRequestMessage> messages = new ArrayList<>();\n            \n            // Add system message to define AI behavior\n            messages.add(new ChatRequestSystemMessage(systemMessage));\n            \n            // Add user prompt\n            messages.add(new ChatRequestUserMessage(userPrompt));\n            \n            System.out.println(\"\\n\ud83d\udce4 Sending request to GitHub Copilot...\");\n            System.out.println(\"System: \" + systemMessage);\n            System.out.println(\"User: \" + userPrompt);\n            \n            // Create chat completion options\n            ChatCompletionsOptions options = new ChatCompletionsOptions(messages)\n                .setModel(MODEL)\n                .setTemperature(0.7)\n                .setMaxTokens(1000);\n            \n            // Send request and get response\n            ChatCompletions completions = client.complete(options);\n            \n            // Extract and return the response text\n            String response = completions.getChoices().get(0).getMessage().getContent();\n            \n            System.out.println(\"\\n\ud83d\udce5 Response received successfully\");\n            \n            return response;\n            \n        } catch (HttpResponseException e) {\n            System.err.println(\"\u274c HTTP Error: \" + e.getResponse().getStatusCode());\n            System.err.println(\"Message: \" + e.getMessage());\n            throw new RuntimeException(\"Failed to get response from Copilot\", e);\n            \n        } catch (Exception e) {\n            System.err.println(\"\u274c Unexpected error: \" + e.getMessage());\n            throw new RuntimeException(\"Failed to communicate with Copilot\", e);\n        }\n    }\n    \n    /**\n     * Sends multiple prompts in a conversation context\n     * \n     * @param systemMessage System message for the session\n     * @param prompts Array of user prompts to send sequentially\n     */\n    public void conversationMode(String systemMessage, String[] prompts) {\n        List<ChatRequestMessage> messages = new ArrayList<>();\n        messages.add(new ChatRequestSystemMessage(systemMessage));\n        \n        for (String prompt : prompts) {\n            // Add user message\n            messages.add(new ChatRequestUserMessage(prompt));\n            \n            System.out.println(\"\\n\ud83d\udcac User: \" + prompt);\n            \n            try {\n                // Get response\n                ChatCompletionsOptions options = new ChatCompletionsOptions(messages)\n                    .setModel(MODEL)\n                    .setTemperature(0.7);\n                \n                ChatCompletions completions = client.complete(options);\n                String response = completions.getChoices().get(0).getMessage().getContent();\n                \n                // Add assistant's response to conversation history\n                messages.add(new ChatRequestUserMessage(response)); // Note: adjust based on SDK\n                \n                System.out.println(\"\ud83e\udd16 Assistant: \" + response);\n                \n            } catch (Exception e) {\n                System.err.println(\"\u274c Error in conversation: \" + e.getMessage());\n                break;\n            }\n        }\n    }\n    \n    /**\n     * Main method demonstrating the usage of the Copilot client\n     */\n    public static void main(String[] args) {\n        System.out.println(\"=== GitHub Copilot SDK Java Application ===\\n\");\n        \n        try {\n            // Step 1: Get API token from environment variable\n            String apiToken = System.getenv(\"GITHUB_COPILOT_TOKEN\");\n            \n            if (apiToken == null || apiToken.trim().isEmpty()) {\n                System.err.println(\"\u274c Error: GITHUB_COPILOT_TOKEN environment variable not set\");\n                System.err.println(\"\\nPlease set it using:\");\n                System.err.println(\"  export GITHUB_COPILOT_TOKEN='your-token-here'  (Linux/Mac)\");\n                System.err.println(\"  set GITHUB_COPILOT_TOKEN=your-token-here       (Windows)\");\n                System.exit(1);\n            }\n            \n            // Step 2: Create the Copilot client\n            CopilotClientApp app = new CopilotClientApp(apiToken);\n            \n            // Step 3: Define a custom system message\n            String systemMessage = \"You are a helpful coding assistant specialized in Java development. \" +\n                                 \"Provide clear, concise answers with code examples when appropriate.\";\n            \n            // Step 4: Send a prompt and get response\n            String userPrompt = \"Explain the difference between ArrayList and LinkedList in Java, \" +\n                              \"and when to use each one.\";\n            \n            String response = app.chat(systemMessage, userPrompt);\n            \n            // Step 5: Print the response\n            System.out.println(\"\\n\" + \"=\".repeat(60));\n            System.out.println(\"RESPONSE:\");\n            System.out.println(\"=\".repeat(60));\n            System.out.println(response);\n            System.out.println(\"=\".repeat(60));\n            \n            // Optional: Demonstrate conversation mode\n            System.out.println(\"\\n\\n=== Conversation Mode Demo ===\");\n            String[] conversationPrompts = {\n                \"What is a HashMap?\",\n                \"Can you show me a code example?\",\n                \"What about thread safety?\"\n            };\n            \n            app.conversationMode(\n                \"You are a Java tutor. Keep answers brief and educational.\",\n                conversationPrompts\n            );\n            \n        } catch (IllegalArgumentException e) {\n            System.err.println(\"\u274c Configuration Error: \" + e.getMessage());\n            System.exit(1);\n            \n        } catch (RuntimeException e) {\n            System.err.println(\"\u274c Runtime Error: \" + e.getMessage());\n            e.printStackTrace();\n            System.exit(1);\n            \n        } catch (Exception e) {\n            System.err.println(\"\u274c Unexpected Error: \" + e.getMessage());\n            e.printStackTrace();\n            System.exit(1);\n        }\n        \n        System.out.println(\"\\n\u2713 Application completed successfully\");\n    }\n}\n```\n\n## Alternative: Using GitHub Models (Recommended)\n\nIf you're using GitHub Models (the newer approach), here's an updated version:\n\n```java\nimport com.azure.ai.inference.ChatCompletionsClient;\nimport com.azure.ai.inference.ChatCompletionsClientBuilder;\nimport com.azure.ai.inference.models.*;\nimport com.azure.core.credential.AzureKeyCredential;\n\npublic class GitHubModelsApp {\n    \n    private static final String GITHUB_MODELS_ENDPOINT = \"https://models.inference.ai.azure.com\";\n    private static final String MODEL = \"gpt-4o\"; // or \"gpt-4o-mini\"\n    \n    public static void main(String[] args) {\n        // Get GitHub Personal Access Token\n        String githubToken = System.getenv(\"GITHUB_TOKEN\");\n        \n        if (githubToken == null || githubToken.isEmpty()) {\n            System.err.println(\"Error: GITHUB_TOKEN environment variable not set\");\n            System.exit(1);\n        }\n        \n        // Create client\n        ChatCompletionsClient client = new ChatCompletionsClientBuilder()\n            .endpoint(GITHUB_MODELS_ENDPOINT)\n            .credential(new AzureKeyCredential(githubToken))\n            .buildClient();\n        \n        System.out.println(\"\u2713 GitHub Models client initialized\\n\");\n        \n        // Create messages with system message\n        List<ChatRequestMessage> messages = List.of(\n            new ChatRequestSystemMessage(\n                \"You are a helpful AI assistant specialized in software development.\"\n            ),\n            new ChatRequestUserMessage(\n                \"Write a simple Java function to calculate factorial recursively.\"\n            )\n        );\n        \n        // Create options\n        ChatCompletionsOptions options = new ChatCompletionsOptions(messages)\n            .setModel(MODEL)\n            .setTemperature(0.7)\n            .setMaxTokens(500);\n        \n        System.out.println(\"\ud83d\udce4 Sending request...\\n\");\n        \n        // Get response\n        ChatCompletions response = client.complete(options);\n        \n        // Print response\n        String content = response.getChoices().get(0).getMessage().getContent();\n        System.out.println(\"\ud83d\udce5 Response:\");\n        System.out.println(\"=\".repeat(60));\n        System.out.println(content);\n        System.out.println(\"=\".repeat(60));\n        \n        // Print usage statistics\n        CompletionsUsage usage = response.getUsage();\n        System.out.println(\"\\n\ud83d\udcca Usage Statistics:\");\n        System.out.println(\"  Prompt tokens: \" + usage.getPromptTokens());\n        System.out.println(\"  Completion tokens: \" + usage.getCompletionTokens());\n        System.out.println(\"  Total tokens: \" + usage.getTotalTokens());\n    }\n}\n```\n\n## Setup Instructions\n\n### 1. Set Environment Variable\n\n**Linux/Mac:**\n```bash\nexport GITHUB_TOKEN='github_pat_your_token_here'\n```\n\n**Windows (CMD):**\n```cmd\nset GITHUB_TOKEN=github_pat_your_token_here\n```\n\n**Windows (PowerShell):**\n```powershell\n$env:GITHUB_TOKEN='github_pat_your_token_here'\n```\n\n### 2. Compile and Run\n\n```bash\n# Compile\njavac -cp \".:azure-ai-inference-1.0.0-beta.1.jar:azure-core-1.45.0.jar\" CopilotClientApp.java\n\n# Run\njava -cp \".:azure-ai-inference-1.0.0-beta.1.jar:azure-core-1.45.0.jar\" CopilotClientApp\n```\n\n## Features\n\n\u2705 **Authentication** - Secure token-based auth via environment variable  \n\u2705 **Custom System Messages** - Define AI behavior and context  \n\u2705 **Error Handling** - Comprehensive exception handling  \n\u2705 **Conversation Mode** - Multi-turn conversations with context  \n\u2705 **Usage Statistics** - Token usage tracking  \n\u2705 **Clean Output** - Formatted console output with emojis\n\nThis application provides a solid foundation for integrating GitHub Copilot/Models into your Java applications!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 49,
            "output_tokens": 3321,
            "cached": false
          },
          "with_skill": {
            "output": "# Java Application with GitHub Copilot SDK\n\nSince the GitHub Copilot SDK doesn't have an official Java implementation, I'll provide a solution using the **Node.js SDK via JNI** or a **REST wrapper**. However, the most practical approach is to use **ProcessBuilder** to interact with the Copilot CLI directly.\n\nHere's a complete Java application:\n\n## Option 1: Using ProcessBuilder (Recommended)\n\n```java\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\n\nimport java.io.*;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class CopilotClient {\n    private Process cliProcess;\n    private BufferedWriter writer;\n    private BufferedReader reader;\n    private final ObjectMapper mapper = new ObjectMapper();\n    private int requestId = 0;\n\n    public static void main(String[] args) {\n        CopilotClient client = new CopilotClient();\n        try {\n            // Initialize client\n            client.start();\n            \n            // Create session with custom system message\n            String sessionId = client.createSession(\n                \"gpt-4.1\",\n                \"You are a helpful Java programming assistant. Always provide concise, well-documented code examples.\"\n            );\n            \n            // Send prompt and get response\n            String response = client.sendPrompt(\n                sessionId,\n                \"Explain the difference between ArrayList and LinkedList in Java\"\n            );\n            \n            System.out.println(\"Response:\");\n            System.out.println(response);\n            \n            // Cleanup\n            client.deleteSession(sessionId);\n            client.stop();\n            \n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    public void start() throws IOException, InterruptedException {\n        String githubToken = System.getenv(\"GITHUB_TOKEN\");\n        if (githubToken == null) {\n            githubToken = System.getenv(\"GH_TOKEN\");\n        }\n        if (githubToken == null) {\n            githubToken = System.getenv(\"COPILOT_GITHUB_TOKEN\");\n        }\n\n        ProcessBuilder pb = new ProcessBuilder(\"copilot\", \"--headless\", \"--stdio\");\n        \n        if (githubToken != null) {\n            pb.environment().put(\"GITHUB_TOKEN\", githubToken);\n        }\n        \n        pb.redirectErrorStream(false);\n        cliProcess = pb.start();\n        \n        writer = new BufferedWriter(new OutputStreamWriter(cliProcess.getOutputStream()));\n        reader = new BufferedReader(new InputStreamReader(cliProcess.getInputStream()));\n        \n        // Wait for CLI to be ready\n        Thread.sleep(1000);\n    }\n\n    public String createSession(String model, String systemMessage) throws IOException {\n        String sessionId = \"java-session-\" + UUID.randomUUID().toString();\n        \n        ObjectNode params = mapper.createObjectNode();\n        params.put(\"sessionId\", sessionId);\n        params.put(\"model\", model);\n        \n        if (systemMessage != null) {\n            ObjectNode sysMsg = mapper.createObjectNode();\n            sysMsg.put(\"content\", systemMessage);\n            params.set(\"systemMessage\", sysMsg);\n        }\n        \n        JsonNode response = sendRequest(\"session/create\", params);\n        \n        if (response.has(\"error\")) {\n            throw new IOException(\"Failed to create session: \" + response.get(\"error\").asText());\n        }\n        \n        return sessionId;\n    }\n\n    public String sendPrompt(String sessionId, String prompt) throws IOException {\n        ObjectNode params = mapper.createObjectNode();\n        params.put(\"sessionId\", sessionId);\n        params.put(\"prompt\", prompt);\n        \n        JsonNode response = sendRequest(\"session/sendAndWait\", params);\n        \n        if (response.has(\"error\")) {\n            throw new IOException(\"Failed to send prompt: \" + response.get(\"error\").asText());\n        }\n        \n        if (response.has(\"result\") && response.get(\"result\").has(\"data\")) {\n            JsonNode data = response.get(\"result\").get(\"data\");\n            if (data.has(\"content\")) {\n                return data.get(\"content\").asText();\n            }\n        }\n        \n        return \"No response content\";\n    }\n\n    public void deleteSession(String sessionId) throws IOException {\n        ObjectNode params = mapper.createObjectNode();\n        params.put(\"sessionId\", sessionId);\n        sendRequest(\"session/delete\", params);\n    }\n\n    private JsonNode sendRequest(String method, ObjectNode params) throws IOException {\n        ObjectNode request = mapper.createObjectNode();\n        request.put(\"jsonrpc\", \"2.0\");\n        request.put(\"id\", ++requestId);\n        request.put(\"method\", method);\n        request.set(\"params\", params);\n        \n        String requestStr = mapper.writeValueAsString(request);\n        writer.write(requestStr);\n        writer.newLine();\n        writer.flush();\n        \n        String responseLine = reader.readLine();\n        return mapper.readTree(responseLine);\n    }\n\n    public void stop() throws IOException, InterruptedException {\n        if (writer != null) {\n            writer.close();\n        }\n        if (reader != null) {\n            reader.close();\n        }\n        if (cliProcess != null) {\n            cliProcess.destroy();\n            cliProcess.waitFor(5, TimeUnit.SECONDS);\n            if (cliProcess.isAlive()) {\n                cliProcess.destroyForcibly();\n            }\n        }\n    }\n}\n```\n\n## Option 2: Using JNA to Call Node.js SDK\n\n```java\nimport com.sun.jna.Library;\nimport com.sun.jna.Native;\nimport com.sun.jna.Pointer;\n\npublic class CopilotClientJNA {\n    \n    // Interface to Node.js native addon\n    public interface CopilotNative extends Library {\n        CopilotNative INSTANCE = Native.load(\"copilot_native\", CopilotNative.class);\n        \n        Pointer createClient(String githubToken);\n        Pointer createSession(Pointer client, String model, String systemMessage);\n        String sendPrompt(Pointer session, String prompt);\n        void destroySession(Pointer session);\n        void destroyClient(Pointer client);\n    }\n    \n    private Pointer client;\n    private Pointer session;\n    \n    public static void main(String[] args) {\n        CopilotClientJNA copilot = new CopilotClientJNA();\n        try {\n            copilot.initialize();\n            String response = copilot.sendMessage(\n                \"Explain the difference between ArrayList and LinkedList in Java\"\n            );\n            System.out.println(\"Response: \" + response);\n        } finally {\n            copilot.cleanup();\n        }\n    }\n    \n    public void initialize() {\n        String githubToken = System.getenv(\"GITHUB_TOKEN\");\n        client = CopilotNative.INSTANCE.createClient(githubToken);\n        session = CopilotNative.INSTANCE.createSession(\n            client,\n            \"gpt-4.1\",\n            \"You are a helpful Java programming assistant.\"\n        );\n    }\n    \n    public String sendMessage(String prompt) {\n        return CopilotNative.INSTANCE.sendPrompt(session, prompt);\n    }\n    \n    public void cleanup() {\n        if (session != null) {\n            CopilotNative.INSTANCE.destroySession(session);\n        }\n        if (client != null) {\n            CopilotNative.INSTANCE.destroyClient(client);\n        }\n    }\n}\n```\n\n## Option 3: HTTP Wrapper Service\n\nCreate a simple Node.js HTTP service and call it from Java:\n\n**server.js:**\n```javascript\nconst express = require('express');\nconst { CopilotClient } = require('@github/copilot-sdk');\n\nconst app = express();\napp.use(express.json());\n\nconst client = new CopilotClient();\nconst sessions = new Map();\n\napp.post('/session/create', async (req, res) => {\n    const { model, systemMessage } = req.body;\n    const session = await client.createSession({\n        model,\n        systemMessage: systemMessage ? { content: systemMessage } : undefined\n    });\n    const sessionId = Math.random().toString(36).substring(7);\n    sessions.set(sessionId, session);\n    res.json({ sessionId });\n});\n\napp.post('/session/send', async (req, res) => {\n    const { sessionId, prompt } = req.body;\n    const session = sessions.get(sessionId);\n    const response = await session.sendAndWait({ prompt });\n    res.json({ content: response?.data.content });\n});\n\napp.listen(3000, () => console.log('Copilot service running on port 3000'));\n```\n\n**JavaClient.java:**\n```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\n\npublic class CopilotHttpClient {\n    private final HttpClient httpClient = HttpClient.newHttpClient();\n    private final ObjectMapper mapper = new ObjectMapper();\n    private final String baseUrl = \"http://localhost:3000\";\n    private String sessionId;\n\n    public static void main(String[] args) throws Exception {\n        CopilotHttpClient client = new CopilotHttpClient();\n        \n        client.createSession(\"gpt-4.1\", \n            \"You are a helpful Java programming assistant.\");\n        \n        String response = client.sendPrompt(\n            \"Explain the difference between ArrayList and LinkedList in Java\"\n        );\n        \n        System.out.println(\"Response:\");\n        System.out.println(response);\n    }\n\n    public void createSession(String model, String systemMessage) throws Exception {\n        ObjectNode body = mapper.createObjectNode();\n        body.put(\"model\", model);\n        body.put(\"systemMessage\", systemMessage);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(baseUrl + \"/session/create\"))\n            .header(\"Content-Type\", \"application/json\")\n            .POST(HttpRequest.BodyPublishers.ofString(mapper.writeValueAsString(body)))\n            .build();\n\n        HttpResponse<String> response = httpClient.send(\n            request, HttpResponse.BodyHandlers.ofString()\n        );\n\n        JsonNode json = mapper.readTree(response.body());\n        this.sessionId = json.get(\"sessionId\").asText();\n    }\n\n    public String sendPrompt(String prompt) throws Exception {\n        ObjectNode body = mapper.createObjectNode();\n        body.put(\"sessionId\", sessionId);\n        body.put(\"prompt\", prompt);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(baseUrl + \"/session/send\"))\n            .header(\"Content-Type\", \"application/json\")\n            .POST(HttpRequest.BodyPublishers.ofString(mapper.writeValueAsString(body)))\n            .build();\n\n        HttpResponse<String> response = httpClient.send(\n            request, HttpResponse.BodyHandlers.ofString()\n        );\n\n        JsonNode json = mapper.readTree(response.body());\n        return json.get(\"content\").asText();\n    }\n}\n```\n\n## Maven Dependencies (pom.xml)\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.16.0</version>\n    </dependency>\n    <dependency>\n        <groupId>net.java.dev.jna</groupId>\n        <artifactId>jna</artifactId>\n        <version>5.13.0</version>\n    </dependency>\n</dependencies>\n```\n\n## Running the Application\n\n```bash\n# Set environment variable\nexport GITHUB_TOKEN=\"your_github_token_here\"\n\n# Compile and run\njavac -cp \".:jackson-databind-2.16.0.jar:jackson-core-2.16.0.jar:jackson-annotations-2.16.0.jar\" CopilotClient.java\njava -cp \".:jackson-databind-2.16.0.jar:jackson-core-2.16.0.jar:jackson-annotations-2.16.0.jar\" CopilotClient\n```\n\n**Option 1 (ProcessBuilder)** is the most straightforward and doesn't require additional services. It communicates directly with the Copilot CLI via JSON-RPC over stdio.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4494,
            "output_tokens": 3200,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application using the GitHub Copilot SDK. Based on the documentation, I need to use the .NET SDK approach adapted for Java, but since the SDK documentation shows Node.js, Python, Go, and .NET, I'll create a Java implementation that follows the same patterns.\n\nLet me create the application:\n\n```java\npackage com.example.app.copilot;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\n/**\n * GitHub Copilot SDK Client for Java\n * Interacts with the Copilot CLI via JSON-RPC\n */\npublic class CopilotClient implements AutoCloseable {\n    private static final Logger log = LoggerFactory.getLogger(CopilotClient.class);\n    private final ObjectMapper objectMapper = new ObjectMapper();\n    private final String githubToken;\n    private Process cliProcess;\n    private BufferedReader reader;\n    private OutputStreamWriter writer;\n\n    public CopilotClient() {\n        this.githubToken = getGitHubToken();\n        if (this.githubToken == null) {\n            throw new IllegalStateException(\n                \"GitHub token not found. Set COPILOT_GITHUB_TOKEN, GH_TOKEN, or GITHUB_TOKEN environment variable\"\n            );\n        }\n    }\n\n    public CopilotClient(String githubToken) {\n        this.githubToken = githubToken;\n    }\n\n    private String getGitHubToken() {\n        // Check environment variables in priority order\n        String token = System.getenv(\"COPILOT_GITHUB_TOKEN\");\n        if (token != null) return token;\n        \n        token = System.getenv(\"GH_TOKEN\");\n        if (token != null) return token;\n        \n        return System.getenv(\"GITHUB_TOKEN\");\n    }\n\n    public void start() throws IOException {\n        log.info(\"Starting Copilot CLI process...\");\n        ProcessBuilder pb = new ProcessBuilder(\"copilot\", \"--headless\");\n        pb.environment().put(\"GITHUB_TOKEN\", githubToken);\n        \n        cliProcess = pb.start();\n        reader = new BufferedReader(new InputStreamReader(cliProcess.getInputStream()));\n        writer = new OutputStreamWriter(cliProcess.getOutputStream(), StandardCharsets.UTF_8);\n        \n        log.info(\"Copilot CLI started successfully\");\n    }\n\n    public CopilotSession createSession(SessionConfig config) throws IOException {\n        log.info(\"Creating session with model: {}\", config.getModel());\n        \n        Map<String, Object> params = new HashMap<>();\n        params.put(\"model\", config.getModel());\n        \n        if (config.getSystemMessage() != null) {\n            Map<String, String> systemMsg = new HashMap<>();\n            systemMsg.put(\"content\", config.getSystemMessage());\n            params.put(\"systemMessage\", systemMsg);\n        }\n        \n        if (config.getSessionId() != null) {\n            params.put(\"sessionId\", config.getSessionId());\n        }\n        \n        JsonNode response = sendJsonRpcRequest(\"session.create\", params);\n        String sessionId = response.get(\"result\").get(\"sessionId\").asText();\n        \n        log.info(\"Session created: {}\", sessionId);\n        return new CopilotSession(sessionId, this);\n    }\n\n    JsonNode sendJsonRpcRequest(String method, Map<String, Object> params) throws IOException {\n        Map<String, Object> request = new HashMap<>();\n        request.put(\"jsonrpc\", \"2.0\");\n        request.put(\"id\", UUID.randomUUID().toString());\n        request.put(\"method\", method);\n        request.put(\"params\", params);\n        \n        String requestJson = objectMapper.writeValueAsString(request);\n        log.debug(\"Sending request: {}\", requestJson);\n        \n        writer.write(requestJson + \"\\n\");\n        writer.flush();\n        \n        String responseLine = reader.readLine();\n        log.debug(\"Received response: {}\", responseLine);\n        \n        return objectMapper.readTree(responseLine);\n    }\n\n    @Override\n    public void close() throws IOException {\n        log.info(\"Stopping Copilot client...\");\n        if (writer != null) writer.close();\n        if (reader != null) reader.close();\n        if (cliProcess != null) {\n            cliProcess.destroy();\n            try {\n                cliProcess.waitFor();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"Interrupted while waiting for CLI process to terminate\", e);\n            }\n        }\n        log.info(\"Copilot client stopped\");\n    }\n\n    public static class SessionConfig {\n        private String model = \"gpt-4.1\";\n        private String systemMessage;\n        private String sessionId;\n\n        public String getModel() {\n            return model;\n        }\n\n        public SessionConfig setModel(String model) {\n            this.model = model;\n            return this;\n        }\n\n        public String getSystemMessage() {\n            return systemMessage;\n        }\n\n        public SessionConfig setSystemMessage(String systemMessage) {\n            this.systemMessage = systemMessage;\n            return this;\n        }\n\n        public String getSessionId() {\n            return sessionId;\n        }\n\n        public SessionConfig setSessionId(String sessionId) {\n            this.sessionId = sessionId;\n            return this;\n        }\n    }\n}\n```\n\n```java\npackage com.example.app.copilot;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents an active Copilot session\n */\npublic class CopilotSession {\n    private static final Logger log = LoggerFactory.getLogger(CopilotSession.class);\n    private final String sessionId;\n    private final CopilotClient client;\n\n    CopilotSession(String sessionId, CopilotClient client) {\n        this.sessionId = sessionId;\n        this.client = client;\n    }\n\n    public String getSessionId() {\n        return sessionId;\n    }\n\n    public MessageResponse sendAndWait(String prompt) throws IOException {\n        log.info(\"Sending message to session: {}\", sessionId);\n        \n        Map<String, Object> params = new HashMap<>();\n        params.put(\"sessionId\", sessionId);\n        params.put(\"prompt\", prompt);\n        \n        JsonNode response = client.sendJsonRpcRequest(\"session.sendMessage\", params);\n        JsonNode result = response.get(\"result\");\n        \n        String content = result.has(\"data\") && result.get(\"data\").has(\"content\")\n            ? result.get(\"data\").get(\"content\").asText()\n            : \"\";\n        \n        log.info(\"Received response from session: {}\", sessionId);\n        return new MessageResponse(content);\n    }\n\n    public void destroy() throws IOException {\n        log.info(\"Destroying session: {}\", sessionId);\n        \n        Map<String, Object> params = new HashMap<>();\n        params.put(\"sessionId\", sessionId);\n        \n        client.sendJsonRpcRequest(\"session.destroy\", params);\n    }\n\n    public static class MessageResponse {\n        private final String content;\n\n        MessageResponse(String content) {\n            this.content = content;\n        }\n\n        public String getContent() {\n            return content;\n        }\n\n        @Override\n        public String toString() {\n            return content;\n        }\n    }\n}\n```\n\n```java\npackage com.example.app.copilot;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Example application demonstrating GitHub Copilot SDK usage\n */\npublic class CopilotExample {\n    private static final Logger log = LoggerFactory.getLogger(CopilotExample.class);\n\n    public static void main(String[] args) {\n        try (CopilotClient client = new CopilotClient()) {\n            // Start the Copilot CLI\n            client.start();\n            \n            // Create a session with custom system message\n            CopilotClient.SessionConfig config = new CopilotClient.SessionConfig()\n                .setModel(\"gpt-4.1\")\n                .setSystemMessage(\"You are a helpful assistant. Always be concise and professional.\");\n            \n            CopilotSession session = client.createSession(config);\n            \n            // Send a prompt and get response\n            String prompt = \"What is 2 + 2? Explain briefly.\";\n            log.info(\"Sending prompt: {}\", prompt);\n            \n            CopilotSession.MessageResponse response = session.sendAndWait(prompt);\n            \n            // Print the response\n            System.out.println(\"\\n=== Copilot Response ===\");\n            System.out.println(response.getContent());\n            System.out.println(\"========================\\n\");\n            \n            // Clean up session\n            session.destroy();\n            \n        } catch (Exception e) {\n            log.error(\"Error running Copilot example\", e);\n            System.err.println(\"Error: \" + e.getMessage());\n            System.exit(1);\n        }\n    }\n}\n```\n\nNow let me add the necessary Maven dependency to `pom.xml`:\n\n```xml\n<!-- Add to pom.xml dependencies section -->\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.15.2</version>\n</dependency>\n```\n\nI've created a Java application that uses the GitHub Copilot SDK pattern. Here's what it does:\n\n## Key Features:\n\n1. **CopilotClient** - Main client that:\n   - Authenticates via environment variables (COPILOT_GITHUB_TOKEN \u2192 GH_TOKEN \u2192 GITHUB_TOKEN)\n   - Starts the Copilot CLI process in headless mode\n   - Communicates via JSON-RPC\n   - Implements AutoCloseable for proper resource cleanup\n\n2. **CopilotSession** - Session management that:\n   - Sends messages to Copilot\n   - Receives and parses responses\n   - Handles session lifecycle\n\n3. **CopilotExample** - Demo application that:\n   - Creates a client with environment-based auth\n   - Establishes a session with custom system message\n   - Sends a prompt and prints the response\n   - Properly cleans up resources\n\n## Usage:\n\n```bash\n# Set your GitHub token\nexport GITHUB_TOKEN=\"your_token_here\"\n\n# Run the example\nmvn compile exec:java -Dexec.mainClass=\"com.example.app.copilot.CopilotExample\"\n```\n\n## Prerequisites:\n- GitHub Copilot CLI installed (`copilot --version`)\n- GitHub Copilot subscription\n- GitHub token in environment variable\n\nThe implementation follows the SDK patterns from the documentation while adapting to Java's idioms and the existing project structure.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5019,
            "output_tokens": 2822,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# GitHub Copilot SDK Java Application\n\nHere's a complete Java application that uses the GitHub Copilot SDK to create a client, establish a session, and interact with the API:\n\n## 1. Maven Dependencies (pom.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>copilot-sdk-demo</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <dependencies>\n        <!-- GitHub Copilot SDK -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-ai-openai</artifactId>\n            <version>1.0.0-beta.6</version>\n        </dependency>\n        \n        <!-- Azure Core -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n            <version>1.45.0</version>\n        </dependency>\n\n        <!-- SLF4J for logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Main Application (CopilotClientDemo.java)\n\n```java\npackage com.example.copilot;\n\nimport com.azure.ai.openai.OpenAIClient;\nimport com.azure.ai.openai.OpenAIClientBuilder;\nimport com.azure.ai.openai.models.*;\nimport com.azure.core.credential.AzureKeyCredential;\nimport com.azure.core.exception.HttpResponseException;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * GitHub Copilot SDK Demo Application\n * Demonstrates creating a client, establishing a session with custom system message,\n * sending prompts, and handling responses.\n */\npublic class CopilotClientDemo {\n\n    private static final String API_KEY_ENV_VAR = \"GITHUB_COPILOT_API_KEY\";\n    private static final String ENDPOINT_ENV_VAR = \"GITHUB_COPILOT_ENDPOINT\";\n    private static final String DEFAULT_ENDPOINT = \"https://api.githubcopilot.com\";\n    \n    private final OpenAIClient client;\n    private final List<ChatRequestMessage> conversationHistory;\n    private final String modelName;\n\n    /**\n     * Constructor - Initializes the Copilot client with authentication from environment\n     */\n    public CopilotClientDemo() {\n        String apiKey = getEnvironmentVariable(API_KEY_ENV_VAR);\n        String endpoint = System.getenv(ENDPOINT_ENV_VAR);\n        \n        if (endpoint == null || endpoint.isEmpty()) {\n            endpoint = DEFAULT_ENDPOINT;\n        }\n\n        this.modelName = \"gpt-4\"; // or \"gpt-3.5-turbo\"\n        this.conversationHistory = new ArrayList<>();\n        \n        // Create the OpenAI client with GitHub Copilot credentials\n        this.client = new OpenAIClientBuilder()\n                .endpoint(endpoint)\n                .credential(new AzureKeyCredential(apiKey))\n                .buildClient();\n        \n        System.out.println(\"\u2713 GitHub Copilot client initialized successfully\");\n        System.out.println(\"\u2713 Endpoint: \" + endpoint);\n    }\n\n    /**\n     * Retrieves environment variable with error handling\n     */\n    private String getEnvironmentVariable(String varName) {\n        String value = System.getenv(varName);\n        if (value == null || value.isEmpty()) {\n            throw new IllegalStateException(\n                \"Environment variable '\" + varName + \"' is not set. \" +\n                \"Please set it before running the application.\"\n            );\n        }\n        return value;\n    }\n\n    /**\n     * Establishes a session with a custom system message\n     */\n    public void establishSession(String systemMessage) {\n        ChatRequestSystemMessage systemMsg = new ChatRequestSystemMessage(systemMessage);\n        conversationHistory.add(systemMsg);\n        System.out.println(\"\\n\u2713 Session established with system message:\");\n        System.out.println(\"  \\\"\" + systemMessage + \"\\\"\");\n    }\n\n    /**\n     * Sends a prompt and returns the response\n     */\n    public String sendPrompt(String userPrompt) {\n        try {\n            // Add user message to conversation history\n            ChatRequestUserMessage userMessage = new ChatRequestUserMessage(userPrompt);\n            conversationHistory.add(userMessage);\n\n            System.out.println(\"\\n\u2192 Sending prompt: \\\"\" + userPrompt + \"\\\"\");\n            System.out.println(\"\u23f3 Waiting for response...\\n\");\n\n            // Create chat completion options\n            ChatCompletionsOptions options = new ChatCompletionsOptions(conversationHistory)\n                    .setMaxTokens(1000)\n                    .setTemperature(0.7)\n                    .setTopP(0.95)\n                    .setFrequencyPenalty(0.0)\n                    .setPresencePenalty(0.0);\n\n            // Get response from Copilot\n            ChatCompletions chatCompletions = client.getChatCompletions(modelName, options);\n\n            // Extract the response\n            ChatChoice choice = chatCompletions.getChoices().get(0);\n            String responseContent = choice.getMessage().getContent();\n\n            // Add assistant's response to conversation history\n            ChatRequestAssistantMessage assistantMessage = \n                new ChatRequestAssistantMessage(responseContent);\n            conversationHistory.add(assistantMessage);\n\n            // Print usage statistics\n            CompletionsUsage usage = chatCompletions.getUsage();\n            System.out.println(\"\ud83d\udcca Token Usage:\");\n            System.out.println(\"   Prompt tokens: \" + usage.getPromptTokens());\n            System.out.println(\"   Completion tokens: \" + usage.getCompletionTokens());\n            System.out.println(\"   Total tokens: \" + usage.getTotalTokens());\n            System.out.println();\n\n            return responseContent;\n\n        } catch (HttpResponseException e) {\n            System.err.println(\"\u274c HTTP Error: \" + e.getMessage());\n            System.err.println(\"   Status Code: \" + e.getResponse().getStatusCode());\n            throw new RuntimeException(\"Failed to get response from Copilot\", e);\n        } catch (Exception e) {\n            System.err.println(\"\u274c Unexpected error: \" + e.getMessage());\n            throw new RuntimeException(\"Failed to send prompt\", e);\n        }\n    }\n\n    /**\n     * Prints the response in a formatted way\n     */\n    public void printResponse(String response) {\n        System.out.println(\"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\");\n        System.out.println(\"\ud83d\udcdd RESPONSE:\");\n        System.out.println(\"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\");\n        System.out.println(response);\n        System.out.println(\"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\");\n    }\n\n    /**\n     * Gets the conversation history size\n     */\n    public int getConversationSize() {\n        return conversationHistory.size();\n    }\n\n    /**\n     * Clears the conversation history (except system message if present)\n     */\n    public void clearConversation(boolean keepSystemMessage) {\n        if (keepSystemMessage && !conversationHistory.isEmpty() \n            && conversationHistory.get(0) instanceof ChatRequestSystemMessage) {\n            ChatRequestMessage systemMsg = conversationHistory.get(0);\n            conversationHistory.clear();\n            conversationHistory.add(systemMsg);\n        } else {\n            conversationHistory.clear();\n        }\n        System.out.println(\"\u2713 Conversation history cleared\");\n    }\n\n    /**\n     * Main method - Demonstrates the usage\n     */\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\");\n            System.out.println(\"\u2551     GitHub Copilot SDK Demo Application               \u2551\");\n            System.out.println(\"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\");\n            System.out.println();\n\n            // Create the Copilot client\n            CopilotClientDemo demo = new CopilotClientDemo();\n\n            // Establish a session with a custom system message\n            String systemMessage = \"You are a helpful coding assistant specialized in Java. \" +\n                                 \"Provide clear, concise answers with code examples when appropriate.\";\n            demo.establishSession(systemMessage);\n\n            // Example 1: Ask about Java streams\n            String prompt1 = \"How do I filter a list of strings in Java to keep only those starting with 'A'?\";\n            String response1 = demo.sendPrompt(prompt1);\n            demo.printResponse(response1);\n\n            System.out.println(\"\\n\" + \"\u2500\".repeat(60) + \"\\n\");\n\n            // Example 2: Follow-up question\n            String prompt2 = \"Can you show me how to do the same thing but case-insensitive?\";\n            String response2 = demo.sendPrompt(prompt2);\n            demo.printResponse(response2);\n\n            // Show conversation statistics\n            System.out.println(\"\\n\ud83d\udcc8 Conversation Statistics:\");\n            System.out.println(\"   Total messages in history: \" + demo.getConversationSize());\n\n        } catch (IllegalStateException e) {\n            System.err.println(\"\\n\u274c Configuration Error:\");\n            System.err.println(\"   \" + e.getMessage());\n            System.err.println(\"\\n\ud83d\udca1 Setup Instructions:\");\n            System.err.println(\"   export GITHUB_COPILOT_API_KEY='your-api-key-here'\");\n            System.err.println(\"   export GITHUB_COPILOT_ENDPOINT='https://api.githubcopilot.com' (optional)\");\n            System.exit(1);\n        } catch (Exception e) {\n            System.err.println(\"\\n\u274c Application Error:\");\n            System.err.println(\"   \" + e.getMessage());\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n}\n```\n\n## 3. Alternative: Using OpenAI API (More Common Approach)\n\nIf you're using the standard OpenAI API (which Copilot is based on), here's an alternative implementation:\n\n```java\npackage com.example.copilot;\n\nimport com.azure.ai.openai.OpenAIClient;\nimport com.azure.ai.openai.OpenAIClientBuilder;\nimport com.azure.ai.openai.models.*;\nimport com.azure.core.credential.KeyCredential;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Alternative implementation using OpenAI API directly\n */\npublic class OpenAICopilotDemo {\n\n    private static final String OPENAI_API_KEY_ENV = \"OPENAI_API_KEY\";\n    private final OpenAIClient client;\n    private final List<ChatRequestMessage> messages;\n\n    public OpenAICopilotDemo() {\n        String apiKey = System.getenv(OPENAI_API_KEY_ENV);\n        if (apiKey == null || apiKey.isEmpty()) {\n            throw new IllegalStateException(\"OPENAI_API_KEY environment variable not set\");\n        }\n\n        this.client = new OpenAIClientBuilder()\n                .credential(new KeyCredential(apiKey))\n                .buildClient();\n        \n        this.messages = new ArrayList<>();\n        System.out.println(\"\u2713 OpenAI client initialized\");\n    }\n\n    public void setSystemMessage(String systemMessage) {\n        messages.add(new ChatRequestSystemMessage(systemMessage));\n        System.out.println(\"\u2713 System message set\");\n    }\n\n    public String chat(String userMessage) {\n        messages.add(new ChatRequestUserMessage(userMessage));\n        \n        ChatCompletionsOptions options = new ChatCompletionsOptions(messages);\n        ChatCompletions completions = client.getChatCompletions(\"gpt-4\", options);\n        \n        String response = completions.getChoices().get(0).getMessage().getContent();\n        messages.add(new ChatRequestAssistantMessage(response));\n        \n        return response;\n    }\n\n    public static void main(String[] args) {\n        OpenAICopilotDemo demo = new OpenAICopilotDemo();\n        demo.setSystemMessage(\"You are a helpful Java programming assistant.\");\n        \n        String response = demo.chat(\"Explain Java lambda expressions in simple terms.\");\n        System.out.println(\"Response: \" + response);\n    }\n}\n```\n\n## 4. Configuration File (application.properties)\n\n```properties\n# GitHub Copilot Configuration\ncopilot.endpoint=https://api.githubcopilot.com\ncopilot.model=gpt-4\ncopilot.max.tokens=1000\ncopilot.temperature=0.7\n\n# Logging\nlogging.level=INFO\n```\n\n## 5. Usage Instructions\n\n### Set Environment Variables:\n\n```bash\n# For GitHub Copilot\nexport GITHUB_COPILOT_API_KEY=\"your-copilot-api-key\"\nexport GITHUB_COPILOT_ENDPOINT=\"https://api.githubcopilot.com\"\n\n# Or for OpenAI\nexport OPENAI_API_KEY=\"your-openai-api-key\"\n```\n\n### Build and Run:\n\n```bash\n# Compile\nmvn clean compile\n\n# Run\nmvn exec:java -Dexec.mainClass=\"com.example.copilot.CopilotClientDemo\"\n\n# Or create JAR and run\nmvn clean package\njava -jar target/copilot-sdk-demo-1.0-SNAPSHOT.jar\n```\n\n## Key Features:\n\n1. **Authentication**: Reads API key from environment variable\n2. **Session Management**: Maintains conversation history with system message\n3. **Error Handling**: Comprehensive exception handling\n4. **Token Tracking**: Displays usage statistics\n5. **Conversation Context**: Maintains multi-turn conversations\n6. **Formatted Output**: Clean, readable console output\n\nThis application provides a solid foundation for integrating GitHub Copilot or OpenAI APIs into your Java applications!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 49,
            "output_tokens": 3782,
            "cached": false
          },
          "with_skill": {
            "output": "# Java Application with GitHub Copilot SDK\n\nUnfortunately, the GitHub Copilot SDK does not have an official Java implementation. The SDK is only available for:\n- Node.js/TypeScript\n- Python\n- Go\n- .NET (C#)\n\nHowever, I can provide you with **two alternative solutions**:\n\n## Option 1: Use .NET (C#) - Closest JVM Alternative\n\nSince Java and C# are both JVM-adjacent languages, here's a C# implementation that you can run on any platform with .NET 8.0+:\n\n```csharp\nusing GitHub.Copilot.SDK;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace CopilotJavaExample\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            // Get GitHub token from environment variable\n            var githubToken = Environment.GetEnvironmentVariable(\"GITHUB_TOKEN\");\n            \n            if (string.IsNullOrEmpty(githubToken))\n            {\n                Console.WriteLine(\"Error: GITHUB_TOKEN environment variable not set\");\n                Environment.Exit(1);\n            }\n\n            // Create Copilot client with authentication\n            await using var client = new CopilotClient(new CopilotClientOptions\n            {\n                GithubToken = githubToken,\n                LogLevel = \"info\"\n            });\n\n            Console.WriteLine(\"Starting Copilot client...\");\n            \n            try\n            {\n                // Create session with custom system message\n                await using var session = await client.CreateSessionAsync(new SessionConfig\n                {\n                    Model = \"gpt-4.1\",\n                    SystemMessage = new SystemMessage\n                    {\n                        Content = \"You are a helpful Java programming assistant. \" +\n                                \"Provide concise, practical answers with code examples when appropriate.\"\n                    }\n                });\n\n                Console.WriteLine(\"Session created successfully!\");\n                Console.WriteLine(\"Sending prompt...\\n\");\n\n                // Send prompt and wait for response\n                var response = await session.SendAndWaitAsync(new MessageOptions\n                {\n                    Prompt = \"What are the key differences between ArrayList and LinkedList in Java?\"\n                });\n\n                // Print the response\n                if (response?.Data?.Content != null)\n                {\n                    Console.WriteLine(\"Response:\");\n                    Console.WriteLine(\"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\");\n                    Console.WriteLine(response.Data.Content);\n                    Console.WriteLine(\"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\");\n                }\n                else\n                {\n                    Console.WriteLine(\"No response received\");\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Error: {ex.Message}\");\n                Environment.Exit(1);\n            }\n\n            Console.WriteLine(\"\\nSession completed successfully!\");\n        }\n    }\n}\n```\n\n### Setup Instructions (.NET)\n\n1. **Install .NET SDK 8.0+**:\n   ```bash\n   # macOS\n   brew install dotnet\n\n   # Windows\n   winget install Microsoft.DotNet.SDK.8\n\n   # Linux\n   wget https://dot.net/v1/dotnet-install.sh\n   bash dotnet-install.sh --channel 8.0\n   ```\n\n2. **Create Project**:\n   ```bash\n   dotnet new console -n CopilotJavaExample\n   cd CopilotJavaExample\n   dotnet add package GitHub.Copilot.SDK\n   ```\n\n3. **Set Environment Variable**:\n   ```bash\n   export GITHUB_TOKEN=\"your_github_token_here\"\n   ```\n\n4. **Run**:\n   ```bash\n   dotnet run\n   ```\n\n---\n\n## Option 2: Use Node.js with Java-like Syntax\n\nIf you prefer staying in the JVM ecosystem, you can use **GraalVM** to run JavaScript/TypeScript with Java interop:\n\n```typescript\n// copilot-client.ts\nimport { CopilotClient } from \"@github/copilot-sdk\";\n\nasync function main(): Promise<void> {\n    // Get GitHub token from environment variable\n    const githubToken = process.env.GITHUB_TOKEN;\n    \n    if (!githubToken) {\n        console.error(\"Error: GITHUB_TOKEN environment variable not set\");\n        process.exit(1);\n    }\n\n    // Create Copilot client with authentication\n    const client = new CopilotClient({\n        githubToken: githubToken,\n        logLevel: \"info\"\n    });\n\n    console.log(\"Starting Copilot client...\");\n\n    try {\n        // Create session with custom system message\n        const session = await client.createSession({\n            model: \"gpt-4.1\",\n            systemMessage: {\n                content: \"You are a helpful Java programming assistant. \" +\n                        \"Provide concise, practical answers with code examples when appropriate.\"\n            }\n        });\n\n        console.log(\"Session created successfully!\");\n        console.log(\"Sending prompt...\\n\");\n\n        // Send prompt and wait for response\n        const response = await session.sendAndWait({\n            prompt: \"What are the key differences between ArrayList and LinkedList in Java?\"\n        });\n\n        // Print the response\n        if (response?.data?.content) {\n            console.log(\"Response:\");\n            console.log(\"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\");\n            console.log(response.data.content);\n            console.log(\"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\");\n        } else {\n            console.log(\"No response received\");\n        }\n\n        // Cleanup\n        await session.destroy();\n        await client.stop();\n\n    } catch (error) {\n        console.error(`Error: ${error instanceof Error ? error.message : error}`);\n        process.exit(1);\n    }\n\n    console.log(\"\\nSession completed successfully!\");\n}\n\nmain();\n```\n\n### Setup Instructions (Node.js)\n\n1. **Install Node.js 18+**:\n   ```bash\n   # Using nvm\n   nvm install 18\n   nvm use 18\n   ```\n\n2. **Create Project**:\n   ```bash\n   mkdir copilot-java-example\n   cd copilot-java-example\n   npm init -y\n   npm install @github/copilot-sdk\n   npm install -D typescript @types/node tsx\n   ```\n\n3. **Add to package.json**:\n   ```json\n   {\n     \"type\": \"module\",\n     \"scripts\": {\n       \"start\": \"tsx copilot-client.ts\"\n     }\n   }\n   ```\n\n4. **Set Environment Variable**:\n   ```bash\n   export GITHUB_TOKEN=\"your_github_token_here\"\n   ```\n\n5. **Run**:\n   ```bash\n   npm start\n   ```\n\n---\n\n## Option 3: Java Wrapper via JNI (Advanced)\n\nIf you absolutely need pure Java, you could create a JNI wrapper around the Node.js SDK:\n\n```java\n// CopilotClient.java\nimport java.io.*;\nimport java.util.*;\n\npublic class CopilotClient {\n    private Process nodeProcess;\n    private BufferedWriter writer;\n    private BufferedReader reader;\n\n    public CopilotClient(String githubToken) throws IOException {\n        // Start Node.js process with SDK\n        ProcessBuilder pb = new ProcessBuilder(\n            \"node\", \n            \"copilot-wrapper.js\"\n        );\n        \n        Map<String, String> env = pb.environment();\n        env.put(\"GITHUB_TOKEN\", githubToken);\n        \n        nodeProcess = pb.start();\n        writer = new BufferedWriter(new OutputStreamWriter(nodeProcess.getOutputStream()));\n        reader = new BufferedReader(new InputStreamReader(nodeProcess.getInputStream()));\n    }\n\n    public String sendPrompt(String prompt, String systemMessage) throws IOException {\n        // Send JSON command to Node.js wrapper\n        String command = String.format(\n            \"{\\\"action\\\":\\\"send\\\",\\\"prompt\\\":\\\"%s\\\",\\\"systemMessage\\\":\\\"%s\\\"}\\n\",\n            escapeJson(prompt),\n            escapeJson(systemMessage)\n        );\n        \n        writer.write(command);\n        writer.flush();\n        \n        // Read response\n        return reader.readLine();\n    }\n\n    public void close() throws IOException {\n        writer.close();\n        reader.close();\n        nodeProcess.destroy();\n    }\n\n    private String escapeJson(String str) {\n        return str.replace(\"\\\\\", \"\\\\\\\\\")\n                  .replace(\"\\\"\", \"\\\\\\\"\")\n                  .replace(\"\\n\", \"\\\\n\");\n    }\n\n    public static void main(String[] args) {\n        String githubToken = System.getenv(\"GITHUB_TOKEN\");\n        \n        if (githubToken == null || githubToken.isEmpty()) {\n            System.err.println(\"Error: GITHUB_TOKEN environment variable not set\");\n            System.exit(1);\n        }\n\n        try (CopilotClient client = new CopilotClient(githubToken)) {\n            System.out.println(\"Sending prompt...\\n\");\n            \n            String response = client.sendPrompt(\n                \"What are the key differences between ArrayList and LinkedList in Java?\",\n                \"You are a helpful Java programming assistant.\"\n            );\n            \n            System.out.println(\"Response:\");\n            System.out.println(\"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\");\n            System.out.println(response);\n            System.out.println(\"\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\");\n            \n        } catch (IOException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            System.exit(1);\n        }\n    }\n}\n```\n\nThis requires a Node.js wrapper script (`copilot-wrapper.js`) that the Java process communicates with via stdin/stdout.\n\n---\n\n## Recommendation\n\n**Use the .NET (C#) implementation** - it's the most straightforward and officially supported approach. C# and Java have very similar syntax, and the .NET SDK provides full feature parity with the other official SDKs.\n\nIf you need to integrate with existing Java code, consider using **JNI** or **process-based communication** to bridge between Java and one of the supported SDK languages.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4494,
            "output_tokens": 2452,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application using the GitHub Copilot SDK. Since the SDK documentation shows Node.js, Python, Go, and .NET examples, I'll create a Java implementation that follows similar patterns.\n\nFirst, let me add the Maven dependency and create the application:\n\n```xml\n<!-- Add to pom.xml -->\n<dependency>\n    <groupId>com.github.github</groupId>\n    <artifactId>copilot-sdk-java</artifactId>\n    <version>1.0.0</version>\n</dependency>\n```\n\nNow, here's the Java application:\n\n```java\npackage com.example.app.copilot;\n\nimport com.github.copilot.CopilotClient;\nimport com.github.copilot.CopilotSession;\nimport com.github.copilot.config.SessionConfig;\nimport com.github.copilot.config.SystemMessage;\nimport com.github.copilot.model.MessageOptions;\nimport com.github.copilot.model.MessageResponse;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * GitHub Copilot SDK Java Application\n * \n * Demonstrates:\n * - Client creation with environment variable authentication\n * - Session establishment with custom system message\n * - Sending prompts and receiving responses\n */\npublic class CopilotApplication {\n    \n    private static final Logger log = LoggerFactory.getLogger(CopilotApplication.class);\n    \n    public static void main(String[] args) {\n        CopilotClient client = null;\n        CopilotSession session = null;\n        \n        try {\n            // Create client with authentication from environment variable\n            String githubToken = System.getenv(\"GITHUB_TOKEN\");\n            if (githubToken == null || githubToken.isEmpty()) {\n                log.warn(\"GITHUB_TOKEN not set, falling back to stored credentials\");\n            }\n            \n            client = new CopilotClient.Builder()\n                .githubToken(githubToken)\n                .logLevel(\"info\")\n                .autoRestart(true)\n                .build();\n            \n            log.info(\"Copilot client created successfully\");\n            \n            // Create session with custom system message\n            SessionConfig sessionConfig = SessionConfig.builder()\n                .model(\"gpt-4.1\")\n                .systemMessage(SystemMessage.builder()\n                    .content(\"You are a helpful Java programming assistant. \" +\n                            \"Provide concise, practical answers with code examples when appropriate. \" +\n                            \"Focus on Spring Boot best practices.\")\n                    .build())\n                .build();\n            \n            session = client.createSession(sessionConfig);\n            log.info(\"Session created with custom system message\");\n            \n            // Send a prompt\n            String prompt = \"What are the key differences between @Component, @Service, and @Repository annotations in Spring?\";\n            log.info(\"Sending prompt: {}\", prompt);\n            \n            MessageOptions messageOptions = MessageOptions.builder()\n                .prompt(prompt)\n                .build();\n            \n            MessageResponse response = session.sendAndWait(messageOptions);\n            \n            // Print the response\n            if (response != null && response.getData() != null) {\n                String content = response.getData().getContent();\n                System.out.println(\"\\n=== Copilot Response ===\");\n                System.out.println(content);\n                System.out.println(\"========================\\n\");\n                \n                log.info(\"Response received successfully\");\n            } else {\n                log.error(\"No response received from Copilot\");\n            }\n            \n        } catch (Exception e) {\n            log.error(\"Error during Copilot interaction\", e);\n            System.err.println(\"Error: \" + e.getMessage());\n            System.exit(1);\n            \n        } finally {\n            // Clean up resources\n            try {\n                if (session != null) {\n                    session.destroy();\n                    log.info(\"Session destroyed\");\n                }\n                if (client != null) {\n                    client.stop();\n                    log.info(\"Client stopped\");\n                }\n            } catch (Exception e) {\n                log.error(\"Error during cleanup\", e);\n            }\n        }\n    }\n}\n```\n\nHere's also a more advanced version with streaming support:\n\n```java\npackage com.example.app.copilot;\n\nimport com.github.copilot.CopilotClient;\nimport com.github.copilot.CopilotSession;\nimport com.github.copilot.config.SessionConfig;\nimport com.github.copilot.config.SystemMessage;\nimport com.github.copilot.events.SessionEvent;\nimport com.github.copilot.events.SessionEventType;\nimport com.github.copilot.model.MessageOptions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Advanced Copilot Application with Streaming\n */\npublic class CopilotStreamingApplication {\n    \n    private static final Logger log = LoggerFactory.getLogger(CopilotStreamingApplication.class);\n    \n    public static void main(String[] args) {\n        CopilotClient client = null;\n        CopilotSession session = null;\n        \n        try {\n            // Create client\n            client = new CopilotClient.Builder()\n                .githubToken(System.getenv(\"GITHUB_TOKEN\"))\n                .logLevel(\"info\")\n                .build();\n            \n            log.info(\"Copilot client created\");\n            \n            // Create streaming session\n            SessionConfig sessionConfig = SessionConfig.builder()\n                .model(\"gpt-4.1\")\n                .streaming(true)\n                .systemMessage(SystemMessage.builder()\n                    .content(\"You are a helpful Java programming assistant specializing in Spring Boot.\")\n                    .build())\n                .build();\n            \n            session = client.createSession(sessionConfig);\n            \n            // Set up event handlers for streaming\n            CompletableFuture<Void> streamComplete = new CompletableFuture<>();\n            \n            session.on(event -> {\n                if (event.getType() == SessionEventType.ASSISTANT_MESSAGE_DELTA) {\n                    // Print each chunk as it arrives\n                    System.out.print(event.getData().getDeltaContent());\n                } else if (event.getType() == SessionEventType.SESSION_IDLE) {\n                    System.out.println(\"\\n\");\n                    streamComplete.complete(null);\n                } else if (event.getType() == SessionEventType.ERROR_OCCURRED) {\n                    log.error(\"Error during streaming: {}\", event.getData().getError());\n                    streamComplete.completeExceptionally(\n                        new RuntimeException(event.getData().getError()));\n                }\n            });\n            \n            log.info(\"Event handlers registered\");\n            \n            // Send prompt\n            String prompt = \"Explain the Spring Bean lifecycle with a simple example.\";\n            System.out.println(\"Prompt: \" + prompt);\n            System.out.println(\"\\nStreaming response:\\n\");\n            \n            MessageOptions messageOptions = MessageOptions.builder()\n                .prompt(prompt)\n                .build();\n            \n            session.sendAndWait(messageOptions);\n            \n            // Wait for streaming to complete\n            streamComplete.get(60, TimeUnit.SECONDS);\n            \n            log.info(\"Streaming completed successfully\");\n            \n        } catch (Exception e) {\n            log.error(\"Error during Copilot interaction\", e);\n            System.err.println(\"Error: \" + e.getMessage());\n            System.exit(1);\n            \n        } finally {\n            try {\n                if (session != null) session.destroy();\n                if (client != null) client.stop();\n            } catch (Exception e) {\n                log.error(\"Error during cleanup\", e);\n            }\n        }\n    }\n}\n```\n\nAnd here's a utility class for reusable Copilot operations:\n\n```java\npackage com.example.app.copilot;\n\nimport com.github.copilot.CopilotClient;\nimport com.github.copilot.CopilotSession;\nimport com.github.copilot.config.SessionConfig;\nimport com.github.copilot.config.SystemMessage;\nimport com.github.copilot.model.MessageOptions;\nimport com.github.copilot.model.MessageResponse;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\nimport jakarta.annotation.PreDestroy;\n\n/**\n * Spring-managed Copilot Service\n */\n@Component\npublic class CopilotService {\n    \n    private static final Logger log = LoggerFactory.getLogger(CopilotService.class);\n    private final CopilotClient client;\n    \n    public CopilotService() {\n        this.client = new CopilotClient.Builder()\n            .githubToken(System.getenv(\"GITHUB_TOKEN\"))\n            .logLevel(\"info\")\n            .autoRestart(true)\n            .build();\n        \n        log.info(\"CopilotService initialized\");\n    }\n    \n    /**\n     * Send a prompt and get a response\n     */\n    public String askQuestion(String prompt, String systemMessageContent) {\n        CopilotSession session = null;\n        try {\n            SessionConfig config = SessionConfig.builder()\n                .model(\"gpt-4.1\")\n                .systemMessage(SystemMessage.builder()\n                    .content(systemMessageContent)\n                    .build())\n                .build();\n            \n            session = client.createSession(config);\n            \n            MessageOptions options = MessageOptions.builder()\n                .prompt(prompt)\n                .build();\n            \n            MessageResponse response = session.sendAndWait(options);\n            \n            if (response != null && response.getData() != null) {\n                return response.getData().getContent();\n            }\n            \n            throw new RuntimeException(\"No response received from Copilot\");\n            \n        } catch (Exception e) {\n            log.error(\"Error asking question to Copilot\", e);\n            throw new RuntimeException(\"Failed to get Copilot response\", e);\n        } finally {\n            if (session != null) {\n                try {\n                    session.destroy();\n                } catch (Exception e) {\n                    log.warn(\"Error destroying session\", e);\n                }\n            }\n        }\n    }\n    \n    @PreDestroy\n    public void cleanup() {\n        try {\n            client.stop();\n            log.info(\"CopilotService stopped\");\n        } catch (Exception e) {\n            log.error(\"Error stopping Copilot client\", e);\n        }\n    }\n}\n```\n\n**Key features:**\n\n1. **Authentication**: Uses `GITHUB_TOKEN` environment variable with fallback to stored credentials\n2. **Custom system message**: Configures AI behavior for Java/Spring Boot assistance\n3. **Error handling**: Comprehensive try-catch-finally with proper resource cleanup\n4. **Logging**: SLF4J logging throughout\n5. **Streaming support**: Optional streaming version for real-time responses\n6. **Spring integration**: Service component for use in Spring applications\n\n**To run:**\n```bash\nexport GITHUB_TOKEN=your_token_here\nmvn exec:java -Dexec.mainClass=\"com.example.app.copilot.CopilotApplication\"\n```\n\nNote: The actual Java SDK API may differ from this implementation as I've extrapolated from the other language examples. You may need to adjust based on the actual Java SDK documentation when it's available.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5019,
            "output_tokens": 2842,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "copilot-sdk-03",
      "task_type": "similar_syntax",
      "target_language": "csharp",
      "expected_patterns": [
        "new CopilotClient\\(\\)",
        "CreateSessionAsync",
        "SendAndWaitAsync",
        "provider.*type.*openai|azure",
        "wireApi.*responses",
        "await using",
        "DisposeAsync"
      ],
      "anti_patterns": [
        "client\\.createSession\\(",
        "client\\.create_session\\(",
        "copilot\\.NewClient\\(",
        "sendAndWait\\(",
        "send_and_wait\\(",
        "client\\.stop\\(\\)"
      ],
      "pattern_sources": [
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/dotnet/README.md",
          "description": ".NET Copilot SDK: new CopilotClient(), CreateSessionAsync, SendAndWaitAsync, await using, DisposeAsync, provider configuration with type openai/azure, wireApi.responses"
        },
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/using",
          "description": "C# await using disposal pattern for async resource cleanup"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/docs/getting-started.md",
          "description": "Anti-patterns: TypeScript camelCase createSession, sendAndWait patterns that should not appear in .NET"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/python/README.md",
          "description": "Anti-patterns: Python snake_case create_session, send_and_wait, client.stop() patterns that should not appear in .NET"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/go/README.md",
          "description": "Anti-patterns: Go copilot.NewClient pattern that should not appear in .NET"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# GitHub Copilot SDK with Azure OpenAI BYOK Session\n\nHere's a complete C# .NET application that demonstrates using the GitHub Copilot SDK with Azure OpenAI:\n\n```csharp\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace CopilotAzureOpenAIDemo\n{\n    public class Program\n    {\n        private const string GITHUB_TOKEN = \"your_github_token_here\";\n        private const string AZURE_OPENAI_ENDPOINT = \"https://your-resource.openai.azure.com\";\n        private const string AZURE_OPENAI_KEY = \"your_azure_openai_key_here\";\n        private const string AZURE_DEPLOYMENT_NAME = \"gpt-4\"; // or your deployment name\n\n        public static async Task Main(string[] args)\n        {\n            try\n            {\n                await RunCopilotSessionAsync();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Error: {ex.Message}\");\n                Console.WriteLine($\"Stack trace: {ex.StackTrace}\");\n            }\n        }\n\n        private static async Task RunCopilotSessionAsync()\n        {\n            using var httpClient = new HttpClient();\n            \n            // Step 1: Create BYOK session\n            Console.WriteLine(\"Creating BYOK session...\");\n            var sessionToken = await CreateBYOKSessionAsync(httpClient);\n            Console.WriteLine($\"Session created successfully\");\n\n            // Step 2: Send prompt using Responses wire API\n            Console.WriteLine(\"\\nSending prompt...\");\n            await SendPromptAndHandleResponseAsync(httpClient, sessionToken);\n        }\n\n        private static async Task<string> CreateBYOKSessionAsync(HttpClient httpClient)\n        {\n            var sessionRequest = new\n            {\n                azure_openai = new\n                {\n                    endpoint = AZURE_OPENAI_ENDPOINT,\n                    deployment_name = AZURE_DEPLOYMENT_NAME,\n                    api_key = AZURE_OPENAI_KEY\n                }\n            };\n\n            var requestContent = new StringContent(\n                JsonSerializer.Serialize(sessionRequest),\n                Encoding.UTF8,\n                \"application/json\"\n            );\n\n            using var request = new HttpRequestMessage(HttpMethod.Post, \n                \"https://api.github.com/copilot_internal/v2/sessions\");\n            \n            request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", GITHUB_TOKEN);\n            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            request.Headers.UserAgent.Add(new ProductInfoHeaderValue(\"CopilotDemo\", \"1.0\"));\n            request.Content = requestContent;\n\n            using var response = await httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            using var jsonDoc = JsonDocument.Parse(responseContent);\n            \n            var sessionToken = jsonDoc.RootElement.GetProperty(\"token\").GetString();\n            \n            if (string.IsNullOrEmpty(sessionToken))\n            {\n                throw new InvalidOperationException(\"Failed to retrieve session token\");\n            }\n\n            return sessionToken;\n        }\n\n        private static async Task SendPromptAndHandleResponseAsync(HttpClient httpClient, string sessionToken)\n        {\n            var promptRequest = new\n            {\n                messages = new[]\n                {\n                    new\n                    {\n                        role = \"system\",\n                        content = \"You are a helpful coding assistant.\"\n                    },\n                    new\n                    {\n                        role = \"user\",\n                        content = \"Write a simple C# function to calculate the fibonacci sequence.\"\n                    }\n                },\n                model = \"gpt-4\",\n                temperature = 0.7,\n                max_tokens = 1000,\n                stream = false\n            };\n\n            var requestContent = new StringContent(\n                JsonSerializer.Serialize(promptRequest),\n                Encoding.UTF8,\n                \"application/json\"\n            );\n\n            using var request = new HttpRequestMessage(HttpMethod.Post,\n                \"https://api.github.com/copilot_internal/v2/chat/completions\");\n            \n            request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", sessionToken);\n            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            request.Headers.UserAgent.Add(new ProductInfoHeaderValue(\"CopilotDemo\", \"1.0\"));\n            request.Content = requestContent;\n\n            using var response = await httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            \n            // Parse and display the response\n            await HandleResponseAsync(responseContent);\n        }\n\n        private static async Task HandleResponseAsync(string responseContent)\n        {\n            await Task.Run(() =>\n            {\n                using var jsonDoc = JsonDocument.Parse(responseContent);\n                var root = jsonDoc.RootElement;\n\n                Console.WriteLine(\"\\n=== Response ===\");\n                \n                if (root.TryGetProperty(\"choices\", out var choices) && choices.GetArrayLength() > 0)\n                {\n                    var firstChoice = choices[0];\n                    \n                    if (firstChoice.TryGetProperty(\"message\", out var message))\n                    {\n                        if (message.TryGetProperty(\"content\", out var content))\n                        {\n                            Console.WriteLine($\"\\nContent:\\n{content.GetString()}\");\n                        }\n                        \n                        if (message.TryGetProperty(\"role\", out var role))\n                        {\n                            Console.WriteLine($\"\\nRole: {role.GetString()}\");\n                        }\n                    }\n\n                    if (firstChoice.TryGetProperty(\"finish_reason\", out var finishReason))\n                    {\n                        Console.WriteLine($\"Finish Reason: {finishReason.GetString()}\");\n                    }\n                }\n\n                if (root.TryGetProperty(\"usage\", out var usage))\n                {\n                    Console.WriteLine(\"\\n=== Usage Statistics ===\");\n                    \n                    if (usage.TryGetProperty(\"prompt_tokens\", out var promptTokens))\n                    {\n                        Console.WriteLine($\"Prompt Tokens: {promptTokens.GetInt32()}\");\n                    }\n                    \n                    if (usage.TryGetProperty(\"completion_tokens\", out var completionTokens))\n                    {\n                        Console.WriteLine($\"Completion Tokens: {completionTokens.GetInt32()}\");\n                    }\n                    \n                    if (usage.TryGetProperty(\"total_tokens\", out var totalTokens))\n                    {\n                        Console.WriteLine($\"Total Tokens: {totalTokens.GetInt32()}\");\n                    }\n                }\n\n                if (root.TryGetProperty(\"id\", out var id))\n                {\n                    Console.WriteLine($\"\\nResponse ID: {id.GetString()}\");\n                }\n            });\n        }\n    }\n}\n```\n\n## Streaming Version with Proper Disposal\n\nHere's an enhanced version that supports streaming responses:\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace CopilotAzureOpenAIDemo.Streaming\n{\n    public class StreamingCopilotClient : IAsyncDisposable\n    {\n        private readonly HttpClient _httpClient;\n        private readonly string _githubToken;\n        private string? _sessionToken;\n        private bool _disposed;\n\n        public StreamingCopilotClient(string githubToken)\n        {\n            _githubToken = githubToken ?? throw new ArgumentNullException(nameof(githubToken));\n            _httpClient = new HttpClient\n            {\n                Timeout = TimeSpan.FromMinutes(5)\n            };\n        }\n\n        public async Task<bool> CreateSessionAsync(\n            string azureEndpoint,\n            string deploymentName,\n            string apiKey)\n        {\n            ThrowIfDisposed();\n\n            var sessionRequest = new\n            {\n                azure_openai = new\n                {\n                    endpoint = azureEndpoint,\n                    deployment_name = deploymentName,\n                    api_key = apiKey\n                }\n            };\n\n            var requestContent = new StringContent(\n                JsonSerializer.Serialize(sessionRequest),\n                Encoding.UTF8,\n                \"application/json\"\n            );\n\n            using var request = new HttpRequestMessage(\n                HttpMethod.Post,\n                \"https://api.github.com/copilot_internal/v2/sessions\");\n            \n            request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", _githubToken);\n            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            request.Headers.UserAgent.Add(new ProductInfoHeaderValue(\"CopilotStreamingDemo\", \"1.0\"));\n            request.Content = requestContent;\n\n            using var response = await _httpClient.SendAsync(request);\n            \n            if (!response.IsSuccessStatusCode)\n            {\n                var errorContent = await response.Content.ReadAsStringAsync();\n                throw new HttpRequestException(\n                    $\"Failed to create session: {response.StatusCode} - {errorContent}\");\n            }\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            using var jsonDoc = JsonDocument.Parse(responseContent);\n            \n            _sessionToken = jsonDoc.RootElement.GetProperty(\"token\").GetString();\n            \n            return !string.IsNullOrEmpty(_sessionToken);\n        }\n\n        public async Task SendPromptWithStreamingAsync(\n            string prompt,\n            Action<string> onChunkReceived,\n            string systemMessage = \"You are a helpful coding assistant.\")\n        {\n            ThrowIfDisposed();\n\n            if (string.IsNullOrEmpty(_sessionToken))\n            {\n                throw new InvalidOperationException(\"Session not created. Call CreateSessionAsync first.\");\n            }\n\n            var promptRequest = new\n            {\n                messages = new[]\n                {\n                    new { role = \"system\", content = systemMessage },\n                    new { role = \"user\", content = prompt }\n                },\n                model = \"gpt-4\",\n                temperature = 0.7,\n                max_tokens = 2000,\n                stream = true\n            };\n\n            var requestContent = new StringContent(\n                JsonSerializer.Serialize(promptRequest),\n                Encoding.UTF8,\n                \"application/json\"\n            );\n\n            using var request = new HttpRequestMessage(\n                HttpMethod.Post,\n                \"https://api.github.com/copilot_internal/v2/chat/completions\");\n            \n            request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", _sessionToken);\n            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"text/event-stream\"));\n            request.Headers.UserAgent.Add(new ProductInfoHeaderValue(\"CopilotStreamingDemo\", \"1.0\"));\n            request.Content = requestContent;\n\n            using var response = await _httpClient.SendAsync(\n                request,\n                HttpCompletionOption.ResponseHeadersRead);\n            \n            response.EnsureSuccessStatusCode();\n\n            await using var stream = await response.Content.ReadAsStreamAsync();\n            using var reader = new StreamReader(stream);\n\n            while (!reader.EndOfStream)\n            {\n                var line = await reader.ReadLineAsync();\n                \n                if (string.IsNullOrWhiteSpace(line))\n                    continue;\n\n                if (line.StartsWith(\"data: \"))\n                {\n                    var data = line.Substring(6);\n                    \n                    if (data == \"[DONE]\")\n                    {\n                        Console.WriteLine(\"\\n\\n[Stream completed]\");\n                        break;\n                    }\n\n                    try\n                    {\n                        using var jsonDoc = JsonDocument.Parse(data);\n                        var root = jsonDoc.RootElement;\n\n                        if (root.TryGetProperty(\"choices\", out var choices) && \n                            choices.GetArrayLength() > 0)\n                        {\n                            var firstChoice = choices[0];\n                            \n                            if (firstChoice.TryGetProperty(\"delta\", out var delta) &&\n                                delta.TryGetProperty(\"content\", out var content))\n                            {\n                                var chunk = content.GetString();\n                                if (!string.IsNullOrEmpty(chunk))\n                                {\n                                    onChunkReceived(chunk);\n                                }\n                            }\n                        }\n                    }\n                    catch (JsonException ex)\n                    {\n                        Console.WriteLine($\"Failed to parse JSON: {ex.Message}\");\n                    }\n                }\n            }\n        }\n\n        private void ThrowIfDisposed()\n        {\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(nameof(StreamingCopilotClient));\n            }\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            if (_disposed)\n                return;\n\n            _httpClient?.Dispose();\n            _disposed = true;\n\n            await Task.CompletedTask;\n        }\n    }\n\n    // Usage example\n    public class StreamingProgram\n    {\n        public static async Task Main(string[] args)\n        {\n            const string githubToken = \"your_github_token_here\";\n            const string azureEndpoint = \"https://your-resource.openai.azure.com\";\n            const string azureKey = \"your_azure_openai_key_here\";\n            const string deploymentName = \"gpt-4\";\n\n            await using var client = new StreamingCopilotClient(githubToken);\n\n            try\n            {\n                Console.WriteLine(\"Creating BYOK session...\");\n                var sessionCreated = await client.CreateSessionAsync(\n                    azureEndpoint,\n                    deploymentName,\n                    azureKey);\n\n                if (!sessionCreated)\n                {\n                    Console.WriteLine(\"Failed to create session\");\n                    return;\n                }\n\n                Console.WriteLine(\"Session created successfully!\\n\");\n                Console.WriteLine(\"Sending prompt with streaming...\\n\");\n                Console.WriteLine(\"=== Response ===\\n\");\n\n                await client.SendPromptWithStreamingAsync(\n                    \"Write a C# function to reverse a string with detailed comments.\",\n                    chunk => Console.Write(chunk));\n\n                Console.WriteLine(\"\\n\\nDone!\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"\\nError: {ex.Message}\");\n                Console.WriteLine($\"Stack trace: {ex.StackTrace}\");\n            }\n        }\n    }\n}\n```\n\n## Project File (.csproj)\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <LangVersion>latest</LangVersion>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"System.Text.Json\" Version=\"8.0.0\" />\n  </ItemGroup>\n\n</Project>\n```\n\n## Configuration Helper\n\n```csharp\nusing System;\nusing System.Text.Json;\nusing System.IO;\n\nnamespace CopilotAzureOpenAIDemo\n{\n    public class Configuration\n    {\n        public string GitHubToken { get; set; } = string.Empty;\n        public string AzureOpenAIEndpoint { get; set; } = string.Empty;\n        public string AzureOpenAIKey { get; set; } = string.Empty;\n        public string AzureDeploymentName { get; set; } = string.Empty;\n\n        public static Configuration LoadFromFile(string path = \"appsettings.json\")\n        {\n            if (!File.Exists(path))\n            {\n                var defaultConfig = new Configuration\n                {\n                    GitHubToken = \"your_github_token_here\",\n                    AzureOpenAIEndpoint = \"https://your-resource.openai.azure.com\",\n                    AzureOpenAIKey = \"your_azure_openai_key_here\",\n                    AzureDeploymentName = \"gpt-4\"\n                };\n\n                var json = JsonSerializer.Serialize(defaultConfig, new JsonSerializerOptions \n                { \n                ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 60,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure OpenAI BYOK with GitHub Copilot SDK\n\nHere's a complete C# .NET application that demonstrates using the GitHub Copilot SDK with Azure OpenAI as a BYOK provider:\n\n```csharp\nusing GitHub.Copilot.SDK;\nusing GitHub.Copilot.SDK.Models;\nusing Microsoft.Extensions.Configuration;\n\nnamespace CopilotAzureOpenAIExample;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        // Load configuration from appsettings.json or environment variables\n        var configuration = new ConfigurationBuilder()\n            .AddJsonFile(\"appsettings.json\", optional: true)\n            .AddEnvironmentVariables()\n            .Build();\n\n        var azureEndpoint = configuration[\"AzureOpenAI:Endpoint\"] \n            ?? throw new InvalidOperationException(\"Azure OpenAI endpoint not configured\");\n        var azureApiKey = configuration[\"AzureOpenAI:ApiKey\"] \n            ?? throw new InvalidOperationException(\"Azure OpenAI API key not configured\");\n        var deploymentName = configuration[\"AzureOpenAI:DeploymentName\"] ?? \"gpt-4\";\n\n        Console.WriteLine(\"Starting GitHub Copilot SDK with Azure OpenAI BYOK...\\n\");\n\n        try\n        {\n            // Create and start the Copilot client\n            await using var client = new CopilotClient(new CopilotClientOptions\n            {\n                LogLevel = \"info\"\n            });\n\n            Console.WriteLine(\"Creating session with Azure OpenAI provider...\");\n\n            // Create session with Azure OpenAI BYOK provider\n            await using var session = await client.CreateSessionAsync(new SessionConfig\n            {\n                Model = deploymentName,\n                Streaming = true,\n                Provider = new ProviderConfig\n                {\n                    Type = \"azure\",\n                    BaseUrl = azureEndpoint,\n                    ApiKey = azureApiKey,\n                    WireApi = \"responses\" // Use Responses API for GPT-4/GPT-5 series\n                }\n            });\n\n            Console.WriteLine($\"Session created with ID: {session.SessionId}\\n\");\n\n            // Subscribe to streaming events\n            var responseBuilder = new System.Text.StringBuilder();\n            var isComplete = false;\n\n            session.On((SessionEvent evt) =>\n            {\n                switch (evt.Type)\n                {\n                    case SessionEventType.AssistantMessageDelta:\n                        if (evt.Data?.DeltaContent != null)\n                        {\n                            Console.Write(evt.Data.DeltaContent);\n                            responseBuilder.Append(evt.Data.DeltaContent);\n                        }\n                        break;\n\n                    case SessionEventType.SessionIdle:\n                        Console.WriteLine(\"\\n\\n--- Response Complete ---\");\n                        isComplete = true;\n                        break;\n\n                    case SessionEventType.ErrorOccurred:\n                        Console.WriteLine($\"\\nError: {evt.Data?.Error?.Message}\");\n                        isComplete = true;\n                        break;\n                }\n            });\n\n            // Send prompt and wait for completion\n            Console.WriteLine(\"Sending prompt: 'Explain async/await in C# in 3 sentences.'\\n\");\n            Console.WriteLine(\"--- Streaming Response ---\");\n\n            var response = await session.SendAndWaitAsync(new MessageOptions\n            {\n                Prompt = \"Explain async/await in C# in 3 sentences.\"\n            });\n\n            // Wait for streaming to complete\n            while (!isComplete)\n            {\n                await Task.Delay(100);\n            }\n\n            // Display final response metadata\n            if (response?.Data != null)\n            {\n                Console.WriteLine($\"\\nResponse ID: {response.Data.Id}\");\n                Console.WriteLine($\"Model: {response.Data.Model}\");\n                Console.WriteLine($\"Finish Reason: {response.Data.FinishReason}\");\n                \n                if (response.Data.Usage != null)\n                {\n                    Console.WriteLine($\"Tokens - Prompt: {response.Data.Usage.PromptTokens}, \" +\n                                    $\"Completion: {response.Data.Usage.CompletionTokens}, \" +\n                                    $\"Total: {response.Data.Usage.TotalTokens}\");\n                }\n            }\n\n            // Demonstrate follow-up message in same session\n            Console.WriteLine(\"\\n\\n=== Follow-up Question ===\");\n            responseBuilder.Clear();\n            isComplete = false;\n\n            Console.WriteLine(\"Sending follow-up: 'Give me a code example.'\\n\");\n            Console.WriteLine(\"--- Streaming Response ---\");\n\n            await session.SendAndWaitAsync(new MessageOptions\n            {\n                Prompt = \"Give me a code example.\"\n            });\n\n            while (!isComplete)\n            {\n                await Task.Delay(100);\n            }\n\n            Console.WriteLine(\"\\n\\nSession completed successfully!\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"\\nError: {ex.Message}\");\n            Console.WriteLine($\"Stack trace: {ex.StackTrace}\");\n            Environment.Exit(1);\n        }\n    }\n}\n```\n\n## Configuration File (appsettings.json)\n\n```json\n{\n  \"AzureOpenAI\": {\n    \"Endpoint\": \"https://your-resource.openai.azure.com/openai/deployments/gpt-4/chat/completions?api-version=2024-08-01-preview\",\n    \"ApiKey\": \"your-azure-openai-api-key\",\n    \"DeploymentName\": \"gpt-4\"\n  }\n}\n```\n\n## Project File (.csproj)\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"GitHub.Copilot.SDK\" Version=\"*\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration.Json\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration.EnvironmentVariables\" Version=\"8.0.0\" />\n  </ItemGroup>\n\n  <ItemGroup>\n    <None Update=\"appsettings.json\">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n  </ItemGroup>\n\n</Project>\n```\n\n## Environment Variables Alternative\n\nInstead of `appsettings.json`, you can use environment variables:\n\n```bash\n# Windows PowerShell\n$env:AzureOpenAI__Endpoint=\"https://your-resource.openai.azure.com/openai/deployments/gpt-4/chat/completions?api-version=2024-08-01-preview\"\n$env:AzureOpenAI__ApiKey=\"your-api-key\"\n$env:AzureOpenAI__DeploymentName=\"gpt-4\"\n\n# Linux/macOS\nexport AzureOpenAI__Endpoint=\"https://your-resource.openai.azure.com/openai/deployments/gpt-4/chat/completions?api-version=2024-08-01-preview\"\nexport AzureOpenAI__ApiKey=\"your-api-key\"\nexport AzureOpenAI__DeploymentName=\"gpt-4\"\n```\n\n## Key Features Demonstrated\n\n1. **Proper Async/Await Disposal**: Uses `await using` for automatic cleanup\n2. **Azure OpenAI BYOK**: Configures Azure provider with Responses wire API\n3. **Streaming**: Real-time response handling with event subscriptions\n4. **Session Continuity**: Follow-up messages in the same conversation context\n5. **Error Handling**: Comprehensive try-catch with detailed error messages\n6. **Configuration Management**: Supports both JSON and environment variables\n7. **Response Metadata**: Displays token usage and completion details\n\n## Running the Application\n\n```bash\n# Install dependencies\ndotnet restore\n\n# Run the application\ndotnet run\n\n# Or build and run\ndotnet build\ndotnet run --project CopilotAzureOpenAIExample.csproj\n```\n\n## Expected Output\n\n```\nStarting GitHub Copilot SDK with Azure OpenAI BYOK...\n\nCreating session with Azure OpenAI provider...\nSession created with ID: azure-session-12345\n\nSending prompt: 'Explain async/await in C# in 3 sentences.'\n\n--- Streaming Response ---\nAsync/await in C# enables asynchronous programming by allowing methods to run without blocking the calling thread. The `async` keyword marks a method as asynchronous, while `await` pauses execution until the awaited task completes. This pattern improves application responsiveness, especially for I/O-bound operations like web requests or file access.\n\n--- Response Complete ---\n\nResponse ID: chatcmpl-abc123\nModel: gpt-4\nFinish Reason: stop\nTokens - Prompt: 15, Completion: 67, Total: 82\n\n\n=== Follow-up Question ===\nSending follow-up: 'Give me a code example.'\n\n--- Streaming Response ---\nHere's a simple example:\n\n```csharp\npublic async Task<string> FetchDataAsync(string url)\n{\n    using var client = new HttpClient();\n    string result = await client.GetStringAsync(url);\n    return result;\n}\n```\n\n--- Response Complete ---\n\nSession completed successfully!\n```\n\n## Important Notes\n\n1. **Azure Endpoint Format**: Use the full deployment URL including API version\n2. **Wire API**: Use `\"responses\"` for GPT-4/GPT-5, `\"completions\"` for older models\n3. **Provider Type**: Use `\"azure\"` for native Azure endpoints (not `\"openai\"`)\n4. **No Copilot Subscription**: BYOK doesn't require GitHub Copilot subscription\n5. **Session Persistence**: Provider config must be re-provided when resuming sessions",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4505,
            "output_tokens": 2478,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a C# .NET application that uses the GitHub Copilot SDK with Azure OpenAI BYOK configuration.\n\n```csharp\nusing GitHub.Copilot.SDK;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace App.Services;\n\npublic class CopilotAzureService\n{\n    private readonly ILogger<CopilotAzureService> _logger;\n    private readonly IConfiguration _configuration;\n\n    public CopilotAzureService(ILogger<CopilotAzureService> logger, IConfiguration configuration)\n    {\n        _logger = logger;\n        _configuration = configuration;\n    }\n\n    public async Task<string?> SendPromptAsync(string prompt)\n    {\n        // Create Copilot client\n        await using var client = new CopilotClient(new CopilotClientOptions\n        {\n            LogLevel = \"info\"\n        });\n\n        try\n        {\n            // Get Azure OpenAI configuration from appsettings\n            var azureEndpoint = _configuration[\"AzureOpenAI:Endpoint\"] \n                ?? throw new InvalidOperationException(\"Azure OpenAI endpoint not configured\");\n            var apiKey = _configuration[\"AzureOpenAI:ApiKey\"] \n                ?? throw new InvalidOperationException(\"Azure OpenAI API key not configured\");\n            var deploymentName = _configuration[\"AzureOpenAI:DeploymentName\"] ?? \"gpt-4\";\n\n            _logger.LogInformation(\"Creating BYOK session with Azure OpenAI provider\");\n\n            // Create session with Azure OpenAI BYOK provider using Responses wire API\n            await using var session = await client.CreateSessionAsync(new SessionConfig\n            {\n                Model = deploymentName,\n                Provider = new ProviderConfig\n                {\n                    Type = \"azure\",\n                    BaseUrl = azureEndpoint,\n                    WireApi = \"responses\", // Use Responses wire API for GPT-5 series\n                    ApiKey = apiKey\n                }\n            });\n\n            _logger.LogInformation(\"Sending prompt to Azure OpenAI\");\n\n            // Send prompt and wait for response\n            var response = await session.SendAndWaitAsync(new MessageOptions\n            {\n                Prompt = prompt\n            });\n\n            if (response?.Data?.Content != null)\n            {\n                _logger.LogInformation(\"Received response from Azure OpenAI\");\n                return response.Data.Content;\n            }\n\n            _logger.LogWarning(\"No content in response\");\n            return null;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error communicating with Azure OpenAI via Copilot SDK\");\n            throw;\n        }\n    }\n\n    public async Task<string?> SendPromptWithStreamingAsync(string prompt, Action<string> onDelta)\n    {\n        await using var client = new CopilotClient(new CopilotClientOptions\n        {\n            LogLevel = \"info\"\n        });\n\n        try\n        {\n            var azureEndpoint = _configuration[\"AzureOpenAI:Endpoint\"] \n                ?? throw new InvalidOperationException(\"Azure OpenAI endpoint not configured\");\n            var apiKey = _configuration[\"AzureOpenAI:ApiKey\"] \n                ?? throw new InvalidOperationException(\"Azure OpenAI API key not configured\");\n            var deploymentName = _configuration[\"AzureOpenAI:DeploymentName\"] ?? \"gpt-4\";\n\n            _logger.LogInformation(\"Creating streaming BYOK session with Azure OpenAI\");\n\n            // Create session with streaming enabled\n            await using var session = await client.CreateSessionAsync(new SessionConfig\n            {\n                Model = deploymentName,\n                Streaming = true,\n                Provider = new ProviderConfig\n                {\n                    Type = \"azure\",\n                    BaseUrl = azureEndpoint,\n                    WireApi = \"responses\",\n                    ApiKey = apiKey\n                }\n            });\n\n            var fullResponse = new System.Text.StringBuilder();\n\n            // Subscribe to streaming events\n            session.On((SessionEvent evt) =>\n            {\n                if (evt.Type == SessionEventType.AssistantMessageDelta && \n                    evt.Data?.DeltaContent != null)\n                {\n                    var delta = evt.Data.DeltaContent;\n                    fullResponse.Append(delta);\n                    onDelta(delta);\n                }\n            });\n\n            _logger.LogInformation(\"Sending prompt with streaming\");\n\n            // Send prompt and wait for completion\n            await session.SendAndWaitAsync(new MessageOptions\n            {\n                Prompt = prompt\n            });\n\n            return fullResponse.ToString();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error streaming from Azure OpenAI via Copilot SDK\");\n            throw;\n        }\n    }\n}\n```\n\nNow let me create the configuration file structure:\n\n```json\n{\n  \"AzureOpenAI\": {\n    \"Endpoint\": \"https://your-resource.openai.azure.com/\",\n    \"ApiKey\": \"your-api-key-here\",\n    \"DeploymentName\": \"gpt-4\"\n  },\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  }\n}\n```\n\nAnd a controller to use the service:\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing App.Services;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class CopilotController : ControllerBase\n{\n    private readonly CopilotAzureService _copilotService;\n    private readonly ILogger<CopilotController> _logger;\n\n    public CopilotController(CopilotAzureService copilotService, ILogger<CopilotController> logger)\n    {\n        _copilotService = copilotService;\n        _logger = logger;\n    }\n\n    [HttpPost(\"prompt\")]\n    public async Task<IActionResult> SendPrompt([FromBody] PromptRequest request)\n    {\n        if (string.IsNullOrWhiteSpace(request.Prompt))\n        {\n            return BadRequest(\"Prompt cannot be empty\");\n        }\n\n        try\n        {\n            var response = await _copilotService.SendPromptAsync(request.Prompt);\n            \n            if (response == null)\n            {\n                return StatusCode(500, \"No response received from Azure OpenAI\");\n            }\n\n            return Ok(new { response });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error processing prompt\");\n            return StatusCode(500, \"Error processing prompt\");\n        }\n    }\n\n    [HttpPost(\"prompt-stream\")]\n    public async Task StreamPrompt([FromBody] PromptRequest request)\n    {\n        if (string.IsNullOrWhiteSpace(request.Prompt))\n        {\n            Response.StatusCode = 400;\n            await Response.WriteAsync(\"Prompt cannot be empty\");\n            return;\n        }\n\n        Response.ContentType = \"text/event-stream\";\n        Response.Headers.Add(\"Cache-Control\", \"no-cache\");\n        Response.Headers.Add(\"Connection\", \"keep-alive\");\n\n        try\n        {\n            await _copilotService.SendPromptWithStreamingAsync(request.Prompt, async (delta) =>\n            {\n                await Response.WriteAsync($\"data: {delta}\\n\\n\");\n                await Response.Body.FlushAsync();\n            });\n\n            await Response.WriteAsync(\"data: [DONE]\\n\\n\");\n            await Response.Body.FlushAsync();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error streaming prompt\");\n            await Response.WriteAsync($\"data: Error: {ex.Message}\\n\\n\");\n        }\n    }\n}\n\npublic record PromptRequest(string Prompt);\n```\n\nAnd register the service in Program.cs:\n\n```csharp\nusing App.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Register Copilot service\nbuilder.Services.AddScoped<CopilotAzureService>();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n**Key features:**\n\n1. **BYOK with Azure OpenAI**: Uses `\"azure\"` provider type with your Azure endpoint and API key\n2. **Responses Wire API**: Configured with `WireApi = \"responses\"` for GPT-5 series models\n3. **Proper async/await disposal**: Uses `await using` for both `CopilotClient` and session objects\n4. **Two modes**: Regular request/response and streaming with Server-Sent Events\n5. **Configuration-based**: Azure credentials stored in appsettings.json\n6. **Error handling**: Comprehensive try-catch with logging\n7. **Streaming support**: Real-time delta events with proper event subscription\n\nTo use this, you'll need to:\n1. Install the NuGet package: `dotnet add package GitHub.Copilot.SDK`\n2. Update appsettings.json with your Azure OpenAI endpoint and API key\n3. Ensure the GitHub Copilot CLI is installed and available",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5011,
            "output_tokens": 2350,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# C# GitHub Copilot SDK with Azure OpenAI BYOK Session\n\nHere's a complete C# .NET application that demonstrates using the GitHub Copilot SDK with Azure OpenAI:\n\n```csharp\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace GitHubCopilotBYOK\n{\n    public class Program\n    {\n        private const string GITHUB_TOKEN = \"your_github_token_here\";\n        private const string AZURE_OPENAI_ENDPOINT = \"https://your-resource.openai.azure.com\";\n        private const string AZURE_OPENAI_KEY = \"your_azure_openai_key_here\";\n        private const string AZURE_DEPLOYMENT_NAME = \"gpt-4\"; // or your deployment name\n\n        public static async Task Main(string[] args)\n        {\n            try\n            {\n                await RunCopilotSessionAsync();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Error: {ex.Message}\");\n                Console.WriteLine(ex.StackTrace);\n            }\n        }\n\n        private static async Task RunCopilotSessionAsync()\n        {\n            using var httpClient = new HttpClient();\n            httpClient.DefaultRequestHeaders.Authorization = \n                new AuthenticationHeaderValue(\"Bearer\", GITHUB_TOKEN);\n            httpClient.DefaultRequestHeaders.Accept.Add(\n                new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            // Step 1: Create BYOK session\n            Console.WriteLine(\"Creating BYOK session...\");\n            var sessionId = await CreateBYOKSessionAsync(httpClient);\n            Console.WriteLine($\"Session created: {sessionId}\");\n\n            // Step 2: Send prompt using Responses wire API\n            Console.WriteLine(\"\\nSending prompt...\");\n            await SendPromptAsync(httpClient, sessionId);\n\n            Console.WriteLine(\"\\nSession completed successfully!\");\n        }\n\n        private static async Task<string> CreateBYOKSessionAsync(HttpClient httpClient)\n        {\n            var sessionRequest = new\n            {\n                provider = new\n                {\n                    type = \"azure_openai\",\n                    endpoint = AZURE_OPENAI_ENDPOINT,\n                    api_key = AZURE_OPENAI_KEY,\n                    deployment_name = AZURE_DEPLOYMENT_NAME,\n                    api_version = \"2024-02-15-preview\"\n                },\n                model = \"gpt-4\",\n                capabilities = new\n                {\n                    chat = true,\n                    code_completion = true\n                }\n            };\n\n            var content = new StringContent(\n                JsonSerializer.Serialize(sessionRequest),\n                Encoding.UTF8,\n                \"application/json\");\n\n            using var response = await httpClient.PostAsync(\n                \"https://api.github.com/copilot/byok/sessions\",\n                content);\n\n            response.EnsureSuccessStatusCode();\n\n            var responseBody = await response.Content.ReadAsStringAsync();\n            using var jsonDoc = JsonDocument.Parse(responseBody);\n            \n            return jsonDoc.RootElement.GetProperty(\"session_id\").GetString() \n                ?? throw new InvalidOperationException(\"Session ID not found\");\n        }\n\n        private static async Task SendPromptAsync(HttpClient httpClient, string sessionId)\n        {\n            var promptRequest = new\n            {\n                messages = new[]\n                {\n                    new\n                    {\n                        role = \"system\",\n                        content = \"You are a helpful coding assistant.\"\n                    },\n                    new\n                    {\n                        role = \"user\",\n                        content = \"Write a simple C# function to calculate factorial.\"\n                    }\n                },\n                temperature = 0.7,\n                max_tokens = 500,\n                stream = false\n            };\n\n            var content = new StringContent(\n                JsonSerializer.Serialize(promptRequest),\n                Encoding.UTF8,\n                \"application/json\");\n\n            using var response = await httpClient.PostAsync(\n                $\"https://api.github.com/copilot/byok/sessions/{sessionId}/responses\",\n                content);\n\n            response.EnsureSuccessStatusCode();\n\n            var responseBody = await response.Content.ReadAsStringAsync();\n            \n            // Parse and display the response\n            using var jsonDoc = JsonDocument.Parse(responseBody);\n            var choices = jsonDoc.RootElement.GetProperty(\"choices\");\n            \n            foreach (var choice in choices.EnumerateArray())\n            {\n                var message = choice.GetProperty(\"message\");\n                var responseContent = message.GetProperty(\"content\").GetString();\n                \n                Console.WriteLine(\"\\n=== Response ===\");\n                Console.WriteLine(responseContent);\n                Console.WriteLine(\"================\\n\");\n            }\n        }\n    }\n}\n```\n\n## Advanced Version with Streaming Support\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace GitHubCopilotBYOK.Advanced\n{\n    public class CopilotBYOKClient : IAsyncDisposable\n    {\n        private readonly HttpClient _httpClient;\n        private readonly string _githubToken;\n        private readonly AzureOpenAIConfig _azureConfig;\n        private string? _sessionId;\n\n        public CopilotBYOKClient(\n            string githubToken,\n            AzureOpenAIConfig azureConfig)\n        {\n            _githubToken = githubToken;\n            _azureConfig = azureConfig;\n            _httpClient = new HttpClient();\n            \n            _httpClient.DefaultRequestHeaders.Authorization = \n                new AuthenticationHeaderValue(\"Bearer\", _githubToken);\n            _httpClient.DefaultRequestHeaders.Accept.Add(\n                new MediaTypeWithQualityHeaderValue(\"application/json\"));\n        }\n\n        public async Task<string> CreateSessionAsync()\n        {\n            var sessionRequest = new\n            {\n                provider = new\n                {\n                    type = \"azure_openai\",\n                    endpoint = _azureConfig.Endpoint,\n                    api_key = _azureConfig.ApiKey,\n                    deployment_name = _azureConfig.DeploymentName,\n                    api_version = _azureConfig.ApiVersion\n                },\n                model = _azureConfig.Model,\n                capabilities = new\n                {\n                    chat = true,\n                    code_completion = true\n                }\n            };\n\n            var content = new StringContent(\n                JsonSerializer.Serialize(sessionRequest),\n                Encoding.UTF8,\n                \"application/json\");\n\n            using var response = await _httpClient.PostAsync(\n                \"https://api.github.com/copilot/byok/sessions\",\n                content);\n\n            response.EnsureSuccessStatusCode();\n\n            var responseBody = await response.Content.ReadAsStringAsync();\n            using var jsonDoc = JsonDocument.Parse(responseBody);\n            \n            _sessionId = jsonDoc.RootElement.GetProperty(\"session_id\").GetString() \n                ?? throw new InvalidOperationException(\"Session ID not found\");\n\n            return _sessionId;\n        }\n\n        public async Task<CopilotResponse> SendPromptAsync(\n            string prompt,\n            string systemMessage = \"You are a helpful coding assistant.\",\n            double temperature = 0.7,\n            int maxTokens = 500)\n        {\n            if (string.IsNullOrEmpty(_sessionId))\n            {\n                throw new InvalidOperationException(\"Session not created. Call CreateSessionAsync first.\");\n            }\n\n            var promptRequest = new\n            {\n                messages = new[]\n                {\n                    new { role = \"system\", content = systemMessage },\n                    new { role = \"user\", content = prompt }\n                },\n                temperature,\n                max_tokens = maxTokens,\n                stream = false\n            };\n\n            var content = new StringContent(\n                JsonSerializer.Serialize(promptRequest),\n                Encoding.UTF8,\n                \"application/json\");\n\n            using var response = await _httpClient.PostAsync(\n                $\"https://api.github.com/copilot/byok/sessions/{_sessionId}/responses\",\n                content);\n\n            response.EnsureSuccessStatusCode();\n\n            var responseBody = await response.Content.ReadAsStringAsync();\n            return ParseResponse(responseBody);\n        }\n\n        public async Task SendPromptStreamAsync(\n            string prompt,\n            Action<string> onChunkReceived,\n            string systemMessage = \"You are a helpful coding assistant.\",\n            double temperature = 0.7,\n            int maxTokens = 500)\n        {\n            if (string.IsNullOrEmpty(_sessionId))\n            {\n                throw new InvalidOperationException(\"Session not created. Call CreateSessionAsync first.\");\n            }\n\n            var promptRequest = new\n            {\n                messages = new[]\n                {\n                    new { role = \"system\", content = systemMessage },\n                    new { role = \"user\", content = prompt }\n                },\n                temperature,\n                max_tokens = maxTokens,\n                stream = true\n            };\n\n            var content = new StringContent(\n                JsonSerializer.Serialize(promptRequest),\n                Encoding.UTF8,\n                \"application/json\");\n\n            using var request = new HttpRequestMessage(HttpMethod.Post,\n                $\"https://api.github.com/copilot/byok/sessions/{_sessionId}/responses\")\n            {\n                Content = content\n            };\n\n            using var response = await _httpClient.SendAsync(\n                request,\n                HttpCompletionOption.ResponseHeadersRead);\n\n            response.EnsureSuccessStatusCode();\n\n            await using var stream = await response.Content.ReadAsStreamAsync();\n            using var reader = new StreamReader(stream);\n\n            while (!reader.EndOfStream)\n            {\n                var line = await reader.ReadLineAsync();\n                \n                if (string.IsNullOrWhiteSpace(line) || !line.StartsWith(\"data: \"))\n                {\n                    continue;\n                }\n\n                var data = line.Substring(6); // Remove \"data: \" prefix\n                \n                if (data == \"[DONE]\")\n                {\n                    break;\n                }\n\n                try\n                {\n                    using var jsonDoc = JsonDocument.Parse(data);\n                    var choices = jsonDoc.RootElement.GetProperty(\"choices\");\n                    \n                    foreach (var choice in choices.EnumerateArray())\n                    {\n                        if (choice.TryGetProperty(\"delta\", out var delta) &&\n                            delta.TryGetProperty(\"content\", out var content))\n                        {\n                            var chunk = content.GetString();\n                            if (!string.IsNullOrEmpty(chunk))\n                            {\n                                onChunkReceived(chunk);\n                            }\n                        }\n                    }\n                }\n                catch (JsonException)\n                {\n                    // Skip malformed JSON\n                    continue;\n                }\n            }\n        }\n\n        public async Task DeleteSessionAsync()\n        {\n            if (string.IsNullOrEmpty(_sessionId))\n            {\n                return;\n            }\n\n            try\n            {\n                using var response = await _httpClient.DeleteAsync(\n                    $\"https://api.github.com/copilot/byok/sessions/{_sessionId}\");\n                \n                response.EnsureSuccessStatusCode();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Warning: Failed to delete session: {ex.Message}\");\n            }\n            finally\n            {\n                _sessionId = null;\n            }\n        }\n\n        private static CopilotResponse ParseResponse(string responseBody)\n        {\n            using var jsonDoc = JsonDocument.Parse(responseBody);\n            var root = jsonDoc.RootElement;\n            \n            var choices = root.GetProperty(\"choices\");\n            var firstChoice = choices[0];\n            var message = firstChoice.GetProperty(\"message\");\n            var content = message.GetProperty(\"content\").GetString() ?? string.Empty;\n            \n            var usage = root.TryGetProperty(\"usage\", out var usageElement)\n                ? new TokenUsage\n                {\n                    PromptTokens = usageElement.GetProperty(\"prompt_tokens\").GetInt32(),\n                    CompletionTokens = usageElement.GetProperty(\"completion_tokens\").GetInt32(),\n                    TotalTokens = usageElement.GetProperty(\"total_tokens\").GetInt32()\n                }\n                : null;\n\n            return new CopilotResponse\n            {\n                Content = content,\n                Usage = usage\n            };\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            await DeleteSessionAsync();\n            _httpClient?.Dispose();\n        }\n    }\n\n    public class AzureOpenAIConfig\n    {\n        public required string Endpoint { get; init; }\n        public required string ApiKey { get; init; }\n        public required string DeploymentName { get; init; }\n        public string Model { get; init; } = \"gpt-4\";\n        public string ApiVersion { get; init; } = \"2024-02-15-preview\";\n    }\n\n    public class CopilotResponse\n    {\n        public required string Content { get; init; }\n        public TokenUsage? Usage { get; init; }\n    }\n\n    public class TokenUsage\n    {\n        public int PromptTokens { get; init; }\n        public int CompletionTokens { get; init; }\n        public int TotalTokens { get; init; }\n    }\n\n    // Example usage\n    public class AdvancedProgram\n    {\n        public static async Task Main(string[] args)\n        {\n            var config = new AzureOpenAIConfig\n            {\n                Endpoint = \"https://your-resource.openai.azure.com\",\n                ApiKey = \"your_azure_openai_key_here\",\n                DeploymentName = \"gpt-4\"\n            };\n\n            await using var client = new CopilotBYOKClient(\n                \"your_github_token_here\",\n                config);\n\n            try\n            {\n                // Create session\n                Console.WriteLine(\"Creating BYOK session...\");\n                var sessionId = await client.CreateSessionAsync();\n                Console.WriteLine($\"Session created: {sessionId}\\n\");\n\n                // Example 1: Non-streaming request\n                Console.WriteLine(\"=== Non-Streaming Example ===\");\n                var response = await client.SendPromptAsync(\n                    \"Write a C# function to calculate factorial.\");\n                \n                Console.WriteLine(response.Content);\n                \n                if (response.Usage != null)\n                {\n                    Console.WriteLine($\"\\nTokens used: {response.Usage.TotalTokens}\");\n                }\n\n                // Example 2: Streaming request\n                Console.WriteLine(\"\\n\\n=== Streaming Example ===\");\n                await client.SendPromptStreamAsync(\n                    \"Explain async/await in C# in simple terms.\",\n                    chunk => Console.Write(chunk));\n\n                Console.WriteLine(\"\\n\\nCompleted successfully!\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Error: {ex.Message}\");\n                Console.WriteLine(ex.StackTrace);\n            }\n        }\n    }\n}\n```\n\n## Project File (.csproj)\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <LangVersion>latest</LangVersion>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"System.Text.Json\" Version=\"8.0.0\" />\n  </ItemGroup>\n\n</Project>\n```\n\n## Configuration Helper\n\n```csharp\nusing System;\nusing System.Text.Json;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace GitHubCopilotBYOK\n{\n    public class ConfigurationManager\n    {\n        private const string CONFIG_FILE = \"appsettings.json\";\n\n        public static async Task<AppConfiguration> LoadConfigurationAsync()\n        {\n            if (!File.Exists(CONFIG_FILE))\n            {\n                throw new FileNotFoundException(\n                    $\"Configuration file '{CONFIG_FILE}' not found.\");\n            }\n\n            var json = await File.ReadAllTextAsync(CONFIG_FILE);\n            return JsonSerializer.Deserialize<AppConfiguration>(json) \n                ?? throw new InvalidOperationException(\"Failed to deserialize configuration.\");",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 60,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure OpenAI BYOK Example with GitHub Copilot SDK\n\nHere's a complete C# .NET application demonstrating BYOK with Azure OpenAI:\n\n```csharp\nusing GitHub.Copilot.SDK;\nusing Microsoft.Extensions.Configuration;\n\nnamespace CopilotAzureOpenAIExample;\n\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        // Load configuration from appsettings.json or environment variables\n        var configuration = new ConfigurationBuilder()\n            .AddJsonFile(\"appsettings.json\", optional: true)\n            .AddEnvironmentVariables()\n            .Build();\n\n        var azureEndpoint = configuration[\"AzureOpenAI:Endpoint\"] \n            ?? throw new InvalidOperationException(\"Azure OpenAI endpoint not configured\");\n        var apiKey = configuration[\"AzureOpenAI:ApiKey\"] \n            ?? throw new InvalidOperationException(\"Azure OpenAI API key not configured\");\n        var deploymentName = configuration[\"AzureOpenAI:DeploymentName\"] ?? \"gpt-4\";\n\n        Console.WriteLine(\"Starting Azure OpenAI BYOK session...\\n\");\n\n        try\n        {\n            // Create and dispose client properly\n            await using var client = new CopilotClient(new ClientConfig\n            {\n                LogLevel = \"info\"\n            });\n\n            // Create BYOK session with Azure OpenAI provider\n            await using var session = await client.CreateSessionAsync(new SessionConfig\n            {\n                Model = deploymentName,\n                Streaming = true,\n                Provider = new ProviderConfig\n                {\n                    Type = \"azure\",\n                    BaseUrl = azureEndpoint,\n                    ApiKey = apiKey,\n                    WireApi = \"responses\" // Use Responses API for GPT-4/GPT-5 series\n                }\n            });\n\n            Console.WriteLine($\"Session created with model: {deploymentName}\");\n            Console.WriteLine(\"Sending prompt...\\n\");\n\n            // Subscribe to streaming events\n            var responseBuilder = new System.Text.StringBuilder();\n            \n            session.On((SessionEvent evt) =>\n            {\n                switch (evt.Type)\n                {\n                    case SessionEventType.AssistantMessageDelta:\n                        var deltaContent = evt.Data.DeltaContent;\n                        if (!string.IsNullOrEmpty(deltaContent))\n                        {\n                            Console.Write(deltaContent);\n                            responseBuilder.Append(deltaContent);\n                        }\n                        break;\n\n                    case SessionEventType.SessionIdle:\n                        Console.WriteLine(\"\\n\\n--- Session idle ---\");\n                        break;\n\n                    case SessionEventType.ErrorOccurred:\n                        Console.WriteLine($\"\\nError: {evt.Data.Message}\");\n                        break;\n                }\n            });\n\n            // Send prompt and wait for completion\n            var response = await session.SendAndWaitAsync(new MessageOptions\n            {\n                Prompt = \"Explain the benefits of using Azure OpenAI with GitHub Copilot SDK in 3 bullet points.\"\n            });\n\n            // Display final response metadata\n            Console.WriteLine(\"\\n--- Response Metadata ---\");\n            Console.WriteLine($\"Status: {response?.Status}\");\n            Console.WriteLine($\"Message ID: {response?.Data.MessageId}\");\n            Console.WriteLine($\"Total tokens: {response?.Data.Usage?.TotalTokens ?? 0}\");\n            Console.WriteLine($\"Prompt tokens: {response?.Data.Usage?.PromptTokens ?? 0}\");\n            Console.WriteLine($\"Completion tokens: {response?.Data.Usage?.CompletionTokens ?? 0}\");\n\n            // Full response content (if not streaming)\n            if (!string.IsNullOrEmpty(response?.Data.Content))\n            {\n                Console.WriteLine(\"\\n--- Full Response ---\");\n                Console.WriteLine(response.Data.Content);\n            }\n\n            Console.WriteLine(\"\\n\u2713 Session completed successfully\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"\\n\u2717 Error: {ex.Message}\");\n            Console.WriteLine($\"Stack trace: {ex.StackTrace}\");\n            Environment.Exit(1);\n        }\n    }\n}\n```\n\n## Configuration File (appsettings.json)\n\n```json\n{\n  \"AzureOpenAI\": {\n    \"Endpoint\": \"https://your-resource.openai.azure.com\",\n    \"ApiKey\": \"your-api-key-here\",\n    \"DeploymentName\": \"gpt-4\"\n  }\n}\n```\n\n## Project File (.csproj)\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"GitHub.Copilot.SDK\" Version=\"*\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration.Json\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration.EnvironmentVariables\" Version=\"8.0.0\" />\n  </ItemGroup>\n\n  <ItemGroup>\n    <None Update=\"appsettings.json\">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n  </ItemGroup>\n\n</Project>\n```\n\n## Environment Variables Alternative\n\nInstead of `appsettings.json`, you can use environment variables:\n\n```bash\n# Windows\nset AZUREOPENAI__ENDPOINT=https://your-resource.openai.azure.com\nset AZUREOPENAI__APIKEY=your-api-key-here\nset AZUREOPENAI__DEPLOYMENTNAME=gpt-4\n\n# Linux/macOS\nexport AZUREOPENAI__ENDPOINT=https://your-resource.openai.azure.com\nexport AZUREOPENAI__APIKEY=your-api-key-here\nexport AZUREOPENAI__DEPLOYMENTNAME=gpt-4\n```\n\n## Key Features Demonstrated\n\n1. **Proper Async/Await Disposal**: Uses `await using` for both `CopilotClient` and session\n2. **Azure OpenAI Provider**: Configured with native Azure endpoint (no `/openai/v1` suffix)\n3. **Responses Wire API**: Uses `\"responses\"` for GPT-4/GPT-5 compatibility\n4. **Streaming**: Real-time delta content handling\n5. **Event Handling**: Subscribes to multiple event types\n6. **Error Handling**: Try-catch with detailed error messages\n7. **Configuration Management**: Supports both JSON and environment variables\n8. **Token Usage Tracking**: Displays prompt, completion, and total tokens\n\n## Running the Application\n\n```bash\n# Install dependencies\ndotnet restore\n\n# Run\ndotnet run\n\n# Or build and run\ndotnet build\ndotnet run --project CopilotAzureOpenAIExample.csproj\n```\n\n## Expected Output\n\n```\nStarting Azure OpenAI BYOK session...\n\nSession created with model: gpt-4\nSending prompt...\n\nHere are the benefits of using Azure OpenAI with GitHub Copilot SDK:\n\n\u2022 **Enterprise-grade security**: Azure OpenAI provides SOC 2 compliance, data residency controls, and private networking options for sensitive workloads.\n\n\u2022 **Seamless integration**: The SDK abstracts provider differences, allowing you to switch between Azure OpenAI, OpenAI, and other providers without code changes.\n\n\u2022 **Cost optimization**: Use your existing Azure credits and benefit from Azure's pricing models while maintaining full control over API keys and usage.\n\n--- Session idle ---\n\n--- Response Metadata ---\nStatus: success\nMessage ID: msg_abc123\nTotal tokens: 156\nPrompt tokens: 28\nCompletion tokens: 128\n\n\u2713 Session completed successfully\n```\n\n## Important Notes\n\n1. **Endpoint Format**: Use `https://your-resource.openai.azure.com` (no `/openai/v1` suffix for Azure provider)\n2. **Wire API**: Use `\"responses\"` for GPT-4/GPT-5, `\"completions\"` for older models\n3. **Deployment Name**: Must match your Azure OpenAI deployment name exactly\n4. **API Key**: Keep secure, never commit to source control\n5. **Disposal**: Always use `await using` to ensure proper cleanup\n6. **No Copilot Subscription**: BYOK doesn't require a GitHub Copilot subscription",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4505,
            "output_tokens": 2102,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a C# .NET application that uses the GitHub Copilot SDK with Azure OpenAI BYOK configuration.\n\n```csharp\nusing GitHub.Copilot.SDK;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace App.Services;\n\npublic class CopilotAzureService\n{\n    private readonly ILogger<CopilotAzureService> _logger;\n    private readonly IConfiguration _configuration;\n\n    public CopilotAzureService(ILogger<CopilotAzureService> logger, IConfiguration configuration)\n    {\n        _logger = logger;\n        _configuration = configuration;\n    }\n\n    public async Task<string?> SendPromptAsync(string prompt)\n    {\n        // Create Copilot client\n        await using var client = new CopilotClient(new CopilotClientOptions\n        {\n            LogLevel = \"info\"\n        });\n\n        try\n        {\n            // Get Azure OpenAI configuration from appsettings\n            var azureEndpoint = _configuration[\"AzureOpenAI:Endpoint\"] \n                ?? throw new InvalidOperationException(\"Azure OpenAI endpoint not configured\");\n            var azureApiKey = _configuration[\"AzureOpenAI:ApiKey\"] \n                ?? throw new InvalidOperationException(\"Azure OpenAI API key not configured\");\n            var deploymentName = _configuration[\"AzureOpenAI:DeploymentName\"] ?? \"gpt-4\";\n\n            _logger.LogInformation(\"Creating BYOK session with Azure OpenAI provider\");\n\n            // Create session with Azure OpenAI BYOK provider using Responses wire API\n            await using var session = await client.CreateSessionAsync(new SessionConfig\n            {\n                Model = deploymentName,\n                Provider = new ProviderConfig\n                {\n                    Type = \"azure\",\n                    BaseUrl = azureEndpoint,\n                    WireApi = \"responses\", // Use Responses wire API for GPT-5 series\n                    ApiKey = azureApiKey\n                },\n                Streaming = false\n            });\n\n            _logger.LogInformation(\"Sending prompt to Azure OpenAI\");\n\n            // Send prompt and wait for response\n            var response = await session.SendAndWaitAsync(new MessageOptions\n            {\n                Prompt = prompt\n            });\n\n            if (response?.Data?.Content != null)\n            {\n                _logger.LogInformation(\"Received response from Azure OpenAI\");\n                return response.Data.Content;\n            }\n\n            _logger.LogWarning(\"No content in response\");\n            return null;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error communicating with Azure OpenAI via Copilot SDK\");\n            throw;\n        }\n    }\n\n    public async Task<string?> SendPromptWithStreamingAsync(string prompt, Action<string> onDelta)\n    {\n        await using var client = new CopilotClient(new CopilotClientOptions\n        {\n            LogLevel = \"info\"\n        });\n\n        try\n        {\n            var azureEndpoint = _configuration[\"AzureOpenAI:Endpoint\"] \n                ?? throw new InvalidOperationException(\"Azure OpenAI endpoint not configured\");\n            var azureApiKey = _configuration[\"AzureOpenAI:ApiKey\"] \n                ?? throw new InvalidOperationException(\"Azure OpenAI API key not configured\");\n            var deploymentName = _configuration[\"AzureOpenAI:DeploymentName\"] ?? \"gpt-4\";\n\n            _logger.LogInformation(\"Creating streaming BYOK session with Azure OpenAI provider\");\n\n            await using var session = await client.CreateSessionAsync(new SessionConfig\n            {\n                Model = deploymentName,\n                Provider = new ProviderConfig\n                {\n                    Type = \"azure\",\n                    BaseUrl = azureEndpoint,\n                    WireApi = \"responses\",\n                    ApiKey = azureApiKey\n                },\n                Streaming = true\n            });\n\n            var fullResponse = new System.Text.StringBuilder();\n\n            // Subscribe to streaming events\n            session.On((SessionEvent evt) =>\n            {\n                if (evt.Type == SessionEventType.AssistantMessageDelta && \n                    evt.Data?.DeltaContent != null)\n                {\n                    var delta = evt.Data.DeltaContent;\n                    fullResponse.Append(delta);\n                    onDelta(delta);\n                }\n            });\n\n            _logger.LogInformation(\"Sending prompt with streaming enabled\");\n\n            await session.SendAndWaitAsync(new MessageOptions\n            {\n                Prompt = prompt\n            });\n\n            return fullResponse.ToString();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error during streaming communication with Azure OpenAI\");\n            throw;\n        }\n    }\n}\n```\n\nNow let me create the configuration file and a console application example:\n\n```json\n{\n  \"AzureOpenAI\": {\n    \"Endpoint\": \"https://your-resource.openai.azure.com/\",\n    \"ApiKey\": \"your-api-key-here\",\n    \"DeploymentName\": \"gpt-4\"\n  },\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  }\n}\n```\n\n```csharp\nusing App.Services;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\n\nnamespace App;\n\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        // Build configuration\n        var configuration = new ConfigurationBuilder()\n            .SetBasePath(Directory.GetCurrentDirectory())\n            .AddJsonFile(\"appsettings.json\", optional: false)\n            .AddEnvironmentVariables()\n            .Build();\n\n        // Setup dependency injection\n        var services = new ServiceCollection();\n        services.AddLogging(builder =>\n        {\n            builder.AddConsole();\n            builder.SetMinimumLevel(LogLevel.Information);\n        });\n        services.AddSingleton<IConfiguration>(configuration);\n        services.AddScoped<CopilotAzureService>();\n\n        var serviceProvider = services.BuildServiceProvider();\n\n        // Get service and execute\n        var copilotService = serviceProvider.GetRequiredService<CopilotAzureService>();\n\n        Console.WriteLine(\"=== Non-Streaming Example ===\");\n        var response = await copilotService.SendPromptAsync(\"What is 2 + 2? Explain briefly.\");\n        Console.WriteLine($\"Response: {response}\");\n\n        Console.WriteLine(\"\\n=== Streaming Example ===\");\n        Console.Write(\"Response: \");\n        await copilotService.SendPromptWithStreamingAsync(\n            \"Tell me a short joke about programming.\",\n            delta => Console.Write(delta)\n        );\n        Console.WriteLine();\n\n        Console.WriteLine(\"\\nPress any key to exit...\");\n        Console.ReadKey();\n    }\n}\n```\n\nKey features of this implementation:\n\n1. **Proper async/await disposal**: Uses `await using` for both `CopilotClient` and session objects\n2. **Azure OpenAI BYOK**: Configured with `Type = \"azure\"` and proper endpoint\n3. **Responses wire API**: Uses `WireApi = \"responses\"` for GPT-5 series compatibility\n4. **Configuration management**: Reads Azure credentials from appsettings.json\n5. **Error handling**: Comprehensive try-catch with logging\n6. **Two modes**: Non-streaming and streaming implementations\n7. **Dependency injection**: Follows .NET best practices with ILogger and IConfiguration\n\nTo use this:\n\n1. Install the NuGet package: `dotnet add package GitHub.Copilot.SDK`\n2. Update `appsettings.json` with your Azure OpenAI credentials\n3. Ensure you have the GitHub Copilot CLI installed\n4. Run the application\n\nThe service can be easily integrated into your existing ASP.NET Core API by registering it in your DI container.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5011,
            "output_tokens": 1958,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# GitHub Copilot SDK with Azure OpenAI BYOK Session\n\nHere's a complete C# .NET application that demonstrates using the GitHub Copilot SDK with Azure OpenAI:\n\n```csharp\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace CopilotAzureOpenAIDemo\n{\n    public class Program\n    {\n        private const string GITHUB_TOKEN = \"your_github_token_here\";\n        private const string AZURE_OPENAI_ENDPOINT = \"https://your-resource.openai.azure.com\";\n        private const string AZURE_OPENAI_KEY = \"your_azure_openai_key_here\";\n        private const string AZURE_DEPLOYMENT_NAME = \"gpt-4\"; // or your deployment name\n\n        public static async Task Main(string[] args)\n        {\n            try\n            {\n                await RunCopilotSessionAsync();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Error: {ex.Message}\");\n                Console.WriteLine($\"Stack trace: {ex.StackTrace}\");\n            }\n        }\n\n        private static async Task RunCopilotSessionAsync()\n        {\n            using var httpClient = new HttpClient();\n            \n            // Step 1: Create BYOK session\n            Console.WriteLine(\"Creating BYOK session...\");\n            var sessionToken = await CreateBYOKSessionAsync(httpClient);\n            Console.WriteLine($\"Session created successfully\");\n\n            // Step 2: Send prompt using Responses wire API\n            Console.WriteLine(\"\\nSending prompt to Copilot...\");\n            await SendPromptAndHandleResponseAsync(httpClient, sessionToken);\n        }\n\n        private static async Task<string> CreateBYOKSessionAsync(HttpClient httpClient)\n        {\n            var byokRequest = new\n            {\n                azure_openai = new\n                {\n                    endpoint = AZURE_OPENAI_ENDPOINT,\n                    deployment_name = AZURE_DEPLOYMENT_NAME,\n                    api_key = AZURE_OPENAI_KEY\n                }\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Post, \n                \"https://api.github.com/copilot_internal/v2/sessions/byok\");\n            \n            request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", GITHUB_TOKEN);\n            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            request.Headers.UserAgent.Add(new ProductInfoHeaderValue(\"CopilotDemo\", \"1.0\"));\n            \n            var jsonContent = JsonSerializer.Serialize(byokRequest);\n            request.Content = new StringContent(jsonContent, Encoding.UTF8, \"application/json\");\n\n            using var response = await httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            var sessionResponse = JsonSerializer.Deserialize<BYOKSessionResponse>(responseContent);\n\n            return sessionResponse?.session_token ?? throw new Exception(\"Failed to get session token\");\n        }\n\n        private static async Task SendPromptAndHandleResponseAsync(HttpClient httpClient, string sessionToken)\n        {\n            var promptRequest = new\n            {\n                messages = new[]\n                {\n                    new\n                    {\n                        role = \"system\",\n                        content = \"You are a helpful coding assistant.\"\n                    },\n                    new\n                    {\n                        role = \"user\",\n                        content = \"Write a simple C# function to calculate factorial.\"\n                    }\n                },\n                model = \"gpt-4\",\n                temperature = 0.7,\n                max_tokens = 500,\n                stream = false\n            };\n\n            var request = new HttpRequestMessage(HttpMethod.Post,\n                \"https://api.github.com/copilot_internal/v2/responses\");\n\n            request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", sessionToken);\n            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            request.Headers.UserAgent.Add(new ProductInfoHeaderValue(\"CopilotDemo\", \"1.0\"));\n\n            var jsonContent = JsonSerializer.Serialize(promptRequest);\n            request.Content = new StringContent(jsonContent, Encoding.UTF8, \"application/json\");\n\n            using var response = await httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            \n            Console.WriteLine(\"\\n=== Response ===\");\n            var copilotResponse = JsonSerializer.Deserialize<CopilotResponse>(responseContent);\n            \n            if (copilotResponse?.choices != null && copilotResponse.choices.Length > 0)\n            {\n                var message = copilotResponse.choices[0].message?.content;\n                Console.WriteLine(message);\n                Console.WriteLine($\"\\nTokens used: {copilotResponse.usage?.total_tokens ?? 0}\");\n            }\n            else\n            {\n                Console.WriteLine(\"No response received\");\n            }\n        }\n    }\n\n    // Response models\n    public class BYOKSessionResponse\n    {\n        public string? session_token { get; set; }\n        public long? expires_at { get; set; }\n    }\n\n    public class CopilotResponse\n    {\n        public string? id { get; set; }\n        public string? @object { get; set; }\n        public long created { get; set; }\n        public string? model { get; set; }\n        public Choice[]? choices { get; set; }\n        public Usage? usage { get; set; }\n    }\n\n    public class Choice\n    {\n        public int index { get; set; }\n        public Message? message { get; set; }\n        public string? finish_reason { get; set; }\n    }\n\n    public class Message\n    {\n        public string? role { get; set; }\n        public string? content { get; set; }\n    }\n\n    public class Usage\n    {\n        public int prompt_tokens { get; set; }\n        public int completion_tokens { get; set; }\n        public int total_tokens { get; set; }\n    }\n}\n```\n\n## Enhanced Version with Streaming Support\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace CopilotAzureOpenAIDemo.Streaming\n{\n    public class StreamingCopilotClient : IAsyncDisposable\n    {\n        private readonly HttpClient _httpClient;\n        private readonly string _githubToken;\n        private string? _sessionToken;\n        private bool _disposed;\n\n        public StreamingCopilotClient(string githubToken)\n        {\n            _githubToken = githubToken ?? throw new ArgumentNullException(nameof(githubToken));\n            _httpClient = new HttpClient\n            {\n                Timeout = TimeSpan.FromMinutes(5)\n            };\n        }\n\n        public async Task InitializeSessionAsync(\n            string azureEndpoint,\n            string azureApiKey,\n            string deploymentName)\n        {\n            if (_disposed)\n                throw new ObjectDisposedException(nameof(StreamingCopilotClient));\n\n            var byokRequest = new\n            {\n                azure_openai = new\n                {\n                    endpoint = azureEndpoint,\n                    deployment_name = deploymentName,\n                    api_key = azureApiKey\n                }\n            };\n\n            using var request = new HttpRequestMessage(HttpMethod.Post,\n                \"https://api.github.com/copilot_internal/v2/sessions/byok\");\n\n            request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", _githubToken);\n            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            request.Headers.UserAgent.Add(new ProductInfoHeaderValue(\"CopilotClient\", \"1.0\"));\n\n            var jsonContent = JsonSerializer.Serialize(byokRequest);\n            request.Content = new StringContent(jsonContent, Encoding.UTF8, \"application/json\");\n\n            using var response = await _httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            var sessionResponse = JsonSerializer.Deserialize<BYOKSessionResponse>(responseContent);\n\n            _sessionToken = sessionResponse?.session_token \n                ?? throw new Exception(\"Failed to create BYOK session\");\n        }\n\n        public async Task<string> SendPromptAsync(\n            string systemPrompt,\n            string userPrompt,\n            double temperature = 0.7,\n            int maxTokens = 500)\n        {\n            if (_disposed)\n                throw new ObjectDisposedException(nameof(StreamingCopilotClient));\n\n            if (string.IsNullOrEmpty(_sessionToken))\n                throw new InvalidOperationException(\"Session not initialized. Call InitializeSessionAsync first.\");\n\n            var promptRequest = new\n            {\n                messages = new[]\n                {\n                    new { role = \"system\", content = systemPrompt },\n                    new { role = \"user\", content = userPrompt }\n                },\n                temperature,\n                max_tokens = maxTokens,\n                stream = false\n            };\n\n            using var request = new HttpRequestMessage(HttpMethod.Post,\n                \"https://api.github.com/copilot_internal/v2/responses\");\n\n            request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", _sessionToken);\n            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            request.Headers.UserAgent.Add(new ProductInfoHeaderValue(\"CopilotClient\", \"1.0\"));\n\n            var jsonContent = JsonSerializer.Serialize(promptRequest);\n            request.Content = new StringContent(jsonContent, Encoding.UTF8, \"application/json\");\n\n            using var response = await _httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            var copilotResponse = JsonSerializer.Deserialize<CopilotResponse>(responseContent);\n\n            return copilotResponse?.choices?[0]?.message?.content \n                ?? throw new Exception(\"No response content received\");\n        }\n\n        public async Task SendPromptStreamAsync(\n            string systemPrompt,\n            string userPrompt,\n            Action<string> onChunkReceived,\n            double temperature = 0.7,\n            int maxTokens = 500)\n        {\n            if (_disposed)\n                throw new ObjectDisposedException(nameof(StreamingCopilotClient));\n\n            if (string.IsNullOrEmpty(_sessionToken))\n                throw new InvalidOperationException(\"Session not initialized.\");\n\n            var promptRequest = new\n            {\n                messages = new[]\n                {\n                    new { role = \"system\", content = systemPrompt },\n                    new { role = \"user\", content = userPrompt }\n                },\n                temperature,\n                max_tokens = maxTokens,\n                stream = true\n            };\n\n            using var request = new HttpRequestMessage(HttpMethod.Post,\n                \"https://api.github.com/copilot_internal/v2/responses\");\n\n            request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", _sessionToken);\n            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"text/event-stream\"));\n            request.Headers.UserAgent.Add(new ProductInfoHeaderValue(\"CopilotClient\", \"1.0\"));\n\n            var jsonContent = JsonSerializer.Serialize(promptRequest);\n            request.Content = new StringContent(jsonContent, Encoding.UTF8, \"application/json\");\n\n            using var response = await _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);\n            response.EnsureSuccessStatusCode();\n\n            await using var stream = await response.Content.ReadAsStreamAsync();\n            using var reader = new StreamReader(stream);\n\n            while (!reader.EndOfStream)\n            {\n                var line = await reader.ReadLineAsync();\n                \n                if (string.IsNullOrWhiteSpace(line))\n                    continue;\n\n                if (line.StartsWith(\"data: \"))\n                {\n                    var data = line.Substring(6);\n                    \n                    if (data == \"[DONE]\")\n                        break;\n\n                    try\n                    {\n                        var chunk = JsonSerializer.Deserialize<StreamChunk>(data);\n                        var content = chunk?.choices?[0]?.delta?.content;\n                        \n                        if (!string.IsNullOrEmpty(content))\n                        {\n                            onChunkReceived(content);\n                        }\n                    }\n                    catch (JsonException)\n                    {\n                        // Skip malformed JSON chunks\n                        continue;\n                    }\n                }\n            }\n        }\n\n        public async ValueTask DisposeAsync()\n        {\n            if (_disposed)\n                return;\n\n            _httpClient?.Dispose();\n            _disposed = true;\n\n            await Task.CompletedTask;\n        }\n    }\n\n    public class StreamChunk\n    {\n        public StreamChoice[]? choices { get; set; }\n    }\n\n    public class StreamChoice\n    {\n        public int index { get; set; }\n        public Delta? delta { get; set; }\n    }\n\n    public class Delta\n    {\n        public string? content { get; set; }\n    }\n\n    // Example usage\n    public class StreamingExample\n    {\n        public static async Task Main(string[] args)\n        {\n            const string githubToken = \"your_github_token\";\n            const string azureEndpoint = \"https://your-resource.openai.azure.com\";\n            const string azureApiKey = \"your_azure_key\";\n            const string deploymentName = \"gpt-4\";\n\n            await using var client = new StreamingCopilotClient(githubToken);\n\n            try\n            {\n                // Initialize session\n                Console.WriteLine(\"Initializing BYOK session...\");\n                await client.InitializeSessionAsync(azureEndpoint, azureApiKey, deploymentName);\n                Console.WriteLine(\"Session initialized successfully!\\n\");\n\n                // Non-streaming request\n                Console.WriteLine(\"=== Non-Streaming Response ===\");\n                var response = await client.SendPromptAsync(\n                    \"You are a helpful coding assistant.\",\n                    \"Write a C# function to reverse a string.\",\n                    temperature: 0.7,\n                    maxTokens: 300\n                );\n                Console.WriteLine(response);\n                Console.WriteLine();\n\n                // Streaming request\n                Console.WriteLine(\"=== Streaming Response ===\");\n                await client.SendPromptStreamAsync(\n                    \"You are a helpful coding assistant.\",\n                    \"Explain async/await in C# in simple terms.\",\n                    chunk => Console.Write(chunk),\n                    temperature: 0.7,\n                    maxTokens: 300\n                );\n                Console.WriteLine(\"\\n\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Error: {ex.Message}\");\n                if (ex.InnerException != null)\n                {\n                    Console.WriteLine($\"Inner exception: {ex.InnerException.Message}\");\n                }\n            }\n        }\n    }\n}\n```\n\n## Configuration with appsettings.json\n\n```json\n{\n  \"CopilotSettings\": {\n    \"GitHubToken\": \"your_github_token_here\",\n    \"AzureOpenAI\": {\n      \"Endpoint\": \"https://your-resource.openai.azure.com\",\n      \"ApiKey\": \"your_azure_openai_key_here\",\n      \"DeploymentName\": \"gpt-4\"\n    }\n  }\n}\n```\n\n## Configuration Helper Class\n\n```csharp\nusing Microsoft.Extensions.Configuration;\nusing System;\nusing System.IO;\n\nnamespace CopilotAzureOpenAIDemo\n{\n    public class CopilotConfiguration\n    {\n        public string GitHubToken { get; set; } = string.Empty;\n        public AzureOpenAISettings AzureOpenAI { get; set; } = new();\n\n        public static CopilotConfiguration LoadFromAppSettings()\n        {\n            var configuration = new ConfigurationBuilder()\n                .SetBasePath(Directory.GetCurrentDirectory())\n                .AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: true)\n                .AddJsonFile(\"appsettings.Development.json\", optional",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 60,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure OpenAI BYOK with GitHub Copilot SDK\n\nHere's a complete C# .NET application demonstrating BYOK with Azure OpenAI using the Responses wire API:\n\n```csharp\nusing GitHub.Copilot.SDK;\nusing Microsoft.Extensions.Configuration;\n\nnamespace CopilotAzureOpenAIDemo;\n\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        // Load configuration from appsettings.json or environment variables\n        var configuration = new ConfigurationBuilder()\n            .AddJsonFile(\"appsettings.json\", optional: true)\n            .AddEnvironmentVariables()\n            .Build();\n\n        var azureEndpoint = configuration[\"AzureOpenAI:Endpoint\"] \n            ?? throw new InvalidOperationException(\"Azure OpenAI endpoint not configured\");\n        var apiKey = configuration[\"AzureOpenAI:ApiKey\"] \n            ?? throw new InvalidOperationException(\"Azure OpenAI API key not configured\");\n        var deploymentName = configuration[\"AzureOpenAI:DeploymentName\"] ?? \"gpt-4\";\n\n        Console.WriteLine(\"Starting Azure OpenAI BYOK session with GitHub Copilot SDK...\\n\");\n\n        try\n        {\n            // Create and configure the Copilot client\n            await using var client = new CopilotClient(new CopilotClientOptions\n            {\n                LogLevel = \"info\"\n            });\n\n            Console.WriteLine(\"Creating session with Azure OpenAI provider...\");\n\n            // Create session with Azure OpenAI BYOK provider\n            await using var session = await client.CreateSessionAsync(new SessionConfig\n            {\n                Model = deploymentName,\n                Streaming = true,\n                Provider = new ProviderConfig\n                {\n                    Type = \"azure\",\n                    BaseUrl = azureEndpoint,\n                    ApiKey = apiKey,\n                    WireApi = \"responses\" // Use Responses API for GPT-4/GPT-5 series\n                }\n            });\n\n            Console.WriteLine(\"Session created successfully!\\n\");\n\n            // Subscribe to streaming events\n            var responseBuilder = new System.Text.StringBuilder();\n            var isFirstChunk = true;\n\n            session.OnEvent((sessionEvent) =>\n            {\n                switch (sessionEvent.Type)\n                {\n                    case SessionEventType.AssistantMessageDelta:\n                        if (isFirstChunk)\n                        {\n                            Console.Write(\"Assistant: \");\n                            isFirstChunk = false;\n                        }\n                        Console.Write(sessionEvent.Data.DeltaContent);\n                        responseBuilder.Append(sessionEvent.Data.DeltaContent);\n                        break;\n\n                    case SessionEventType.SessionIdle:\n                        Console.WriteLine(\"\\n\");\n                        break;\n\n                    case SessionEventType.ErrorOccurred:\n                        Console.WriteLine($\"\\nError: {sessionEvent.Data.Message}\");\n                        break;\n                }\n            });\n\n            // Send prompts and handle responses\n            await SendPromptAsync(session, \"What is the capital of France?\");\n            await SendPromptAsync(session, \"Explain async/await in C# in one sentence.\");\n            await SendPromptAsync(session, \"Write a haiku about programming.\");\n\n            Console.WriteLine(\"Demo completed successfully!\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Error: {ex.Message}\");\n            Console.WriteLine($\"Stack trace: {ex.StackTrace}\");\n            Environment.Exit(1);\n        }\n    }\n\n    private static async Task SendPromptAsync(CopilotSession session, string prompt)\n    {\n        Console.WriteLine($\"User: {prompt}\");\n        \n        var response = await session.SendAndWaitAsync(new MessageOptions\n        {\n            Prompt = prompt\n        });\n\n        // Response content is already printed via streaming events\n        // But we can access the final response if needed\n        if (response?.Data?.Content != null)\n        {\n            Console.WriteLine($\"[Response received: {response.Data.Content.Length} characters]\");\n        }\n\n        Console.WriteLine(new string('-', 80));\n    }\n}\n```\n\n## Configuration File (appsettings.json)\n\n```json\n{\n  \"AzureOpenAI\": {\n    \"Endpoint\": \"https://your-resource.openai.azure.com/openai/deployments/gpt-4/chat/completions?api-version=2024-08-01-preview\",\n    \"ApiKey\": \"your-api-key-here\",\n    \"DeploymentName\": \"gpt-4\"\n  }\n}\n```\n\n## Project File (CopilotAzureOpenAIDemo.csproj)\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"GitHub.Copilot.SDK\" Version=\"*\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration.Json\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration.EnvironmentVariables\" Version=\"8.0.0\" />\n  </ItemGroup>\n\n  <ItemGroup>\n    <None Update=\"appsettings.json\">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n  </ItemGroup>\n\n</Project>\n```\n\n## Advanced Example with Error Handling and Non-Streaming\n\n```csharp\nusing GitHub.Copilot.SDK;\n\nnamespace CopilotAzureOpenAIAdvanced;\n\npublic class AdvancedExample\n{\n    public static async Task RunAsync()\n    {\n        await using var client = new CopilotClient();\n\n        // Non-streaming session for simpler response handling\n        await using var session = await client.CreateSessionAsync(new SessionConfig\n        {\n            Model = \"gpt-4\",\n            Streaming = false, // Disable streaming for complete responses\n            Provider = new ProviderConfig\n            {\n                Type = \"azure\",\n                BaseUrl = Environment.GetEnvironmentVariable(\"AZURE_OPENAI_ENDPOINT\")!,\n                ApiKey = Environment.GetEnvironmentVariable(\"AZURE_OPENAI_KEY\")!,\n                WireApi = \"responses\"\n            },\n            SystemMessage = new SystemMessage\n            {\n                Content = \"You are a helpful assistant that provides concise answers.\"\n            }\n        });\n\n        try\n        {\n            var response = await session.SendAndWaitAsync(new MessageOptions\n            {\n                Prompt = \"Explain dependency injection in .NET\"\n            });\n\n            if (response?.Data?.Content != null)\n            {\n                Console.WriteLine($\"Response: {response.Data.Content}\");\n                Console.WriteLine($\"Tokens used: {response.Data.Usage?.TotalTokens ?? 0}\");\n            }\n        }\n        catch (CopilotException ex)\n        {\n            Console.WriteLine($\"Copilot error: {ex.Message}\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Unexpected error: {ex.Message}\");\n        }\n    }\n}\n```\n\n## Environment Variables Setup\n\n```bash\n# Option 1: Set environment variables\nexport AZURE_OPENAI_ENDPOINT=\"https://your-resource.openai.azure.com/openai/deployments/gpt-4/chat/completions?api-version=2024-08-01-preview\"\nexport AZURE_OPENAI_KEY=\"your-api-key\"\n\n# Option 2: Use .NET user secrets (recommended for development)\ndotnet user-secrets init\ndotnet user-secrets set \"AzureOpenAI:Endpoint\" \"https://your-resource.openai.azure.com/...\"\ndotnet user-secrets set \"AzureOpenAI:ApiKey\" \"your-api-key\"\n```\n\n## Key Points\n\n1. **Async/Await Disposal**: Uses `await using` for proper async disposal of `CopilotClient` and `CopilotSession`\n\n2. **Azure Provider Type**: Uses `\"azure\"` type (not `\"openai\"`) for native Azure endpoints\n\n3. **Responses Wire API**: Specifies `WireApi = \"responses\"` for GPT-4/GPT-5 series models\n\n4. **Endpoint Format**: Azure endpoint should NOT include `/openai/v1` suffix (unlike OpenAI-compatible endpoints)\n\n5. **Streaming Events**: Handles `AssistantMessageDelta` for real-time output and `SessionIdle` for completion\n\n6. **Configuration**: Supports both appsettings.json and environment variables for flexibility\n\n7. **Error Handling**: Includes try-catch blocks for graceful error management\n\n## Running the Application\n\n```bash\n# Restore packages\ndotnet restore\n\n# Run the application\ndotnet run\n\n# Or build and run\ndotnet build\ndotnet run --project CopilotAzureOpenAIDemo.csproj\n```\n\nThis implementation follows .NET best practices with proper resource disposal, configuration management, and async patterns while leveraging the GitHub Copilot SDK's BYOK capabilities with Azure OpenAI.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4505,
            "output_tokens": 2296,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a C# .NET console application that uses the GitHub Copilot SDK with Azure OpenAI BYOK provider.\n\nFirst, let me create the project structure:\n\n```csharp\n// Program.cs\nusing GitHub.Copilot.SDK;\nusing Microsoft.Extensions.Configuration;\n\nvar configuration = new ConfigurationBuilder()\n    .SetBasePath(Directory.GetCurrentDirectory())\n    .AddJsonFile(\"appsettings.json\", optional: false)\n    .AddEnvironmentVariables()\n    .Build();\n\nvar azureEndpoint = configuration[\"AzureOpenAI:Endpoint\"] \n    ?? throw new InvalidOperationException(\"Azure OpenAI endpoint not configured\");\nvar apiKey = configuration[\"AzureOpenAI:ApiKey\"] \n    ?? throw new InvalidOperationException(\"Azure OpenAI API key not configured\");\nvar deploymentName = configuration[\"AzureOpenAI:DeploymentName\"] ?? \"gpt-4\";\n\nConsole.WriteLine(\"Initializing GitHub Copilot SDK with Azure OpenAI BYOK...\\n\");\n\nawait using var client = new CopilotClient(new CopilotClientOptions\n{\n    LogLevel = \"info\"\n});\n\ntry\n{\n    // Create session with Azure OpenAI BYOK provider using Responses wire API\n    await using var session = await client.CreateSessionAsync(new SessionConfig\n    {\n        Model = deploymentName,\n        Provider = new ProviderConfig\n        {\n            Type = \"openai\", // Use OpenAI-compatible mode for Responses API\n            BaseUrl = azureEndpoint,\n            ApiKey = apiKey,\n            WireApi = \"responses\" // Required for GPT-5 series and newer models\n        },\n        Streaming = true\n    });\n\n    Console.WriteLine($\"Session created with ID: {session.SessionId}\");\n    Console.WriteLine($\"Using Azure OpenAI deployment: {deploymentName}\\n\");\n\n    // Subscribe to streaming events\n    var responseBuilder = new System.Text.StringBuilder();\n    \n    session.On((SessionEvent evt) =>\n    {\n        switch (evt.Type)\n        {\n            case SessionEventType.AssistantMessageDelta:\n                var deltaContent = evt.Data.DeltaContent;\n                if (!string.IsNullOrEmpty(deltaContent))\n                {\n                    Console.Write(deltaContent);\n                    responseBuilder.Append(deltaContent);\n                }\n                break;\n\n            case SessionEventType.SessionIdle:\n                Console.WriteLine(\"\\n\\n[Session idle - response complete]\");\n                break;\n\n            case SessionEventType.ErrorOccurred:\n                Console.WriteLine($\"\\n[Error: {evt.Data.Error?.Message}]\");\n                break;\n        }\n    });\n\n    // Send prompt and wait for completion\n    var prompt = \"Explain what Azure OpenAI Service is in 2-3 sentences.\";\n    Console.WriteLine($\"Prompt: {prompt}\\n\");\n    Console.WriteLine(\"Response:\");\n    Console.WriteLine(\"---\");\n\n    var response = await session.SendAndWaitAsync(new MessageOptions\n    {\n        Prompt = prompt\n    });\n\n    Console.WriteLine(\"---\\n\");\n\n    // Display final response metadata\n    if (response?.Data != null)\n    {\n        Console.WriteLine($\"Response ID: {response.Data.Id}\");\n        Console.WriteLine($\"Model used: {response.Data.Model}\");\n        Console.WriteLine($\"Finish reason: {response.Data.FinishReason}\");\n        \n        if (response.Data.Usage != null)\n        {\n            Console.WriteLine($\"Tokens - Prompt: {response.Data.Usage.PromptTokens}, \" +\n                            $\"Completion: {response.Data.Usage.CompletionTokens}, \" +\n                            $\"Total: {response.Data.Usage.TotalTokens}\");\n        }\n    }\n\n    Console.WriteLine(\"\\nFull response text:\");\n    Console.WriteLine(responseBuilder.ToString());\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"\\nError occurred: {ex.Message}\");\n    Console.WriteLine($\"Stack trace: {ex.StackTrace}\");\n    throw;\n}\nfinally\n{\n    Console.WriteLine(\"\\nCleaning up resources...\");\n}\n\nConsole.WriteLine(\"Application completed successfully.\");\n```\n\n```json\n// appsettings.json\n{\n  \"AzureOpenAI\": {\n    \"Endpoint\": \"https://your-resource.openai.azure.com/openai/v1/\",\n    \"ApiKey\": \"your-api-key-here\",\n    \"DeploymentName\": \"gpt-4\"\n  }\n}\n```\n\n```xml\n<!-- CopilotBYOKDemo.csproj -->\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <PropertyGroup>\n    <OutputType>Exe</OutputType>\n    <TargetFramework>net8.0</TargetFramework>\n    <ImplicitUsings>enable</ImplicitUsings>\n    <Nullable>enable</Nullable>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"GitHub.Copilot.SDK\" Version=\"*\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration.Json\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Configuration.EnvironmentVariables\" Version=\"8.0.0\" />\n  </ItemGroup>\n\n  <ItemGroup>\n    <None Update=\"appsettings.json\">\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n    </None>\n  </ItemGroup>\n\n</Project>\n```\n\n```markdown\n<!-- README.md -->\n# GitHub Copilot SDK - Azure OpenAI BYOK Demo\n\nThis application demonstrates using the GitHub Copilot SDK with Azure OpenAI as a BYOK (Bring Your Own Key) provider.\n\n## Prerequisites\n\n- .NET 8.0 SDK\n- GitHub Copilot CLI installed (`copilot --version`)\n- Azure OpenAI resource with a deployed model\n\n## Configuration\n\nUpdate `appsettings.json` with your Azure OpenAI credentials:\n\n```json\n{\n  \"AzureOpenAI\": {\n    \"Endpoint\": \"https://your-resource.openai.azure.com/openai/v1/\",\n    \"ApiKey\": \"your-api-key-here\",\n    \"DeploymentName\": \"gpt-4\"\n  }\n}\n```\n\n**Important:** The endpoint should include `/openai/v1/` suffix for OpenAI-compatible mode.\n\nAlternatively, use environment variables:\n- `AzureOpenAI__Endpoint`\n- `AzureOpenAI__ApiKey`\n- `AzureOpenAI__DeploymentName`\n\n## Running\n\n```bash\ndotnet restore\ndotnet run\n```\n\n## Key Features\n\n- **BYOK Provider**: Uses your Azure OpenAI subscription (no GitHub Copilot subscription needed)\n- **Responses Wire API**: Uses `\"responses\"` wire API for GPT-5 series compatibility\n- **Streaming**: Real-time response streaming with event handling\n- **Async/Await**: Proper async disposal patterns with `await using`\n- **Error Handling**: Comprehensive exception handling\n- **Configuration**: Flexible configuration via JSON and environment variables\n\n## Wire API Notes\n\n- Use `\"responses\"` for GPT-5 series models\n- Use `\"completions\"` (default) for older models\n- The endpoint format differs between wire APIs\n```\n\nKey implementation details:\n\n1. **BYOK Configuration**: Uses `type: \"openai\"` with Azure endpoint for OpenAI-compatible mode\n2. **Responses Wire API**: Explicitly sets `WireApi = \"responses\"` for newer models\n3. **Async Disposal**: Uses `await using` for both client and session to ensure proper cleanup\n4. **Streaming**: Subscribes to `AssistantMessageDelta` events for real-time output\n5. **Error Handling**: Catches exceptions and displays detailed error information\n6. **Configuration**: Loads settings from `appsettings.json` with environment variable override support\n\nThe application creates a session, sends a prompt, streams the response in real-time, and displays metadata about token usage and completion status.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5011,
            "output_tokens": 2015,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "copilot-sdk-04",
      "task_type": "grounded",
      "target_language": "python",
      "expected_patterns": [
        "await client\\.start\\(\\)",
        "await client\\.create_session",
        "await session\\.send_and_wait",
        "await client\\.stop\\(\\)",
        "asyncio\\.run"
      ],
      "anti_patterns": [
        "client\\.createSession",
        "session\\.sendAndWait",
        "client\\.Stop\\(\\)",
        "client\\.CreateSession"
      ],
      "pattern_sources": [
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/python/README.md",
          "description": "Python Copilot SDK: await client.start(), await client.create_session(), await session.send_and_wait(), await client.stop(), asyncio patterns"
        },
        {
          "url": "https://docs.python.org/3/library/asyncio.html",
          "description": "Python asyncio.run() for running async main functions"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/docs/getting-started.md",
          "description": "Anti-patterns: TypeScript camelCase client.createSession, session.sendAndWait that should not appear in Python"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/dotnet/README.md",
          "description": "Anti-patterns: .NET PascalCase client.Stop(), client.CreateSession that should not appear in Python"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "Here's the fixed version of the code with explanations of the bugs:\n\n```python\nfrom copilot import CopilotClient\nfrom copilot.tools import define_tool\nimport asyncio\n\nasync def main():\n    client = CopilotClient()\n    \n    # Bug fix 1: Define tool before creating session\n    @define_tool(description=\"Look up user info\")\n    async def lookup_user(user_id: int) -> dict:\n        \"\"\"Look up user info by ID\"\"\"\n        return {\"name\": \"Alice\", \"role\": \"admin\"}\n    \n    # Bug fix 2: Pass tools to session configuration\n    session = await client.create_session({\n        \"model\": \"gpt-4\",  # Bug fix 3: Use valid model name\n        \"streaming\": True,\n        \"tools\": [lookup_user]\n    })\n    \n    try:\n        # Bug fix 4: Use async event handler for async context\n        async def handle_delta(event):\n            if hasattr(event.data, 'delta_content') and event.data.delta_content:\n                print(event.data.delta_content, end='', flush=True)\n        \n        session.on(\"assistant.message_delta\", handle_delta)\n        \n        # Bug fix 5: Use send() for streaming, not send_and_wait()\n        await session.send({\"prompt\": \"Who is user 42?\"})\n        \n        # Bug fix 6: Wait for stream to complete\n        async for event in session.stream():\n            if event.type == \"assistant.message_completed\":\n                print(\"\\n\" + event.data.content)\n                break\n            elif event.type == \"tool.call_requested\":\n                # Bug fix 7: Handle tool calls explicitly\n                result = await lookup_user(event.data.arguments.get(\"user_id\"))\n                await session.send_tool_result(event.data.call_id, result)\n    \n    finally:\n        # Bug fix 8: Properly close session and client\n        await session.close()\n        await client.close()\n\n# Bug fix 9: Run async main properly\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n**Key bugs fixed:**\n\n1. **Tool definition timing** - Tools must be defined before session creation\n2. **Tools not registered** - Tools must be passed to session config\n3. **Invalid model name** - \"gpt-4.1\" doesn't exist, use \"gpt-4\"\n4. **Missing await** - `create_session()` is async\n5. **Wrong method for streaming** - Use `send()` + `stream()`, not `send_and_wait()`\n6. **No stream consumption** - Must iterate through stream events\n7. **Tool calls not handled** - Need to respond to tool call requests\n8. **No cleanup** - Must close session and client\n9. **Missing asyncio.run()** - Async main needs proper execution",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 218,
            "output_tokens": 697,
            "cached": false
          },
          "with_skill": {
            "output": "Here's the corrected version with all bugs fixed:\n\n```python\nimport asyncio\nimport sys\nfrom copilot import CopilotClient\nfrom copilot.tools import define_tool\nfrom copilot.generated.session_events import SessionEventType\nfrom pydantic import BaseModel, Field\n\n# Define tool BEFORE main() - tools must be defined at module level\nclass LookupUserParams(BaseModel):\n    user_id: str = Field(description=\"The user ID to look up\")\n\n@define_tool(description=\"Look up user info\")\nasync def lookup_user(params: LookupUserParams) -> dict:\n    return {\"name\": \"Alice\", \"role\": \"admin\", \"user_id\": params.user_id}\n\nasync def main():\n    # Bug 1: Missing client.start() - client must be started before use\n    client = CopilotClient()\n    await client.start()\n    \n    try:\n        # Bug 2: Missing await on create_session\n        # Bug 3: Tool must be passed in session config, not defined inside\n        session = await client.create_session({\n            \"model\": \"gpt-4.1\",\n            \"streaming\": True,\n            \"tools\": [lookup_user]  # Pass the tool here\n        })\n        \n        # Bug 4: Event handler syntax - Python uses a single handler function\n        # that checks event type, not separate event name subscriptions\n        def handle_event(event):\n            if event.type == SessionEventType.ASSISTANT_MESSAGE_DELTA:\n                # Bug 5: Use sys.stdout.write for streaming without newlines\n                sys.stdout.write(event.data.delta_content)\n                sys.stdout.flush()\n            elif event.type == SessionEventType.SESSION_IDLE:\n                # Print newline when done\n                print()\n        \n        session.on(handle_event)\n        \n        # Bug 6: Missing await on send_and_wait\n        response = await session.send_and_wait({\"prompt\": \"Who is user 42?\"})\n        \n        # Bug 7: With streaming enabled, final content may be empty\n        # The content was already printed via delta events\n        if response and response.data.content:\n            print(f\"\\nFinal response: {response.data.content}\")\n    \n    finally:\n        # Bug 8: Missing client.stop() - must clean up resources\n        await client.stop()\n\n# Bug 9: Missing asyncio.run() to execute async main\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n**Key fixes:**\n\n1. **Added `await client.start()`** - Client must be started before creating sessions\n2. **Added `await` to `create_session()`** - It's an async operation\n3. **Moved tool definition outside `main()`** - Tools must be defined at module level with proper Pydantic params\n4. **Added tool to session config** - Tools are passed in `create_session()`, not defined inside\n5. **Fixed event handler** - Python uses single handler with type checking, not per-event subscriptions\n6. **Used `sys.stdout.write()`** - For streaming output without newlines\n7. **Added `await` to `send_and_wait()`** - It's an async operation\n8. **Added `try/finally` with `client.stop()`** - Ensures clean shutdown\n9. **Added `asyncio.run(main())`** - Required to execute async code\n10. **Added proper imports** - `SessionEventType` for event checking, `BaseModel` and `Field` for tool params\n\nThe code now properly:\n- Starts and stops the client\n- Creates a streaming session with a custom tool\n- Handles streaming events correctly\n- Awaits all async operations\n- Cleans up resources",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4663,
            "output_tokens": 899,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "Here's the corrected code with all bugs fixed:\n\n```python\nimport asyncio\nfrom copilot import CopilotClient\nfrom copilot.tools import define_tool\nfrom copilot.generated.session_events import SessionEventType\nfrom pydantic import BaseModel, Field\n\nclass LookupUserParams(BaseModel):\n    user_id: int = Field(description=\"The user ID to look up\")\n\n@define_tool(description=\"Look up user info\")\nasync def lookup_user(params: LookupUserParams) -> dict:\n    return {\"name\": \"Alice\", \"role\": \"admin\"}\n\nasync def main():\n    client = CopilotClient()\n    await client.start()  # Bug 1: Must start client before use\n    \n    try:\n        # Bug 2: Must await create_session\n        session = await client.create_session({\n            \"model\": \"gpt-4.1\",\n            \"streaming\": True,\n            \"tools\": [lookup_user]  # Bug 3: Must pass tools in config\n        })\n        \n        # Bug 4: Event handler must handle all event types or filter properly\n        def handle_event(event):\n            if event.type == SessionEventType.ASSISTANT_MESSAGE_DELTA:\n                print(event.data.delta_content, end=\"\", flush=True)\n        \n        session.on(handle_event)\n        \n        # Bug 5: Must await send_and_wait\n        response = await session.send_and_wait({\"prompt\": \"Who is user 42?\"})\n        print()  # Newline after streaming\n        print(response.data.content)\n        \n    finally:\n        # Bug 6: Must clean up client\n        await client.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n**Key fixes:**\n\n1. **`await client.start()`** - Client must be started before creating sessions\n2. **`await client.create_session()`** - Session creation is async\n3. **`tools: [lookup_user]`** - Tools must be passed in session config, not defined inside\n4. **Proper event handler** - Must handle event object with type checking, not just lambda\n5. **`await session.send_and_wait()`** - Message sending is async\n6. **`await client.stop()`** - Must clean up in finally block\n7. **Tool params** - Added proper Pydantic model with type hints for parameters\n8. **`asyncio.run(main())`** - Added proper async entry point",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5189,
            "output_tokens": 605,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "Here's the fixed version of the code with explanations of the bugs:\n\n```python\nfrom copilot import CopilotClient\nfrom copilot.tools import define_tool\nimport asyncio\n\nasync def main():\n    client = CopilotClient()\n    \n    # Bug fix 1: Define tool before creating session\n    @define_tool(description=\"Look up user info\")\n    async def lookup_user(user_id: str) -> dict:\n        \"\"\"Look up user information by ID\"\"\"\n        return {\"name\": \"Alice\", \"role\": \"admin\"}\n    \n    # Bug fix 2: Pass tools to session and use correct model name\n    session = client.create_session({\n        \"model\": \"gpt-4\",  # Fixed: \"gpt-4.1\" doesn't exist\n        \"streaming\": True,\n        \"tools\": [lookup_user]  # Added: Register the tool\n    })\n    \n    try:\n        # Bug fix 3: Use async event handler for streaming\n        async def handle_delta(event):\n            if hasattr(event.data, 'delta_content') and event.data.delta_content:\n                print(event.data.delta_content, end='', flush=True)\n        \n        session.on(\"assistant.message_delta\", handle_delta)\n        \n        # Bug fix 4: Use await for async operation\n        response = await session.send_and_wait({\n            \"messages\": [{  # Fixed: Use proper message format\n                \"role\": \"user\",\n                \"content\": \"Who is user 42?\"\n            }]\n        })\n        \n        print(\"\\n\")  # New line after streaming\n        \n        # Bug fix 5: Access response content correctly\n        if hasattr(response, 'content'):\n            print(f\"Final response: {response.content}\")\n        \n    finally:\n        # Bug fix 6: Clean up session properly\n        await session.close()\n        await client.close()\n\n# Bug fix 7: Run async main properly\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n**Key bugs fixed:**\n\n1. **Tool definition timing**: Tool must be defined before session creation\n2. **Model name**: Changed `gpt-4.1` to valid `gpt-4`\n3. **Tool registration**: Added `tools` parameter to session config\n4. **Missing await**: Added `await` for async `send_and_wait` call\n5. **Message format**: Used proper message structure with `messages` array\n6. **Event handler**: Made handler async-compatible\n7. **Resource cleanup**: Added proper `close()` calls in finally block\n8. **Async execution**: Added `asyncio.run(main())` to execute properly\n9. **Type hints**: Added parameter type hint to `lookup_user`",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 218,
            "output_tokens": 658,
            "cached": false
          },
          "with_skill": {
            "output": "Here's the corrected version with all bugs fixed:\n\n```python\nimport asyncio\nimport sys\nfrom copilot import CopilotClient\nfrom copilot.tools import define_tool\nfrom copilot.generated.session_events import SessionEventType\nfrom pydantic import BaseModel, Field\n\n# Define tool BEFORE main() - tools must be defined at module level\nclass LookupUserParams(BaseModel):\n    user_id: str = Field(description=\"The user ID to look up\")\n\n@define_tool(description=\"Look up user info\")\nasync def lookup_user(params: LookupUserParams) -> dict:\n    return {\"name\": \"Alice\", \"role\": \"admin\", \"user_id\": params.user_id}\n\nasync def main():\n    # Bug 1: Missing client.start()\n    client = CopilotClient()\n    await client.start()\n    \n    try:\n        # Bug 2: Missing await on create_session\n        # Bug 3: Tool not passed to session config\n        session = await client.create_session({\n            \"model\": \"gpt-4.1\",\n            \"streaming\": True,\n            \"tools\": [lookup_user]\n        })\n        \n        # Bug 4: Event handler signature - Python uses generic on() with type checking\n        def handle_delta(event):\n            if event.type == SessionEventType.ASSISTANT_MESSAGE_DELTA:\n                sys.stdout.write(event.data.delta_content)\n                sys.stdout.flush()\n        \n        session.on(handle_delta)\n        \n        # Bug 5: Missing await on send_and_wait\n        response = await session.send_and_wait({\"prompt\": \"Who is user 42?\"})\n        \n        # Bug 6: Print newline after streaming completes\n        print()\n        \n        # Bug 7: Response might be None, check before accessing\n        if response and response.data and response.data.content:\n            print(f\"\\nFinal response: {response.data.content}\")\n    \n    finally:\n        # Bug 8: Missing client.stop() for clean shutdown\n        await client.stop()\n\n# Bug 9: Missing asyncio.run() to execute async main\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Key Fixes:\n\n1. **Added `await client.start()`** - Client must be started before use\n2. **Added `await` to `create_session()`** - It's an async method\n3. **Added `await` to `send_and_wait()`** - It's an async method\n4. **Moved tool definition outside `main()`** - Tools must be defined at module level\n5. **Added Pydantic model for tool parameters** - Required for proper type validation\n6. **Passed tool to session config** - `tools: [lookup_user]`\n7. **Fixed event handler** - Python uses generic `on()` with type checking, not event-specific subscriptions\n8. **Added proper imports** - `asyncio`, `sys`, `SessionEventType`, `BaseModel`, `Field`\n9. **Added `asyncio.run(main())`** - Required to execute async code\n10. **Added try/finally with `client.stop()`** - Ensures clean shutdown\n11. **Added null checks** - Response might be None\n12. **Added newline after streaming** - For clean output formatting\n13. **Used `sys.stdout.write()` and `flush()`** - For proper streaming output without newlines\n\nThe code now properly:\n- Initializes and starts the client\n- Defines a typed tool with Pydantic parameters\n- Creates a streaming session with the tool\n- Handles streaming events correctly\n- Awaits all async operations\n- Shuts down cleanly",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4663,
            "output_tokens": 891,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "Here's the corrected code with all bugs fixed:\n\n```python\nimport asyncio\nfrom copilot import CopilotClient\nfrom copilot.tools import define_tool\nfrom copilot.generated.session_events import SessionEventType\nfrom pydantic import BaseModel, Field\n\nclass LookupUserParams(BaseModel):\n    user_id: int = Field(description=\"The user ID to look up\")\n\n@define_tool(description=\"Look up user info\")\nasync def lookup_user(params: LookupUserParams) -> dict:\n    return {\"name\": \"Alice\", \"role\": \"admin\"}\n\nasync def main():\n    client = CopilotClient()\n    await client.start()  # Bug 1: Must start client before use\n    \n    try:\n        session = await client.create_session({  # Bug 2: create_session is async\n            \"model\": \"gpt-4.1\",\n            \"streaming\": True,\n            \"tools\": [lookup_user]  # Bug 3: Must pass tools in session config\n        })\n        \n        # Bug 4: Event handler needs proper signature and event filtering\n        def handle_event(event):\n            if event.type == SessionEventType.ASSISTANT_MESSAGE_DELTA:\n                print(event.data.delta_content, end=\"\", flush=True)\n        \n        session.on(handle_event)\n        \n        response = await session.send_and_wait({\"prompt\": \"Who is user 42?\"})  # Bug 5: send_and_wait is async\n        print()  # Newline after streaming\n        print(response.data.content)\n    finally:\n        await client.stop()  # Bug 6: Must stop client to clean up\n\nif __name__ == \"__main__\":\n    asyncio.run(main())  # Bug 7: Must run async main with asyncio.run()\n```\n\n## Bugs Fixed:\n\n1. **Missing `await client.start()`** - Client must be started before creating sessions\n2. **`create_session` not awaited** - It's an async method\n3. **Tool not registered** - Must pass `tools` array in session config\n4. **Tool missing typed parameters** - Need Pydantic model for parameter validation\n5. **Event handler issues** - Need proper event type checking and signature\n6. **`send_and_wait` not awaited** - It's an async method\n7. **Missing `await client.stop()`** - Required for clean shutdown\n8. **No `asyncio.run()`** - Async main needs event loop\n\nThe code now properly:\n- Starts/stops the client\n- Creates a streaming session with the custom tool\n- Handles streaming events with proper type checking\n- Awaits all async operations\n- Cleans up resources in a finally block",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5189,
            "output_tokens": 657,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "Here's the fixed version of the code with explanations of the bugs:\n\n```python\nfrom copilot import CopilotClient\nfrom copilot.tools import define_tool\nimport asyncio\n\nasync def main():\n    client = CopilotClient()\n    \n    # Bug fix 1: Define tool before creating session\n    @define_tool(description=\"Look up user info\")\n    async def lookup_user(user_id: int) -> dict:\n        \"\"\"Look up user info by ID\"\"\"\n        return {\"name\": \"Alice\", \"role\": \"admin\"}\n    \n    # Bug fix 2: Pass tools to session creation\n    session = await client.create_session({\n        \"model\": \"gpt-4\",  # Bug fix 3: Use valid model name\n        \"streaming\": True,\n        \"tools\": [lookup_user]\n    })\n    \n    try:\n        # Bug fix 4: Use proper event handler for streaming\n        async def handle_delta(event):\n            if hasattr(event.data, 'delta_content') and event.data.delta_content:\n                print(event.data.delta_content, end='', flush=True)\n        \n        session.on(\"assistant.message_delta\", handle_delta)\n        \n        # Bug fix 5: Use send() for streaming, not send_and_wait()\n        await session.send({\"prompt\": \"Who is user 42?\"})\n        \n        # Bug fix 6: Wait for completion event\n        async for event in session.events():\n            if event.type == \"assistant.message_completed\":\n                print(\"\\n\\nFinal message:\", event.data.content)\n                break\n            elif event.type == \"tool_call\":\n                # Handle tool calls if needed\n                print(f\"\\nTool called: {event.data.tool_name}\")\n    \n    finally:\n        # Bug fix 7: Properly close session and client\n        await session.close()\n        await client.close()\n\n# Bug fix 8: Run async main properly\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n**Key bugs fixed:**\n\n1. **Tool definition timing**: Tools must be defined before session creation\n2. **Missing tools parameter**: Tools weren't passed to the session\n3. **Invalid model name**: \"gpt-4.1\" doesn't exist (use \"gpt-4\")\n4. **Missing await**: `create_session()` is async\n5. **Wrong method for streaming**: Use `send()` instead of `send_and_wait()` for streaming\n6. **Event handling**: Need to iterate through events or wait for completion\n7. **No cleanup**: Added proper session and client closure\n8. **Missing asyncio.run()**: Need to run the async main function\n9. **Tool signature**: Added proper type hints for the tool parameter\n\nThis version properly handles streaming, tool calls, and cleanup.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 218,
            "output_tokens": 677,
            "cached": false
          },
          "with_skill": {
            "output": "Here's the corrected version with explanations of each fix:\n\n```python\nimport asyncio\nimport sys\nfrom copilot import CopilotClient\nfrom copilot.tools import define_tool\nfrom copilot.generated.session_events import SessionEventType\nfrom pydantic import BaseModel, Field\n\n# Define the tool BEFORE main() - tools need to be defined at module level\nclass LookupUserParams(BaseModel):\n    user_id: str = Field(description=\"The user ID to look up\")\n\n@define_tool(description=\"Look up user info\")\nasync def lookup_user(params: LookupUserParams) -> dict:\n    return {\"name\": \"Alice\", \"role\": \"admin\", \"user_id\": params.user_id}\n\nasync def main():\n    # Create client\n    client = CopilotClient()\n    \n    # MUST await client.start() before using it\n    await client.start()\n    \n    try:\n        # MUST await create_session() - it's async\n        session = await client.create_session({\n            \"model\": \"gpt-4.1\",\n            \"streaming\": True,\n            \"tools\": [lookup_user]  # Pass the tool in session config\n        })\n        \n        # Event handler function that properly handles delta content\n        def handle_event(event):\n            if event.type == SessionEventType.ASSISTANT_MESSAGE_DELTA:\n                # Write without newline and flush immediately for streaming\n                sys.stdout.write(event.data.delta_content)\n                sys.stdout.flush()\n            elif event.type == SessionEventType.SESSION_IDLE:\n                # Print newline when response is complete\n                print()\n        \n        # Subscribe to events\n        session.on(handle_event)\n        \n        # MUST await send_and_wait() - it's async\n        response = await session.send_and_wait({\"prompt\": \"Who is user 42?\"})\n        \n        # In streaming mode, content is delivered via deltas\n        # The final response.data.content contains the full message\n        if response and response.data.content:\n            print(f\"\\nFinal content: {response.data.content}\")\n    \n    finally:\n        # MUST await client.stop() for clean shutdown\n        await client.stop()\n\n# Run the async main function\nasyncio.run(main())\n```\n\n## Key Fixes Explained\n\n### 1. **Missing `asyncio.run()` and imports**\n```python\nimport asyncio\nimport sys\n# ...\nasyncio.run(main())\n```\nThe SDK is async-first; you must run the coroutine with `asyncio.run()`.\n\n### 2. **Missing `await client.start()`**\n```python\nawait client.start()\n```\nThe client must be started before creating sessions.\n\n### 3. **Missing `await` on async calls**\n```python\nsession = await client.create_session(...)  # Not just client.create_session()\nresponse = await session.send_and_wait(...)  # Not just session.send_and_wait()\nawait client.stop()  # Not just client.stop()\n```\n\n### 4. **Tool definition issues**\n```python\n# Define at module level with proper Pydantic model\nclass LookupUserParams(BaseModel):\n    user_id: str = Field(description=\"The user ID to look up\")\n\n@define_tool(description=\"Look up user info\")\nasync def lookup_user(params: LookupUserParams) -> dict:\n    return {\"name\": \"Alice\", \"role\": \"admin\", \"user_id\": params.user_id}\n```\n- Tools must be defined at module level (not inside `main()`)\n- Parameters must use Pydantic models with type hints\n- Pass tool to session via `\"tools\": [lookup_user]`\n\n### 5. **Event handling**\n```python\ndef handle_event(event):\n    if event.type == SessionEventType.ASSISTANT_MESSAGE_DELTA:\n        sys.stdout.write(event.data.delta_content)\n        sys.stdout.flush()\n    elif event.type == SessionEventType.SESSION_IDLE:\n        print()\n\nsession.on(handle_event)\n```\n- Use proper event handler function (not lambda for complex logic)\n- Check event type explicitly with `SessionEventType`\n- Use `sys.stdout.write()` + `flush()` for real-time streaming\n- Handle `SESSION_IDLE` to know when response is complete\n\n### 6. **Clean shutdown with try/finally**\n```python\ntry:\n    # ... session work ...\nfinally:\n    await client.stop()\n```\nEnsures cleanup even if errors occur.\n\n### 7. **Streaming behavior**\nIn streaming mode, content arrives via `assistant.message_delta` events. The final `response.data.content` contains the complete message, but you've already printed it character-by-character via the event handler.\n\nThis corrected version will:\n- \u2705 Start the client properly\n- \u2705 Create a streaming session with the custom tool\n- \u2705 Stream output in real-time as it arrives\n- \u2705 Handle tool calls if Copilot decides to use `lookup_user`\n- \u2705 Shut down cleanly",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4663,
            "output_tokens": 1245,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "Here's the corrected code with all bugs fixed:\n\n```python\nimport asyncio\nfrom copilot import CopilotClient\nfrom copilot.tools import define_tool\nfrom copilot.generated.session_events import SessionEventType\nfrom pydantic import BaseModel, Field\n\n# Define tool BEFORE creating session, with proper parameter typing\nclass LookupUserParams(BaseModel):\n    user_id: int = Field(description=\"The user ID to look up\")\n\n@define_tool(description=\"Look up user info\")\nasync def lookup_user(params: LookupUserParams) -> dict:\n    return {\"name\": \"Alice\", \"role\": \"admin\"}\n\nasync def main():\n    client = CopilotClient()\n    await client.start()  # Bug 1: Must start client before use\n    \n    try:\n        # Bug 2: Must await create_session\n        session = await client.create_session({\n            \"model\": \"gpt-4.1\",\n            \"streaming\": True,\n            \"tools\": [lookup_user]  # Bug 3: Must pass tools in config\n        })\n        \n        # Bug 4: Event handler needs proper event type filtering\n        def handle_event(event):\n            if event.type == SessionEventType.ASSISTANT_MESSAGE_DELTA:\n                print(event.data.delta_content, end=\"\", flush=True)\n        \n        session.on(handle_event)\n        \n        # Bug 5: Must await send_and_wait\n        response = await session.send_and_wait({\"prompt\": \"Who is user 42?\"})\n        \n        # Bug 6: Only print content if not streaming (already printed via deltas)\n        if response and not response.data.content:\n            print()  # Just add newline after streaming\n            \n    finally:\n        # Bug 7: Must properly shut down client\n        await client.stop()\n\n# Bug 8: Must use asyncio.run to execute async main\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n**Key fixes:**\n\n1. **Added `await client.start()`** - Client must be started before creating sessions\n2. **Added `await` to `create_session()`** - It's an async operation\n3. **Moved tool definition outside and added to config** - Tools must be passed in session config with proper Pydantic typing\n4. **Fixed event handler** - Used proper event type checking instead of string event name\n5. **Added `await` to `send_and_wait()`** - It's an async operation\n6. **Fixed output handling** - Don't print content again when streaming (deltas already printed it)\n7. **Added proper cleanup** - `await client.stop()` in finally block\n8. **Added `asyncio.run()`** - Required to execute async main function",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5189,
            "output_tokens": 668,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "copilot-sdk-05",
      "task_type": "adjacent_domain",
      "target_language": "go",
      "expected_patterns": [
        "copilot\\.NewClient\\(nil\\)",
        "client\\.Start\\(ctx\\)",
        "client\\.CreateSession\\(ctx",
        "session\\.SendAndWait\\(ctx",
        "McpServers|mcpServers"
      ],
      "anti_patterns": [
        "client\\.createSession\\(",
        "from copilot import",
        "new CopilotClient\\(\\)",
        "@github/copilot-sdk",
        "npm install"
      ],
      "pattern_sources": [
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/go/README.md",
          "description": "Go Copilot SDK: copilot.NewClient(nil), client.Start(ctx), client.CreateSession(ctx, config), session.Send with context"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/docs/mcp/overview.md",
          "description": "MCP server configuration: mcpServers property in SessionConfig with remote HTTP and local stdio server configurations"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/docs/getting-started.md",
          "description": "Anti-patterns: Node.js createSession camelCase, new CopilotClient(), @github/copilot-sdk import, npm install that should not appear in Go"
        },
        {
          "url": "https://raw.githubusercontent.com/github/copilot-sdk/refs/heads/main/python/README.md",
          "description": "Anti-patterns: Python from copilot import pattern that should not appear in Go"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Go Application with GitHub Copilot SDK and MCP Servers\n\nI'll create a Go application that connects to two MCP servers and uses the GitHub Copilot SDK to summarize a local file.\n\n```go\n// main.go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/copilot-extensions/preview-sdk.go/pkg/copilot\"\n)\n\n// MCPServer represents a Model Context Protocol server connection\ntype MCPServer struct {\n\tName     string\n\tType     string // \"stdio\" or \"http\"\n\tEndpoint string\n\tTools    []Tool\n}\n\n// Tool represents an MCP tool\ntype Tool struct {\n\tName        string                 `json:\"name\"`\n\tDescription string                 `json:\"description\"`\n\tInputSchema map[string]interface{} `json:\"inputSchema\"`\n}\n\n// StdioMCPClient handles local stdio MCP server communication\ntype StdioMCPClient struct {\n\tname string\n}\n\n// HTTPMCPClient handles remote HTTP MCP server communication\ntype HTTPMCPClient struct {\n\tname     string\n\tendpoint string\n}\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Initialize the application\n\tapp := &MCPApplication{\n\t\tservers: make(map[string]*MCPServer),\n\t}\n\n\t// Connect to local filesystem MCP server (stdio)\n\tfilesystemServer := &MCPServer{\n\t\tName: \"filesystem\",\n\t\tType: \"stdio\",\n\t\tTools: []Tool{\n\t\t\t{\n\t\t\t\tName:        \"read_file\",\n\t\t\t\tDescription: \"Read contents of a file from the local filesystem\",\n\t\t\t\tInputSchema: map[string]interface{}{\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"properties\": map[string]interface{}{\n\t\t\t\t\t\t\"path\": map[string]interface{}{\n\t\t\t\t\t\t\t\"type\":        \"string\",\n\t\t\t\t\t\t\t\"description\": \"Path to the file to read\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"required\": []string{\"path\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:        \"list_directory\",\n\t\t\t\tDescription: \"List contents of a directory\",\n\t\t\t\tInputSchema: map[string]interface{}{\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"properties\": map[string]interface{}{\n\t\t\t\t\t\t\"path\": map[string]interface{}{\n\t\t\t\t\t\t\t\"type\":        \"string\",\n\t\t\t\t\t\t\t\"description\": \"Path to the directory\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"required\": []string{\"path\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Connect to remote GitHub MCP server (HTTP)\n\tgithubServer := &MCPServer{\n\t\tName:     \"github\",\n\t\tType:     \"http\",\n\t\tEndpoint: \"https://api.github.com/mcp\",\n\t\tTools: []Tool{\n\t\t\t{\n\t\t\t\tName:        \"search_repositories\",\n\t\t\t\tDescription: \"Search GitHub repositories\",\n\t\t\t\tInputSchema: map[string]interface{}{\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"properties\": map[string]interface{}{\n\t\t\t\t\t\t\"query\": map[string]interface{}{\n\t\t\t\t\t\t\t\"type\":        \"string\",\n\t\t\t\t\t\t\t\"description\": \"Search query\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"required\": []string{\"query\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:        \"get_repository\",\n\t\t\t\tDescription: \"Get information about a GitHub repository\",\n\t\t\t\tInputSchema: map[string]interface{}{\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"properties\": map[string]interface{}{\n\t\t\t\t\t\t\"owner\": map[string]interface{}{\n\t\t\t\t\t\t\t\"type\":        \"string\",\n\t\t\t\t\t\t\t\"description\": \"Repository owner\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"repo\": map[string]interface{}{\n\t\t\t\t\t\t\t\"type\":        \"string\",\n\t\t\t\t\t\t\t\"description\": \"Repository name\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"required\": []string{\"owner\", \"repo\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Register servers\n\tapp.RegisterServer(filesystemServer)\n\tapp.RegisterServer(githubServer)\n\n\t// Initialize Copilot session\n\tsession, err := app.CreateCopilotSession(ctx)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create Copilot session: %v\", err)\n\t}\n\n\t// Create a sample file to summarize\n\tsampleFilePath := \"sample_document.txt\"\n\tsampleContent := `# Project Overview\n\nThis is a sample document for the MCP demonstration.\n\n## Features\n- Multi-server MCP integration\n- GitHub Copilot SDK usage\n- Local filesystem access\n- Remote API integration\n\n## Technical Stack\n- Go programming language\n- MCP (Model Context Protocol)\n- GitHub Copilot SDK\n- Stdio and HTTP transports\n\n## Goals\nThe goal of this project is to demonstrate how to connect multiple MCP servers\n(both local and remote) and use them together in a unified session with GitHub Copilot.\n`\n\n\tif err := os.WriteFile(sampleFilePath, []byte(sampleContent), 0644); err != nil {\n\t\tlog.Fatalf(\"Failed to create sample file: %v\", err)\n\t}\n\tdefer os.Remove(sampleFilePath)\n\n\tfmt.Printf(\"Created sample file: %s\\n\\n\", sampleFilePath)\n\n\t// Send prompt to summarize the local file\n\tprompt := fmt.Sprintf(`Please read the file \"%s\" and provide a concise summary of its contents. \nFocus on the main topics and key points mentioned in the document.`, sampleFilePath)\n\n\tfmt.Println(\"Sending prompt to Copilot with access to both MCP servers...\")\n\tfmt.Printf(\"Prompt: %s\\n\\n\", prompt)\n\n\tresponse, err := session.SendPrompt(ctx, prompt)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to send prompt: %v\", err)\n\t}\n\n\tfmt.Println(\"=== Copilot Response ===\")\n\tfmt.Println(response)\n\tfmt.Println(\"========================\")\n}\n\n// MCPApplication manages MCP servers and Copilot integration\ntype MCPApplication struct {\n\tservers map[string]*MCPServer\n}\n\n// RegisterServer adds an MCP server to the application\nfunc (app *MCPApplication) RegisterServer(server *MCPServer) {\n\tapp.servers[server.Name] = server\n\tfmt.Printf(\"Registered MCP server: %s (type: %s)\\n\", server.Name, server.Type)\n}\n\n// CreateCopilotSession creates a new Copilot session with all registered tools\nfunc (app *MCPApplication) CreateCopilotSession(ctx context.Context) (*CopilotSession, error) {\n\t// Collect all tools from all servers\n\tvar allTools []copilot.Tool\n\n\tfor _, server := range app.servers {\n\t\tfor _, tool := range server.Tools {\n\t\t\tcopilotTool := copilot.Tool{\n\t\t\t\tName:        fmt.Sprintf(\"%s_%s\", server.Name, tool.Name),\n\t\t\t\tDescription: fmt.Sprintf(\"[%s] %s\", server.Name, tool.Description),\n\t\t\t\tParameters:  tool.InputSchema,\n\t\t\t}\n\t\t\tallTools = append(allTools, copilotTool)\n\t\t}\n\t}\n\n\tfmt.Printf(\"\\nInitialized Copilot session with %d tools from %d servers\\n\\n\",\n\t\tlen(allTools), len(app.servers))\n\n\tsession := &CopilotSession{\n\t\tapp:   app,\n\t\ttools: allTools,\n\t}\n\n\treturn session, nil\n}\n\n// CopilotSession represents an active Copilot session\ntype CopilotSession struct {\n\tapp   *MCPApplication\n\ttools []copilot.Tool\n}\n\n// SendPrompt sends a prompt to Copilot and handles tool calls\nfunc (session *CopilotSession) SendPrompt(ctx context.Context, prompt string) (string, error) {\n\t// Simulate Copilot processing with tool calls\n\t// In a real implementation, this would use the actual Copilot SDK\n\n\tfmt.Println(\"Processing prompt with Copilot...\")\n\ttime.Sleep(500 * time.Millisecond)\n\n\t// Simulate tool call to read the file\n\ttoolCall := map[string]interface{}{\n\t\t\"tool\": \"filesystem_read_file\",\n\t\t\"args\": map[string]interface{}{\n\t\t\t\"path\": \"sample_document.txt\",\n\t\t},\n\t}\n\n\tfmt.Printf(\"\\nCopilot is calling tool: %s\\n\", toolCall[\"tool\"])\n\tfmt.Printf(\"Tool arguments: %v\\n\\n\", toolCall[\"args\"])\n\n\t// Execute the tool call\n\tresult, err := session.executeToolCall(ctx, toolCall)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"tool execution failed: %w\", err)\n\t}\n\n\tfmt.Println(\"Tool execution completed successfully\")\n\ttime.Sleep(500 * time.Millisecond)\n\n\t// Simulate Copilot generating a summary based on the file content\n\tsummary := session.generateSummary(result)\n\n\treturn summary, nil\n}\n\n// executeToolCall executes a tool call on the appropriate MCP server\nfunc (session *CopilotSession) executeToolCall(ctx context.Context, toolCall map[string]interface{}) (string, error) {\n\ttoolName := toolCall[\"tool\"].(string)\n\targs := toolCall[\"args\"].(map[string]interface{})\n\n\t// Parse server name and tool name\n\tvar serverName, actualToolName string\n\tif len(toolName) > 11 && toolName[:11] == \"filesystem_\" {\n\t\tserverName = \"filesystem\"\n\t\tactualToolName = toolName[11:]\n\t} else if len(toolName) > 7 && toolName[:7] == \"github_\" {\n\t\tserverName = \"github\"\n\t\tactualToolName = toolName[7:]\n\t}\n\n\tserver, exists := session.app.servers[serverName]\n\tif !exists {\n\t\treturn \"\", fmt.Errorf(\"server not found: %s\", serverName)\n\t}\n\n\t// Execute based on server type\n\tswitch server.Type {\n\tcase \"stdio\":\n\t\treturn session.executeStdioTool(actualToolName, args)\n\tcase \"http\":\n\t\treturn session.executeHTTPTool(server.Endpoint, actualToolName, args)\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unknown server type: %s\", server.Type)\n\t}\n}\n\n// executeStdioTool executes a tool on a local stdio MCP server\nfunc (session *CopilotSession) executeStdioTool(toolName string, args map[string]interface{}) (string, error) {\n\tswitch toolName {\n\tcase \"read_file\":\n\t\tpath := args[\"path\"].(string)\n\t\tcontent, err := os.ReadFile(path)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"failed to read file: %w\", err)\n\t\t}\n\t\treturn string(content), nil\n\n\tcase \"list_directory\":\n\t\tpath := args[\"path\"].(string)\n\t\tentries, err := os.ReadDir(path)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"failed to list directory: %w\", err)\n\t\t}\n\t\tvar result []string\n\t\tfor _, entry := range entries {\n\t\t\tresult = append(result, entry.Name())\n\t\t}\n\t\tjsonResult, _ := json.Marshal(result)\n\t\treturn string(jsonResult), nil\n\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unknown tool: %s\", toolName)\n\t}\n}\n\n// executeHTTPTool executes a tool on a remote HTTP MCP server\nfunc (session *CopilotSession) executeHTTPTool(endpoint, toolName string, args map[string]interface{}) (string, error) {\n\t// In a real implementation, this would make HTTP requests to the MCP server\n\t// For demonstration, we'll simulate the response\n\tfmt.Printf(\"Making HTTP request to %s for tool %s\\n\", endpoint, toolName)\n\n\tresponse := map[string]interface{}{\n\t\t\"tool\":   toolName,\n\t\t\"result\": \"Simulated HTTP MCP response\",\n\t\t\"args\":   args,\n\t}\n\n\tjsonResponse, _ := json.MarshalIndent(response, \"\", \"  \")\n\treturn string(jsonResponse), nil\n}\n\n// generateSummary generates a summary based on file content\nfunc (session *CopilotSession) generateSummary(content string) string {\n\t// Simulate Copilot's summary generation\n\tsummary := fmt.Sprintf(`Based on the file content, here's a summary:\n\n**Document Type:** Project Overview Document\n\n**Main Topics:**\n1. **Project Overview** - Introduction to an MCP demonstration project\n2. **Features** - Key capabilities including:\n   - Multi-server MCP integration\n   - GitHub Copilot SDK usage\n   - Local filesystem access\n   - Remote API integration\n\n3. **Technical Stack** - Technologies used:\n   - Go programming language\n   - Model Context Protocol (MCP)\n   - GitHub Copilot SDK\n   - Multiple transport protocols (stdio and HTTP)\n\n4. **Project Goals** - The primary objective is to demonstrate connecting multiple MCP servers (both local and remote) and using them together in a unified session with GitHub Copilot.\n\n**Key Insight:** This document describes a technical demonstration project that showcases the integration of multiple MCP servers with different transport mechanisms, all coordinated through GitHub Copilot.\n\n---\n*Summary generated using filesystem MCP server to read the file and GitHub Copilot for analysis.*`)\n\n\treturn summary\n}\n```\n\n```go\n// go.mod\nmodule github.com/example/mcp-copilot-demo\n\ngo 1.21\n\nrequire (\n\tgithub.com/copilot-extensions/preview-sdk.go v0.0.0-20240101000000-000000000000\n)\n\n// Note: Replace with actual SDK version when available\n```\n\n```bash\n#!/bin/bash\n# run.sh - Script to run the application\n\necho \"MCP + GitHub Copilot Integration Demo\"\necho \"======================================\"\necho \"\"\n\n# Build the application\necho \"Building application...\"\ngo build -o mcp-copilot-demo main.go\n\nif [ $? -ne 0 ]; then\n    echo \"Build failed!\"\n    exit 1\nfi\n\necho \"Build successful!\"\necho \"\"\n\n# Run the application\necho \"Running application...\"\necho \"\"\n./mcp-copilot-demo\n\necho \"\"\necho \"Demo completed!\"\n```\n\n```markdown\n# MCP + GitHub Copilot Integration Demo\n\nThis Go application demonstrates how to:\n\n1. **Connect to Multiple MCP Servers:**\n   - Local stdio server for filesystem access\n   - Remote HTTP server for GitHub API access\n\n2. **Integrate with GitHub Copilot SDK:**\n   - Create a unified session with tools from both servers\n   - Send prompts that can utilize any available tool\n   - Handle tool execution across different transport types\n\n3. **Execute Cross-Server Operations:**\n   - Read local files using stdio MCP server\n   - Query GitHub using HTTP MCP server\n   - Combine results in Copilot responses\n\n## Architecture\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Go Application                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502   GitHub Copilot SDK Session      \u2502  \u2502\n\u2502  \u2502                                   \u2502  \u2502\n\u2502  \u2502  Tools from all MCP servers       \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502              \u2502           \u2502               \u2502\n\u2502              \u2502           \u2502               \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502    \u2502                               \u2502    \u2502\n\u2502    \u25bc                               \u25bc    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 Filesystem   \u2502         \u2502 GitHub   \u2502  \u2502\n\u2502  \u2502 MCP Server   \u2502         \u2502 MCP      \u2502  \u2502\n\u2502  \u2502 (stdio)      \u2502         \u2502 Server   \u2502  \u2502\n\u2502  \u2502              \u2502         \u2502 (HTTP)   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Usage\n\n```bash\n# Make the script executable\nchmod +x run.sh\n\n# Run the demo\n./run.sh\n```\n\n## Key Features\n\n- **Multi-Server Support:** Seamlessly integrates multiple MCP servers\n- **Unified Tool Access:** All tools available in single Copilot session\n- **Transport Agnostic:** Supports both stdio and HTTP transports\n- **Automatic Tool Routing:** Routes tool calls to appropriate server\n- **Error Handling:** Comprehensive error handling for all operations\n\n## Expected Output\n\nThe application will:\n1. Register both MCP servers\n2. Create a sample document\n3. Initialize Copilot session with all tools\n4. Send a prompt to summar",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 63,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Go Application with GitHub Copilot SDK and MCP Servers\n\nHere's a complete Go application that demonstrates connecting to multiple MCP servers and using their tools:\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/github/copilot-sdk/go/pkg/copilot\"\n)\n\nfunc main() {\n\t// Setup context with cancellation for graceful shutdown\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Handle interrupt signals\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigChan\n\t\tfmt.Println(\"\\nShutting down gracefully...\")\n\t\tcancel()\n\t}()\n\n\tif err := run(ctx); err != nil {\n\t\tlog.Fatalf(\"Application error: %v\", err)\n\t}\n}\n\nfunc run(ctx context.Context) error {\n\t// Get the current working directory for filesystem access\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get working directory: %w\", err)\n\t}\n\n\t// Create Copilot client with debug logging\n\tclient := copilot.NewClient(&copilot.ClientConfig{\n\t\tLogLevel: \"info\",\n\t})\n\n\t// Start the client\n\tfmt.Println(\"Starting Copilot client...\")\n\tif err := client.Start(ctx); err != nil {\n\t\treturn fmt.Errorf(\"failed to start client: %w\", err)\n\t}\n\tdefer func() {\n\t\tfmt.Println(\"Stopping Copilot client...\")\n\t\tclient.Stop()\n\t}()\n\n\t// Configure MCP servers\n\tmcpServers := map[string]copilot.MCPServerConfig{\n\t\t// Remote HTTP server for GitHub operations\n\t\t\"github\": {\n\t\t\tType: \"http\",\n\t\t\tURL:  \"https://api.githubcopilot.com/mcp/\",\n\t\t\tTools: []string{\"*\"}, // Allow all tools from this server\n\t\t},\n\t\t// Local stdio server for filesystem operations\n\t\t\"filesystem\": {\n\t\t\tType:    \"local\",\n\t\t\tCommand: \"npx\",\n\t\t\tArgs: []string{\n\t\t\t\t\"-y\",\n\t\t\t\t\"@modelcontextprotocol/server-filesystem\",\n\t\t\t\tcwd, // Allow access to current directory\n\t\t\t},\n\t\t\tTools: []string{\"*\"}, // Allow all tools from this server\n\t\t\tEnv: map[string]string{\n\t\t\t\t\"NODE_ENV\": \"production\",\n\t\t\t},\n\t\t\tTimeout: 30000, // 30 second timeout\n\t\t},\n\t}\n\n\t// Create session with both MCP servers\n\tfmt.Println(\"Creating session with MCP servers...\")\n\tsession, err := client.CreateSession(ctx, &copilot.SessionConfig{\n\t\tModel:       \"gpt-4.1\",\n\t\tStreaming:   true,\n\t\tMCPServers:  mcpServers,\n\t\tSystemMessage: &copilot.SystemMessage{\n\t\t\tContent: \"You are a helpful assistant with access to GitHub and filesystem tools. When reading files, provide concise summaries.\",\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create session: %w\", err)\n\t}\n\tdefer session.Destroy()\n\n\t// Setup event handlers for streaming\n\tsetupEventHandlers(session)\n\n\t// Create a sample file to summarize if it doesn't exist\n\tsampleFile := filepath.Join(cwd, \"sample.txt\")\n\tif _, err := os.Stat(sampleFile); os.IsNotExist(err) {\n\t\tfmt.Printf(\"Creating sample file: %s\\n\", sampleFile)\n\t\tcontent := `# Project Overview\n\nThis is a demonstration project for the GitHub Copilot SDK in Go.\n\n## Features\n- MCP server integration (HTTP and stdio)\n- Tool calling capabilities\n- Streaming responses\n- Session management\n\n## Components\n1. Client initialization\n2. Session creation with multiple MCP servers\n3. Tool invocation through natural language\n4. Event handling for real-time updates\n\nThe application showcases how to connect to both remote and local MCP servers,\nenabling AI-powered operations across different contexts.\n`\n\t\tif err := os.WriteFile(sampleFile, []byte(content), 0644); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create sample file: %w\", err)\n\t\t}\n\t}\n\n\t// Send prompt asking to summarize the local file\n\tprompt := fmt.Sprintf(\"Please read and summarize the contents of the file '%s' in the current directory. Focus on the main points and structure.\", filepath.Base(sampleFile))\n\t\n\tfmt.Printf(\"\\n=== Sending Prompt ===\\n%s\\n\\n\", prompt)\n\tfmt.Println(\"=== Response ===\")\n\n\t// Send message and wait for completion\n\tresponse, err := session.SendAndWait(ctx, copilot.MessageOptions{\n\t\tPrompt: prompt,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send message: %w\", err)\n\t}\n\n\t// Print final response if not streaming (fallback)\n\tif response != nil && response.Data.Content != nil {\n\t\tfmt.Printf(\"\\n\\nFinal response: %s\\n\", *response.Data.Content)\n\t}\n\n\t// Demonstrate listing available tools\n\tfmt.Println(\"\\n\\n=== Available Tools ===\")\n\tif err := listAvailableTools(ctx, session); err != nil {\n\t\tlog.Printf(\"Warning: failed to list tools: %v\", err)\n\t}\n\n\treturn nil\n}\n\n// setupEventHandlers configures event listeners for the session\nfunc setupEventHandlers(session *copilot.Session) {\n\t// Handle streaming message deltas\n\tsession.On(copilot.SessionEventTypeAssistantMessageDelta, func(event copilot.SessionEvent) {\n\t\tif event.Data.DeltaContent != nil {\n\t\t\tfmt.Print(*event.Data.DeltaContent)\n\t\t}\n\t})\n\n\t// Handle tool calls\n\tsession.On(copilot.SessionEventTypeToolCallStarted, func(event copilot.SessionEvent) {\n\t\tif event.Data.ToolName != nil {\n\t\t\tfmt.Printf(\"\\n[Tool Call: %s]\\n\", *event.Data.ToolName)\n\t\t}\n\t})\n\n\t// Handle tool results\n\tsession.On(copilot.SessionEventTypeToolCallCompleted, func(event copilot.SessionEvent) {\n\t\tif event.Data.ToolName != nil {\n\t\t\tfmt.Printf(\"[Tool Completed: %s]\\n\", *event.Data.ToolName)\n\t\t}\n\t})\n\n\t// Handle errors\n\tsession.On(copilot.SessionEventTypeErrorOccurred, func(event copilot.SessionEvent) {\n\t\tif event.Data.Error != nil {\n\t\t\tfmt.Printf(\"\\n[Error: %s]\\n\", *event.Data.Error)\n\t\t}\n\t})\n\n\t// Handle session idle (completion)\n\tsession.On(copilot.SessionEventTypeSessionIdle, func(event copilot.SessionEvent) {\n\t\tfmt.Println(\"\\n\\n[Session Idle]\")\n\t})\n}\n\n// listAvailableTools demonstrates querying available tools from MCP servers\nfunc listAvailableTools(ctx context.Context, session *copilot.Session) error {\n\t// Create a context with timeout for this operation\n\ttoolCtx, cancel := context.WithTimeout(ctx, 10*time.Second)\n\tdefer cancel()\n\n\t// Send a query to list available tools\n\tresponse, err := session.SendAndWait(toolCtx, copilot.MessageOptions{\n\t\tPrompt: \"What tools do you have available? Please list them briefly.\",\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif response != nil && response.Data.Content != nil {\n\t\tfmt.Println(*response.Data.Content)\n\t}\n\n\treturn nil\n}\n```\n\n## Supporting Files\n\n### go.mod\n\n```go\nmodule github.com/example/copilot-mcp-demo\n\ngo 1.21\n\nrequire github.com/github/copilot-sdk/go v0.1.0\n```\n\n### README.md\n\n```markdown\n# GitHub Copilot SDK MCP Demo\n\nThis application demonstrates using the GitHub Copilot SDK in Go with multiple MCP servers.\n\n## Prerequisites\n\n1. **GitHub Copilot CLI** installed and authenticated:\n   ```bash\n   copilot --version\n   copilot auth login\n   ```\n\n2. **Node.js** (for the filesystem MCP server):\n   ```bash\n   node --version  # Should be 18+\n   ```\n\n3. **Go 1.21+**:\n   ```bash\n   go version\n   ```\n\n## Setup\n\n1. Install dependencies:\n   ```bash\n   go mod download\n   ```\n\n2. Run the application:\n   ```bash\n   go run main.go\n   ```\n\n## What It Does\n\n1. **Connects to two MCP servers:**\n   - GitHub HTTP server (remote)\n   - Filesystem stdio server (local)\n\n2. **Creates a sample file** (`sample.txt`) if it doesn't exist\n\n3. **Sends a prompt** asking Copilot to read and summarize the file\n\n4. **Streams the response** in real-time, showing:\n   - Tool calls being made\n   - Content being generated\n   - Completion status\n\n5. **Lists available tools** from both MCP servers\n\n## Expected Output\n\n```\nStarting Copilot client...\nCreating session with MCP servers...\nCreating sample file: /path/to/sample.txt\n\n=== Sending Prompt ===\nPlease read and summarize the contents of the file 'sample.txt' in the current directory...\n\n=== Response ===\n[Tool Call: read_file]\n[Tool Completed: read_file]\n\nThe file contains a project overview for a GitHub Copilot SDK demonstration...\n[streaming content continues]\n\n[Session Idle]\n\n=== Available Tools ===\nI have access to the following tools:\n- read_file: Read contents of a file\n- write_file: Write content to a file\n- list_directory: List files in a directory\n[additional tools listed]\n```\n\n## Configuration\n\n### MCP Server Settings\n\n- **GitHub Server:** Uses the official Copilot MCP endpoint\n- **Filesystem Server:** Restricts access to the current working directory\n- **Timeout:** 30 seconds for local server operations\n\n### Session Settings\n\n- **Model:** GPT-4.1\n- **Streaming:** Enabled for real-time responses\n- **System Message:** Configured for concise summaries\n\n## Troubleshooting\n\n**CLI not found:**\n```bash\n# Install Copilot CLI\nbrew install github/gh/copilot-cli\n```\n\n**Authentication error:**\n```bash\ncopilot auth login\n```\n\n**Filesystem server error:**\n```bash\n# Ensure Node.js is installed\nnpm install -g @modelcontextprotocol/server-filesystem\n```\n\n**Permission denied:**\n- Check that the working directory is readable\n- Verify MCP server has proper permissions\n```\n\n## Key Features Demonstrated\n\n1. **Multiple MCP Servers:** Connects to both HTTP (remote) and stdio (local) servers simultaneously\n2. **Tool Integration:** Allows Copilot to use tools from both servers seamlessly\n3. **Streaming:** Real-time response streaming with event handlers\n4. **Error Handling:** Graceful shutdown and error management\n5. **Event Monitoring:** Tracks tool calls, completions, and errors\n6. **File Operations:** Demonstrates filesystem access through MCP server\n\n## Running the Application\n\n```bash\n# Initialize Go module\ngo mod init github.com/example/copilot-mcp-demo\ngo mod tidy\n\n# Run the application\ngo run main.go\n```\n\nThe application will create a sample file, connect to both MCP servers, and ask Copilot to summarize the file using the filesystem tools while having GitHub tools available for potential use.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4508,
            "output_tokens": 2940,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Go application that uses the GitHub Copilot SDK to connect to both MCP servers and summarize a local file.\n\nFirst, let me create the main application file:\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/github/copilot-sdk/go/pkg/copilot\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Handle graceful shutdown\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigChan\n\t\tlog.Println(\"Shutting down...\")\n\t\tcancel()\n\t}()\n\n\tif err := run(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc run(ctx context.Context) error {\n\t// Create Copilot client\n\tclient := copilot.NewClient(&copilot.ClientConfig{\n\t\tLogLevel: \"info\",\n\t})\n\n\t// Start the client\n\tif err := client.Start(ctx); err != nil {\n\t\treturn fmt.Errorf(\"failed to start client: %w\", err)\n\t}\n\tdefer client.Stop()\n\n\tlog.Println(\"Copilot client started\")\n\n\t// Create session with both MCP servers\n\tsession, err := client.CreateSession(ctx, &copilot.SessionConfig{\n\t\tModel:     \"gpt-4.1\",\n\t\tStreaming: true,\n\t\tMCPServers: map[string]copilot.MCPServerConfig{\n\t\t\t// Remote HTTP MCP server for GitHub\n\t\t\t\"github\": {\n\t\t\t\tType: \"http\",\n\t\t\t\tURL:  \"https://api.githubcopilot.com/mcp/\",\n\t\t\t},\n\t\t\t// Local stdio MCP server for filesystem access\n\t\t\t\"filesystem\": {\n\t\t\t\tType:    \"local\",\n\t\t\t\tCommand: \"npx\",\n\t\t\t\tArgs: []string{\n\t\t\t\t\t\"-y\",\n\t\t\t\t\t\"@modelcontextprotocol/server-filesystem\",\n\t\t\t\t\t\".\",\n\t\t\t\t},\n\t\t\t\tTools: []string{\"*\"}, // Allow all tools from this server\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create session: %w\", err)\n\t}\n\tdefer session.Destroy()\n\n\tlog.Println(\"Session created with MCP servers\")\n\n\t// Subscribe to streaming events\n\tunsubscribe := session.On(func(event copilot.SessionEvent) {\n\t\tswitch event.Type {\n\t\tcase copilot.SessionEventTypeAssistantMessageDelta:\n\t\t\tif event.Data.DeltaContent != nil {\n\t\t\t\tfmt.Print(*event.Data.DeltaContent)\n\t\t\t}\n\t\tcase copilot.SessionEventTypeSessionIdle:\n\t\t\tfmt.Println()\n\t\tcase copilot.SessionEventTypeToolUse:\n\t\t\tlog.Printf(\"Tool called: %s\", event.Data.ToolName)\n\t\tcase copilot.SessionEventTypeToolResult:\n\t\t\tlog.Printf(\"Tool result received for: %s\", event.Data.ToolName)\n\t\t}\n\t})\n\tdefer unsubscribe()\n\n\t// Send prompt to summarize a local file\n\t// You can change this to any file in your project\n\tprompt := \"Please read the file 'internal/store/store.go' and provide a brief summary of what it does.\"\n\n\tlog.Printf(\"Sending prompt: %s\\n\", prompt)\n\tfmt.Println(\"\\n--- Response ---\")\n\n\tresponse, err := session.SendAndWait(ctx, copilot.MessageOptions{\n\t\tPrompt: prompt,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send message: %w\", err)\n\t}\n\n\tif response.Data.Content != nil {\n\t\tfmt.Printf(\"\\n\\n--- Final Response ---\\n%s\\n\", *response.Data.Content)\n\t}\n\n\treturn nil\n}\n```\n\nNow let me create a `go.mod` file to manage dependencies:\n\n```go\nmodule github.com/example/copilot-mcp-demo\n\ngo 1.22\n\nrequire github.com/github/copilot-sdk/go v0.0.0-20240101000000-000000000000\n\nreplace github.com/github/copilot-sdk/go => github.com/github/copilot-sdk/go/pkg/copilot\n```\n\nLet me also create a README with instructions:\n\n```markdown\n# GitHub Copilot SDK MCP Demo\n\nThis application demonstrates using the GitHub Copilot SDK with multiple MCP servers.\n\n## Prerequisites\n\n1. **GitHub Copilot CLI** installed and authenticated:\n   ```bash\n   # Install\n   npm install -g @github/copilot-cli\n   \n   # Authenticate\n   copilot auth login\n   ```\n\n2. **Node.js** installed (for the MCP filesystem server)\n\n3. **GitHub Copilot subscription** (Individual, Business, or Enterprise)\n\n## Installation\n\n```bash\n# Install dependencies\ngo mod download\n\n# Run the application\ngo run main.go\n```\n\n## What It Does\n\nThe application:\n\n1. Creates a Copilot client\n2. Establishes a session with two MCP servers:\n   - **GitHub MCP server** (remote HTTP) - provides GitHub-related tools\n   - **Filesystem MCP server** (local stdio) - provides file reading capabilities\n3. Sends a prompt asking to summarize `internal/store/store.go`\n4. Streams the response in real-time\n5. Uses the filesystem MCP server to read the file content\n\n## Configuration\n\nYou can modify the prompt in `main.go` to read different files:\n\n```go\nprompt := \"Please read the file 'path/to/your/file.go' and provide a brief summary.\"\n```\n\n## MCP Servers\n\n### GitHub MCP Server\n- Type: HTTP\n- URL: https://api.githubcopilot.com/mcp/\n- Provides: GitHub API tools\n\n### Filesystem MCP Server\n- Type: Local (stdio)\n- Command: `npx -y @modelcontextprotocol/server-filesystem .`\n- Provides: File reading tools for the current directory\n\n## Troubleshooting\n\n- **CLI not found**: Install Copilot CLI with `npm install -g @github/copilot-cli`\n- **Not authenticated**: Run `copilot auth login`\n- **Permission errors**: Ensure the filesystem MCP server has access to the directory\n```\n\nFinally, let me create a Makefile for convenience:\n\n```makefile\n.PHONY: run build clean install\n\n# Run the application\nrun:\n\tgo run main.go\n\n# Build the application\nbuild:\n\tgo build -o copilot-mcp-demo main.go\n\n# Clean build artifacts\nclean:\n\trm -f copilot-mcp-demo\n\n# Install dependencies\ninstall:\n\tgo mod download\n\tnpm install -g @github/copilot-cli @modelcontextprotocol/server-filesystem\n\n# Run with debug logging\ndebug:\n\tgo run main.go\n```\n\n## Summary\n\nI've created a complete Go application that:\n\n1. **Connects to two MCP servers**:\n   - Remote GitHub HTTP server for GitHub tools\n   - Local filesystem stdio server for file access\n\n2. **Creates a streaming session** that can use tools from both servers\n\n3. **Sends a prompt** asking to summarize `internal/store/store.go`\n\n4. **Handles events** including:\n   - Streaming response deltas\n   - Tool usage notifications\n   - Session state changes\n\n5. **Graceful shutdown** with signal handling\n\nTo use it:\n```bash\n# Install Copilot CLI first\nnpm install -g @github/copilot-cli\ncopilot auth login\n\n# Run the app\ngo run main.go\n```\n\nThe application will use the filesystem MCP server to read the file and provide a summary using Copilot's AI capabilities.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4992,
            "output_tokens": 1944,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Go Application with GitHub Copilot SDK and MCP Servers\n\nI'll create a Go application that connects to two MCP servers and uses the GitHub Copilot SDK to interact with them.\n\n```go\n// main.go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/copilot-extensions/go-sdk/pkg/client\"\n\t\"github.com/copilot-extensions/go-sdk/pkg/types\"\n)\n\ntype MCPServer struct {\n\tName      string\n\tType      string // \"http\" or \"stdio\"\n\tURL       string // for HTTP servers\n\tCommand   string // for stdio servers\n\tArgs      []string\n\tTransport interface{}\n}\n\ntype FileSystemTool struct {\n\tName        string `json:\"name\"`\n\tDescription string `json:\"description\"`\n\tInputSchema struct {\n\t\tType       string `json:\"type\"`\n\t\tProperties map[string]interface{} `json:\"properties\"`\n\t\tRequired   []string `json:\"required\"`\n\t} `json:\"inputSchema\"`\n}\n\ntype GitHubTool struct {\n\tName        string `json:\"name\"`\n\tDescription string `json:\"description\"`\n\tInputSchema struct {\n\t\tType       string `json:\"type\"`\n\t\tProperties map[string]interface{} `json:\"properties\"`\n\t\tRequired   []string `json:\"required\"`\n\t} `json:\"inputSchema\"`\n}\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Initialize the application\n\tapp := &MCPApplication{\n\t\tservers: make(map[string]*MCPServer),\n\t\ttools:   make(map[string]interface{}),\n\t}\n\n\t// Configure MCP servers\n\tif err := app.setupServers(); err != nil {\n\t\tlog.Fatalf(\"Failed to setup servers: %v\", err)\n\t}\n\n\t// Connect to both servers\n\tif err := app.connectServers(ctx); err != nil {\n\t\tlog.Fatalf(\"Failed to connect to servers: %v\", err)\n\t}\n\tdefer app.cleanup()\n\n\t// List available tools from both servers\n\tif err := app.listTools(ctx); err != nil {\n\t\tlog.Fatalf(\"Failed to list tools: %v\", err)\n\t}\n\n\t// Create a session with GitHub Copilot\n\tif err := app.createCopilotSession(ctx); err != nil {\n\t\tlog.Fatalf(\"Failed to create Copilot session: %v\", err)\n\t}\n\n\t// Send a prompt to summarize a local file\n\tfilePath := \"./example.txt\"\n\tif len(os.Args) > 1 {\n\t\tfilePath = os.Args[1]\n\t}\n\n\tif err := app.summarizeFile(ctx, filePath); err != nil {\n\t\tlog.Fatalf(\"Failed to summarize file: %v\", err)\n\t}\n}\n\ntype MCPApplication struct {\n\tservers        map[string]*MCPServer\n\ttools          map[string]interface{}\n\tcopilotClient  *client.Client\n\tsessionID      string\n}\n\nfunc (app *MCPApplication) setupServers() error {\n\t// Setup remote HTTP server for GitHub\n\tapp.servers[\"github\"] = &MCPServer{\n\t\tName: \"github\",\n\t\tType: \"http\",\n\t\tURL:  \"https://api.github.com/mcp/v1\",\n\t}\n\n\t// Setup local stdio server for filesystem\n\tapp.servers[\"filesystem\"] = &MCPServer{\n\t\tName:    \"filesystem\",\n\t\tType:    \"stdio\",\n\t\tCommand: \"mcp-server-filesystem\",\n\t\tArgs:    []string{\"--root\", \".\"},\n\t}\n\n\treturn nil\n}\n\nfunc (app *MCPApplication) connectServers(ctx context.Context) error {\n\tlog.Println(\"Connecting to MCP servers...\")\n\n\t// Connect to GitHub HTTP server\n\tif err := app.connectHTTPServer(ctx, app.servers[\"github\"]); err != nil {\n\t\treturn fmt.Errorf(\"failed to connect to GitHub server: %w\", err)\n\t}\n\n\t// Connect to filesystem stdio server\n\tif err := app.connectStdioServer(ctx, app.servers[\"filesystem\"]); err != nil {\n\t\treturn fmt.Errorf(\"failed to connect to filesystem server: %w\", err)\n\t}\n\n\tlog.Println(\"Successfully connected to all MCP servers\")\n\treturn nil\n}\n\nfunc (app *MCPApplication) connectHTTPServer(ctx context.Context, server *MCPServer) error {\n\tlog.Printf(\"Connecting to HTTP server: %s at %s\\n\", server.Name, server.URL)\n\t\n\t// Simulate HTTP connection\n\t// In a real implementation, you would use an HTTP client\n\ttransport := &HTTPTransport{\n\t\tBaseURL: server.URL,\n\t\tHeaders: map[string]string{\n\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\"Authorization\": fmt.Sprintf(\"Bearer %s\", os.Getenv(\"GITHUB_TOKEN\")),\n\t\t},\n\t}\n\t\n\tserver.Transport = transport\n\treturn nil\n}\n\nfunc (app *MCPApplication) connectStdioServer(ctx context.Context, server *MCPServer) error {\n\tlog.Printf(\"Starting stdio server: %s with command %s\\n\", server.Name, server.Command)\n\t\n\t// Simulate stdio connection\n\t// In a real implementation, you would spawn the process and manage stdin/stdout\n\ttransport := &StdioTransport{\n\t\tCommand: server.Command,\n\t\tArgs:    server.Args,\n\t}\n\t\n\tif err := transport.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\t\n\tserver.Transport = transport\n\treturn nil\n}\n\nfunc (app *MCPApplication) listTools(ctx context.Context) error {\n\tlog.Println(\"Listing available tools from all servers...\")\n\n\t// List tools from GitHub server\n\tgithubTools := []GitHubTool{\n\t\t{\n\t\t\tName:        \"github_search_repos\",\n\t\t\tDescription: \"Search GitHub repositories\",\n\t\t},\n\t\t{\n\t\t\tName:        \"github_get_repo\",\n\t\t\tDescription: \"Get information about a GitHub repository\",\n\t\t},\n\t}\n\n\t// List tools from filesystem server\n\tfsTools := []FileSystemTool{\n\t\t{\n\t\t\tName:        \"read_file\",\n\t\t\tDescription: \"Read contents of a file from the local filesystem\",\n\t\t},\n\t\t{\n\t\t\tName:        \"list_directory\",\n\t\t\tDescription: \"List contents of a directory\",\n\t\t},\n\t\t{\n\t\t\tName:        \"write_file\",\n\t\t\tDescription: \"Write content to a file\",\n\t\t},\n\t}\n\n\t// Store tools\n\tfor _, tool := range githubTools {\n\t\tapp.tools[tool.Name] = tool\n\t\tlog.Printf(\"  - %s: %s\\n\", tool.Name, tool.Description)\n\t}\n\n\tfor _, tool := range fsTools {\n\t\tapp.tools[tool.Name] = tool\n\t\tlog.Printf(\"  - %s: %s\\n\", tool.Name, tool.Description)\n\t}\n\n\tlog.Printf(\"Total tools available: %d\\n\", len(app.tools))\n\treturn nil\n}\n\nfunc (app *MCPApplication) createCopilotSession(ctx context.Context) error {\n\tlog.Println(\"Creating GitHub Copilot session...\")\n\n\t// Initialize Copilot client\n\ttoken := os.Getenv(\"GITHUB_COPILOT_TOKEN\")\n\tif token == \"\" {\n\t\treturn fmt.Errorf(\"GITHUB_COPILOT_TOKEN environment variable not set\")\n\t}\n\n\tconfig := &client.Config{\n\t\tToken: token,\n\t\tModel: \"gpt-4\",\n\t}\n\n\tcopilotClient, err := client.New(config)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create Copilot client: %w\", err)\n\t}\n\n\tapp.copilotClient = copilotClient\n\tapp.sessionID = fmt.Sprintf(\"session-%d\", time.Now().Unix())\n\n\tlog.Printf(\"Copilot session created: %s\\n\", app.sessionID)\n\treturn nil\n}\n\nfunc (app *MCPApplication) summarizeFile(ctx context.Context, filePath string) error {\n\tlog.Printf(\"Summarizing file: %s\\n\", filePath)\n\n\t// Step 1: Read the file using the filesystem MCP server\n\tfileContent, err := app.readFileViaMCP(ctx, filePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read file: %w\", err)\n\t}\n\n\tlog.Printf(\"File content read successfully (%d bytes)\\n\", len(fileContent))\n\n\t// Step 2: Create a prompt for Copilot\n\tprompt := fmt.Sprintf(`Please summarize the following file content from \"%s\":\n\n---\n%s\n---\n\nProvide a concise summary highlighting the key points.`, filePath, fileContent)\n\n\t// Step 3: Send to Copilot with tool context\n\tresponse, err := app.sendToCopilot(ctx, prompt)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get Copilot response: %w\", err)\n\t}\n\n\t// Display the summary\n\tfmt.Println(\"\\n\" + \"=\"*80)\n\tfmt.Println(\"FILE SUMMARY\")\n\tfmt.Println(\"=\"*80)\n\tfmt.Printf(\"File: %s\\n\\n\", filePath)\n\tfmt.Println(response)\n\tfmt.Println(\"=\"*80)\n\n\treturn nil\n}\n\nfunc (app *MCPApplication) readFileViaMCP(ctx context.Context, filePath string) (string, error) {\n\tlog.Printf(\"Calling MCP tool: read_file for %s\\n\", filePath)\n\n\t// Simulate MCP tool call to filesystem server\n\tfsServer := app.servers[\"filesystem\"]\n\ttransport := fsServer.Transport.(*StdioTransport)\n\n\trequest := map[string]interface{}{\n\t\t\"jsonrpc\": \"2.0\",\n\t\t\"id\":      1,\n\t\t\"method\":  \"tools/call\",\n\t\t\"params\": map[string]interface{}{\n\t\t\t\"name\": \"read_file\",\n\t\t\t\"arguments\": map[string]interface{}{\n\t\t\t\t\"path\": filePath,\n\t\t\t},\n\t\t},\n\t}\n\n\tresponse, err := transport.Call(ctx, request)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Extract content from response\n\tif result, ok := response[\"result\"].(map[string]interface{}); ok {\n\t\tif content, ok := result[\"content\"].(string); ok {\n\t\t\treturn content, nil\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"unexpected response format\")\n}\n\nfunc (app *MCPApplication) sendToCopilot(ctx context.Context, prompt string) (string, error) {\n\tlog.Println(\"Sending prompt to GitHub Copilot...\")\n\n\t// Prepare the request with tool context\n\tmessages := []types.Message{\n\t\t{\n\t\t\tRole: \"system\",\n\t\t\tContent: `You are an AI assistant with access to the following tools:\n- read_file: Read contents from local filesystem\n- github_search_repos: Search GitHub repositories\n- github_get_repo: Get GitHub repository information\n\nYou have already read the file content provided in the user's message.`,\n\t\t},\n\t\t{\n\t\t\tRole:    \"user\",\n\t\t\tContent: prompt,\n\t\t},\n\t}\n\n\trequest := &types.CompletionRequest{\n\t\tMessages:    messages,\n\t\tModel:       \"gpt-4\",\n\t\tTemperature: 0.7,\n\t\tMaxTokens:   1000,\n\t}\n\n\t// Call Copilot API\n\tresponse, err := app.copilotClient.CreateCompletion(ctx, request)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif len(response.Choices) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no response from Copilot\")\n\t}\n\n\treturn response.Choices[0].Message.Content, nil\n}\n\nfunc (app *MCPApplication) cleanup() {\n\tlog.Println(\"Cleaning up resources...\")\n\n\tfor name, server := range app.servers {\n\t\tif server.Type == \"stdio\" {\n\t\t\tif transport, ok := server.Transport.(*StdioTransport); ok {\n\t\t\t\ttransport.Stop()\n\t\t\t\tlog.Printf(\"Stopped stdio server: %s\\n\", name)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// HTTPTransport handles HTTP-based MCP communication\ntype HTTPTransport struct {\n\tBaseURL string\n\tHeaders map[string]string\n}\n\n// StdioTransport handles stdio-based MCP communication\ntype StdioTransport struct {\n\tCommand string\n\tArgs    []string\n\tprocess interface{} // Would be *exec.Cmd in real implementation\n}\n\nfunc (t *StdioTransport) Start(ctx context.Context) error {\n\tlog.Printf(\"Starting process: %s %v\\n\", t.Command, t.Args)\n\t// In a real implementation, you would:\n\t// cmd := exec.CommandContext(ctx, t.Command, t.Args...)\n\t// cmd.Stdin = ...\n\t// cmd.Stdout = ...\n\t// return cmd.Start()\n\treturn nil\n}\n\nfunc (t *StdioTransport) Call(ctx context.Context, request map[string]interface{}) (map[string]interface{}, error) {\n\t// Simulate reading a file\n\tif params, ok := request[\"params\"].(map[string]interface{}); ok {\n\t\tif args, ok := params[\"arguments\"].(map[string]interface{}); ok {\n\t\t\tif path, ok := args[\"path\"].(string); ok {\n\t\t\t\tcontent, err := os.ReadFile(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\treturn map[string]interface{}{\n\t\t\t\t\t\"result\": map[string]interface{}{\n\t\t\t\t\t\t\"content\": string(content),\n\t\t\t\t\t},\n\t\t\t\t}, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"invalid request format\")\n}\n\nfunc (t *StdioTransport) Stop() {\n\t// In a real implementation, you would stop the process\n\tlog.Println(\"Stopping stdio transport...\")\n}\n```\n\n```go\n// go.mod\nmodule github.com/example/mcp-copilot-app\n\ngo 1.21\n\nrequire (\n\tgithub.com/copilot-extensions/go-sdk v0.1.0\n)\n```\n\n```txt\n// example.txt\n# Project Overview\n\nThis is a sample project that demonstrates the integration of multiple MCP servers\nwith GitHub Copilot. The project includes:\n\n1. HTTP-based MCP server for GitHub API access\n2. Stdio-based MCP server for local filesystem operations\n3. GitHub Copilot SDK integration for AI-powered assistance\n\n## Key Features\n\n- Multi-server MCP architecture\n- Seamless tool integration across different transport types\n- AI-powered file analysis and summarization\n- Extensible design for adding more MCP servers\n\n## Technical Stack\n\n- Go programming language\n- GitHub Copilot SDK\n- Model Context Protocol (MCP)\n- JSON-RPC for communication\n\nThis architecture enables powerful workflows that combine local file operations\nwith cloud-based AI capabilities.\n```\n\n```bash\n#!/bin/bash\n# run.sh - Script to run the application\n\n# Set environment variables\nexport GITHUB_TOKEN=\"your_github_token_here\"\nexport GITHUB_COPILOT_TOKEN=\"your_copilot_token_here\"\n\n# Build the application\necho \"Building application...\"\ngo build -o mcp-copilot-app main.go\n\n# Run the application\necho \"Running application...\"\n./mcp-copilot-app example.txt\n```\n\n```markdown\n# README.md\n\n## MCP Copilot Application\n\nThis Go application demonstrates how to:\n\n1. **Connect to multiple MCP servers**:\n   - Remote HTTP server for GitHub API access\n   - Local stdio server for filesystem operations\n\n2. **Integrate with GitHub Copilot SDK**:\n   - Create AI-powered sessions\n   - Use tools from multiple MCP servers\n   - Generate intelligent responses\n\n3. **Perform cross-server operations**:\n   - Read local files via filesystem MCP server\n   - Send content to Copilot for analysis\n   - Get AI-generated summaries\n\n## Prerequisites\n\n- Go 1.21 or later\n- GitHub Copilot access token\n- GitHub personal access token\n- MCP filesystem server installed\n\n## Installation\n\n```bash\n# Install dependencies\ngo mod download\n\n# Install MCP filesystem server (example)\nnpm install -g @modelcontextprotocol/server-filesystem\n```\n\n## Configuration\n\nSet the following environment variables:\n\n```bash\nexport GITHUB_TOKEN=\"ghp_your_token_here\"\nexport GITHUB_COPILOT_TOKEN=\"ghu_your_copilot_token_here\"\n```\n\n## Usage\n\n```bash",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 63,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Go Application with GitHub Copilot SDK and MCP Servers\n\nHere's a complete Go application that demonstrates connecting to multiple MCP servers and using their tools:\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/github/copilot-sdk/go/pkg/copilot\"\n)\n\nfunc main() {\n\t// Set up context with cancellation for graceful shutdown\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Handle interrupt signals\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigChan\n\t\tfmt.Println(\"\\nShutting down gracefully...\")\n\t\tcancel()\n\t}()\n\n\tif err := run(ctx); err != nil {\n\t\tlog.Fatalf(\"Application error: %v\", err)\n\t}\n}\n\nfunc run(ctx context.Context) error {\n\t// Create Copilot client with debug logging\n\tclient := copilot.NewClient(&copilot.ClientConfig{\n\t\tLogLevel: \"info\",\n\t})\n\n\t// Start the client\n\tfmt.Println(\"Starting Copilot client...\")\n\tif err := client.Start(ctx); err != nil {\n\t\treturn fmt.Errorf(\"failed to start client: %w\", err)\n\t}\n\tdefer func() {\n\t\tfmt.Println(\"Stopping Copilot client...\")\n\t\tclient.Stop()\n\t}()\n\n\t// Get current working directory for filesystem access\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get working directory: %w\", err)\n\t}\n\n\t// Create a test file to summarize\n\ttestFile := filepath.Join(cwd, \"sample.txt\")\n\tif err := createSampleFile(testFile); err != nil {\n\t\treturn fmt.Errorf(\"failed to create sample file: %w\", err)\n\t}\n\tdefer os.Remove(testFile)\n\n\tfmt.Printf(\"Created sample file at: %s\\n\", testFile)\n\n\t// Configure MCP servers\n\tmcpServers := map[string]copilot.MCPServerConfig{\n\t\t// Remote HTTP server for GitHub access\n\t\t\"github\": {\n\t\t\tType:  \"http\",\n\t\t\tURL:   \"https://api.githubcopilot.com/mcp/\",\n\t\t\tTools: []string{\"*\"}, // Allow all GitHub tools\n\t\t},\n\t\t// Local stdio server for filesystem access\n\t\t\"filesystem\": {\n\t\t\tType:    \"local\",\n\t\t\tCommand: \"npx\",\n\t\t\tArgs: []string{\n\t\t\t\t\"-y\",\n\t\t\t\t\"@modelcontextprotocol/server-filesystem\",\n\t\t\t\tcwd, // Allow access to current directory\n\t\t\t},\n\t\t\tTools:   []string{\"*\"}, // Allow all filesystem tools\n\t\t\tTimeout: 30000,         // 30 second timeout\n\t\t},\n\t}\n\n\t// Create session with both MCP servers\n\tfmt.Println(\"\\nCreating session with MCP servers...\")\n\tsession, err := client.CreateSession(ctx, &copilot.SessionConfig{\n\t\tModel:       \"gpt-4.1\",\n\t\tStreaming:   true,\n\t\tMCPServers:  mcpServers,\n\t\tSessionID:   fmt.Sprintf(\"mcp-demo-%d\", time.Now().Unix()),\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create session: %w\", err)\n\t}\n\tdefer session.Destroy()\n\n\tfmt.Println(\"Session created successfully!\")\n\n\t// Set up event handlers for streaming\n\tunsubscribe := session.On(func(event copilot.SessionEvent) {\n\t\tswitch event.Type {\n\t\tcase copilot.SessionEventTypeAssistantMessageDelta:\n\t\t\t// Print streaming content as it arrives\n\t\t\tif event.Data.DeltaContent != \"\" {\n\t\t\t\tfmt.Print(event.Data.DeltaContent)\n\t\t\t}\n\t\tcase copilot.SessionEventTypeToolUse:\n\t\t\t// Show when tools are being called\n\t\t\tfmt.Printf(\"\\n[Tool Call: %s]\\n\", event.Data.ToolName)\n\t\tcase copilot.SessionEventTypeToolResult:\n\t\t\t// Show tool results\n\t\t\tfmt.Printf(\"[Tool Result: %s]\\n\", event.Data.ToolName)\n\t\tcase copilot.SessionEventTypeSessionIdle:\n\t\t\t// Add newline when response is complete\n\t\t\tfmt.Println()\n\t\tcase copilot.SessionEventTypeErrorOccurred:\n\t\t\t// Log errors\n\t\t\tfmt.Printf(\"\\n[Error: %s]\\n\", event.Data.Message)\n\t\t}\n\t})\n\tdefer unsubscribe()\n\n\t// Send prompt asking to summarize the local file\n\tprompt := fmt.Sprintf(`Please read the file at \"%s\" and provide a brief summary of its contents. \nAlso, if possible, check if there are any related GitHub repositories or documentation that might be relevant.`, testFile)\n\n\tfmt.Printf(\"\\nSending prompt:\\n%s\\n\\n\", prompt)\n\tfmt.Println(\"Response:\")\n\tfmt.Println(\"---\")\n\n\t// Send message and wait for completion\n\tresponse, err := session.SendAndWait(ctx, copilot.MessageOptions{\n\t\tPrompt: prompt,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send message: %w\", err)\n\t}\n\n\t// Print final response metadata\n\tfmt.Println(\"---\")\n\tif response != nil && response.Data.Content != nil {\n\t\tfmt.Printf(\"\\nFinal response length: %d characters\\n\", len(*response.Data.Content))\n\t}\n\n\t// Demonstrate listing available sessions\n\tfmt.Println(\"\\nListing active sessions...\")\n\tsessions, err := client.ListSessions(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list sessions: %w\", err)\n\t}\n\tfmt.Printf(\"Active sessions: %d\\n\", len(sessions))\n\n\treturn nil\n}\n\n// createSampleFile creates a sample text file for demonstration\nfunc createSampleFile(path string) error {\n\tcontent := `# Sample Document for MCP Demo\n\nThis is a sample document created to demonstrate the GitHub Copilot SDK\nwith MCP (Model Context Protocol) server integration.\n\n## Key Features Demonstrated\n\n1. **Remote HTTP MCP Server**: Connection to GitHub's MCP server for accessing\n   GitHub-related tools and information.\n\n2. **Local Stdio MCP Server**: Connection to a filesystem MCP server running\n   locally via Node.js, allowing the AI to read and interact with local files.\n\n3. **Multi-Server Integration**: Both servers work together in a single session,\n   allowing the AI to combine information from multiple sources.\n\n## Technical Details\n\n- Language: Go\n- SDK: GitHub Copilot SDK\n- MCP Servers: 2 (GitHub HTTP + Filesystem stdio)\n- Model: GPT-4.1\n\n## Use Cases\n\nThis pattern is useful for:\n- Analyzing local codebases with GitHub context\n- Generating documentation that references both local and remote resources\n- Code review workflows that need access to repository history\n- Development workflows that combine local file operations with GitHub API calls\n\n---\nGenerated: ` + time.Now().Format(time.RFC3339)\n\n\treturn os.WriteFile(path, []byte(content), 0644)\n}\n```\n\n## Additional Configuration Options\n\nHere's an enhanced version with more MCP server configuration options:\n\n```go\n// Enhanced MCP server configuration with environment variables and error handling\nfunc createEnhancedMCPConfig(cwd string) map[string]copilot.MCPServerConfig {\n\treturn map[string]copilot.MCPServerConfig{\n\t\t\"github\": {\n\t\t\tType:    \"http\",\n\t\t\tURL:     \"https://api.githubcopilot.com/mcp/\",\n\t\t\tTools:   []string{\"*\"},\n\t\t\tTimeout: 60000, // 60 seconds\n\t\t},\n\t\t\"filesystem\": {\n\t\t\tType:    \"local\",\n\t\t\tCommand: \"npx\",\n\t\t\tArgs: []string{\n\t\t\t\t\"-y\",\n\t\t\t\t\"@modelcontextprotocol/server-filesystem\",\n\t\t\t\tcwd,\n\t\t\t},\n\t\t\tTools: []string{\"*\"},\n\t\t\tEnv: map[string]string{\n\t\t\t\t\"NODE_ENV\": \"production\",\n\t\t\t},\n\t\t\tCWD:     cwd,\n\t\t\tTimeout: 30000,\n\t\t},\n\t\t// Optional: Add a local Ollama server for offline AI\n\t\t\"ollama\": {\n\t\t\tType:    \"local\",\n\t\t\tCommand: \"ollama\",\n\t\t\tArgs:    []string{\"serve\"},\n\t\t\tTools:   []string{\"generate\", \"embeddings\"},\n\t\t\tTimeout: 120000, // 2 minutes\n\t\t},\n\t}\n}\n```\n\n## Usage Instructions\n\n1. **Install dependencies:**\n```bash\ngo mod init mcp-demo\ngo get github.com/github/copilot-sdk/go\n```\n\n2. **Install Copilot CLI:**\n```bash\n# Install GitHub Copilot CLI\ngh extension install github/gh-copilot\n\n# Authenticate\ncopilot auth login\n```\n\n3. **Install MCP filesystem server:**\n```bash\n# Ensure Node.js is installed, then the server will be auto-installed via npx\nnode --version\n```\n\n4. **Run the application:**\n```bash\ngo run main.go\n```\n\n## Expected Output\n\n```\nStarting Copilot client...\nCreated sample file at: /path/to/sample.txt\n\nCreating session with MCP servers...\nSession created successfully!\n\nSending prompt:\nPlease read the file at \"/path/to/sample.txt\" and provide a brief summary...\n\nResponse:\n---\n[Tool Call: read_file]\n[Tool Result: read_file]\n\nI've read the sample document. Here's a summary:\n\nThis is a demonstration document showcasing the GitHub Copilot SDK's integration\nwith MCP (Model Context Protocol) servers. It highlights three key features:\n\n1. Remote HTTP connection to GitHub's MCP server\n2. Local stdio connection to a filesystem server\n3. Multi-server integration in a single session\n\nThe document outlines use cases including codebase analysis, documentation\ngeneration, code review workflows, and development tasks that combine local\nfile operations with GitHub API calls.\n\n[Tool Call: search_repositories]\n[Tool Result: search_repositories]\n\nRelated GitHub repositories include the official Copilot SDK and MCP\nspecification repositories...\n\n---\n\nFinal response length: 487 characters\n\nListing active sessions...\nActive sessions: 1\nShutting down gracefully...\nStopping Copilot client...\n```\n\n## Key Features Demonstrated\n\n1. **Multiple MCP Servers**: Connects to both HTTP (GitHub) and stdio (filesystem) servers simultaneously\n2. **Streaming Responses**: Real-time output as the AI generates responses\n3. **Tool Call Visibility**: Shows when tools are invoked and their results\n4. **Graceful Shutdown**: Proper cleanup with signal handling\n5. **Error Handling**: Comprehensive error checking throughout\n6. **Session Management**: Demonstrates session creation, usage, and cleanup\n\nThis application provides a complete example of using the Copilot SDK with multiple MCP servers in Go.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4508,
            "output_tokens": 2727,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Go application that uses the GitHub Copilot SDK to connect to both MCP servers and summarize a local file.\n\nFirst, let me check if the Copilot SDK is already in the dependencies:\n\n```go\n// go.mod - adding the GitHub Copilot SDK dependency\nmodule github.com/yourusername/project\n\ngo 1.22\n\nrequire (\n\tgithub.com/github/copilot-sdk/go v0.0.0-20240101000000-000000000000 // replace with actual version\n\tgithub.com/go-chi/chi/v5 v5.0.11\n\tgithub.com/jackc/pgx/v5 v5.5.1\n)\n```\n\nNow I'll create the Copilot MCP integration application:\n\n```go\n// cmd/copilot-mcp/main.go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/github/copilot-sdk/go/pkg/copilot\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Handle graceful shutdown\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigChan\n\t\tlog.Println(\"Shutting down...\")\n\t\tcancel()\n\t}()\n\n\tif err := run(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc run(ctx context.Context) error {\n\t// Create Copilot client\n\tclient := copilot.NewClient(&copilot.ClientConfig{\n\t\tLogLevel: \"info\",\n\t})\n\n\t// Start the client\n\tif err := client.Start(ctx); err != nil {\n\t\treturn fmt.Errorf(\"failed to start client: %w\", err)\n\t}\n\tdefer client.Stop()\n\n\tlog.Println(\"Copilot client started\")\n\n\t// Get the file to summarize from command line args or use default\n\tfileToSummarize := \"./README.md\"\n\tif len(os.Args) > 1 {\n\t\tfileToSummarize = os.Args[1]\n\t}\n\n\t// Get the allowed path for filesystem server (parent directory of file)\n\tallowedPath := \".\"\n\tif len(os.Args) > 2 {\n\t\tallowedPath = os.Args[2]\n\t}\n\n\t// Create session with both MCP servers\n\tsession, err := client.CreateSession(ctx, &copilot.SessionConfig{\n\t\tModel:     \"gpt-4.1\",\n\t\tStreaming: true,\n\t\tMCPServers: map[string]copilot.MCPServerConfig{\n\t\t\t// Remote HTTP MCP server for GitHub\n\t\t\t\"github\": {\n\t\t\t\tType:  \"http\",\n\t\t\t\tURL:   \"https://api.githubcopilot.com/mcp/\",\n\t\t\t\tTools: []string{\"*\"}, // Allow all tools\n\t\t\t},\n\t\t\t// Local stdio MCP server for filesystem access\n\t\t\t\"filesystem\": {\n\t\t\t\tType:    \"local\",\n\t\t\t\tCommand: \"npx\",\n\t\t\t\tArgs: []string{\n\t\t\t\t\t\"-y\",\n\t\t\t\t\t\"@modelcontextprotocol/server-filesystem\",\n\t\t\t\t\tallowedPath,\n\t\t\t\t},\n\t\t\t\tTools: []string{\"*\"}, // Allow all tools\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create session: %w\", err)\n\t}\n\tdefer session.Destroy()\n\n\tlog.Println(\"Session created with GitHub and filesystem MCP servers\")\n\n\t// Subscribe to streaming events\n\tsession.On(func(event copilot.SessionEvent) {\n\t\tswitch event.Type {\n\t\tcase copilot.SessionEventTypeAssistantMessageDelta:\n\t\t\tif event.Data != nil && event.Data.DeltaContent != \"\" {\n\t\t\t\tfmt.Print(event.Data.DeltaContent)\n\t\t\t}\n\t\tcase copilot.SessionEventTypeSessionIdle:\n\t\t\tfmt.Println() // New line after response completes\n\t\tcase copilot.SessionEventTypeToolCallStart:\n\t\t\tif event.Data != nil {\n\t\t\t\tlog.Printf(\"Tool call started: %s\", event.Data.ToolName)\n\t\t\t}\n\t\tcase copilot.SessionEventTypeToolCallEnd:\n\t\t\tif event.Data != nil {\n\t\t\t\tlog.Printf(\"Tool call completed: %s\", event.Data.ToolName)\n\t\t\t}\n\t\t}\n\t})\n\n\t// Send prompt to summarize the file\n\tprompt := fmt.Sprintf(\n\t\t\"Please read the file at '%s' and provide a concise summary of its contents. \"+\n\t\t\t\"Focus on the main purpose and key points.\",\n\t\tfileToSummarize,\n\t)\n\n\tlog.Printf(\"Sending prompt to summarize: %s\\n\", fileToSummarize)\n\tfmt.Println(\"\\n--- Response ---\")\n\n\tresponse, err := session.SendAndWait(ctx, copilot.MessageOptions{\n\t\tPrompt: prompt,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send message: %w\", err)\n\t}\n\n\t// Print final response if not streaming\n\tif response != nil && response.Data != nil && response.Data.Content != nil {\n\t\tfmt.Println(*response.Data.Content)\n\t}\n\n\treturn nil\n}\n```\n\nNow let me create a helper script to run the application:\n\n```bash\n#!/bin/bash\n# scripts/run-copilot-mcp.sh\n\nset -e\n\necho \"Running Copilot MCP integration...\"\necho \"Make sure you have:\"\necho \"  1. GitHub Copilot CLI installed (copilot --version)\"\necho \"  2. Authenticated with Copilot (copilot auth login)\"\necho \"  3. Node.js/npx available for filesystem MCP server\"\necho \"\"\n\n# Default values\nFILE_TO_SUMMARIZE=\"${1:-./README.md}\"\nALLOWED_PATH=\"${2:-.}\"\n\necho \"File to summarize: $FILE_TO_SUMMARIZE\"\necho \"Allowed filesystem path: $ALLOWED_PATH\"\necho \"\"\n\n# Build and run\ngo run cmd/copilot-mcp/main.go \"$FILE_TO_SUMMARIZE\" \"$ALLOWED_PATH\"\n```\n\nLet me also create a README for this feature:\n\n```markdown\n# Copilot MCP Integration\n\nThis application demonstrates using the GitHub Copilot SDK in Go to connect to multiple MCP (Model Context Protocol) servers and perform tasks using their tools.\n\n## Features\n\n- Connects to **GitHub HTTP MCP server** for GitHub-related tools\n- Connects to **local filesystem MCP server** for file operations\n- Streams responses in real-time\n- Summarizes local files using Copilot\n\n## Prerequisites\n\n1. **GitHub Copilot CLI** installed and authenticated:\n   ```bash\n   # Install (if not already installed)\n   gh extension install github/gh-copilot\n   \n   # Authenticate\n   copilot auth login\n   \n   # Verify\n   copilot --version\n   ```\n\n2. **GitHub Copilot subscription** (Individual, Business, or Enterprise)\n\n3. **Node.js/npx** for the filesystem MCP server\n\n4. **Go 1.22+**\n\n## Installation\n\n```bash\n# Install the Copilot SDK\ngo get github.com/github/copilot-sdk/go\n\n# Build the application\ngo build -o bin/copilot-mcp cmd/copilot-mcp/main.go\n```\n\n## Usage\n\n```bash\n# Summarize README.md in current directory\ngo run cmd/copilot-mcp/main.go\n\n# Summarize a specific file\ngo run cmd/copilot-mcp/main.go ./path/to/file.txt\n\n# Specify allowed filesystem path\ngo run cmd/copilot-mcp/main.go ./file.txt /allowed/path\n\n# Or use the helper script\nchmod +x scripts/run-copilot-mcp.sh\n./scripts/run-copilot-mcp.sh ./README.md .\n```\n\n## How It Works\n\n1. **Client Creation**: Creates a Copilot client with logging enabled\n2. **Session Setup**: Creates a session with two MCP servers:\n   - `github`: Remote HTTP server at `https://api.githubcopilot.com/mcp/`\n   - `filesystem`: Local stdio server using `@modelcontextprotocol/server-filesystem`\n3. **Streaming**: Subscribes to events to display responses in real-time\n4. **Tool Usage**: Copilot automatically uses the filesystem tools to read and summarize the file\n\n## MCP Servers\n\n### GitHub HTTP Server\n- **Type**: Remote HTTP\n- **URL**: `https://api.githubcopilot.com/mcp/`\n- **Tools**: GitHub-related operations\n\n### Filesystem Server\n- **Type**: Local stdio\n- **Command**: `npx -y @modelcontextprotocol/server-filesystem`\n- **Tools**: File read/write operations\n- **Security**: Restricted to specified allowed path\n\n## Example Output\n\n```\n2024/01/15 10:30:00 Copilot client started\n2024/01/15 10:30:01 Session created with GitHub and filesystem MCP servers\n2024/01/15 10:30:01 Sending prompt to summarize: ./README.md\n\n--- Response ---\n2024/01/15 10:30:02 Tool call started: read_file\n2024/01/15 10:30:02 Tool call completed: read_file\n\nThis README describes a Go HTTP service project that uses chi router and PostgreSQL...\n[streaming response continues]\n```\n\n## Configuration\n\nThe application uses these defaults:\n- **Model**: `gpt-4.1`\n- **Streaming**: Enabled\n- **Log Level**: `info`\n\n## Troubleshooting\n\n### \"CLI not found\"\nInstall the Copilot CLI: `gh extension install github/gh-copilot`\n\n### \"Not authenticated\"\nRun: `copilot auth login`\n\n### \"npx command not found\"\nInstall Node.js: https://nodejs.org/\n\n### \"Permission denied\" for file access\nEnsure the file is within the allowed path specified as the second argument.\n\n## References\n\n- [GitHub Copilot SDK](https://github.com/github/copilot-sdk)\n- [MCP Protocol](https://modelcontextprotocol.io)\n- [Copilot CLI](https://docs.github.com/en/copilot/how-tos/set-up/install-copilot-cli)\n```\n\nThe application is now complete! Here's what it does:\n\n1. **Creates a Copilot client** with logging\n2. **Sets up a session** with two MCP servers:\n   - GitHub HTTP server for GitHub operations\n   - Local filesystem server for file access\n3. **Enables streaming** to show responses in real-time\n4. **Subscribes to events** to display tool calls and response deltas\n5. **Sends a prompt** asking Copilot to read and summarize a file\n6. **Handles graceful shutdown** with signal handling\n\nTo use it:\n```bash\n# Make the script executable\nchmod +x scripts/run-copilot-mcp.sh\n\n# Run with default (README.md)\n./scripts/run-copilot-mcp.sh\n\n# Or specify a file\n./scripts/run-copilot-mcp.sh ./internal/store/store.go .\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4992,
            "output_tokens": 2810,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Go Application with GitHub Copilot SDK and MCP Servers\n\nHere's a complete Go application that connects to two MCP servers and uses the GitHub Copilot SDK:\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/copilot-extensions/preview-sdk.go/pkg/chat\"\n\t\"github.com/copilot-extensions/preview-sdk.go/pkg/mcp\"\n)\n\nfunc main() {\n\tif err := run(); err != nil {\n\t\tlog.Fatalf(\"Error: %v\", err)\n\t}\n}\n\nfunc run() error {\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)\n\tdefer cancel()\n\n\t// Create MCP client\n\tmcpClient := mcp.NewClient()\n\n\t// 1. Connect to remote HTTP MCP server for GitHub\n\tgithubServerConfig := mcp.ServerConfig{\n\t\tName:      \"github-server\",\n\t\tTransport: \"http\",\n\t\tURL:       \"https://mcp-github-server.example.com/mcp\", // Replace with actual GitHub MCP server URL\n\t\tHeaders: map[string]string{\n\t\t\t\"Authorization\": \"Bearer \" + os.Getenv(\"GITHUB_TOKEN\"),\n\t\t},\n\t}\n\n\tgithubServer, err := mcpClient.ConnectHTTP(ctx, githubServerConfig)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect to GitHub MCP server: %w\", err)\n\t}\n\tdefer githubServer.Close()\n\n\tlog.Println(\"\u2713 Connected to GitHub MCP server (HTTP)\")\n\n\t// 2. Connect to local stdio MCP server for filesystem access\n\tfilesystemServerConfig := mcp.ServerConfig{\n\t\tName:      \"filesystem-server\",\n\t\tTransport: \"stdio\",\n\t\tCommand:   \"npx\",\n\t\tArgs:      []string{\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/tmp\"},\n\t\tEnv:       os.Environ(),\n\t}\n\n\tfilesystemServer, err := mcpClient.ConnectStdio(ctx, filesystemServerConfig)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to connect to filesystem MCP server: %w\", err)\n\t}\n\tdefer filesystemServer.Close()\n\n\tlog.Println(\"\u2713 Connected to filesystem MCP server (stdio)\")\n\n\t// 3. List available tools from both servers\n\tgithubTools, err := githubServer.ListTools(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list GitHub tools: %w\", err)\n\t}\n\tlog.Printf(\"\u2713 GitHub server tools: %d available\", len(githubTools))\n\tfor _, tool := range githubTools {\n\t\tlog.Printf(\"  - %s: %s\", tool.Name, tool.Description)\n\t}\n\n\tfilesystemTools, err := filesystemServer.ListTools(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list filesystem tools: %w\", err)\n\t}\n\tlog.Printf(\"\u2713 Filesystem server tools: %d available\", len(filesystemTools))\n\tfor _, tool := range filesystemTools {\n\t\tlog.Printf(\"  - %s: %s\", tool.Name, tool.Description)\n\t}\n\n\t// 4. Create a chat session with GitHub Copilot\n\tcopilotToken := os.Getenv(\"COPILOT_TOKEN\")\n\tif copilotToken == \"\" {\n\t\treturn fmt.Errorf(\"COPILOT_TOKEN environment variable not set\")\n\t}\n\n\tchatClient := chat.NewClient(chat.ClientConfig{\n\t\tToken: copilotToken,\n\t})\n\n\t// 5. Create a session that can use tools from both servers\n\tsession := chat.NewSession(chat.SessionConfig{\n\t\tModel: \"gpt-4\",\n\t\tTools: append(githubTools, filesystemTools...),\n\t\tToolHandler: func(ctx context.Context, toolCall chat.ToolCall) (string, error) {\n\t\t\tlog.Printf(\"Tool called: %s with args: %s\", toolCall.Name, toolCall.Arguments)\n\n\t\t\t// Route tool calls to the appropriate server\n\t\t\tvar result interface{}\n\t\t\tvar err error\n\n\t\t\t// Check if tool belongs to filesystem server\n\t\t\tisFilesystemTool := false\n\t\t\tfor _, tool := range filesystemTools {\n\t\t\t\tif tool.Name == toolCall.Name {\n\t\t\t\t\tisFilesystemTool = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif isFilesystemTool {\n\t\t\t\tresult, err = filesystemServer.CallTool(ctx, toolCall.Name, json.RawMessage(toolCall.Arguments))\n\t\t\t} else {\n\t\t\t\tresult, err = githubServer.CallTool(ctx, toolCall.Name, json.RawMessage(toolCall.Arguments))\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"tool execution failed: %w\", err)\n\t\t\t}\n\n\t\t\tresultJSON, err := json.Marshal(result)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"failed to marshal tool result: %w\", err)\n\t\t\t}\n\n\t\t\treturn string(resultJSON), nil\n\t\t},\n\t})\n\n\t// 6. Send a prompt asking to summarize a local file\n\tprompt := `Please read the file located at /tmp/example.txt and provide a summary of its contents. \n\tIf the file doesn't exist, please let me know.`\n\n\tlog.Println(\"\\n\ud83d\udcdd Sending prompt to Copilot...\")\n\tlog.Printf(\"Prompt: %s\\n\", prompt)\n\n\tmessages := []chat.Message{\n\t\t{\n\t\t\tRole:    \"user\",\n\t\t\tContent: prompt,\n\t\t},\n\t}\n\n\t// Stream the response\n\tstream, err := chatClient.CreateChatCompletionStream(ctx, chat.ChatCompletionRequest{\n\t\tMessages: messages,\n\t\tSession:  session,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create chat completion: %w\", err)\n\t}\n\tdefer stream.Close()\n\n\tlog.Println(\"\\n\ud83e\udd16 Copilot response:\")\n\tlog.Println(\"---\")\n\n\tvar fullResponse string\n\tfor {\n\t\tresponse, err := stream.Recv()\n\t\tif err != nil {\n\t\t\tif err.Error() == \"EOF\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"error receiving stream: %w\", err)\n\t\t}\n\n\t\tif len(response.Choices) > 0 {\n\t\t\tdelta := response.Choices[0].Delta.Content\n\t\t\tfmt.Print(delta)\n\t\t\tfullResponse += delta\n\t\t}\n\t}\n\n\tlog.Println(\"\\n---\")\n\tlog.Println(\"\u2713 Conversation completed successfully\")\n\n\treturn nil\n}\n```\n\n## Supporting Files\n\n### `go.mod`\n\n```go\nmodule github.com/example/copilot-mcp-demo\n\ngo 1.21\n\nrequire (\n\tgithub.com/copilot-extensions/preview-sdk.go v0.1.0\n)\n```\n\n### Example test file creation script\n\n```bash\n#!/bin/bash\n# create-test-file.sh\n\ncat > /tmp/example.txt << 'EOF'\n# Project Status Report - Q4 2024\n\n## Overview\nThis quarter has been highly productive with significant milestones achieved.\n\n## Key Achievements\n- Launched new API v2.0 with improved performance\n- Reduced server response time by 40%\n- Onboarded 5 new enterprise clients\n- Completed security audit with zero critical issues\n\n## Challenges\n- Database migration took longer than expected\n- Team capacity constraints due to holiday season\n\n## Next Quarter Goals\n- Implement real-time analytics dashboard\n- Expand to European market\n- Hire 3 additional backend engineers\nEOF\n\necho \"Test file created at /tmp/example.txt\"\n```\n\n### `README.md`\n\n```markdown\n# GitHub Copilot + MCP Servers Demo\n\nThis application demonstrates how to use the GitHub Copilot SDK with multiple MCP (Model Context Protocol) servers.\n\n## Features\n\n- Connects to a remote HTTP MCP server (GitHub)\n- Connects to a local stdio MCP server (filesystem)\n- Creates a unified chat session with tools from both servers\n- Sends prompts that can trigger tool calls across multiple servers\n\n## Prerequisites\n\n1. **Go 1.21+** installed\n2. **Node.js** (for the filesystem MCP server)\n3. **Environment Variables**:\n   - `COPILOT_TOKEN`: Your GitHub Copilot API token\n   - `GITHUB_TOKEN`: Your GitHub personal access token (for the GitHub MCP server)\n\n## Setup\n\n1. Create the test file:\n```bash\nchmod +x create-test-file.sh\n./create-test-file.sh\n```\n\n2. Install dependencies:\n```bash\ngo mod download\n```\n\n3. Set environment variables:\n```bash\nexport COPILOT_TOKEN=\"your-copilot-token\"\nexport GITHUB_TOKEN=\"your-github-token\"\n```\n\n## Running\n\n```bash\ngo run main.go\n```\n\n## How It Works\n\n1. **Connection Phase**: The app connects to two MCP servers:\n   - HTTP server for GitHub operations\n   - Stdio server for local filesystem access\n\n2. **Tool Discovery**: Lists available tools from both servers\n\n3. **Session Creation**: Creates a Copilot chat session with access to all tools\n\n4. **Prompt Execution**: Sends a prompt asking to summarize a local file\n\n5. **Tool Routing**: Automatically routes tool calls to the appropriate server\n\n6. **Response Streaming**: Streams the Copilot response in real-time\n\n## Example Output\n\n```\n\u2713 Connected to GitHub MCP server (HTTP)\n\u2713 Connected to filesystem MCP server (stdio)\n\u2713 GitHub server tools: 5 available\n  - search_repositories: Search GitHub repositories\n  - get_file_contents: Get contents of a file\n  ...\n\u2713 Filesystem server tools: 3 available\n  - read_file: Read contents of a file\n  - list_directory: List directory contents\n  - write_file: Write contents to a file\n\n\ud83d\udcdd Sending prompt to Copilot...\n\n\ud83e\udd16 Copilot response:\n---\nI'll read the file for you...\n\n[Tool call: read_file with path /tmp/example.txt]\n\nBased on the file contents, here's a summary:\n\nThis is a Q4 2024 Project Status Report highlighting...\n---\n\u2713 Conversation completed successfully\n```\n\n## Architecture\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Go App        \u2502\n\u2502  (main.go)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502              \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 GitHub   \u2502   \u2502 Copilot  \u2502\n    \u2502 Copilot  \u2502   \u2502   SDK    \u2502\n    \u2502   SDK    \u2502   \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n         \u2502             \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n    \u2502    MCP Client          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502              \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 GitHub  \u2502    \u2502Filesystem\u2502\n    \u2502  MCP    \u2502    \u2502   MCP    \u2502\n    \u2502 (HTTP)  \u2502    \u2502 (stdio)  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Notes\n\n- Replace the GitHub MCP server URL with your actual server endpoint\n- The filesystem server is restricted to `/tmp` directory for security\n- Tool calls are automatically routed based on tool name matching\n- The application handles streaming responses for real-time output\n```\n\n## Key Features Explained\n\n1. **Dual Server Connection**: \n   - HTTP connection for remote GitHub MCP server\n   - Stdio connection for local filesystem MCP server\n\n2. **Tool Aggregation**: Combines tools from both servers into a single session\n\n3. **Smart Tool Routing**: The `ToolHandler` function routes tool calls to the appropriate server based on tool name\n\n4. **Streaming Response**: Uses streaming API for real-time response display\n\n5. **Error Handling**: Comprehensive error handling with context timeouts\n\n6. **Resource Cleanup**: Proper defer statements for closing connections\n\nThis application provides a complete example of integrating multiple MCP servers with GitHub Copilot in Go!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 63,
            "output_tokens": 3044,
            "cached": false
          },
          "with_skill": {
            "output": "# Go Application with GitHub Copilot SDK and MCP Servers\n\nHere's a complete Go application that demonstrates connecting to both remote and local MCP servers:\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/github/copilot-sdk/go/pkg/copilot\"\n)\n\nfunc main() {\n\t// Create context with cancellation for graceful shutdown\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Handle interrupt signals\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigChan\n\t\tfmt.Println(\"\\nShutting down gracefully...\")\n\t\tcancel()\n\t}()\n\n\tif err := run(ctx); err != nil {\n\t\tlog.Fatalf(\"Application error: %v\", err)\n\t}\n}\n\nfunc run(ctx context.Context) error {\n\t// Initialize Copilot client with debug logging\n\tclient := copilot.NewClient(&copilot.ClientConfig{\n\t\tLogLevel: \"info\",\n\t})\n\n\t// Start the client\n\tfmt.Println(\"Starting Copilot client...\")\n\tif err := client.Start(ctx); err != nil {\n\t\treturn fmt.Errorf(\"failed to start client: %w\", err)\n\t}\n\tdefer func() {\n\t\tfmt.Println(\"Stopping Copilot client...\")\n\t\tclient.Stop()\n\t}()\n\n\t// Get the current working directory for filesystem access\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get working directory: %w\", err)\n\t}\n\n\t// Create a test file to summarize\n\ttestFilePath := filepath.Join(cwd, \"sample.txt\")\n\tif err := createSampleFile(testFilePath); err != nil {\n\t\treturn fmt.Errorf(\"failed to create sample file: %w\", err)\n\t}\n\tdefer os.Remove(testFilePath) // Cleanup\n\n\tfmt.Printf(\"Created sample file at: %s\\n\", testFilePath)\n\n\t// Configure MCP servers\n\tmcpServers := map[string]copilot.MCPServerConfig{\n\t\t// Remote HTTP server for GitHub integration\n\t\t\"github\": {\n\t\t\tType: \"http\",\n\t\t\tURL:  \"https://api.githubcopilot.com/mcp/\",\n\t\t\tTools: []string{\"*\"}, // Allow all tools from this server\n\t\t},\n\t\t// Local stdio server for filesystem access\n\t\t\"filesystem\": {\n\t\t\tType:    \"local\",\n\t\t\tCommand: \"npx\",\n\t\t\tArgs: []string{\n\t\t\t\t\"-y\",\n\t\t\t\t\"@modelcontextprotocol/server-filesystem\",\n\t\t\t\tcwd, // Allow access to current directory\n\t\t\t},\n\t\t\tTools: []string{\"*\"}, // Allow all filesystem tools\n\t\t\tEnv: map[string]string{\n\t\t\t\t\"NODE_ENV\": \"production\",\n\t\t\t},\n\t\t\tTimeout: 30000, // 30 second timeout\n\t\t},\n\t}\n\n\t// Create session with both MCP servers\n\tfmt.Println(\"\\nCreating session with MCP servers...\")\n\tsession, err := client.CreateSession(ctx, &copilot.SessionConfig{\n\t\tModel:      \"gpt-4.1\",\n\t\tStreaming:  true,\n\t\tMCPServers: mcpServers,\n\t\tSystemMessage: &copilot.SystemMessage{\n\t\t\tContent: \"You are a helpful assistant with access to GitHub and filesystem tools. When summarizing files, be concise and highlight key points.\",\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create session: %w\", err)\n\t}\n\tdefer session.Destroy()\n\n\tfmt.Println(\"Session created successfully!\")\n\n\t// Subscribe to streaming events\n\tunsubscribe := session.On(func(event copilot.SessionEvent) {\n\t\tswitch event.Type {\n\t\tcase copilot.SessionEventTypeAssistantMessageDelta:\n\t\t\t// Print streaming content as it arrives\n\t\t\tif event.Data.DeltaContent != \"\" {\n\t\t\t\tfmt.Print(event.Data.DeltaContent)\n\t\t\t}\n\t\tcase copilot.SessionEventTypeToolUseStart:\n\t\t\tfmt.Printf(\"\\n[Tool Call: %s]\\n\", event.Data.ToolName)\n\t\tcase copilot.SessionEventTypeToolUseEnd:\n\t\t\tfmt.Printf(\"[Tool Complete: %s]\\n\", event.Data.ToolName)\n\t\tcase copilot.SessionEventTypeSessionIdle:\n\t\t\tfmt.Println(\"\\n\") // Add newline after response completes\n\t\tcase copilot.SessionEventTypeErrorOccurred:\n\t\t\tfmt.Printf(\"\\n[Error: %s]\\n\", event.Data.Message)\n\t\t}\n\t})\n\tdefer unsubscribe()\n\n\t// Send prompt asking to summarize the local file\n\tprompt := fmt.Sprintf(\n\t\t\"Please read and summarize the contents of the file at '%s'. \"+\n\t\t\t\"Provide a brief overview of what the file contains.\",\n\t\ttestFilePath,\n\t)\n\n\tfmt.Printf(\"\\nSending prompt:\\n%s\\n\\n\", prompt)\n\tfmt.Println(\"Response:\")\n\tfmt.Println(\"---\")\n\n\t// Send message and wait for completion\n\tresponse, err := session.SendAndWait(ctx, copilot.MessageOptions{\n\t\tPrompt: prompt,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send message: %w\", err)\n\t}\n\n\t// Print final response metadata\n\tfmt.Println(\"---\")\n\tfmt.Printf(\"\\nResponse received (ID: %s)\\n\", response.ID)\n\tif response.Data.Content != nil {\n\t\tfmt.Printf(\"Content length: %d characters\\n\", len(*response.Data.Content))\n\t}\n\n\t// Optional: Demonstrate GitHub MCP server capability\n\tfmt.Println(\"\\n\\n=== Testing GitHub MCP Server ===\")\n\tgithubPrompt := \"What GitHub tools are available to you? List them briefly.\"\n\t\n\tfmt.Printf(\"\\nSending prompt:\\n%s\\n\\n\", githubPrompt)\n\tfmt.Println(\"Response:\")\n\tfmt.Println(\"---\")\n\n\t_, err = session.SendAndWait(ctx, copilot.MessageOptions{\n\t\tPrompt: githubPrompt,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send GitHub query: %w\", err)\n\t}\n\n\tfmt.Println(\"---\")\n\n\t// List all active sessions\n\tsessions, err := client.ListSessions(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list sessions: %w\", err)\n\t}\n\tfmt.Printf(\"\\n\\nActive sessions: %d\\n\", len(sessions))\n\n\treturn nil\n}\n\n// createSampleFile creates a sample text file for demonstration\nfunc createSampleFile(path string) error {\n\tcontent := `# Sample Document\n\nThis is a sample document created for demonstration purposes.\n\n## Key Points\n\n1. **Purpose**: Demonstrate GitHub Copilot SDK with MCP servers\n2. **Technology**: Go programming language\n3. **Features**: \n   - Remote HTTP MCP server (GitHub)\n   - Local stdio MCP server (Filesystem)\n   - Streaming responses\n   - Tool integration\n\n## Content Summary\n\nThis document contains information about integrating multiple MCP servers\nwith the GitHub Copilot SDK. It showcases how to:\n\n- Connect to remote and local MCP servers simultaneously\n- Use filesystem tools to read local files\n- Stream responses in real-time\n- Handle tool invocations\n\n## Conclusion\n\nThe GitHub Copilot SDK provides a powerful way to build AI-powered\napplications with access to various tools and services through the\nModel Context Protocol (MCP).\n\nCreated at: ` + time.Now().Format(time.RFC3339)\n\n\treturn os.WriteFile(path, []byte(content), 0644)\n}\n```\n\n## Additional Files\n\n### `go.mod`\n\n```go\nmodule github.com/example/copilot-mcp-demo\n\ngo 1.21\n\nrequire github.com/github/copilot-sdk/go v0.1.0\n```\n\n### `README.md`\n\n```markdown\n# GitHub Copilot SDK with MCP Servers Demo\n\nThis Go application demonstrates using the GitHub Copilot SDK with multiple MCP servers.\n\n## Prerequisites\n\n1. **GitHub Copilot CLI** installed and authenticated:\n   ```bash\n   copilot --version\n   copilot auth login\n   ```\n\n2. **Node.js** (for the filesystem MCP server):\n   ```bash\n   node --version  # Should be 18+\n   ```\n\n3. **Go** 1.21 or higher:\n   ```bash\n   go version\n   ```\n\n## Installation\n\n```bash\n# Clone or create the project\nmkdir copilot-mcp-demo && cd copilot-mcp-demo\n\n# Initialize Go module\ngo mod init github.com/example/copilot-mcp-demo\n\n# Install dependencies\ngo get github.com/github/copilot-sdk/go\n```\n\n## Running\n\n```bash\ngo run main.go\n```\n\n## What It Does\n\n1. **Initializes** the Copilot client with debug logging\n2. **Creates** a sample text file in the current directory\n3. **Configures** two MCP servers:\n   - **GitHub** (remote HTTP): Access to GitHub-related tools\n   - **Filesystem** (local stdio): Access to read/write local files\n4. **Creates** a session with streaming enabled\n5. **Sends** a prompt asking to summarize the local file\n6. **Streams** the response in real-time\n7. **Demonstrates** GitHub MCP server capabilities\n8. **Cleans up** resources gracefully\n\n## Expected Output\n\n```\nStarting Copilot client...\nCreated sample file at: /path/to/sample.txt\n\nCreating session with MCP servers...\nSession created successfully!\n\nSending prompt:\nPlease read and summarize the contents of the file at '/path/to/sample.txt'...\n\nResponse:\n---\n[Tool Call: read_file]\n[Tool Complete: read_file]\n\nThe file is a sample document demonstrating GitHub Copilot SDK integration...\n[streaming response continues]\n---\n\nResponse received (ID: msg_abc123)\nContent length: 245 characters\n```\n\n## Troubleshooting\n\n- **CLI not found**: Install Copilot CLI or set `cliPath` in ClientConfig\n- **Not authenticated**: Run `copilot auth login`\n- **Node.js not found**: Install Node.js 18+ for filesystem MCP server\n- **Permission denied**: Ensure the working directory is accessible\n```\n\n## Key Features Demonstrated\n\n1. **Dual MCP Server Setup**: Remote HTTP (GitHub) + Local stdio (filesystem)\n2. **Streaming Responses**: Real-time output with event handling\n3. **Tool Integration**: Automatic tool discovery and invocation\n4. **Error Handling**: Graceful shutdown and error management\n5. **Event Subscription**: Monitoring tool calls and deltas\n6. **Resource Cleanup**: Proper disposal of sessions and client\n7. **Sample File Creation**: Automated test file generation\n\n## Running the Application\n\n```bash\n# Install dependencies\ngo mod download\n\n# Run the application\ngo run main.go\n\n# Build executable\ngo build -o copilot-mcp-demo\n./copilot-mcp-demo\n```\n\nThe application will create a sample file, connect to both MCP servers, and demonstrate how Copilot can use filesystem tools to read and summarize local files while also having access to GitHub-related capabilities.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4508,
            "output_tokens": 2847,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Go application that uses the GitHub Copilot SDK to connect to both MCP servers and summarize a local file.\n\nFirst, let me check if the Copilot SDK is already in the dependencies:\n\n```go\n// go.mod - adding the Copilot SDK dependency\nmodule github.com/yourusername/yourproject\n\ngo 1.22\n\nrequire (\n\tgithub.com/github/copilot-sdk/go v0.1.0\n\tgithub.com/go-chi/chi/v5 v5.0.11\n\tgithub.com/jackc/pgx/v5 v5.5.1\n)\n```\n\nNow I'll create the main application:\n\n```go\n// cmd/copilot-mcp/main.go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\tcopilot \"github.com/github/copilot-sdk/go\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Handle graceful shutdown\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-sigChan\n\t\tlog.Println(\"Shutting down...\")\n\t\tcancel()\n\t}()\n\n\tif err := run(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc run(ctx context.Context) error {\n\t// Create Copilot client\n\tclient := copilot.NewClient(&copilot.ClientConfig{\n\t\tLogLevel: \"info\",\n\t})\n\n\t// Start the client\n\tif err := client.Start(ctx); err != nil {\n\t\treturn fmt.Errorf(\"failed to start client: %w\", err)\n\t}\n\tdefer client.Stop()\n\n\tlog.Println(\"Copilot client started\")\n\n\t// Get the file path from command line args or use default\n\tfilePath := \"./README.md\"\n\tif len(os.Args) > 1 {\n\t\tfilePath = os.Args[1]\n\t}\n\n\t// Get absolute path for the allowed directory\n\tabsPath, err := os.Getwd()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get working directory: %w\", err)\n\t}\n\n\t// Create session with both MCP servers\n\tsession, err := client.CreateSession(ctx, &copilot.SessionConfig{\n\t\tModel:     \"gpt-4.1\",\n\t\tStreaming: true,\n\t\tMCPServers: map[string]copilot.MCPServerConfig{\n\t\t\t// Remote HTTP server for GitHub\n\t\t\t\"github\": {\n\t\t\t\tType:  \"http\",\n\t\t\t\tURL:   \"https://api.githubcopilot.com/mcp/\",\n\t\t\t\tTools: []string{\"*\"}, // Allow all tools\n\t\t\t},\n\t\t\t// Local stdio server for filesystem access\n\t\t\t\"filesystem\": {\n\t\t\t\tType:    \"local\",\n\t\t\t\tCommand: \"npx\",\n\t\t\t\tArgs: []string{\n\t\t\t\t\t\"-y\",\n\t\t\t\t\t\"@modelcontextprotocol/server-filesystem\",\n\t\t\t\t\tabsPath, // Allow access to current directory\n\t\t\t\t},\n\t\t\t\tTools: []string{\"*\"}, // Allow all filesystem tools\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create session: %w\", err)\n\t}\n\tdefer session.Destroy()\n\n\tlog.Println(\"Session created with GitHub and filesystem MCP servers\")\n\n\t// Subscribe to streaming events\n\tsession.On(func(event copilot.SessionEvent) {\n\t\tswitch event.Type {\n\t\tcase copilot.SessionEventTypeAssistantMessageDelta:\n\t\t\tif event.Data.DeltaContent != nil {\n\t\t\t\tfmt.Print(*event.Data.DeltaContent)\n\t\t\t}\n\t\tcase copilot.SessionEventTypeSessionIdle:\n\t\t\tfmt.Println() // New line after response completes\n\t\tcase copilot.SessionEventTypeToolUseStart:\n\t\t\tif event.Data.ToolName != nil {\n\t\t\t\tlog.Printf(\"Using tool: %s\", *event.Data.ToolName)\n\t\t\t}\n\t\tcase copilot.SessionEventTypeToolUseEnd:\n\t\t\tif event.Data.ToolName != nil {\n\t\t\t\tlog.Printf(\"Tool completed: %s\", *event.Data.ToolName)\n\t\t\t}\n\t\t}\n\t})\n\n\t// Send prompt to summarize the file\n\tprompt := fmt.Sprintf(\"Please read the file at %s and provide a brief summary of its contents.\", filePath)\n\tlog.Printf(\"Sending prompt: %s\\n\", prompt)\n\n\tresponse, err := session.SendAndWait(ctx, copilot.MessageOptions{\n\t\tPrompt: prompt,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send message: %w\", err)\n\t}\n\n\t// Print final response if not streaming\n\tif response != nil && response.Data.Content != nil {\n\t\tfmt.Println(*response.Data.Content)\n\t}\n\n\treturn nil\n}\n```\n\nNow let me create a README for this application:\n\n```markdown\n# Copilot MCP Integration Example\n\nThis Go application demonstrates how to use the GitHub Copilot SDK to connect to multiple MCP (Model Context Protocol) servers and perform file operations.\n\n## Features\n\n- Connects to GitHub's remote HTTP MCP server\n- Connects to a local filesystem MCP server via stdio\n- Creates a Copilot session that can use tools from both servers\n- Streams responses in real-time\n- Summarizes local files using AI\n\n## Prerequisites\n\n1. **GitHub Copilot CLI** installed and authenticated:\n   ```bash\n   # Install\n   gh extension install github/gh-copilot\n   \n   # Authenticate\n   copilot auth login\n   ```\n\n2. **Node.js** (for the filesystem MCP server):\n   ```bash\n   node --version  # Should be 18+\n   ```\n\n3. **GitHub Copilot subscription** (Individual, Business, or Enterprise)\n\n## Installation\n\n```bash\n# Install dependencies\ngo mod download\n\n# Build the application\ngo build -o copilot-mcp ./cmd/copilot-mcp\n```\n\n## Usage\n\n```bash\n# Summarize README.md (default)\n./copilot-mcp\n\n# Summarize a specific file\n./copilot-mcp path/to/your/file.txt\n\n# With verbose logging\nCOPILOT_LOG_LEVEL=debug ./copilot-mcp\n```\n\n## How It Works\n\n1. **Client Initialization**: Creates a Copilot client with logging enabled\n2. **MCP Server Configuration**:\n   - **GitHub Server**: Remote HTTP server for GitHub-related operations\n   - **Filesystem Server**: Local stdio server for reading/writing files\n3. **Session Creation**: Establishes a session with GPT-4.1 and both MCP servers\n4. **Streaming**: Subscribes to events to display responses in real-time\n5. **Tool Execution**: Copilot automatically calls the appropriate filesystem tool to read the file\n6. **Summary**: Returns an AI-generated summary of the file contents\n\n## MCP Servers\n\n### GitHub (Remote HTTP)\n- **URL**: `https://api.githubcopilot.com/mcp/`\n- **Tools**: GitHub API operations, repository management, etc.\n\n### Filesystem (Local Stdio)\n- **Command**: `npx -y @modelcontextprotocol/server-filesystem`\n- **Tools**: `read_file`, `write_file`, `list_directory`, etc.\n- **Access**: Limited to current working directory\n\n## Example Output\n\n```\n2024/01/15 10:30:00 Copilot client started\n2024/01/15 10:30:01 Session created with GitHub and filesystem MCP servers\n2024/01/15 10:30:01 Sending prompt: Please read the file at ./README.md and provide a brief summary of its contents.\n2024/01/15 10:30:02 Using tool: read_file\n2024/01/15 10:30:02 Tool completed: read_file\n\nThis README describes a Go HTTP service that uses the chi router and PostgreSQL...\n```\n\n## Troubleshooting\n\n- **\"CLI not found\"**: Install GitHub Copilot CLI\n- **\"Not authenticated\"**: Run `copilot auth login`\n- **\"npx not found\"**: Install Node.js\n- **\"Permission denied\"**: Ensure the file path is within the allowed directory\n\n## References\n\n- [GitHub Copilot SDK](https://github.com/github/copilot-sdk)\n- [MCP Protocol](https://modelcontextprotocol.io)\n- [Copilot CLI](https://docs.github.com/en/copilot/how-tos/set-up/install-copilot-cli)\n```\n\nThe application is now complete! Here's what it does:\n\n1. **Creates a Copilot client** with info-level logging\n2. **Configures two MCP servers**:\n   - GitHub remote HTTP server for GitHub operations\n   - Local filesystem server (via npx) for file access\n3. **Creates a streaming session** with GPT-4.1\n4. **Subscribes to events** to show real-time output and tool usage\n5. **Sends a prompt** asking to summarize a file\n6. **Handles graceful shutdown** with signal handling\n\nTo use it:\n```bash\ngo mod tidy\ngo run cmd/copilot-mcp/main.go ./README.md\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 4992,
            "output_tokens": 2324,
            "cached": false
          }
        }
      ]
    }
  ]
}