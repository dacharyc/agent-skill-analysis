{
  "skill_name": "azure-identity-java",
  "generated_at": "2026-02-16T09:01:59.453394+00:00",
  "model": "claude-sonnet-4-5-20250929",
  "temperature": 0.3,
  "runs_per_condition": 3,
  "contamination_score": 0.52,
  "risk_level": "high",
  "test_category": "sdk_cross_lang",
  "tasks": [
    {
      "task_id": "azure-identity-java-01",
      "task_type": "direct_target",
      "target_language": "java",
      "expected_patterns": [
        "DefaultAzureCredentialBuilder",
        "managedIdentityClientId\\(",
        "tenantId\\(",
        "\\.build\\(\\)",
        "BlobServiceClientBuilder",
        "KeyClientBuilder",
        "CredentialUnavailableException"
      ],
      "anti_patterns": [
        "DefaultAzureCredential\\(",
        "from azure\\.identity",
        "require.*@azure/identity",
        "azidentity\\.NewDefaultAzureCredential",
        "Azure\\.Identity",
        "credential_chain|ChainedTokenCredential.*add_credential"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.defaultazurecredentialbuilder",
          "description": "Java DefaultAzureCredentialBuilder API reference - source of new DefaultAzureCredentialBuilder(), managedIdentityClientId() method, tenantId() method, and .build() method with code examples"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.credentialunavailableexception",
          "description": "Java CredentialUnavailableException API reference - exception thrown when credential is unavailable for authentication error handling"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.storage.blob.blobserviceclientbuilder",
          "description": "Java BlobServiceClientBuilder API reference - source of BlobServiceClientBuilder class for Azure Blob Storage client creation with builder pattern"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.keys.keyclientbuilder",
          "description": "Java KeyClientBuilder API reference - source of KeyClientBuilder class with credential(), vaultUrl(), and build() methods for Azure Key Vault client creation"
        },
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-identity/azure.identity.defaultazurecredential",
          "description": "Anti-patterns: Python DefaultAzureCredential() direct instantiation, from azure.identity import pattern"
        },
        {
          "url": "https://learn.microsoft.com/en-us/javascript/api/@azure/identity/defaultazurecredential",
          "description": "Anti-patterns: JavaScript require('@azure/identity') pattern"
        },
        {
          "url": "https://pkg.go.dev/github.com/Azure/azure-sdk-for-go/sdk/azidentity",
          "description": "Anti-patterns: Go azidentity.NewDefaultAzureCredential function"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "```java\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobServiceClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\n\n@Service\npublic class AzureAuthenticationService {\n\n    private static final Logger logger = LoggerFactory.getLogger(AzureAuthenticationService.class);\n\n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n\n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.storage.account-url}\")\n    private String storageAccountUrl;\n\n    @Value(\"${azure.keyvault.url}\")\n    private String keyVaultUrl;\n\n    private DefaultAzureCredential credential;\n    private BlobServiceClient blobServiceClient;\n    private KeyClient keyClient;\n\n    @PostConstruct\n    public void initialize() {\n        try {\n            this.credential = createAzureCredential();\n            this.blobServiceClient = createBlobServiceClient();\n            this.keyClient = createKeyClient();\n            logger.info(\"Azure authentication and clients initialized successfully\");\n        } catch (Exception e) {\n            logger.error(\"Failed to initialize Azure clients\", e);\n            throw new RuntimeException(\"Azure initialization failed\", e);\n        }\n    }\n\n    /**\n     * Creates and configures DefaultAzureCredential with specific tenant ID and managed identity client ID\n     *\n     * @return Configured DefaultAzureCredential\n     * @throws ClientAuthenticationException if credential creation fails\n     */\n    private DefaultAzureCredential createAzureCredential() {\n        try {\n            logger.info(\"Creating Azure credential with tenant ID: {} and managed identity client ID: {}\", \n                       tenantId, managedIdentityClientId);\n\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                    .tenantId(tenantId)\n                    .managedIdentityClientId(managedIdentityClientId)\n                    .build();\n\n            logger.info(\"Azure credential created successfully\");\n            return credential;\n\n        } catch (Exception e) {\n            logger.error(\"Failed to create Azure credential\", e);\n            throw new ClientAuthenticationException(\"Unable to create Azure credential\", null, e);\n        }\n    }\n\n    /**\n     * Creates BlobServiceClient using the configured credential\n     *\n     * @return Configured BlobServiceClient\n     * @throws AzureAuthenticationException if client creation fails\n     */\n    private BlobServiceClient createBlobServiceClient() {\n        try {\n            logger.info(\"Creating BlobServiceClient for storage account: {}\", storageAccountUrl);\n\n            BlobServiceClient client = new BlobServiceClientBuilder()\n                    .endpoint(storageAccountUrl)\n                    .credential(credential)\n                    .buildClient();\n\n            // Test the connection\n            client.getAccountInfo();\n            logger.info(\"BlobServiceClient created and validated successfully\");\n            return client;\n\n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Authentication failed when creating BlobServiceClient\", e);\n            throw new AzureAuthenticationException(\"Failed to authenticate to Azure Storage\", e);\n        } catch (Exception e) {\n            logger.error(\"Failed to create BlobServiceClient\", e);\n            throw new AzureAuthenticationException(\"Failed to create BlobServiceClient\", e);\n        }\n    }\n\n    /**\n     * Creates KeyClient using the configured credential\n     *\n     * @return Configured KeyClient\n     * @throws AzureAuthenticationException if client creation fails\n     */\n    private KeyClient createKeyClient() {\n        try {\n            logger.info(\"Creating KeyClient for Key Vault: {}\", keyVaultUrl);\n\n            KeyClient client = new KeyClientBuilder()\n                    .vaultUrl(keyVaultUrl)\n                    .credential(credential)\n                    .buildClient();\n\n            // Test the connection by attempting to list keys (requires appropriate permissions)\n            try {\n                client.listPropertiesOfKeys().stream().findFirst();\n                logger.info(\"KeyClient created and validated successfully\");\n            } catch (Exception e) {\n                logger.warn(\"KeyClient created but validation failed (may lack list permissions): {}\", \n                           e.getMessage());\n            }\n\n            return client;\n\n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Authentication failed when creating KeyClient\", e);\n            throw new AzureAuthenticationException(\"Failed to authenticate to Azure Key Vault\", e);\n        } catch (Exception e) {\n            logger.error(\"Failed to create KeyClient\", e);\n            throw new AzureAuthenticationException(\"Failed to create KeyClient\", e);\n        }\n    }\n\n    /**\n     * Gets the configured BlobServiceClient\n     *\n     * @return BlobServiceClient instance\n     * @throws IllegalStateException if client is not initialized\n     */\n    public BlobServiceClient getBlobServiceClient() {\n        if (blobServiceClient == null) {\n            throw new IllegalStateException(\"BlobServiceClient is not initialized\");\n        }\n        return blobServiceClient;\n    }\n\n    /**\n     * Gets the configured KeyClient\n     *\n     * @return KeyClient instance\n     * @throws IllegalStateException if client is not initialized\n     */\n    public KeyClient getKeyClient() {\n        if (keyClient == null) {\n            throw new IllegalStateException(\"KeyClient is not initialized\");\n        }\n        return keyClient;\n    }\n\n    /**\n     * Gets the configured credential\n     *\n     * @return DefaultAzureCredential instance\n     * @throws IllegalStateException if credential is not initialized\n     */\n    public TokenCredential getCredential() {\n        if (credential == null) {\n            throw new IllegalStateException(\"Azure credential is not initialized\");\n        }\n        return credential;\n    }\n\n    /**\n     * Validates that all Azure clients are properly initialized and can authenticate\n     *\n     * @return true if all clients are valid\n     * @throws AzureAuthenticationException if validation fails\n     */\n    public boolean validateAuthentication() {\n        try {\n            logger.info(\"Validating Azure authentication and clients\");\n\n            // Validate BlobServiceClient\n            blobServiceClient.getAccountInfo();\n            logger.debug(\"BlobServiceClient validation successful\");\n\n            // Validate KeyClient (may fail if no list permissions)\n            try {\n                keyClient.listPropertiesOfKeys().stream().findFirst();\n                logger.debug(\"KeyClient validation successful\");\n            } catch (Exception e) {\n                logger.warn(\"KeyClient validation skipped (may lack permissions): {}\", e.getMessage());\n            }\n\n            logger.info(\"Azure authentication validation completed successfully\");\n            return true;\n\n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Authentication validation failed\", e);\n            throw new AzureAuthenticationException(\"Azure authentication validation failed\", e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error during authentication validation\", e);\n            throw new AzureAuthenticationException(\"Unexpected error during validation\", e);\n        }\n    }\n\n    /**\n     * Custom exception for Azure authentication errors\n     */\n    public static class AzureAuthenticationException extends RuntimeException {\n        public AzureAuthenticationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```\n\n```java\n// application.properties or application.yml configuration\n```\n\n```properties\n# application.properties\nazure.tenant-id=your-tenant-id-here\nazure.managed-identity.client-id=your-managed-identity-client-id-here\nazure.storage.account-url=https://yourstorageaccount.blob.core.windows.net\nazure.keyvault.url=https://yourkeyvault.vault.azure.net/\n```\n\n```yaml\n# application.yml\nazure:\n  tenant-id: your-tenant-id-here\n  managed-identity:\n    client-id: your-managed-identity-client-id-here\n  storage:\n    account-url: https://yourstorageaccount.blob.core.windows.net\n  keyvault:\n    url: https://yourkeyvault.vault.azure.net/\n```\n\n```xml\n<!-- pom.xml dependencies -->\n<dependencies>\n    <!-- Spring Boot Starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.11.0</version>\n    </dependency>\n\n    <!-- Azure Storage Blob -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-storage-blob</artifactId>\n        <version>12.25.0</version>\n    </dependency>\n\n    <!-- Azure Key Vault Keys -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n        <version>4.7.0</version>\n    </dependency>\n\n    <!-- Logging -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n    </dependency>\n</dependencies>\n```\n\n```java\n// Example usage in a controller or another service\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class AzureTestController {\n\n    @Autowired\n    private AzureAuthenticationService azureAuthService;\n\n    @GetMapping(\"/test-azure-connection\")\n    public String testAzureConnection() {\n        try {\n            boolean isValid = azureAuthService.validateAuthentication();\n            return isValid ? \"Azure authentication successful\" : \"Azure authentication failed\";\n        } catch (AzureAuthenticationService.AzureAuthenticationException e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    @GetMapping(\"/list-containers\")\n    public String listContainers() {\n        try {\n            var blobClient = azureAuthService.getBlobServiceClient();\n            var containers = blobClient.listBlobContainers();\n            StringBuilder result = new StringBuilder(\"Containers:\\n\");\n            containers.forEach(container -> result.append(\"- \").append(container.getName()).append(\"\\n\"));\n            return result.toString();\n        } catch (Exception e) {\n            return \"Error listing containers: \" + e.getMessage();\n        }\n    }\n}\n```\n\nThis implementation provides:\n\n1. **Proper Configuration**: Uses `DefaultAzureCredentialBuilder` with specific tenant ID and managed identity client ID\n2. **Error Handling**: Catches `ClientAuthenticationException` and wraps it in a custom exception\n3. **Initialization**: Uses `@PostConstruct` to initialize clients on service startup\n4. **Validation**: Includes methods to validate authentication\n5. **Logging**: Comprehensive logging for debugging\n6. **Spring Integration**: Proper Spring Boot service with dependency injection support\n7. **Both Clients**: Creates and manages both `BlobServiceClient` and `KeyClient`",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 76,
            "output_tokens": 2870,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Authentication Service with DefaultAzureCredential\n\nHere's a complete Spring Boot service class that demonstrates Azure authentication with proper configuration and error handling:\n\n```java\npackage com.example.azure.service;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobServiceClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\n\n/**\n * Service for managing Azure authentication and client initialization.\n * Uses DefaultAzureCredential with user-assigned managed identity.\n */\n@Service\npublic class AzureAuthenticationService {\n\n    private static final Logger logger = LoggerFactory.getLogger(AzureAuthenticationService.class);\n\n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n\n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.storage.account-name}\")\n    private String storageAccountName;\n\n    @Value(\"${azure.keyvault.vault-url}\")\n    private String keyVaultUrl;\n\n    private DefaultAzureCredential credential;\n    private BlobServiceClient blobServiceClient;\n    private KeyClient keyClient;\n\n    /**\n     * Initializes Azure credential and clients after bean construction.\n     */\n    @PostConstruct\n    public void initialize() {\n        try {\n            logger.info(\"Initializing Azure authentication with tenant ID: {}\", tenantId);\n            this.credential = createAzureCredential();\n            this.blobServiceClient = createBlobServiceClient();\n            this.keyClient = createKeyClient();\n            logger.info(\"Azure clients initialized successfully\");\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"No Azure credential available. Ensure managed identity is configured or Azure CLI is logged in.\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure authentication: No credential available\", e);\n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Azure authentication failed. Check tenant ID and managed identity configuration.\", e);\n            throw new IllegalStateException(\"Failed to authenticate with Azure\", e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error during Azure client initialization\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure clients\", e);\n        }\n    }\n\n    /**\n     * Creates and configures DefaultAzureCredential with specific tenant and managed identity.\n     *\n     * @return Configured DefaultAzureCredential\n     * @throws CredentialUnavailableException if no credential is available\n     */\n    private DefaultAzureCredential createAzureCredential() throws CredentialUnavailableException {\n        logger.debug(\"Creating DefaultAzureCredential with managed identity client ID: {}\", managedIdentityClientId);\n\n        return new DefaultAzureCredentialBuilder()\n                .tenantId(tenantId)\n                .managedIdentityClientId(managedIdentityClientId)\n                .build();\n    }\n\n    /**\n     * Creates BlobServiceClient using the configured credential.\n     *\n     * @return Configured BlobServiceClient\n     * @throws CredentialUnavailableException if credential is not available\n     */\n    private BlobServiceClient createBlobServiceClient() throws CredentialUnavailableException {\n        String endpoint = String.format(\"https://%s.blob.core.windows.net\", storageAccountName);\n        logger.debug(\"Creating BlobServiceClient for endpoint: {}\", endpoint);\n\n        try {\n            return new BlobServiceClientBuilder()\n                    .endpoint(endpoint)\n                    .credential(credential)\n                    .buildClient();\n        } catch (Exception e) {\n            logger.error(\"Failed to create BlobServiceClient for endpoint: {}\", endpoint, e);\n            throw e;\n        }\n    }\n\n    /**\n     * Creates KeyClient using the configured credential.\n     *\n     * @return Configured KeyClient\n     * @throws CredentialUnavailableException if credential is not available\n     */\n    private KeyClient createKeyClient() throws CredentialUnavailableException {\n        logger.debug(\"Creating KeyClient for vault URL: {}\", keyVaultUrl);\n\n        try {\n            return new KeyClientBuilder()\n                    .vaultUrl(keyVaultUrl)\n                    .credential(credential)\n                    .buildClient();\n        } catch (Exception e) {\n            logger.error(\"Failed to create KeyClient for vault: {}\", keyVaultUrl, e);\n            throw e;\n        }\n    }\n\n    /**\n     * Gets the configured BlobServiceClient.\n     *\n     * @return BlobServiceClient instance\n     * @throws IllegalStateException if client is not initialized\n     */\n    public BlobServiceClient getBlobServiceClient() {\n        if (blobServiceClient == null) {\n            throw new IllegalStateException(\"BlobServiceClient not initialized. Check initialization logs.\");\n        }\n        return blobServiceClient;\n    }\n\n    /**\n     * Gets the configured KeyClient.\n     *\n     * @return KeyClient instance\n     * @throws IllegalStateException if client is not initialized\n     */\n    public KeyClient getKeyClient() {\n        if (keyClient == null) {\n            throw new IllegalStateException(\"KeyClient not initialized. Check initialization logs.\");\n        }\n        return keyClient;\n    }\n\n    /**\n     * Gets the configured credential.\n     *\n     * @return DefaultAzureCredential instance\n     * @throws IllegalStateException if credential is not initialized\n     */\n    public TokenCredential getCredential() {\n        if (credential == null) {\n            throw new IllegalStateException(\"Credential not initialized. Check initialization logs.\");\n        }\n        return credential;\n    }\n\n    /**\n     * Validates that all required configuration properties are set.\n     *\n     * @throws IllegalArgumentException if any required property is missing\n     */\n    public void validateConfiguration() {\n        if (tenantId == null || tenantId.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"azure.tenant-id must be configured\");\n        }\n        if (managedIdentityClientId == null || managedIdentityClientId.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"azure.managed-identity.client-id must be configured\");\n        }\n        if (storageAccountName == null || storageAccountName.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"azure.storage.account-name must be configured\");\n        }\n        if (keyVaultUrl == null || keyVaultUrl.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"azure.keyvault.vault-url must be configured\");\n        }\n    }\n}\n```\n\n## Configuration File (application.yml)\n\n```yaml\nazure:\n  tenant-id: ${AZURE_TENANT_ID:12345678-1234-1234-1234-123456789012}\n  managed-identity:\n    client-id: ${AZURE_CLIENT_ID:87654321-4321-4321-4321-210987654321}\n  storage:\n    account-name: ${AZURE_STORAGE_ACCOUNT:mystorageaccount}\n  keyvault:\n    vault-url: ${AZURE_KEYVAULT_URL:https://myvault.vault.azure.net}\n\nlogging:\n  level:\n    com.azure: DEBUG\n    com.example.azure: DEBUG\n```\n\n## Maven Dependencies (pom.xml)\n\n```xml\n<dependencies>\n    <!-- Spring Boot Starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.15.0</version>\n    </dependency>\n\n    <!-- Azure Storage Blob -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-storage-blob</artifactId>\n        <version>12.30.0</version>\n    </dependency>\n\n    <!-- Azure Key Vault Keys -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n        <version>4.9.0</version>\n    </dependency>\n\n    <!-- Logging -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n    </dependency>\n</dependencies>\n```\n\n## Usage Example\n\n```java\npackage com.example.azure.controller;\n\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport com.azure.storage.blob.BlobContainerClient;\nimport com.example.azure.service.AzureAuthenticationService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/api/azure\")\npublic class AzureTestController {\n\n    @Autowired\n    private AzureAuthenticationService azureAuthService;\n\n    @GetMapping(\"/test-storage\")\n    public String testStorageAccess() {\n        try {\n            BlobContainerClient containerClient = azureAuthService\n                    .getBlobServiceClient()\n                    .getBlobContainerClient(\"test-container\");\n\n            boolean exists = containerClient.exists();\n            return \"Storage access successful. Container exists: \" + exists;\n        } catch (Exception e) {\n            return \"Storage access failed: \" + e.getMessage();\n        }\n    }\n\n    @GetMapping(\"/test-keyvault\")\n    public String testKeyVaultAccess() {\n        try {\n            KeyVaultKey key = azureAuthService\n                    .getKeyClient()\n                    .getKey(\"test-key\");\n\n            return \"Key Vault access successful. Key name: \" + key.getName();\n        } catch (Exception e) {\n            return \"Key Vault access failed: \" + e.getMessage();\n        }\n    }\n}\n```\n\n## Unit Test Example\n\n```java\npackage com.example.azure.service;\n\nimport com.azure.identity.CredentialUnavailableException;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.TestPropertySource;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n@SpringBootTest\n@TestPropertySource(properties = {\n    \"azure.tenant-id=test-tenant-id\",\n    \"azure.managed-identity.client-id=test-client-id\",\n    \"azure.storage.account-name=teststorage\",\n    \"azure.keyvault.vault-url=https://testvault.vault.azure.net\"\n})\nclass AzureAuthenticationServiceTest {\n\n    @Autowired\n    private AzureAuthenticationService service;\n\n    @Test\n    void testConfigurationValidation() {\n        assertDoesNotThrow(() -> service.validateConfiguration());\n    }\n\n    @Test\n    void testGetBlobServiceClient() {\n        assertNotNull(service.getBlobServiceClient());\n    }\n\n    @Test\n    void testGetKeyClient() {\n        assertNotNull(service.getKeyClient());\n    }\n\n    @Test\n    void testGetCredential() {\n        assertNotNull(service.getCredential());\n    }\n}\n```\n\n## Key Features\n\n1. **Proper Configuration**: Uses Spring Boot's `@Value` annotations with environment variable fallbacks\n2. **DefaultAzureCredential**: Configured with specific tenant ID and user-assigned managed identity\n3. **Error Handling**: Catches `CredentialUnavailableException` and `ClientAuthenticationException`\n4. **Logging**: Comprehensive logging for debugging authentication issues\n5. **Lazy Initialization**: Clients are created once during `@PostConstruct`\n6. **Thread-Safe**: Singleton service with immutable clients\n7. **Validation**: Configuration validation method\n8. **Production-Ready**: Includes proper exception handling and state management\n\n## Environment Variables\n\nSet these for local development or production:\n\n```bash\nexport AZURE_TENANT_ID=\"12345678-1234-1234-1234-123456789012\"\nexport AZURE_CLIENT_ID=\"87654321-4321-4321-4321-210987654321\"\nexport AZURE_STORAGE_ACCOUNT=\"mystorageaccount\"\nexport AZURE_KEYVAULT_URL=\"https://myvault.vault.azure.net\"\n```\n\nThis service provides a robust, production-ready implementation for Azure authentication in Spring Boot applications.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10853,
            "output_tokens": 3271,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive Azure service class with proper authentication, client initialization, and error handling.\n\n```java\npackage com.example.app.service;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobServiceClientBuilder;\nimport jakarta.annotation.PostConstruct;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class AzureAuthenticationService {\n    \n    private static final Logger log = LoggerFactory.getLogger(AzureAuthenticationService.class);\n    \n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n    \n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n    \n    @Value(\"${azure.storage.account-endpoint}\")\n    private String storageAccountEndpoint;\n    \n    @Value(\"${azure.keyvault.vault-url}\")\n    private String keyVaultUrl;\n    \n    private DefaultAzureCredential credential;\n    private BlobServiceClient blobServiceClient;\n    private KeyClient keyClient;\n    \n    @PostConstruct\n    public void initialize() {\n        try {\n            log.info(\"Initializing Azure authentication with tenant ID: {} and managed identity client ID: {}\", \n                     tenantId, managedIdentityClientId);\n            \n            // Configure DefaultAzureCredential with tenant ID and user-assigned managed identity\n            credential = new DefaultAzureCredentialBuilder()\n                .tenantId(tenantId)\n                .managedIdentityClientId(managedIdentityClientId)\n                .build();\n            \n            // Initialize Azure clients\n            initializeBlobServiceClient();\n            initializeKeyClient();\n            \n            log.info(\"Azure authentication and client initialization completed successfully\");\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential available for Azure authentication. \" +\n                     \"Ensure managed identity is configured or environment variables are set.\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure authentication: No credential available\", e);\n            \n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed with Azure. Check tenant ID and managed identity configuration.\", e);\n            throw new IllegalStateException(\"Failed to authenticate with Azure\", e);\n            \n        } catch (Exception e) {\n            log.error(\"Unexpected error during Azure client initialization\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure clients\", e);\n        }\n    }\n    \n    private void initializeBlobServiceClient() {\n        try {\n            log.info(\"Initializing BlobServiceClient for endpoint: {}\", storageAccountEndpoint);\n            \n            blobServiceClient = new BlobServiceClientBuilder()\n                .endpoint(storageAccountEndpoint)\n                .credential(credential)\n                .buildClient();\n            \n            log.info(\"BlobServiceClient initialized successfully\");\n            \n        } catch (Exception e) {\n            log.error(\"Failed to initialize BlobServiceClient\", e);\n            throw new IllegalStateException(\"Failed to create BlobServiceClient\", e);\n        }\n    }\n    \n    private void initializeKeyClient() {\n        try {\n            log.info(\"Initializing KeyClient for vault: {}\", keyVaultUrl);\n            \n            keyClient = new KeyClientBuilder()\n                .vaultUrl(keyVaultUrl)\n                .credential(credential)\n                .buildClient();\n            \n            log.info(\"KeyClient initialized successfully\");\n            \n        } catch (Exception e) {\n            log.error(\"Failed to initialize KeyClient\", e);\n            throw new IllegalStateException(\"Failed to create KeyClient\", e);\n        }\n    }\n    \n    /**\n     * Gets the configured Azure credential.\n     * \n     * @return the DefaultAzureCredential instance\n     * @throws IllegalStateException if credential is not initialized\n     */\n    public TokenCredential getCredential() {\n        if (credential == null) {\n            throw new IllegalStateException(\"Azure credential not initialized\");\n        }\n        return credential;\n    }\n    \n    /**\n     * Gets the BlobServiceClient for Azure Blob Storage operations.\n     * \n     * @return the BlobServiceClient instance\n     * @throws IllegalStateException if client is not initialized\n     */\n    public BlobServiceClient getBlobServiceClient() {\n        if (blobServiceClient == null) {\n            throw new IllegalStateException(\"BlobServiceClient not initialized\");\n        }\n        return blobServiceClient;\n    }\n    \n    /**\n     * Gets the KeyClient for Azure Key Vault operations.\n     * \n     * @return the KeyClient instance\n     * @throws IllegalStateException if client is not initialized\n     */\n    public KeyClient getKeyClient() {\n        if (keyClient == null) {\n            throw new IllegalStateException(\"KeyClient not initialized\");\n        }\n        return keyClient;\n    }\n}\n```\n\nNow let me create the corresponding configuration properties file:\n\n```properties\n# src/main/resources/application.properties\n\n# Azure Authentication Configuration\nazure.tenant-id=${AZURE_TENANT_ID}\nazure.managed-identity.client-id=${AZURE_CLIENT_ID}\n\n# Azure Storage Configuration\nazure.storage.account-endpoint=https://${AZURE_STORAGE_ACCOUNT_NAME}.blob.core.windows.net\n\n# Azure Key Vault Configuration\nazure.keyvault.vault-url=https://${AZURE_KEYVAULT_NAME}.vault.azure.net\n```\n\nAnd the required Maven dependencies:\n\n```xml\n<!-- Add to pom.xml -->\n<dependencies>\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.18.2</version>\n    </dependency>\n    \n    <!-- Azure Storage Blob -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-storage-blob</artifactId>\n        <version>12.29.0</version>\n    </dependency>\n    \n    <!-- Azure Key Vault Keys -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n        <version>4.9.1</version>\n    </dependency>\n</dependencies>\n```\n\nHere's an example of how to use this service:\n\n```java\npackage com.example.app.service;\n\nimport com.azure.storage.blob.BlobContainerClient;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class ExampleUsageService {\n    \n    private final AzureAuthenticationService azureAuthService;\n    \n    public ExampleUsageService(AzureAuthenticationService azureAuthService) {\n        this.azureAuthService = azureAuthService;\n    }\n    \n    public void uploadBlobExample(String containerName, String blobName, String content) {\n        BlobContainerClient containerClient = azureAuthService.getBlobServiceClient()\n            .getBlobContainerClient(containerName);\n        \n        containerClient.getBlobClient(blobName)\n            .upload(content.getBytes(), true);\n    }\n    \n    public KeyVaultKey getKeyExample(String keyName) {\n        return azureAuthService.getKeyClient()\n            .getKey(keyName);\n    }\n}\n```\n\n**Key Features:**\n\n1. \u2705 **DefaultAzureCredential** configured with tenant ID and user-assigned managed identity\n2. \u2705 **BlobServiceClient** and **KeyClient** initialization\n3. \u2705 **Proper error handling** for `CredentialUnavailableException` and `ClientAuthenticationException`\n4. \u2705 **Spring Boot integration** with `@PostConstruct` for initialization\n5. \u2705 **Configuration via properties** with environment variable fallbacks\n6. \u2705 **Comprehensive logging** for debugging\n7. \u2705 **Null-safety checks** in getter methods\n\nThe service will automatically authenticate when the Spring context starts and throw clear exceptions if authentication fails.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11378,
            "output_tokens": 2116,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "```java\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.exception.AzureException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobServiceClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\n\n@Service\npublic class AzureAuthenticationService {\n\n    private static final Logger logger = LoggerFactory.getLogger(AzureAuthenticationService.class);\n\n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n\n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.storage.account-url}\")\n    private String storageAccountUrl;\n\n    @Value(\"${azure.keyvault.url}\")\n    private String keyVaultUrl;\n\n    private DefaultAzureCredential credential;\n    private BlobServiceClient blobServiceClient;\n    private KeyClient keyClient;\n\n    /**\n     * Initializes the Azure credential and clients after bean construction\n     */\n    @PostConstruct\n    public void initialize() {\n        try {\n            this.credential = createAzureCredential();\n            this.blobServiceClient = createBlobServiceClient();\n            this.keyClient = createKeyClient();\n            logger.info(\"Azure authentication and clients initialized successfully\");\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Azure credentials are unavailable. Please check your authentication configuration.\", e);\n            throw new AzureAuthenticationException(\"Failed to authenticate with Azure: \" + e.getMessage(), e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error during Azure client initialization\", e);\n            throw new AzureAuthenticationException(\"Failed to initialize Azure clients: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Creates and configures DefaultAzureCredential with specific tenant ID and managed identity\n     *\n     * @return Configured DefaultAzureCredential\n     * @throws CredentialUnavailableException if credentials cannot be obtained\n     */\n    private DefaultAzureCredential createAzureCredential() throws CredentialUnavailableException {\n        logger.info(\"Creating Azure credential with tenant ID: {} and managed identity client ID: {}\", \n                    tenantId, managedIdentityClientId);\n\n        try {\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                    .tenantId(tenantId)\n                    .managedIdentityClientId(managedIdentityClientId)\n                    .build();\n\n            logger.info(\"DefaultAzureCredential created successfully\");\n            return credential;\n\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Credential unavailable: {}\", e.getMessage());\n            throw e;\n        } catch (Exception e) {\n            logger.error(\"Error creating Azure credential\", e);\n            throw new AzureAuthenticationException(\"Failed to create Azure credential\", e);\n        }\n    }\n\n    /**\n     * Creates BlobServiceClient using the configured credential\n     *\n     * @return Configured BlobServiceClient\n     * @throws CredentialUnavailableException if authentication fails\n     */\n    private BlobServiceClient createBlobServiceClient() throws CredentialUnavailableException {\n        logger.info(\"Creating BlobServiceClient for storage account: {}\", storageAccountUrl);\n\n        try {\n            BlobServiceClient client = new BlobServiceClientBuilder()\n                    .endpoint(storageAccountUrl)\n                    .credential(credential)\n                    .buildClient();\n\n            // Test the connection by attempting to get account info\n            client.getAccountInfo();\n            logger.info(\"BlobServiceClient created and authenticated successfully\");\n            return client;\n\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Failed to authenticate BlobServiceClient: {}\", e.getMessage());\n            throw e;\n        } catch (AzureException e) {\n            logger.error(\"Azure service error while creating BlobServiceClient\", e);\n            throw new AzureAuthenticationException(\"Failed to create BlobServiceClient: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Creates KeyClient using the configured credential\n     *\n     * @return Configured KeyClient\n     * @throws CredentialUnavailableException if authentication fails\n     */\n    private KeyClient createKeyClient() throws CredentialUnavailableException {\n        logger.info(\"Creating KeyClient for Key Vault: {}\", keyVaultUrl);\n\n        try {\n            KeyClient client = new KeyClientBuilder()\n                    .vaultUrl(keyVaultUrl)\n                    .credential(credential)\n                    .buildClient();\n\n            logger.info(\"KeyClient created successfully\");\n            return client;\n\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Failed to authenticate KeyClient: {}\", e.getMessage());\n            throw e;\n        } catch (AzureException e) {\n            logger.error(\"Azure service error while creating KeyClient\", e);\n            throw new AzureAuthenticationException(\"Failed to create KeyClient: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Gets the configured BlobServiceClient\n     *\n     * @return BlobServiceClient instance\n     */\n    public BlobServiceClient getBlobServiceClient() {\n        if (blobServiceClient == null) {\n            throw new IllegalStateException(\"BlobServiceClient is not initialized\");\n        }\n        return blobServiceClient;\n    }\n\n    /**\n     * Gets the configured KeyClient\n     *\n     * @return KeyClient instance\n     */\n    public KeyClient getKeyClient() {\n        if (keyClient == null) {\n            throw new IllegalStateException(\"KeyClient is not initialized\");\n        }\n        return keyClient;\n    }\n\n    /**\n     * Gets the configured credential\n     *\n     * @return TokenCredential instance\n     */\n    public TokenCredential getCredential() {\n        if (credential == null) {\n            throw new IllegalStateException(\"Credential is not initialized\");\n        }\n        return credential;\n    }\n\n    /**\n     * Validates the current authentication by attempting to refresh the token\n     *\n     * @return true if authentication is valid, false otherwise\n     */\n    public boolean validateAuthentication() {\n        try {\n            // Attempt to get a token to validate the credential\n            credential.getToken(new com.azure.core.credential.TokenRequestContext()\n                    .addScopes(\"https://storage.azure.com/.default\"))\n                    .block();\n            logger.info(\"Authentication validation successful\");\n            return true;\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Authentication validation failed: credentials unavailable\", e);\n            return false;\n        } catch (Exception e) {\n            logger.error(\"Authentication validation failed\", e);\n            return false;\n        }\n    }\n\n    /**\n     * Custom exception for Azure authentication errors\n     */\n    public static class AzureAuthenticationException extends RuntimeException {\n        public AzureAuthenticationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```\n\n```java\n// application.properties or application.yml configuration example\n```\n\n```properties\n# application.properties\nazure.tenant-id=your-tenant-id-here\nazure.managed-identity.client-id=your-managed-identity-client-id-here\nazure.storage.account-url=https://yourstorageaccount.blob.core.windows.net\nazure.keyvault.url=https://yourkeyvault.vault.azure.net\n```\n\n```yaml\n# application.yml\nazure:\n  tenant-id: your-tenant-id-here\n  managed-identity:\n    client-id: your-managed-identity-client-id-here\n  storage:\n    account-url: https://yourstorageaccount.blob.core.windows.net\n  keyvault:\n    url: https://yourkeyvault.vault.azure.net\n```\n\n```xml\n<!-- pom.xml dependencies -->\n<dependencies>\n    <!-- Spring Boot Starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.11.0</version>\n    </dependency>\n\n    <!-- Azure Storage Blob -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-storage-blob</artifactId>\n        <version>12.25.0</version>\n    </dependency>\n\n    <!-- Azure Key Vault Keys -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n        <version>4.7.0</version>\n    </dependency>\n\n    <!-- SLF4J for logging -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n    </dependency>\n</dependencies>\n```\n\n```java\n// Example usage in a controller or another service\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class AzureResourceController {\n\n    @Autowired\n    private AzureAuthenticationService azureAuthService;\n\n    @GetMapping(\"/api/azure/validate\")\n    public String validateAzureAuth() {\n        if (azureAuthService.validateAuthentication()) {\n            return \"Azure authentication is valid\";\n        } else {\n            return \"Azure authentication failed\";\n        }\n    }\n\n    @GetMapping(\"/api/blob/containers\")\n    public String listContainers() {\n        try {\n            var blobServiceClient = azureAuthService.getBlobServiceClient();\n            var containers = blobServiceClient.listBlobContainers();\n            \n            StringBuilder result = new StringBuilder(\"Containers:\\n\");\n            containers.forEach(container -> \n                result.append(\"- \").append(container.getName()).append(\"\\n\")\n            );\n            \n            return result.toString();\n        } catch (Exception e) {\n            return \"Error listing containers: \" + e.getMessage();\n        }\n    }\n\n    @GetMapping(\"/api/keyvault/keys\")\n    public String listKeys() {\n        try {\n            var keyClient = azureAuthService.getKeyClient();\n            var keys = keyClient.listPropertiesOfKeys();\n            \n            StringBuilder result = new StringBuilder(\"Keys:\\n\");\n            keys.forEach(keyProperties -> \n                result.append(\"- \").append(keyProperties.getName()).append(\"\\n\")\n            );\n            \n            return result.toString();\n        } catch (Exception e) {\n            return \"Error listing keys: \" + e.getMessage();\n        }\n    }\n}\n```\n\nThis implementation provides:\n\n1. **Proper Configuration**: Uses `DefaultAzureCredentialBuilder` with specific tenant ID and managed identity client ID\n2. **Error Handling**: Catches and handles `CredentialUnavailableException` specifically\n3. **Multiple Clients**: Creates both `BlobServiceClient` and `KeyClient` using the same credential\n4. **Logging**: Comprehensive logging for debugging authentication issues\n5. **Validation**: Method to validate authentication status\n6. **Spring Integration**: Proper use of Spring annotations and dependency injection\n7. **Initialization**: Uses `@PostConstruct` to initialize clients after bean creation",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 76,
            "output_tokens": 2965,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Authentication Service with DefaultAzureCredential\n\nHere's a comprehensive Spring Boot service class that demonstrates Azure authentication with proper configuration and error handling:\n\n```java\npackage com.example.azure.service;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobServiceClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\n\n/**\n * Service for managing Azure authentication and client creation.\n * Uses DefaultAzureCredential with user-assigned managed identity.\n */\n@Service\npublic class AzureAuthenticationService {\n\n    private static final Logger logger = LoggerFactory.getLogger(AzureAuthenticationService.class);\n\n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n\n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.storage.account-name}\")\n    private String storageAccountName;\n\n    @Value(\"${azure.keyvault.vault-url}\")\n    private String keyVaultUrl;\n\n    private DefaultAzureCredential credential;\n    private BlobServiceClient blobServiceClient;\n    private KeyClient keyClient;\n\n    /**\n     * Initializes the Azure credential after bean construction.\n     * Validates that authentication is working.\n     */\n    @PostConstruct\n    public void initialize() {\n        try {\n            logger.info(\"Initializing Azure authentication with tenant ID: {} and managed identity: {}\", \n                       tenantId, managedIdentityClientId);\n            \n            this.credential = createCredential();\n            \n            // Validate credential by attempting to get a token\n            validateCredential();\n            \n            logger.info(\"Azure authentication initialized successfully\");\n            \n        } catch (CredentialUnavailableException e) {\n            logger.error(\"No Azure credential available. Ensure the application is running in an Azure environment \" +\n                        \"with managed identity enabled, or that environment variables are set correctly.\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure authentication\", e);\n            \n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Azure authentication failed. Check tenant ID, client ID, and permissions.\", e);\n            throw new IllegalStateException(\"Failed to authenticate with Azure\", e);\n            \n        } catch (Exception e) {\n            logger.error(\"Unexpected error during Azure authentication initialization\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure authentication\", e);\n        }\n    }\n\n    /**\n     * Creates and configures the DefaultAzureCredential with specific tenant and managed identity.\n     *\n     * @return Configured DefaultAzureCredential\n     */\n    private DefaultAzureCredential createCredential() {\n        logger.debug(\"Creating DefaultAzureCredential with tenant: {} and managed identity: {}\", \n                    tenantId, managedIdentityClientId);\n        \n        return new DefaultAzureCredentialBuilder()\n            .tenantId(tenantId)\n            .managedIdentityClientId(managedIdentityClientId)\n            .build();\n    }\n\n    /**\n     * Validates that the credential can successfully obtain a token.\n     * This helps catch authentication issues early.\n     */\n    private void validateCredential() {\n        try {\n            // Attempt to get a token for Azure Storage to validate the credential\n            credential.getToken(new com.azure.core.credential.TokenRequestContext()\n                .addScopes(\"https://storage.azure.com/.default\"))\n                .block();\n            \n            logger.debug(\"Credential validation successful\");\n            \n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Credential validation failed - no credential available\", e);\n            throw e;\n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Credential validation failed - authentication error\", e);\n            throw e;\n        }\n    }\n\n    /**\n     * Gets or creates a BlobServiceClient for Azure Blob Storage.\n     *\n     * @return BlobServiceClient instance\n     * @throws CredentialUnavailableException if no credential is available\n     * @throws ClientAuthenticationException if authentication fails\n     */\n    public BlobServiceClient getBlobServiceClient() {\n        if (blobServiceClient == null) {\n            synchronized (this) {\n                if (blobServiceClient == null) {\n                    try {\n                        String endpoint = String.format(\"https://%s.blob.core.windows.net\", storageAccountName);\n                        \n                        logger.info(\"Creating BlobServiceClient for endpoint: {}\", endpoint);\n                        \n                        blobServiceClient = new BlobServiceClientBuilder()\n                            .endpoint(endpoint)\n                            .credential(credential)\n                            .buildClient();\n                        \n                        logger.info(\"BlobServiceClient created successfully\");\n                        \n                    } catch (CredentialUnavailableException e) {\n                        logger.error(\"Failed to create BlobServiceClient - credential unavailable\", e);\n                        throw e;\n                    } catch (ClientAuthenticationException e) {\n                        logger.error(\"Failed to create BlobServiceClient - authentication failed\", e);\n                        throw e;\n                    } catch (Exception e) {\n                        logger.error(\"Unexpected error creating BlobServiceClient\", e);\n                        throw new RuntimeException(\"Failed to create BlobServiceClient\", e);\n                    }\n                }\n            }\n        }\n        return blobServiceClient;\n    }\n\n    /**\n     * Gets or creates a KeyClient for Azure Key Vault.\n     *\n     * @return KeyClient instance\n     * @throws CredentialUnavailableException if no credential is available\n     * @throws ClientAuthenticationException if authentication fails\n     */\n    public KeyClient getKeyClient() {\n        if (keyClient == null) {\n            synchronized (this) {\n                if (keyClient == null) {\n                    try {\n                        logger.info(\"Creating KeyClient for vault URL: {}\", keyVaultUrl);\n                        \n                        keyClient = new KeyClientBuilder()\n                            .vaultUrl(keyVaultUrl)\n                            .credential(credential)\n                            .buildClient();\n                        \n                        logger.info(\"KeyClient created successfully\");\n                        \n                    } catch (CredentialUnavailableException e) {\n                        logger.error(\"Failed to create KeyClient - credential unavailable\", e);\n                        throw e;\n                    } catch (ClientAuthenticationException e) {\n                        logger.error(\"Failed to create KeyClient - authentication failed\", e);\n                        throw e;\n                    } catch (Exception e) {\n                        logger.error(\"Unexpected error creating KeyClient\", e);\n                        throw new RuntimeException(\"Failed to create KeyClient\", e);\n                    }\n                }\n            }\n        }\n        return keyClient;\n    }\n\n    /**\n     * Gets the configured credential.\n     *\n     * @return DefaultAzureCredential instance\n     */\n    public TokenCredential getCredential() {\n        return credential;\n    }\n\n    /**\n     * Checks if the service is properly authenticated.\n     *\n     * @return true if authenticated, false otherwise\n     */\n    public boolean isAuthenticated() {\n        try {\n            if (credential == null) {\n                return false;\n            }\n            \n            // Try to get a token to verify authentication\n            credential.getToken(new com.azure.core.credential.TokenRequestContext()\n                .addScopes(\"https://management.azure.com/.default\"))\n                .block();\n            \n            return true;\n            \n        } catch (Exception e) {\n            logger.warn(\"Authentication check failed\", e);\n            return false;\n        }\n    }\n}\n```\n\n## Configuration File (application.yml)\n\n```yaml\nazure:\n  tenant-id: ${AZURE_TENANT_ID:your-tenant-id}\n  managed-identity:\n    client-id: ${AZURE_CLIENT_ID:your-managed-identity-client-id}\n  storage:\n    account-name: ${AZURE_STORAGE_ACCOUNT_NAME:yourstorageaccount}\n  keyvault:\n    vault-url: ${AZURE_KEYVAULT_URL:https://your-vault.vault.azure.net}\n\n# Logging configuration\nlogging:\n  level:\n    com.example.azure: DEBUG\n    com.azure.identity: DEBUG\n    com.azure.core: INFO\n```\n\n## Alternative Configuration (application.properties)\n\n```properties\n# Azure Configuration\nazure.tenant-id=${AZURE_TENANT_ID:your-tenant-id}\nazure.managed-identity.client-id=${AZURE_CLIENT_ID:your-managed-identity-client-id}\nazure.storage.account-name=${AZURE_STORAGE_ACCOUNT_NAME:yourstorageaccount}\nazure.keyvault.vault-url=${AZURE_KEYVAULT_URL:https://your-vault.vault.azure.net}\n\n# Logging\nlogging.level.com.example.azure=DEBUG\nlogging.level.com.azure.identity=DEBUG\nlogging.level.com.azure.core=INFO\n```\n\n## Maven Dependencies (pom.xml)\n\n```xml\n<dependencies>\n    <!-- Spring Boot Starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.15.0</version>\n    </dependency>\n\n    <!-- Azure Storage Blob -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-storage-blob</artifactId>\n        <version>12.30.0</version>\n    </dependency>\n\n    <!-- Azure Key Vault Keys -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n        <version>4.9.0</version>\n    </dependency>\n\n    <!-- SLF4J for logging -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n    </dependency>\n</dependencies>\n```\n\n## Usage Example\n\n```java\npackage com.example.azure.controller;\n\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobContainerClient;\nimport com.example.azure.service.AzureAuthenticationService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/azure\")\npublic class AzureController {\n\n    private final AzureAuthenticationService authService;\n\n    @Autowired\n    public AzureController(AzureAuthenticationService authService) {\n        this.authService = authService;\n    }\n\n    @GetMapping(\"/health\")\n    public ResponseEntity<String> checkHealth() {\n        if (authService.isAuthenticated()) {\n            return ResponseEntity.ok(\"Azure authentication is healthy\");\n        } else {\n            return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)\n                .body(\"Azure authentication is not available\");\n        }\n    }\n\n    @GetMapping(\"/storage/containers\")\n    public ResponseEntity<?> listContainers() {\n        try {\n            BlobServiceClient client = authService.getBlobServiceClient();\n            var containers = client.listBlobContainers()\n                .stream()\n                .map(container -> container.getName())\n                .toList();\n            \n            return ResponseEntity.ok(containers);\n            \n        } catch (CredentialUnavailableException e) {\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)\n                .body(\"Azure credentials not available: \" + e.getMessage());\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(\"Error accessing storage: \" + e.getMessage());\n        }\n    }\n\n    @GetMapping(\"/keyvault/keys\")\n    public ResponseEntity<?> listKeys() {\n        try {\n            KeyClient client = authService.getKeyClient();\n            var keys = client.listPropertiesOfKeys()\n                .stream()\n                .map(keyProperties -> keyProperties.getName())\n                .toList();\n            \n            return ResponseEntity.ok(keys);\n            \n        } catch (CredentialUnavailableException e) {\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)\n                .body(\"Azure credentials not available: \" + e.getMessage());\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(\"Error accessing Key Vault: \" + e.getMessage());\n        }\n    }\n}\n```\n\n## Environment Variables\n\nSet these environment variables when running the application:\n\n```bash\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_ID=\"your-managed-identity-client-id\"\nexport AZURE_STORAGE_ACCOUNT_NAME=\"yourstorageaccount\"\nexport AZURE_KEYVAULT_URL=\"https://your-vault.vault.azure.net\"\n```\n\n## Key Features\n\n1. **Proper Configuration**: Uses `@Value` annotations for externalized configuration\n2. **Lazy Initialization**: Clients are created on first use with thread-safe double-checked locking\n3. **Comprehensive Error Handling**: Catches and logs `CredentialUnavailableException` and `ClientAuthenticationException`\n4. **Credential Validation**: Validates authentication during initialization\n5. **Health Check**: Provides method to check authentication status\n6. **Thread Safety**: Synchronized client creation\n7. **Logging**: Detailed logging at appropriate levels\n8. **Spring Boot Integration**: Uses `@PostConstruct` for initialization\n\nThis implementation follows Azure SDK best practices and provides robust error handling for production use.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10853,
            "output_tokens": 3617,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive Azure service class with proper authentication and error handling.\n\n```java\npackage com.example.app.service;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobServiceClientBuilder;\nimport jakarta.annotation.PostConstruct;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class AzureAuthenticationService {\n    \n    private static final Logger log = LoggerFactory.getLogger(AzureAuthenticationService.class);\n    \n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n    \n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n    \n    @Value(\"${azure.storage.account-endpoint}\")\n    private String storageAccountEndpoint;\n    \n    @Value(\"${azure.keyvault.vault-url}\")\n    private String keyVaultUrl;\n    \n    private DefaultAzureCredential credential;\n    private BlobServiceClient blobServiceClient;\n    private KeyClient keyClient;\n    \n    @PostConstruct\n    public void initialize() {\n        try {\n            log.info(\"Initializing Azure authentication with tenant ID: {} and managed identity client ID: {}\", \n                     tenantId, managedIdentityClientId);\n            \n            // Configure DefaultAzureCredential with tenant ID and user-assigned managed identity\n            credential = new DefaultAzureCredentialBuilder()\n                .tenantId(tenantId)\n                .managedIdentityClientId(managedIdentityClientId)\n                .build();\n            \n            // Initialize BlobServiceClient\n            blobServiceClient = createBlobServiceClient();\n            log.info(\"Successfully initialized BlobServiceClient for endpoint: {}\", storageAccountEndpoint);\n            \n            // Initialize KeyClient\n            keyClient = createKeyClient();\n            log.info(\"Successfully initialized KeyClient for vault: {}\", keyVaultUrl);\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"Azure credentials are unavailable. Ensure managed identity is configured or Azure CLI is logged in.\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure authentication: No credentials available\", e);\n        } catch (Exception e) {\n            log.error(\"Unexpected error during Azure service initialization\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure services\", e);\n        }\n    }\n    \n    private BlobServiceClient createBlobServiceClient() {\n        try {\n            return new BlobServiceClientBuilder()\n                .endpoint(storageAccountEndpoint)\n                .credential(credential)\n                .buildClient();\n        } catch (CredentialUnavailableException e) {\n            log.error(\"Failed to create BlobServiceClient: credentials unavailable\", e);\n            throw e;\n        } catch (Exception e) {\n            log.error(\"Failed to create BlobServiceClient for endpoint: {}\", storageAccountEndpoint, e);\n            throw new IllegalStateException(\"Failed to initialize Blob Storage client\", e);\n        }\n    }\n    \n    private KeyClient createKeyClient() {\n        try {\n            return new KeyClientBuilder()\n                .vaultUrl(keyVaultUrl)\n                .credential(credential)\n                .buildClient();\n        } catch (CredentialUnavailableException e) {\n            log.error(\"Failed to create KeyClient: credentials unavailable\", e);\n            throw e;\n        } catch (Exception e) {\n            log.error(\"Failed to create KeyClient for vault: {}\", keyVaultUrl, e);\n            throw new IllegalStateException(\"Failed to initialize Key Vault client\", e);\n        }\n    }\n    \n    public TokenCredential getCredential() {\n        if (credential == null) {\n            throw new IllegalStateException(\"Azure credential not initialized\");\n        }\n        return credential;\n    }\n    \n    public BlobServiceClient getBlobServiceClient() {\n        if (blobServiceClient == null) {\n            throw new IllegalStateException(\"BlobServiceClient not initialized\");\n        }\n        return blobServiceClient;\n    }\n    \n    public KeyClient getKeyClient() {\n        if (keyClient == null) {\n            throw new IllegalStateException(\"KeyClient not initialized\");\n        }\n        return keyClient;\n    }\n}\n```\n\nNow let me create the corresponding application properties file:\n\n```properties\n# Azure Authentication Configuration\nazure.tenant-id=${AZURE_TENANT_ID}\nazure.managed-identity.client-id=${AZURE_CLIENT_ID}\n\n# Azure Storage Configuration\nazure.storage.account-endpoint=https://${AZURE_STORAGE_ACCOUNT_NAME}.blob.core.windows.net\n\n# Azure Key Vault Configuration\nazure.keyvault.vault-url=https://${AZURE_KEYVAULT_NAME}.vault.azure.net\n```\n\nAnd the required Maven dependencies:\n\n```xml\n<!-- Azure Identity -->\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-identity</artifactId>\n    <version>1.15.0</version>\n</dependency>\n\n<!-- Azure Storage Blob -->\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-storage-blob</artifactId>\n    <version>12.28.1</version>\n</dependency>\n\n<!-- Azure Key Vault Keys -->\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-security-keyvault-keys</artifactId>\n    <version>4.9.1</version>\n</dependency>\n```\n\n## Key Features:\n\n1. **DefaultAzureCredential Configuration**: Configured with specific tenant ID and user-assigned managed identity client ID\n2. **Proper Error Handling**: Catches `CredentialUnavailableException` specifically and provides clear error messages\n3. **Lazy Initialization**: Uses `@PostConstruct` to initialize clients after dependency injection\n4. **Logging**: Comprehensive logging for debugging authentication issues\n5. **Null Safety**: Getter methods check for null before returning clients\n6. **Spring Integration**: Uses `@Value` annotations for configuration from properties files\n7. **Environment Variables**: Configuration supports environment variable substitution for security\n\nThe service will automatically try authentication methods in this order:\n1. Environment variables\n2. Workload Identity (AKS)\n3. Managed Identity (with the specified client ID)\n4. Azure CLI\n5. Azure PowerShell",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11378,
            "output_tokens": 1673,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "```java\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.exception.AzureException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobServiceClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\n\n@Service\npublic class AzureAuthenticationService {\n\n    private static final Logger logger = LoggerFactory.getLogger(AzureAuthenticationService.class);\n\n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n\n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.storage.account-url}\")\n    private String storageAccountUrl;\n\n    @Value(\"${azure.keyvault.url}\")\n    private String keyVaultUrl;\n\n    private DefaultAzureCredential credential;\n    private BlobServiceClient blobServiceClient;\n    private KeyClient keyClient;\n\n    /**\n     * Initializes the Azure credential and clients after bean construction\n     */\n    @PostConstruct\n    public void initialize() {\n        try {\n            this.credential = createAzureCredential();\n            this.blobServiceClient = createBlobServiceClient();\n            this.keyClient = createKeyClient();\n            logger.info(\"Azure authentication and clients initialized successfully\");\n        } catch (Exception e) {\n            logger.error(\"Failed to initialize Azure authentication service\", e);\n            throw new RuntimeException(\"Azure authentication initialization failed\", e);\n        }\n    }\n\n    /**\n     * Creates and configures DefaultAzureCredential with specific tenant ID and managed identity\n     *\n     * @return Configured DefaultAzureCredential\n     * @throws CredentialUnavailableException if credentials cannot be obtained\n     */\n    private DefaultAzureCredential createAzureCredential() throws CredentialUnavailableException {\n        try {\n            logger.info(\"Creating DefaultAzureCredential with tenant ID: {} and managed identity client ID: {}\", \n                       tenantId, managedIdentityClientId);\n\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                    .tenantId(tenantId)\n                    .managedIdentityClientId(managedIdentityClientId)\n                    .build();\n\n            logger.info(\"DefaultAzureCredential created successfully\");\n            return credential;\n\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Credentials are unavailable. Ensure the application is running in an Azure environment \" +\n                        \"with managed identity enabled, or appropriate credentials are configured.\", e);\n            throw e;\n        } catch (Exception e) {\n            logger.error(\"Unexpected error while creating Azure credential\", e);\n            throw new RuntimeException(\"Failed to create Azure credential\", e);\n        }\n    }\n\n    /**\n     * Creates BlobServiceClient using the configured credential\n     *\n     * @return Configured BlobServiceClient\n     * @throws CredentialUnavailableException if authentication fails\n     */\n    private BlobServiceClient createBlobServiceClient() throws CredentialUnavailableException {\n        try {\n            logger.info(\"Creating BlobServiceClient for storage account: {}\", storageAccountUrl);\n\n            BlobServiceClient client = new BlobServiceClientBuilder()\n                    .endpoint(storageAccountUrl)\n                    .credential(credential)\n                    .buildClient();\n\n            // Test the connection by attempting to get account info\n            client.getAccountInfo();\n            logger.info(\"BlobServiceClient created and authenticated successfully\");\n            return client;\n\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Failed to authenticate BlobServiceClient - credentials unavailable\", e);\n            throw e;\n        } catch (AzureException e) {\n            logger.error(\"Azure service error while creating BlobServiceClient: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Failed to create BlobServiceClient\", e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error while creating BlobServiceClient\", e);\n            throw new RuntimeException(\"Failed to create BlobServiceClient\", e);\n        }\n    }\n\n    /**\n     * Creates KeyClient using the configured credential\n     *\n     * @return Configured KeyClient\n     * @throws CredentialUnavailableException if authentication fails\n     */\n    private KeyClient createKeyClient() throws CredentialUnavailableException {\n        try {\n            logger.info(\"Creating KeyClient for Key Vault: {}\", keyVaultUrl);\n\n            KeyClient client = new KeyClientBuilder()\n                    .vaultUrl(keyVaultUrl)\n                    .credential(credential)\n                    .buildClient();\n\n            logger.info(\"KeyClient created successfully\");\n            return client;\n\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Failed to authenticate KeyClient - credentials unavailable\", e);\n            throw e;\n        } catch (AzureException e) {\n            logger.error(\"Azure service error while creating KeyClient: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Failed to create KeyClient\", e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error while creating KeyClient\", e);\n            throw new RuntimeException(\"Failed to create KeyClient\", e);\n        }\n    }\n\n    /**\n     * Gets the BlobServiceClient instance\n     *\n     * @return BlobServiceClient\n     */\n    public BlobServiceClient getBlobServiceClient() {\n        if (blobServiceClient == null) {\n            throw new IllegalStateException(\"BlobServiceClient is not initialized\");\n        }\n        return blobServiceClient;\n    }\n\n    /**\n     * Gets the KeyClient instance\n     *\n     * @return KeyClient\n     */\n    public KeyClient getKeyClient() {\n        if (keyClient == null) {\n            throw new IllegalStateException(\"KeyClient is not initialized\");\n        }\n        return keyClient;\n    }\n\n    /**\n     * Gets the credential instance\n     *\n     * @return DefaultAzureCredential\n     */\n    public TokenCredential getCredential() {\n        if (credential == null) {\n            throw new IllegalStateException(\"Credential is not initialized\");\n        }\n        return credential;\n    }\n\n    /**\n     * Validates that all required configuration properties are set\n     *\n     * @return true if configuration is valid\n     */\n    public boolean validateConfiguration() {\n        boolean isValid = true;\n\n        if (tenantId == null || tenantId.isEmpty()) {\n            logger.error(\"Azure tenant ID is not configured\");\n            isValid = false;\n        }\n\n        if (managedIdentityClientId == null || managedIdentityClientId.isEmpty()) {\n            logger.error(\"Managed identity client ID is not configured\");\n            isValid = false;\n        }\n\n        if (storageAccountUrl == null || storageAccountUrl.isEmpty()) {\n            logger.error(\"Storage account URL is not configured\");\n            isValid = false;\n        }\n\n        if (keyVaultUrl == null || keyVaultUrl.isEmpty()) {\n            logger.error(\"Key Vault URL is not configured\");\n            isValid = false;\n        }\n\n        return isValid;\n    }\n}\n```\n\nAnd here's the corresponding `application.properties` or `application.yml` configuration:\n\n**application.properties:**\n```properties\n# Azure Authentication Configuration\nazure.tenant-id=your-tenant-id-here\nazure.managed-identity.client-id=your-managed-identity-client-id-here\n\n# Azure Storage Configuration\nazure.storage.account-url=https://yourstorageaccount.blob.core.windows.net\n\n# Azure Key Vault Configuration\nazure.keyvault.url=https://yourkeyvault.vault.azure.net\n```\n\n**application.yml:**\n```yaml\nazure:\n  tenant-id: your-tenant-id-here\n  managed-identity:\n    client-id: your-managed-identity-client-id-here\n  storage:\n    account-url: https://yourstorageaccount.blob.core.windows.net\n  keyvault:\n    url: https://yourkeyvault.vault.azure.net\n```\n\n**pom.xml dependencies:**\n```xml\n<dependencies>\n    <!-- Spring Boot Starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.11.0</version>\n    </dependency>\n\n    <!-- Azure Storage Blob -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-storage-blob</artifactId>\n        <version>12.25.0</version>\n    </dependency>\n\n    <!-- Azure Key Vault Keys -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n        <version>4.7.0</version>\n    </dependency>\n\n    <!-- Logging -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n    </dependency>\n</dependencies>\n```\n\n**Example usage in a controller:**\n```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class AzureTestController {\n\n    @Autowired\n    private AzureAuthenticationService azureAuthService;\n\n    @GetMapping(\"/test-blob-storage\")\n    public String testBlobStorage() {\n        try {\n            var blobClient = azureAuthService.getBlobServiceClient();\n            var accountInfo = blobClient.getAccountInfo();\n            return \"Successfully connected to Blob Storage. Account Kind: \" + accountInfo.getAccountKind();\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    @GetMapping(\"/test-keyvault\")\n    public String testKeyVault() {\n        try {\n            var keyClient = azureAuthService.getKeyClient();\n            var keys = keyClient.listPropertiesOfKeys();\n            return \"Successfully connected to Key Vault\";\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n}\n```\n\nThis service class provides:\n\n1. **Proper configuration** of `DefaultAzureCredential` with tenant ID and managed identity client ID\n2. **Comprehensive error handling** for `CredentialUnavailableException` and other Azure exceptions\n3. **Initialization on startup** using `@PostConstruct`\n4. **Logging** at appropriate levels for debugging and monitoring\n5. **Validation methods** to ensure configuration is correct\n6. **Thread-safe singleton** clients managed by Spring\n7. **Clean separation of concerns** with dedicated methods for each client creation",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 76,
            "output_tokens": 2822,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Authentication Service with DefaultAzureCredential\n\nHere's a comprehensive Spring Boot service class that implements Azure authentication with proper configuration and error handling:\n\n```java\npackage com.example.azure.service;\n\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobServiceClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\n\n/**\n * Service for managing Azure authentication and client initialization.\n * Uses DefaultAzureCredential with user-assigned managed identity.\n */\n@Service\npublic class AzureAuthenticationService {\n\n    private static final Logger logger = LoggerFactory.getLogger(AzureAuthenticationService.class);\n\n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n\n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.storage.account-endpoint}\")\n    private String storageAccountEndpoint;\n\n    @Value(\"${azure.keyvault.vault-url}\")\n    private String keyVaultUrl;\n\n    private DefaultAzureCredential credential;\n    private BlobServiceClient blobServiceClient;\n    private KeyClient keyClient;\n\n    /**\n     * Initializes Azure credential and clients after bean construction.\n     */\n    @PostConstruct\n    public void initialize() {\n        try {\n            logger.info(\"Initializing Azure authentication with tenant ID: {}\", tenantId);\n            this.credential = createAzureCredential();\n            this.blobServiceClient = createBlobServiceClient();\n            this.keyClient = createKeyClient();\n            logger.info(\"Azure authentication and clients initialized successfully\");\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"No Azure credential available. Ensure managed identity is configured or Azure CLI is logged in.\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure authentication: No credential available\", e);\n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Azure authentication failed. Check tenant ID and managed identity configuration.\", e);\n            throw new IllegalStateException(\"Failed to authenticate with Azure\", e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error during Azure client initialization\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure clients\", e);\n        }\n    }\n\n    /**\n     * Creates and configures DefaultAzureCredential with tenant ID and managed identity.\n     *\n     * @return Configured DefaultAzureCredential\n     * @throws CredentialUnavailableException if no credential is available\n     */\n    private DefaultAzureCredential createAzureCredential() throws CredentialUnavailableException {\n        logger.debug(\"Creating DefaultAzureCredential with managed identity client ID: {}\", managedIdentityClientId);\n\n        return new DefaultAzureCredentialBuilder()\n                .tenantId(tenantId)\n                .managedIdentityClientId(managedIdentityClientId)\n                .build();\n    }\n\n    /**\n     * Creates BlobServiceClient using the configured credential.\n     *\n     * @return Initialized BlobServiceClient\n     * @throws ClientAuthenticationException if authentication fails\n     */\n    private BlobServiceClient createBlobServiceClient() throws ClientAuthenticationException {\n        logger.debug(\"Creating BlobServiceClient for endpoint: {}\", storageAccountEndpoint);\n\n        return new BlobServiceClientBuilder()\n                .endpoint(storageAccountEndpoint)\n                .credential(credential)\n                .buildClient();\n    }\n\n    /**\n     * Creates KeyClient using the configured credential.\n     *\n     * @return Initialized KeyClient\n     * @throws ClientAuthenticationException if authentication fails\n     */\n    private KeyClient createKeyClient() throws ClientAuthenticationException {\n        logger.debug(\"Creating KeyClient for vault URL: {}\", keyVaultUrl);\n\n        return new KeyClientBuilder()\n                .vaultUrl(keyVaultUrl)\n                .credential(credential)\n                .buildClient();\n    }\n\n    /**\n     * Gets the BlobServiceClient instance.\n     *\n     * @return BlobServiceClient\n     * @throws IllegalStateException if client is not initialized\n     */\n    public BlobServiceClient getBlobServiceClient() {\n        if (blobServiceClient == null) {\n            throw new IllegalStateException(\"BlobServiceClient is not initialized\");\n        }\n        return blobServiceClient;\n    }\n\n    /**\n     * Gets the KeyClient instance.\n     *\n     * @return KeyClient\n     * @throws IllegalStateException if client is not initialized\n     */\n    public KeyClient getKeyClient() {\n        if (keyClient == null) {\n            throw new IllegalStateException(\"KeyClient is not initialized\");\n        }\n        return keyClient;\n    }\n\n    /**\n     * Gets the DefaultAzureCredential instance.\n     *\n     * @return DefaultAzureCredential\n     * @throws IllegalStateException if credential is not initialized\n     */\n    public DefaultAzureCredential getCredential() {\n        if (credential == null) {\n            throw new IllegalStateException(\"DefaultAzureCredential is not initialized\");\n        }\n        return credential;\n    }\n\n    /**\n     * Validates that all required Azure clients are initialized.\n     *\n     * @return true if all clients are initialized\n     */\n    public boolean isInitialized() {\n        return credential != null && blobServiceClient != null && keyClient != null;\n    }\n}\n```\n\n## Configuration File (application.yml)\n\n```yaml\nazure:\n  tenant-id: ${AZURE_TENANT_ID:12345678-1234-1234-1234-123456789012}\n  managed-identity:\n    client-id: ${AZURE_CLIENT_ID:87654321-4321-4321-4321-210987654321}\n  storage:\n    account-endpoint: ${AZURE_STORAGE_ENDPOINT:https://mystorageaccount.blob.core.windows.net}\n  keyvault:\n    vault-url: ${AZURE_KEYVAULT_URL:https://myvault.vault.azure.net}\n\nlogging:\n  level:\n    com.azure: DEBUG\n    com.example.azure: DEBUG\n```\n\n## Alternative: application.properties\n\n```properties\nazure.tenant-id=${AZURE_TENANT_ID:12345678-1234-1234-1234-123456789012}\nazure.managed-identity.client-id=${AZURE_CLIENT_ID:87654321-4321-4321-4321-210987654321}\nazure.storage.account-endpoint=${AZURE_STORAGE_ENDPOINT:https://mystorageaccount.blob.core.windows.net}\nazure.keyvault.vault-url=${AZURE_KEYVAULT_URL:https://myvault.vault.azure.net}\n\nlogging.level.com.azure=DEBUG\nlogging.level.com.example.azure=DEBUG\n```\n\n## Maven Dependencies (pom.xml)\n\n```xml\n<properties>\n    <azure.version>1.2.29</azure.version>\n    <spring-boot.version>3.2.0</spring-boot.version>\n</properties>\n\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-sdk-bom</artifactId>\n            <version>${azure.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <!-- Spring Boot -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n    </dependency>\n\n    <!-- Azure Storage Blob -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-storage-blob</artifactId>\n    </dependency>\n\n    <!-- Azure Key Vault Keys -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n    </dependency>\n\n    <!-- Logging -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n    </dependency>\n</dependencies>\n```\n\n## Example Usage in a Controller\n\n```java\npackage com.example.azure.controller;\n\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport com.azure.storage.blob.BlobContainerClient;\nimport com.azure.storage.blob.models.BlobItem;\nimport com.example.azure.service.AzureAuthenticationService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/api/azure\")\npublic class AzureController {\n\n    private final AzureAuthenticationService azureAuthService;\n\n    @Autowired\n    public AzureController(AzureAuthenticationService azureAuthService) {\n        this.azureAuthService = azureAuthService;\n    }\n\n    /**\n     * Lists blobs in a container.\n     */\n    @GetMapping(\"/blobs/{containerName}\")\n    public ResponseEntity<List<String>> listBlobs(@PathVariable String containerName) {\n        try {\n            BlobContainerClient containerClient = azureAuthService\n                    .getBlobServiceClient()\n                    .getBlobContainerClient(containerName);\n\n            List<String> blobNames = new ArrayList<>();\n            for (BlobItem blobItem : containerClient.listBlobs()) {\n                blobNames.add(blobItem.getName());\n            }\n\n            return ResponseEntity.ok(blobNames);\n        } catch (Exception e) {\n            return ResponseEntity.internalServerError().build();\n        }\n    }\n\n    /**\n     * Gets a key from Key Vault.\n     */\n    @GetMapping(\"/keys/{keyName}\")\n    public ResponseEntity<String> getKey(@PathVariable String keyName) {\n        try {\n            KeyVaultKey key = azureAuthService.getKeyClient().getKey(keyName);\n            return ResponseEntity.ok(\"Key ID: \" + key.getId());\n        } catch (Exception e) {\n            return ResponseEntity.internalServerError().build();\n        }\n    }\n\n    /**\n     * Health check endpoint.\n     */\n    @GetMapping(\"/health\")\n    public ResponseEntity<String> health() {\n        if (azureAuthService.isInitialized()) {\n            return ResponseEntity.ok(\"Azure clients initialized successfully\");\n        }\n        return ResponseEntity.status(503).body(\"Azure clients not initialized\");\n    }\n}\n```\n\n## Advanced Configuration with Custom Error Handling\n\n```java\npackage com.example.azure.config;\n\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Configuration class for Azure authentication.\n */\n@Configuration\npublic class AzureAuthConfig {\n\n    private static final Logger logger = LoggerFactory.getLogger(AzureAuthConfig.class);\n\n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n\n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.credential.exclude-cli:false}\")\n    private boolean excludeAzureCli;\n\n    @Value(\"${azure.credential.exclude-environment:false}\")\n    private boolean excludeEnvironment;\n\n    /**\n     * Creates DefaultAzureCredential bean with custom configuration.\n     */\n    @Bean\n    public DefaultAzureCredential defaultAzureCredential() {\n        try {\n            logger.info(\"Creating DefaultAzureCredential with tenant: {}, managed identity: {}\",\n                    tenantId, managedIdentityClientId);\n\n            DefaultAzureCredentialBuilder builder = new DefaultAzureCredentialBuilder()\n                    .tenantId(tenantId)\n                    .managedIdentityClientId(managedIdentityClientId);\n\n            // Optional: exclude specific credential types\n            if (excludeAzureCli) {\n                logger.debug(\"Excluding Azure CLI credential\");\n                builder.excludeAzureCliCredential();\n            }\n\n            if (excludeEnvironment) {\n                logger.debug(\"Excluding environment credential\");\n                builder.excludeEnvironmentCredential();\n            }\n\n            DefaultAzureCredential credential = builder.build();\n            logger.info(\"DefaultAzureCredential created successfully\");\n            return credential;\n\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"No Azure credential available. Authentication chain exhausted.\", e);\n            logger.error(\"Ensure one of the following is configured:\");\n            logger.error(\"  1. Managed Identity is enabled on the Azure resource\");\n            logger.error(\"  2. Environment variables (AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID) are set\");\n            logger.error(\"  3. Azure CLI is logged in (az login)\");\n            throw new IllegalStateException(\"Failed to create Azure credential: No credential available\", e);\n\n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Azure authentication failed. Check credentials and permissions.\", e);\n            throw new IllegalStateException(\"Failed to authenticate with Azure\", e);\n\n        } catch (Exception e) {\n            logger.error(\"Unexpected error creating Azure credential\", e);\n            throw new IllegalStateException(\"Failed to create Azure credential\", e);\n        }\n    }\n}\n```\n\n## Environment Variables for Local Development\n\n```bash\n# For local development with service principal\nexport AZURE_TENANT_ID=\"12345678-1234-1234-1234-123456789012\"\nexport AZURE_CLIENT_ID=\"87654321-4321-4321-4321-210987654321\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\nexport AZURE_STORAGE_ENDPOINT=\"https://mystorageaccount.blob.core.windows.net\"\nexport AZURE_KEYVAULT_URL=\"https://myvault.vault.azure.net\"\n\n# Or use Azure CLI\naz login\n```\n\n## Key Features\n\n1. **DefaultAzureCredential Configuration**: Properly configured with tenant ID and user-assigned managed identity\n2. **Comprehensive Error Handling**: Catches `CredentialUnavailableException` and `ClientAuthenticationException`\n3. **Spring Boot Integration**: Uses `@PostConstruct` for initialization and `@Value` for configuration\n4. **Multiple Client Support**: Creates both `BlobServiceClient` and `KeyClient`\n5. **Logging**: Detailed logging for debugging authentication issues\n6. **Validation**: Health check methods to verify initialization\n7. **Production-Ready**: Follows Spring Boot best practices with proper dependency injection\n\nThis implementation will work seamlessly in both local development (using Azure CLI or environment variables) and production (using managed identity).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10853,
            "output_tokens": 3914,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive Azure service class with proper authentication and error handling.\n\n```java\npackage com.example.app.service;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.storage.blob.BlobServiceClient;\nimport com.azure.storage.blob.BlobServiceClientBuilder;\nimport jakarta.annotation.PostConstruct;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class AzureAuthenticationService {\n    \n    private static final Logger log = LoggerFactory.getLogger(AzureAuthenticationService.class);\n    \n    @Value(\"${azure.tenant-id}\")\n    private String tenantId;\n    \n    @Value(\"${azure.managed-identity.client-id}\")\n    private String managedIdentityClientId;\n    \n    @Value(\"${azure.storage.account-endpoint}\")\n    private String storageAccountEndpoint;\n    \n    @Value(\"${azure.keyvault.vault-url}\")\n    private String keyVaultUrl;\n    \n    private DefaultAzureCredential credential;\n    private BlobServiceClient blobServiceClient;\n    private KeyClient keyClient;\n    \n    @PostConstruct\n    public void initialize() {\n        try {\n            log.info(\"Initializing Azure authentication with tenant ID: {} and managed identity client ID: {}\", \n                    tenantId, managedIdentityClientId);\n            \n            // Configure DefaultAzureCredential with tenant ID and user-assigned managed identity\n            credential = new DefaultAzureCredentialBuilder()\n                    .tenantId(tenantId)\n                    .managedIdentityClientId(managedIdentityClientId)\n                    .build();\n            \n            // Initialize BlobServiceClient\n            blobServiceClient = createBlobServiceClient();\n            log.info(\"Successfully initialized BlobServiceClient for endpoint: {}\", storageAccountEndpoint);\n            \n            // Initialize KeyClient\n            keyClient = createKeyClient();\n            log.info(\"Successfully initialized KeyClient for vault: {}\", keyVaultUrl);\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"Azure credentials are unavailable. Ensure the application is running in an Azure environment \" +\n                    \"with managed identity enabled, or that appropriate environment variables are set.\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure authentication: credentials unavailable\", e);\n        } catch (Exception e) {\n            log.error(\"Unexpected error during Azure authentication initialization\", e);\n            throw new IllegalStateException(\"Failed to initialize Azure authentication\", e);\n        }\n    }\n    \n    /**\n     * Creates a BlobServiceClient using the configured credential.\n     * \n     * @return BlobServiceClient instance\n     * @throws CredentialUnavailableException if credentials cannot be obtained\n     */\n    private BlobServiceClient createBlobServiceClient() throws CredentialUnavailableException {\n        try {\n            return new BlobServiceClientBuilder()\n                    .endpoint(storageAccountEndpoint)\n                    .credential(credential)\n                    .buildClient();\n        } catch (CredentialUnavailableException e) {\n            log.error(\"Failed to create BlobServiceClient: credentials unavailable\", e);\n            throw e;\n        } catch (Exception e) {\n            log.error(\"Failed to create BlobServiceClient\", e);\n            throw new RuntimeException(\"Failed to create BlobServiceClient\", e);\n        }\n    }\n    \n    /**\n     * Creates a KeyClient using the configured credential.\n     * \n     * @return KeyClient instance\n     * @throws CredentialUnavailableException if credentials cannot be obtained\n     */\n    private KeyClient createKeyClient() throws CredentialUnavailableException {\n        try {\n            return new KeyClientBuilder()\n                    .vaultUrl(keyVaultUrl)\n                    .credential(credential)\n                    .buildClient();\n        } catch (CredentialUnavailableException e) {\n            log.error(\"Failed to create KeyClient: credentials unavailable\", e);\n            throw e;\n        } catch (Exception e) {\n            log.error(\"Failed to create KeyClient\", e);\n            throw new RuntimeException(\"Failed to create KeyClient\", e);\n        }\n    }\n    \n    /**\n     * Gets the configured Azure credential.\n     * \n     * @return TokenCredential instance\n     */\n    public TokenCredential getCredential() {\n        if (credential == null) {\n            throw new IllegalStateException(\"Azure credential not initialized\");\n        }\n        return credential;\n    }\n    \n    /**\n     * Gets the BlobServiceClient for Azure Blob Storage operations.\n     * \n     * @return BlobServiceClient instance\n     */\n    public BlobServiceClient getBlobServiceClient() {\n        if (blobServiceClient == null) {\n            throw new IllegalStateException(\"BlobServiceClient not initialized\");\n        }\n        return blobServiceClient;\n    }\n    \n    /**\n     * Gets the KeyClient for Azure Key Vault operations.\n     * \n     * @return KeyClient instance\n     */\n    public KeyClient getKeyClient() {\n        if (keyClient == null) {\n            throw new IllegalStateException(\"KeyClient not initialized\");\n        }\n        return keyClient;\n    }\n}\n```\n\nNow let me create the corresponding application properties file:\n\n```properties\n# Azure Authentication Configuration\nazure.tenant-id=${AZURE_TENANT_ID}\nazure.managed-identity.client-id=${AZURE_CLIENT_ID}\n\n# Azure Storage Configuration\nazure.storage.account-endpoint=https://${AZURE_STORAGE_ACCOUNT_NAME}.blob.core.windows.net\n\n# Azure Key Vault Configuration\nazure.keyvault.vault-url=https://${AZURE_KEYVAULT_NAME}.vault.azure.net\n```\n\nAnd the required Maven dependencies for `pom.xml`:\n\n```xml\n<!-- Azure Identity -->\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-identity</artifactId>\n    <version>1.15.0</version>\n</dependency>\n\n<!-- Azure Storage Blob -->\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-storage-blob</artifactId>\n    <version>12.28.1</version>\n</dependency>\n\n<!-- Azure Key Vault Keys -->\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-security-keyvault-keys</artifactId>\n    <version>4.9.0</version>\n</dependency>\n```\n\n## Key Features:\n\n1. **DefaultAzureCredential Configuration**: Configured with specific tenant ID and user-assigned managed identity client ID\n2. **Proper Error Handling**: Catches `CredentialUnavailableException` specifically and provides helpful error messages\n3. **Lazy Initialization**: Uses `@PostConstruct` to initialize clients after dependency injection\n4. **Client Access**: Provides getter methods for both `BlobServiceClient` and `KeyClient`\n5. **Logging**: Comprehensive logging for debugging authentication issues\n6. **Configuration**: Externalized configuration using Spring properties\n7. **Null Safety**: Checks for null before returning clients\n\nThe service will automatically authenticate using the managed identity when deployed to Azure, and the credential can fall back to other methods (like Azure CLI) during local development.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11378,
            "output_tokens": 1876,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-identity-java-02",
      "task_type": "cross_language",
      "target_language": "python",
      "expected_patterns": [
        "from azure\\.identity import DefaultAzureCredential",
        "DefaultAzureCredential\\(\\)",
        "BlobServiceClient",
        "credential=credential",
        "except.*Error"
      ],
      "anti_patterns": [
        "DefaultAzureCredentialBuilder",
        "\\.build\\(\\)",
        "import com\\.azure",
        "new.*Builder\\(\\)",
        "\\.buildClient\\(\\)"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-identity/azure.identity.defaultazurecredential",
          "description": "Python DefaultAzureCredential: direct instantiation with DefaultAzureCredential()"
        },
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-storage-blob/azure.storage.blob.blobserviceclient",
          "description": "Python BlobServiceClient with credential= keyword argument"
        },
        {
          "url": "https://docs.python.org/3/tutorial/errors.html",
          "description": "Python exception handling - source of except keyword and Error exception handling as required by prompt ('handles authentication errors')"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.defaultazurecredentialbuilder",
          "description": "Anti-patterns: Java DefaultAzureCredentialBuilder, .build(), .buildClient() patterns"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Azure Blob Storage Authentication and Container Listing Script\n\nHere's a complete Python script that demonstrates Azure authentication and blob storage operations:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Blob Storage Container Listing Script\nAuthenticates using DefaultAzureCredential and lists all containers in a storage account.\n\"\"\"\n\nimport sys\nfrom azure.identity import DefaultAzureCredential\nfrom azure.storage.blob import BlobServiceClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    HttpResponseError,\n    ServiceRequestError\n)\n\n# Configuration\nSTORAGE_ACCOUNT_NAME = \"your_storage_account_name\"  # Replace with your storage account name\nSTORAGE_ACCOUNT_URL = f\"https://{STORAGE_ACCOUNT_NAME}.blob.core.windows.net\"\n\n\ndef authenticate_azure():\n    \"\"\"\n    Authenticate to Azure using DefaultAzureCredential.\n    \n    Returns:\n        DefaultAzureCredential: Authenticated credential object\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n    \"\"\"\n    try:\n        print(\"Authenticating to Azure...\")\n        credential = DefaultAzureCredential()\n        \n        # Test the credential by attempting to get a token\n        token = credential.get_token(\"https://storage.azure.com/.default\")\n        print(\"\u2713 Authentication successful!\")\n        return credential\n        \n    except ClientAuthenticationError as e:\n        print(f\"\u2717 Authentication failed: {e}\")\n        print(\"\\nTroubleshooting tips:\")\n        print(\"1. Ensure you're logged in via Azure CLI: az login\")\n        print(\"2. Check if environment variables are set (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET)\")\n        print(\"3. Verify managed identity is configured if running on Azure\")\n        raise\n    except Exception as e:\n        print(f\"\u2717 Unexpected error during authentication: {e}\")\n        raise\n\n\ndef create_blob_service_client(credential):\n    \"\"\"\n    Create a BlobServiceClient using the provided credential.\n    \n    Args:\n        credential: Azure credential object\n        \n    Returns:\n        BlobServiceClient: Authenticated blob service client\n    \"\"\"\n    try:\n        print(f\"\\nConnecting to storage account: {STORAGE_ACCOUNT_NAME}\")\n        blob_service_client = BlobServiceClient(\n            account_url=STORAGE_ACCOUNT_URL,\n            credential=credential\n        )\n        return blob_service_client\n        \n    except Exception as e:\n        print(f\"\u2717 Failed to create BlobServiceClient: {e}\")\n        raise\n\n\ndef list_containers(blob_service_client):\n    \"\"\"\n    List all containers in the storage account.\n    \n    Args:\n        blob_service_client: Authenticated BlobServiceClient\n        \n    Returns:\n        list: List of container names\n    \"\"\"\n    try:\n        print(\"\\nListing containers...\")\n        print(\"-\" * 60)\n        \n        containers = []\n        container_list = blob_service_client.list_containers(include_metadata=True)\n        \n        for i, container in enumerate(container_list, 1):\n            containers.append(container.name)\n            print(f\"{i}. Container: {container.name}\")\n            \n            # Display additional container properties\n            if container.metadata:\n                print(f\"   Metadata: {container.metadata}\")\n            if hasattr(container, 'last_modified'):\n                print(f\"   Last Modified: {container.last_modified}\")\n            print()\n        \n        if not containers:\n            print(\"No containers found in the storage account.\")\n        else:\n            print(f\"\\nTotal containers: {len(containers)}\")\n        \n        print(\"-\" * 60)\n        return containers\n        \n    except ClientAuthenticationError as e:\n        print(f\"\u2717 Authentication error while listing containers: {e}\")\n        print(\"Your credentials may have expired or lack necessary permissions.\")\n        print(\"Required permission: 'Storage Blob Data Reader' or 'Storage Blob Data Contributor'\")\n        raise\n        \n    except HttpResponseError as e:\n        print(f\"\u2717 HTTP error while listing containers: {e}\")\n        if e.status_code == 403:\n            print(\"Access denied. Ensure you have the required RBAC role assigned.\")\n            print(\"Required roles: 'Storage Blob Data Reader' or higher\")\n        elif e.status_code == 404:\n            print(f\"Storage account '{STORAGE_ACCOUNT_NAME}' not found.\")\n        raise\n        \n    except ServiceRequestError as e:\n        print(f\"\u2717 Network error while connecting to storage account: {e}\")\n        print(\"Check your network connection and storage account URL.\")\n        raise\n        \n    except Exception as e:\n        print(f\"\u2717 Unexpected error while listing containers: {e}\")\n        raise\n\n\ndef list_blobs_in_container(blob_service_client, container_name, max_blobs=10):\n    \"\"\"\n    List blobs in a specific container (optional functionality).\n    \n    Args:\n        blob_service_client: Authenticated BlobServiceClient\n        container_name: Name of the container\n        max_blobs: Maximum number of blobs to display\n    \"\"\"\n    try:\n        print(f\"\\nListing blobs in container '{container_name}' (max {max_blobs})...\")\n        container_client = blob_service_client.get_container_client(container_name)\n        \n        blob_list = container_client.list_blobs()\n        \n        for i, blob in enumerate(blob_list, 1):\n            if i > max_blobs:\n                print(f\"... and more (showing first {max_blobs} blobs)\")\n                break\n            print(f\"  - {blob.name} ({blob.size} bytes)\")\n            \n    except Exception as e:\n        print(f\"\u2717 Error listing blobs in container '{container_name}': {e}\")\n\n\ndef main():\n    \"\"\"\n    Main function to orchestrate the Azure Blob Storage operations.\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"Azure Blob Storage Container Listing Script\")\n    print(\"=\" * 60)\n    \n    try:\n        # Step 1: Authenticate to Azure\n        credential = authenticate_azure()\n        \n        # Step 2: Create BlobServiceClient\n        blob_service_client = create_blob_service_client(credential)\n        \n        # Step 3: List all containers\n        containers = list_containers(blob_service_client)\n        \n        # Optional: List blobs in the first container\n        if containers:\n            print(\"\\n\" + \"=\" * 60)\n            response = input(f\"\\nWould you like to list blobs in '{containers[0]}'? (y/n): \")\n            if response.lower() == 'y':\n                list_blobs_in_container(blob_service_client, containers[0])\n        \n        print(\"\\n\u2713 Script completed successfully!\")\n        return 0\n        \n    except ClientAuthenticationError:\n        print(\"\\n\u2717 Script failed due to authentication error.\")\n        return 1\n        \n    except HttpResponseError as e:\n        print(f\"\\n\u2717 Script failed due to HTTP error: {e.status_code}\")\n        return 1\n        \n    except Exception as e:\n        print(f\"\\n\u2717 Script failed with unexpected error: {type(e).__name__}\")\n        return 1\n        \n    finally:\n        print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```\n\n## Installation Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nazure-identity>=1.12.0\nazure-storage-blob>=12.19.0\nazure-core>=1.26.0\n```\n\nInstall dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n## Configuration\n\nBefore running the script, update the `STORAGE_ACCOUNT_NAME` variable:\n\n```python\nSTORAGE_ACCOUNT_NAME = \"mystorageaccount\"  # Replace with your actual storage account name\n```\n\n## Authentication Methods\n\nThe `DefaultAzureCredential` tries multiple authentication methods in order:\n\n1. **Environment Variables** - Service Principal credentials\n2. **Managed Identity** - For Azure-hosted applications\n3. **Azure CLI** - Uses `az login` credentials\n4. **Azure PowerShell** - Uses PowerShell credentials\n5. **Interactive Browser** - Opens browser for authentication\n\n## Usage Examples\n\n### Using Azure CLI (Recommended for local development):\n\n```bash\n# Login to Azure\naz login\n\n# Run the script\npython azure_blob_list.py\n```\n\n### Using Service Principal (Environment Variables):\n\n```bash\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\n\npython azure_blob_list.py\n```\n\n## Required Azure Permissions\n\nAssign one of these RBAC roles to your identity:\n\n- **Storage Blob Data Reader** - Read-only access\n- **Storage Blob Data Contributor** - Read/write access\n\n```bash\n# Assign role using Azure CLI\naz role assignment create \\\n    --role \"Storage Blob Data Reader\" \\\n    --assignee <user-email-or-service-principal-id> \\\n    --scope /subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.Storage/storageAccounts/<storage-account>\n```\n\nThis script provides comprehensive error handling, clear user feedback, and demonstrates best practices for Azure authentication!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 51,
            "output_tokens": 2309,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Blob Storage Authentication with DefaultAzureCredential\n\nHere's a complete Python script that demonstrates Azure authentication and blob storage operations:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Blob Storage Authentication Example\nDemonstrates using DefaultAzureCredential to authenticate and list blob containers.\n\"\"\"\n\nimport os\nimport sys\nfrom typing import List\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError\n)\nfrom azure.storage.blob import BlobServiceClient, ContainerProperties\n\n\ndef get_storage_account_url() -> str:\n    \"\"\"\n    Get storage account URL from environment variable.\n    \n    Returns:\n        str: Storage account URL\n        \n    Raises:\n        ValueError: If AZURE_STORAGE_ACCOUNT_NAME is not set\n    \"\"\"\n    account_name = os.getenv(\"AZURE_STORAGE_ACCOUNT_NAME\")\n    if not account_name:\n        raise ValueError(\n            \"AZURE_STORAGE_ACCOUNT_NAME environment variable must be set. \"\n            \"Example: export AZURE_STORAGE_ACCOUNT_NAME=mystorageaccount\"\n        )\n    \n    return f\"https://{account_name}.blob.core.windows.net\"\n\n\ndef create_blob_service_client() -> BlobServiceClient:\n    \"\"\"\n    Create BlobServiceClient using DefaultAzureCredential.\n    \n    DefaultAzureCredential tries authentication methods in this order:\n    1. Environment variables (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET)\n    2. Workload Identity (for AKS)\n    3. Managed Identity (for Azure-hosted apps)\n    4. Azure CLI (az login)\n    5. Azure PowerShell\n    6. Azure Developer CLI (azd auth login)\n    \n    Returns:\n        BlobServiceClient: Authenticated client\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n    \"\"\"\n    try:\n        # Get storage account URL\n        account_url = get_storage_account_url()\n        \n        # Create credential\n        # For production, consider configuring specific options:\n        # credential = DefaultAzureCredential(\n        #     managed_identity_client_id=\"<user-assigned-identity-client-id>\",\n        #     exclude_environment_credential=False,\n        #     exclude_cli_credential=False\n        # )\n        credential = DefaultAzureCredential()\n        \n        # Create BlobServiceClient\n        blob_service_client = BlobServiceClient(\n            account_url=account_url,\n            credential=credential\n        )\n        \n        print(f\"\u2713 Created BlobServiceClient for: {account_url}\")\n        return blob_service_client\n        \n    except ValueError as e:\n        print(f\"\u2717 Configuration error: {e}\", file=sys.stderr)\n        raise\n    except ClientAuthenticationError as e:\n        print(f\"\u2717 Authentication failed: {e.message}\", file=sys.stderr)\n        print(\"\\nTroubleshooting tips:\", file=sys.stderr)\n        print(\"1. Run 'az login' if using Azure CLI authentication\", file=sys.stderr)\n        print(\"2. Set environment variables for service principal:\", file=sys.stderr)\n        print(\"   - AZURE_TENANT_ID\", file=sys.stderr)\n        print(\"   - AZURE_CLIENT_ID\", file=sys.stderr)\n        print(\"   - AZURE_CLIENT_SECRET\", file=sys.stderr)\n        print(\"3. Ensure managed identity is enabled (for Azure-hosted apps)\", file=sys.stderr)\n        print(\"4. Verify you have 'Storage Blob Data Reader' role on the storage account\", file=sys.stderr)\n        raise\n    except Exception as e:\n        print(f\"\u2717 Unexpected error creating client: {e}\", file=sys.stderr)\n        raise\n\n\ndef list_containers(blob_service_client: BlobServiceClient) -> List[ContainerProperties]:\n    \"\"\"\n    List all containers in the storage account.\n    \n    Args:\n        blob_service_client: Authenticated BlobServiceClient\n        \n    Returns:\n        List[ContainerProperties]: List of container properties\n        \n    Raises:\n        ClientAuthenticationError: If token is invalid/expired\n        HttpResponseError: If API call fails\n    \"\"\"\n    try:\n        print(\"\\nListing containers...\")\n        containers = list(blob_service_client.list_containers())\n        \n        if not containers:\n            print(\"  No containers found in this storage account\")\n        else:\n            print(f\"  Found {len(containers)} container(s):\")\n            for container in containers:\n                print(f\"    - {container.name}\")\n                if container.metadata:\n                    print(f\"      Metadata: {container.metadata}\")\n        \n        return containers\n        \n    except ClientAuthenticationError as e:\n        print(f\"\u2717 Authentication error while listing containers: {e.message}\", file=sys.stderr)\n        print(\"  Token may have expired. Try re-authenticating.\", file=sys.stderr)\n        raise\n    except ResourceNotFoundError as e:\n        print(f\"\u2717 Storage account not found: {e.message}\", file=sys.stderr)\n        raise\n    except HttpResponseError as e:\n        print(f\"\u2717 API error: {e.message}\", file=sys.stderr)\n        print(f\"  Status code: {e.status_code}\", file=sys.stderr)\n        if e.status_code == 403:\n            print(\"  Permission denied. Ensure you have the required role assignment:\", file=sys.stderr)\n            print(\"  - Storage Blob Data Reader (minimum)\", file=sys.stderr)\n            print(\"  - Storage Blob Data Contributor (for write access)\", file=sys.stderr)\n        raise\n    except Exception as e:\n        print(f\"\u2717 Unexpected error: {e}\", file=sys.stderr)\n        raise\n\n\ndef get_container_details(blob_service_client: BlobServiceClient, container_name: str):\n    \"\"\"\n    Get detailed information about a specific container.\n    \n    Args:\n        blob_service_client: Authenticated BlobServiceClient\n        container_name: Name of the container\n    \"\"\"\n    try:\n        container_client = blob_service_client.get_container_client(container_name)\n        properties = container_client.get_container_properties()\n        \n        print(f\"\\nContainer '{container_name}' details:\")\n        print(f\"  Last modified: {properties.last_modified}\")\n        print(f\"  ETag: {properties.etag}\")\n        print(f\"  Lease status: {properties.lease.status}\")\n        print(f\"  Public access: {properties.public_access or 'None'}\")\n        \n        # List blobs in container\n        print(f\"\\n  Listing blobs in '{container_name}':\")\n        blobs = list(container_client.list_blobs())\n        if not blobs:\n            print(\"    No blobs found\")\n        else:\n            print(f\"    Found {len(blobs)} blob(s):\")\n            for blob in blobs[:10]:  # Show first 10\n                print(f\"      - {blob.name} ({blob.size} bytes)\")\n            if len(blobs) > 10:\n                print(f\"      ... and {len(blobs) - 10} more\")\n                \n    except ResourceNotFoundError:\n        print(f\"\u2717 Container '{container_name}' not found\", file=sys.stderr)\n    except ClientAuthenticationError as e:\n        print(f\"\u2717 Authentication error: {e.message}\", file=sys.stderr)\n    except Exception as e:\n        print(f\"\u2717 Error getting container details: {e}\", file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main function to demonstrate Azure authentication and blob operations.\"\"\"\n    print(\"=\" * 60)\n    print(\"Azure Blob Storage Authentication Example\")\n    print(\"Using DefaultAzureCredential\")\n    print(\"=\" * 60)\n    \n    try:\n        # Create authenticated client\n        blob_service_client = create_blob_service_client()\n        \n        # List all containers\n        containers = list_containers(blob_service_client)\n        \n        # Get details for first container (if any)\n        if containers:\n            first_container = containers[0].name\n            get_container_details(blob_service_client, first_container)\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"\u2713 Script completed successfully\")\n        print(\"=\" * 60)\n        \n        return 0\n        \n    except ClientAuthenticationError:\n        print(\"\\n\u2717 Authentication failed. Please check your credentials.\", file=sys.stderr)\n        return 1\n    except ValueError as e:\n        print(f\"\\n\u2717 Configuration error: {e}\", file=sys.stderr)\n        return 1\n    except Exception as e:\n        print(f\"\\n\u2717 Unexpected error: {e}\", file=sys.stderr)\n        return 1\n    finally:\n        # Cleanup (credential doesn't need explicit cleanup)\n        pass\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```\n\n## Installation Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nazure-identity==1.19.0\nazure-storage-blob==12.24.0\n```\n\nInstall dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n## Usage Examples\n\n### 1. Using Azure CLI Authentication (Local Development)\n\n```bash\n# Login to Azure\naz login\n\n# Set storage account name\nexport AZURE_STORAGE_ACCOUNT_NAME=mystorageaccount\n\n# Run script\npython azure_blob_auth.py\n```\n\n### 2. Using Service Principal (CI/CD)\n\n```bash\n# Set environment variables\nexport AZURE_TENANT_ID=12345678-1234-1234-1234-123456789012\nexport AZURE_CLIENT_ID=87654321-4321-4321-4321-210987654321\nexport AZURE_CLIENT_SECRET=your-client-secret\nexport AZURE_STORAGE_ACCOUNT_NAME=mystorageaccount\n\n# Run script\npython azure_blob_auth.py\n```\n\n### 3. Using Managed Identity (Azure VM/App Service)\n\n```bash\n# Only storage account name needed - managed identity is automatic\nexport AZURE_STORAGE_ACCOUNT_NAME=mystorageaccount\n\n# For user-assigned managed identity, also set:\nexport AZURE_CLIENT_ID=<user-assigned-identity-client-id>\n\n# Run script\npython azure_blob_auth.py\n```\n\n## Advanced Example with Error Recovery\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAdvanced example with retry logic and detailed error handling.\n\"\"\"\n\nimport os\nimport sys\nimport time\nfrom typing import Optional\n\nfrom azure.identity import DefaultAzureCredential, ChainedTokenCredential, ManagedIdentityCredential, AzureCliCredential\nfrom azure.core.exceptions import ClientAuthenticationError, ServiceRequestError\nfrom azure.storage.blob import BlobServiceClient\nfrom azure.core.pipeline.policies import RetryPolicy\n\n\ndef create_robust_credential():\n    \"\"\"\n    Create a credential chain with explicit fallback order.\n    Useful when you want more control than DefaultAzureCredential.\n    \"\"\"\n    credentials = []\n    \n    # Try managed identity first (for production)\n    try:\n        mi_credential = ManagedIdentityCredential(\n            client_id=os.getenv(\"AZURE_CLIENT_ID\")  # For user-assigned MI\n        )\n        credentials.append(mi_credential)\n        print(\"\u2713 Added ManagedIdentityCredential to chain\")\n    except Exception as e:\n        print(f\"  Skipping ManagedIdentityCredential: {e}\")\n    \n    # Fallback to Azure CLI (for development)\n    try:\n        cli_credential = AzureCliCredential()\n        credentials.append(cli_credential)\n        print(\"\u2713 Added AzureCliCredential to chain\")\n    except Exception as e:\n        print(f\"  Skipping AzureCliCredential: {e}\")\n    \n    if not credentials:\n        raise ValueError(\"No credentials available in chain\")\n    \n    return ChainedTokenCredential(*credentials)\n\n\ndef create_blob_client_with_retry(max_retries: int = 3) -> Optional[BlobServiceClient]:\n    \"\"\"\n    Create BlobServiceClient with retry logic for transient failures.\n    \n    Args:\n        max_retries: Maximum number of retry attempts\n        \n    Returns:\n        BlobServiceClient or None if all retries fail\n    \"\"\"\n    account_url = f\"https://{os.getenv('AZURE_STORAGE_ACCOUNT_NAME')}.blob.core.windows.net\"\n    \n    for attempt in range(1, max_retries + 1):\n        try:\n            print(f\"\\nAttempt {attempt}/{max_retries} to create client...\")\n            \n            credential = DefaultAzureCredential()\n            \n            blob_service_client = BlobServiceClient(\n                account_url=account_url,\n                credential=credential,\n                retry_policy=RetryPolicy(\n                    retry_total=3,\n                    retry_backoff_factor=0.8\n                )\n            )\n            \n            # Test authentication by making a simple API call\n            _ = blob_service_client.get_account_information()\n            \n            print(f\"\u2713 Successfully authenticated on attempt {attempt}\")\n            return blob_service_client\n            \n        except ClientAuthenticationError as e:\n            print(f\"\u2717 Authentication failed on attempt {attempt}: {e.message}\")\n            if attempt < max_retries:\n                wait_time = 2 ** attempt  # Exponential backoff\n                print(f\"  Retrying in {wait_time} seconds...\")\n                time.sleep(wait_time)\n            else:\n                print(\"\u2717 All retry attempts exhausted\")\n                return None\n                \n        except ServiceRequestError as e:\n            print(f\"\u2717 Network error on attempt {attempt}: {e}\")\n            if attempt < max_retries:\n                wait_time = 2 ** attempt\n                print(f\"  Retrying in {wait_time} seconds...\")\n                time.sleep(wait_time)\n            else:\n                print(\"\u2717 All retry attempts exhausted\")\n                return None\n                \n        except Exception as e:\n            print(f\"\u2717 Unexpected error: {e}\")\n            return None\n    \n    return None\n\n\ndef main():\n    \"\"\"Main function with robust error handling.\"\"\"\n    print(\"Advanced Azure Blob Storage Authentication\")\n    print(\"=\" * 60)\n    \n    # Validate environment\n    if not os.getenv(\"AZURE_STORAGE_ACCOUNT_NAME\"):\n        print(\"\u2717 AZURE_STORAGE_ACCOUNT_NAME must be set\", file=sys.stderr)\n        return 1\n    \n    # Create client with retry logic\n    client = create_blob_client_with_retry(max_retries=3)\n    \n    if not client:\n        print(\"\\n\u2717 Failed to create authenticated client\", file=sys.stderr)\n        return 1\n    \n    # Use client\n    try:\n        containers = list(client.list_containers())\n        print(f\"\\n\u2713 Found {len(containers)} container(s)\")\n        for container in containers:\n            print(f\"  - {container.name}\")\n    except Exception as e:\n        print(f\"\\n\u2717 Error listing containers: {e}\", file=sys.stderr)\n        return 1\n    \n    print(\"\\n\u2713 Script completed successfully\")\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```\n\n## Required Azure Permissions\n\nGrant the identity (user, service principal, or managed identity) the following role:\n\n```bash\n# Minimum permission for read operations\naz role assignment create \\\n  --role \"Storage Blob Data Reader\" \\\n  --assignee <user-email-or-service-principal-id> \\\n  --scope /subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.Storage/storageAccounts/<storage-account>\n\n# For write operations\naz role assignment create \\\n  --role \"Storage Blob Data Contributor\" \\\n  --assignee <user-email-or-service-principal-id> \\\n  --scope /subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.Storage/storageAccounts/<storage-account>\n```\n\n## Troubleshooting\n\n**Authentication fails with \"No credential available\":**\n- Run `az login` for local development\n- Set `AZURE_TENANT_ID`, `AZURE_CLIENT_ID`, `AZURE_CLIENT_SECRET` for service principal\n- Enable managed identity for Azure-hosted apps",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10828,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Python script that authenticates to Azure using DefaultAzureCredential and lists blob containers with proper error handling.\n\n```python\n\"\"\"Azure Blob Storage container listing using DefaultAzureCredential.\"\"\"\nimport logging\nimport sys\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import ClientAuthenticationError\nfrom azure.storage.blob import BlobServiceClient\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\ndef list_blob_containers(storage_account_name: str) -> None:\n    \"\"\"\n    List all containers in an Azure Storage account using DefaultAzureCredential.\n    \n    Args:\n        storage_account_name: Name of the Azure Storage account\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n        Exception: For other Azure service errors\n    \"\"\"\n    try:\n        # Create DefaultAzureCredential\n        # This will try multiple authentication methods in order:\n        # 1. EnvironmentCredential\n        # 2. WorkloadIdentityCredential\n        # 3. ManagedIdentityCredential\n        # 4. AzureCliCredential\n        # 5. AzurePowerShellCredential\n        logger.info(\"Initializing DefaultAzureCredential...\")\n        credential = DefaultAzureCredential()\n        \n        # Construct the blob service endpoint\n        account_url = f\"https://{storage_account_name}.blob.core.windows.net\"\n        logger.info(f\"Connecting to storage account: {account_url}\")\n        \n        # Create BlobServiceClient\n        blob_service_client = BlobServiceClient(\n            account_url=account_url,\n            credential=credential\n        )\n        \n        # List containers\n        logger.info(\"Listing containers...\")\n        containers = blob_service_client.list_containers()\n        \n        container_count = 0\n        for container in containers:\n            container_count += 1\n            logger.info(f\"Container {container_count}: {container.name}\")\n            logger.info(f\"  Last modified: {container.last_modified}\")\n            logger.info(f\"  Public access: {container.public_access or 'None'}\")\n        \n        if container_count == 0:\n            logger.info(\"No containers found in the storage account\")\n        else:\n            logger.info(f\"Total containers: {container_count}\")\n            \n    except ClientAuthenticationError as e:\n        logger.error(\"Authentication failed. Please ensure you are logged in via Azure CLI or have proper credentials configured.\")\n        logger.error(f\"Error details: {e.message}\")\n        raise\n    except Exception as e:\n        logger.error(f\"An error occurred: {type(e).__name__}\")\n        logger.error(f\"Error details: {str(e)}\")\n        raise\n    finally:\n        # Clean up credential\n        if 'credential' in locals():\n            credential.close()\n\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    if len(sys.argv) != 2:\n        print(\"Usage: python list_blob_containers.py <storage_account_name>\")\n        print(\"\\nExample: python list_blob_containers.py mystorageaccount\")\n        print(\"\\nNote: Ensure you are authenticated via one of these methods:\")\n        print(\"  - Azure CLI: Run 'az login'\")\n        print(\"  - Environment variables: Set AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_CLIENT_SECRET\")\n        print(\"  - Managed Identity: Run on Azure VM, App Service, or AKS\")\n        sys.exit(1)\n    \n    storage_account_name = sys.argv[1]\n    \n    try:\n        list_blob_containers(storage_account_name)\n    except ClientAuthenticationError:\n        logger.error(\"\\nAuthentication troubleshooting:\")\n        logger.error(\"1. Run 'az login' if using Azure CLI\")\n        logger.error(\"2. Set environment variables if using service principal:\")\n        logger.error(\"   - AZURE_TENANT_ID\")\n        logger.error(\"   - AZURE_CLIENT_ID\")\n        logger.error(\"   - AZURE_CLIENT_SECRET\")\n        logger.error(\"3. Ensure managed identity is enabled if running on Azure\")\n        sys.exit(1)\n    except Exception:\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis script:\n\n\u2705 **Uses DefaultAzureCredential** - Recommended approach that works in dev and production\n\u2705 **Creates BlobServiceClient** - Properly configured with credential\n\u2705 **Lists containers** - Iterates through all containers with metadata\n\u2705 **Handles authentication errors** - Catches `ClientAuthenticationError` specifically\n\u2705 **Provides helpful error messages** - Guides users on authentication setup\n\u2705 **Cleans up resources** - Closes credential in finally block\n\u2705 **Logging** - Comprehensive logging for debugging\n\n**Usage:**\n```bash\n# Install dependencies first\npip install azure-identity azure-storage-blob\n\n# Run the script\npython list_blob_containers.py mystorageaccount\n```\n\n**Authentication methods** (DefaultAzureCredential tries these in order):\n1. **Azure CLI** - Run `az login` first (best for local dev)\n2. **Environment variables** - Set `AZURE_TENANT_ID`, `AZURE_CLIENT_ID`, `AZURE_CLIENT_SECRET`\n3. **Managed Identity** - Automatic on Azure VMs, App Service, AKS\n\nThe script provides clear error messages and troubleshooting steps if authentication fails.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11354,
            "output_tokens": 1380,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Azure Blob Storage Authentication and Container Listing Script\n\nHere's a complete Python script that demonstrates Azure authentication and blob storage operations:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Blob Storage Container Listing Script\nAuthenticates using DefaultAzureCredential and lists all containers in a storage account.\n\"\"\"\n\nimport sys\nfrom typing import List\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    HttpResponseError,\n    ServiceRequestError\n)\nfrom azure.storage.blob import BlobServiceClient, ContainerProperties\n\n\ndef get_blob_service_client(storage_account_name: str) -> BlobServiceClient:\n    \"\"\"\n    Create and return a BlobServiceClient using DefaultAzureCredential.\n    \n    Args:\n        storage_account_name: Name of the Azure Storage account\n        \n    Returns:\n        BlobServiceClient instance\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n    \"\"\"\n    try:\n        # Create credential object\n        # DefaultAzureCredential tries multiple authentication methods in order:\n        # 1. Environment variables\n        # 2. Managed Identity\n        # 3. Visual Studio Code\n        # 4. Azure CLI\n        # 5. Azure PowerShell\n        # 6. Interactive browser\n        credential = DefaultAzureCredential()\n        \n        # Construct the storage account URL\n        account_url = f\"https://{storage_account_name}.blob.core.windows.net\"\n        \n        # Create BlobServiceClient\n        blob_service_client = BlobServiceClient(\n            account_url=account_url,\n            credential=credential\n        )\n        \n        print(f\"\u2713 Successfully created BlobServiceClient for: {account_url}\")\n        return blob_service_client\n        \n    except ClientAuthenticationError as e:\n        print(f\"\u2717 Authentication failed: {e.message}\", file=sys.stderr)\n        raise\n    except Exception as e:\n        print(f\"\u2717 Unexpected error creating BlobServiceClient: {str(e)}\", file=sys.stderr)\n        raise\n\n\ndef list_containers(blob_service_client: BlobServiceClient) -> List[ContainerProperties]:\n    \"\"\"\n    List all containers in the storage account.\n    \n    Args:\n        blob_service_client: Authenticated BlobServiceClient instance\n        \n    Returns:\n        List of ContainerProperties objects\n        \n    Raises:\n        HttpResponseError: If the API request fails\n    \"\"\"\n    try:\n        print(\"\\nListing containers...\")\n        containers = list(blob_service_client.list_containers(include_metadata=True))\n        \n        if not containers:\n            print(\"No containers found in this storage account.\")\n            return []\n        \n        print(f\"\\nFound {len(containers)} container(s):\\n\")\n        print(f\"{'Container Name':<30} {'Last Modified':<30} {'Public Access':<15}\")\n        print(\"-\" * 75)\n        \n        for container in containers:\n            public_access = container.public_access or \"None\"\n            last_modified = container.last_modified.strftime(\"%Y-%m-%d %H:%M:%S\") if container.last_modified else \"N/A\"\n            \n            print(f\"{container.name:<30} {last_modified:<30} {public_access:<15}\")\n            \n            # Print metadata if available\n            if container.metadata:\n                print(f\"  Metadata: {container.metadata}\")\n        \n        return containers\n        \n    except HttpResponseError as e:\n        if e.status_code == 403:\n            print(f\"\u2717 Access denied: Insufficient permissions to list containers\", file=sys.stderr)\n            print(f\"  Error: {e.message}\", file=sys.stderr)\n        elif e.status_code == 404:\n            print(f\"\u2717 Storage account not found\", file=sys.stderr)\n        else:\n            print(f\"\u2717 HTTP error occurred: {e.status_code} - {e.message}\", file=sys.stderr)\n        raise\n    except ServiceRequestError as e:\n        print(f\"\u2717 Network error: Unable to connect to storage account\", file=sys.stderr)\n        print(f\"  Error: {str(e)}\", file=sys.stderr)\n        raise\n    except Exception as e:\n        print(f\"\u2717 Unexpected error listing containers: {str(e)}\", file=sys.stderr)\n        raise\n\n\ndef get_container_details(blob_service_client: BlobServiceClient, container_name: str):\n    \"\"\"\n    Get detailed information about a specific container.\n    \n    Args:\n        blob_service_client: Authenticated BlobServiceClient instance\n        container_name: Name of the container to inspect\n    \"\"\"\n    try:\n        container_client = blob_service_client.get_container_client(container_name)\n        properties = container_client.get_container_properties()\n        \n        print(f\"\\nDetails for container '{container_name}':\")\n        print(f\"  Last Modified: {properties.last_modified}\")\n        print(f\"  ETag: {properties.etag}\")\n        print(f\"  Lease Status: {properties.lease.status}\")\n        print(f\"  Public Access: {properties.public_access or 'None'}\")\n        \n        if properties.metadata:\n            print(f\"  Metadata: {properties.metadata}\")\n            \n    except HttpResponseError as e:\n        print(f\"\u2717 Error getting container details: {e.message}\", file=sys.stderr)\n    except Exception as e:\n        print(f\"\u2717 Unexpected error: {str(e)}\", file=sys.stderr)\n\n\ndef main():\n    \"\"\"\n    Main function to demonstrate Azure Blob Storage authentication and operations.\n    \"\"\"\n    # Replace with your storage account name\n    STORAGE_ACCOUNT_NAME = \"yourstorageaccount\"\n    \n    # You can also get this from environment variable\n    import os\n    storage_account_name = os.getenv(\"AZURE_STORAGE_ACCOUNT\", STORAGE_ACCOUNT_NAME)\n    \n    if storage_account_name == \"yourstorageaccount\":\n        print(\"\u26a0 Warning: Using default storage account name. Please update STORAGE_ACCOUNT_NAME or set AZURE_STORAGE_ACCOUNT environment variable.\")\n        print(\"\\nUsage:\")\n        print(\"  export AZURE_STORAGE_ACCOUNT=<your-storage-account-name>\")\n        print(\"  python script.py\")\n        return 1\n    \n    try:\n        # Create authenticated BlobServiceClient\n        blob_service_client = get_blob_service_client(storage_account_name)\n        \n        # List all containers\n        containers = list_containers(blob_service_client)\n        \n        # Optionally, get details for the first container\n        if containers:\n            get_container_details(blob_service_client, containers[0].name)\n        \n        print(\"\\n\u2713 Script completed successfully!\")\n        return 0\n        \n    except ClientAuthenticationError:\n        print(\"\\n\u274c Authentication failed. Please ensure you are logged in:\", file=sys.stderr)\n        print(\"   - Run 'az login' for Azure CLI authentication\", file=sys.stderr)\n        print(\"   - Or set environment variables: AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET\", file=sys.stderr)\n        print(\"   - Or use Managed Identity if running in Azure\", file=sys.stderr)\n        return 1\n        \n    except HttpResponseError as e:\n        print(f\"\\n\u274c Azure service error occurred (Status: {e.status_code})\", file=sys.stderr)\n        return 1\n        \n    except ServiceRequestError:\n        print(\"\\n\u274c Network connection error\", file=sys.stderr)\n        return 1\n        \n    except Exception as e:\n        print(f\"\\n\u274c Unexpected error: {str(e)}\", file=sys.stderr)\n        return 1\n    \n    finally:\n        # Cleanup (DefaultAzureCredential doesn't require explicit cleanup)\n        print(\"\\nCleaning up resources...\")\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```\n\n## Installation Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nazure-identity>=1.15.0\nazure-storage-blob>=12.19.0\nazure-core>=1.29.0\n```\n\nInstall dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n## Usage Examples\n\n### 1. Using Azure CLI Authentication\n\n```bash\n# Login to Azure\naz login\n\n# Set storage account name\nexport AZURE_STORAGE_ACCOUNT=mystorageaccount\n\n# Run the script\npython azure_blob_list.py\n```\n\n### 2. Using Service Principal (Environment Variables)\n\n```bash\nexport AZURE_CLIENT_ID=<your-client-id>\nexport AZURE_TENANT_ID=<your-tenant-id>\nexport AZURE_CLIENT_SECRET=<your-client-secret>\nexport AZURE_STORAGE_ACCOUNT=mystorageaccount\n\npython azure_blob_list.py\n```\n\n### 3. Using Managed Identity (in Azure VM/App Service)\n\n```bash\n# No authentication setup needed - just set the storage account\nexport AZURE_STORAGE_ACCOUNT=mystorageaccount\n\npython azure_blob_list.py\n```\n\n## Required Azure Permissions\n\nThe authenticated identity needs the following RBAC role:\n- **Storage Blob Data Reader** (minimum) - to list containers\n- **Storage Blob Data Contributor** - for read/write operations\n\nAssign the role:\n\n```bash\naz role assignment create \\\n    --role \"Storage Blob Data Reader\" \\\n    --assignee <user-or-service-principal-id> \\\n    --scope /subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.Storage/storageAccounts/<storage-account>\n```\n\nThis script provides robust error handling, clear output, and demonstrates best practices for Azure authentication using the azure-identity SDK.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 51,
            "output_tokens": 2437,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Blob Storage Authentication with DefaultAzureCredential\n\nHere's a complete Python script that demonstrates Azure authentication and blob storage operations:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Blob Storage Authentication Example\nDemonstrates using DefaultAzureCredential to authenticate and list containers.\n\"\"\"\n\nimport sys\nimport os\nfrom typing import Optional\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    HttpResponseError,\n    ServiceRequestError\n)\nfrom azure.storage.blob import BlobServiceClient, ContainerProperties\n\n\ndef create_blob_service_client(\n    storage_account_name: str,\n    credential: Optional[DefaultAzureCredential] = None\n) -> BlobServiceClient:\n    \"\"\"\n    Create a BlobServiceClient using DefaultAzureCredential.\n    \n    Args:\n        storage_account_name: Name of the Azure Storage account\n        credential: Optional credential instance (creates new if None)\n    \n    Returns:\n        BlobServiceClient instance\n    \"\"\"\n    if credential is None:\n        credential = DefaultAzureCredential()\n    \n    account_url = f\"https://{storage_account_name}.blob.core.windows.net\"\n    \n    return BlobServiceClient(\n        account_url=account_url,\n        credential=credential\n    )\n\n\ndef list_containers(blob_service_client: BlobServiceClient) -> None:\n    \"\"\"\n    List all containers in the storage account.\n    \n    Args:\n        blob_service_client: Authenticated BlobServiceClient instance\n    \"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"Listing containers in storage account\")\n    print(\"=\"*60)\n    \n    try:\n        containers = blob_service_client.list_containers(include_metadata=True)\n        \n        container_count = 0\n        for container in containers:\n            container_count += 1\n            print(f\"\\nContainer #{container_count}:\")\n            print(f\"  Name: {container.name}\")\n            print(f\"  Last Modified: {container.last_modified}\")\n            print(f\"  Public Access: {container.public_access or 'Private'}\")\n            \n            if container.metadata:\n                print(f\"  Metadata:\")\n                for key, value in container.metadata.items():\n                    print(f\"    {key}: {value}\")\n        \n        if container_count == 0:\n            print(\"\\nNo containers found in this storage account.\")\n        else:\n            print(f\"\\nTotal containers: {container_count}\")\n            \n    except ClientAuthenticationError as e:\n        print(f\"\\n\u274c Authentication failed: {e.message}\", file=sys.stderr)\n        print(\"\\nPossible causes:\", file=sys.stderr)\n        print(\"  - No valid credentials found\", file=sys.stderr)\n        print(\"  - Insufficient permissions on storage account\", file=sys.stderr)\n        print(\"  - Token expired or invalid\", file=sys.stderr)\n        raise\n    \n    except HttpResponseError as e:\n        print(f\"\\n\u274c HTTP error occurred: {e.message}\", file=sys.stderr)\n        print(f\"Status code: {e.status_code}\", file=sys.stderr)\n        \n        if e.status_code == 403:\n            print(\"\\nAccess denied. Ensure you have 'Storage Blob Data Reader' role.\", file=sys.stderr)\n        elif e.status_code == 404:\n            print(\"\\nStorage account not found. Check the account name.\", file=sys.stderr)\n        \n        raise\n    \n    except ServiceRequestError as e:\n        print(f\"\\n\u274c Network error: {e}\", file=sys.stderr)\n        print(\"Check your network connection and storage account URL.\", file=sys.stderr)\n        raise\n    \n    except Exception as e:\n        print(f\"\\n\u274c Unexpected error: {type(e).__name__}: {e}\", file=sys.stderr)\n        raise\n\n\ndef get_account_info(blob_service_client: BlobServiceClient) -> None:\n    \"\"\"\n    Get storage account information.\n    \n    Args:\n        blob_service_client: Authenticated BlobServiceClient instance\n    \"\"\"\n    try:\n        account_info = blob_service_client.get_account_information()\n        \n        print(\"\\n\" + \"=\"*60)\n        print(\"Storage Account Information\")\n        print(\"=\"*60)\n        print(f\"SKU Name: {account_info.get('sku_name', 'N/A')}\")\n        print(f\"Account Kind: {account_info.get('account_kind', 'N/A')}\")\n        \n    except Exception as e:\n        print(f\"\\n\u26a0\ufe0f  Could not retrieve account info: {e}\", file=sys.stderr)\n\n\ndef main():\n    \"\"\"Main execution function.\"\"\"\n    \n    # Get storage account name from environment variable or command line\n    storage_account_name = os.getenv(\"AZURE_STORAGE_ACCOUNT_NAME\")\n    \n    if len(sys.argv) > 1:\n        storage_account_name = sys.argv[1]\n    \n    if not storage_account_name:\n        print(\"Error: Storage account name not provided.\", file=sys.stderr)\n        print(\"\\nUsage:\", file=sys.stderr)\n        print(\"  python script.py <storage-account-name>\", file=sys.stderr)\n        print(\"  OR set AZURE_STORAGE_ACCOUNT_NAME environment variable\", file=sys.stderr)\n        print(\"\\nExample:\", file=sys.stderr)\n        print(\"  python script.py mystorageaccount\", file=sys.stderr)\n        sys.exit(1)\n    \n    print(\"=\"*60)\n    print(\"Azure Blob Storage Authentication Example\")\n    print(\"=\"*60)\n    print(f\"Storage Account: {storage_account_name}\")\n    \n    try:\n        # Create DefaultAzureCredential\n        print(\"\\n\ud83d\udd10 Creating DefaultAzureCredential...\")\n        print(\"Attempting authentication methods in order:\")\n        print(\"  1. Environment variables\")\n        print(\"  2. Workload Identity (AKS)\")\n        print(\"  3. Managed Identity\")\n        print(\"  4. Azure CLI\")\n        print(\"  5. Azure PowerShell\")\n        print(\"  6. Azure Developer CLI\")\n        \n        credential = DefaultAzureCredential(\n            exclude_interactive_browser_credential=True,  # Disable browser for server scenarios\n            logging_enable=False  # Set to True for debugging\n        )\n        \n        # Create BlobServiceClient\n        print(\"\\n\ud83d\udce6 Creating BlobServiceClient...\")\n        blob_service_client = create_blob_service_client(\n            storage_account_name=storage_account_name,\n            credential=credential\n        )\n        \n        # Get account information\n        get_account_info(blob_service_client)\n        \n        # List containers\n        list_containers(blob_service_client)\n        \n        print(\"\\n\u2705 Operation completed successfully!\")\n        \n    except ClientAuthenticationError as e:\n        print(\"\\n\" + \"=\"*60, file=sys.stderr)\n        print(\"AUTHENTICATION TROUBLESHOOTING\", file=sys.stderr)\n        print(\"=\"*60, file=sys.stderr)\n        print(\"\\n1. For local development, run:\", file=sys.stderr)\n        print(\"   az login\", file=sys.stderr)\n        print(\"\\n2. For service principal, set environment variables:\", file=sys.stderr)\n        print(\"   AZURE_TENANT_ID=<tenant-id>\", file=sys.stderr)\n        print(\"   AZURE_CLIENT_ID=<client-id>\", file=sys.stderr)\n        print(\"   AZURE_CLIENT_SECRET=<client-secret>\", file=sys.stderr)\n        print(\"\\n3. For managed identity (Azure VM/App Service):\", file=sys.stderr)\n        print(\"   - Ensure managed identity is enabled\", file=sys.stderr)\n        print(\"   - Assign 'Storage Blob Data Reader' role\", file=sys.stderr)\n        sys.exit(1)\n    \n    except HttpResponseError as e:\n        print(\"\\n\" + \"=\"*60, file=sys.stderr)\n        print(\"AUTHORIZATION TROUBLESHOOTING\", file=sys.stderr)\n        print(\"=\"*60, file=sys.stderr)\n        print(\"\\nGrant required permissions:\", file=sys.stderr)\n        print(\"  az role assignment create \\\\\", file=sys.stderr)\n        print(\"    --role 'Storage Blob Data Reader' \\\\\", file=sys.stderr)\n        print(f\"    --assignee <user-or-service-principal> \\\\\", file=sys.stderr)\n        print(f\"    --scope /subscriptions/<sub-id>/resourceGroups/<rg>/providers/Microsoft.Storage/storageAccounts/{storage_account_name}\", file=sys.stderr)\n        sys.exit(1)\n    \n    except Exception as e:\n        print(f\"\\n\u274c Fatal error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Enhanced Version with Container Details\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nEnhanced Azure Blob Storage Example\nLists containers with detailed blob information.\n\"\"\"\n\nimport sys\nimport os\nfrom datetime import datetime\nfrom typing import List, Dict, Any\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import ClientAuthenticationError, HttpResponseError\nfrom azure.storage.blob import BlobServiceClient, ContainerClient\n\n\ndef format_size(size_bytes: int) -> str:\n    \"\"\"Format bytes to human-readable size.\"\"\"\n    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:\n        if size_bytes < 1024.0:\n            return f\"{size_bytes:.2f} {unit}\"\n        size_bytes /= 1024.0\n    return f\"{size_bytes:.2f} PB\"\n\n\ndef list_blobs_in_container(\n    container_client: ContainerClient,\n    max_blobs: int = 10\n) -> Dict[str, Any]:\n    \"\"\"\n    List blobs in a container with details.\n    \n    Args:\n        container_client: ContainerClient instance\n        max_blobs: Maximum number of blobs to display\n    \n    Returns:\n        Dictionary with container statistics\n    \"\"\"\n    blob_count = 0\n    total_size = 0\n    \n    print(f\"\\n  Blobs (showing first {max_blobs}):\")\n    \n    try:\n        blobs = container_client.list_blobs()\n        \n        for blob in blobs:\n            blob_count += 1\n            total_size += blob.size\n            \n            if blob_count <= max_blobs:\n                print(f\"    - {blob.name}\")\n                print(f\"      Size: {format_size(blob.size)}\")\n                print(f\"      Last Modified: {blob.last_modified}\")\n                print(f\"      Content Type: {blob.content_settings.content_type or 'N/A'}\")\n        \n        if blob_count > max_blobs:\n            print(f\"    ... and {blob_count - max_blobs} more blobs\")\n        \n        return {\n            'blob_count': blob_count,\n            'total_size': total_size\n        }\n    \n    except Exception as e:\n        print(f\"    \u26a0\ufe0f  Could not list blobs: {e}\")\n        return {'blob_count': 0, 'total_size': 0}\n\n\ndef list_containers_detailed(blob_service_client: BlobServiceClient) -> None:\n    \"\"\"\n    List containers with detailed blob information.\n    \n    Args:\n        blob_service_client: Authenticated BlobServiceClient instance\n    \"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"Detailed Container Listing\")\n    print(\"=\"*60)\n    \n    try:\n        containers = blob_service_client.list_containers(include_metadata=True)\n        \n        container_count = 0\n        total_blobs = 0\n        total_storage = 0\n        \n        for container in containers:\n            container_count += 1\n            print(f\"\\n\ud83d\udce6 Container: {container.name}\")\n            print(f\"   Last Modified: {container.last_modified}\")\n            print(f\"   Public Access: {container.public_access or 'Private'}\")\n            \n            # Get container client\n            container_client = blob_service_client.get_container_client(container.name)\n            \n            # List blobs in container\n            stats = list_blobs_in_container(container_client, max_blobs=5)\n            total_blobs += stats['blob_count']\n            total_storage += stats['total_size']\n            \n            print(f\"   Total Blobs: {stats['blob_count']}\")\n            print(f\"   Total Size: {format_size(stats['total_size'])}\")\n        \n        # Summary\n        print(\"\\n\" + \"=\"*60)\n        print(\"Summary\")\n        print(\"=\"*60)\n        print(f\"Total Containers: {container_count}\")\n        print(f\"Total Blobs: {total_blobs}\")\n        print(f\"Total Storage Used: {format_size(total_storage)}\")\n        \n    except Exception as e:\n        print(f\"\\n\u274c Error listing containers: {e}\", file=sys.stderr)\n        raise\n\n\ndef main():\n    \"\"\"Main execution function.\"\"\"\n    \n    storage_account_name = os.getenv(\"AZURE_STORAGE_ACCOUNT_NAME\")\n    \n    if len(sys.argv) > 1:\n        storage_account_name = sys.argv[1]\n    \n    if not storage_account_name:\n        print(\"Error: Storage account name required.\", file=sys.stderr)\n        print(\"Usage: python script.py <storage-account-name>\", file=sys.stderr)\n        sys.exit(1)\n    \n    print(\"=\"*60)\n    print(\"Azure Blob Storage - Detailed Container Listing\")\n    print(\"=\"*60)\n    print(f\"Storage Account: {storage_account_name}\")\n    \n    try:\n        # Authenticate\n        print(\"\\n\ud83d\udd10 Authenticating with DefaultAzureCredential...\")\n        credential = DefaultAzureCredential()\n        \n        # Create client\n        account_url = f\"https://{storage_account_name}.blob.core.windows.net\"\n        blob_service_client = BlobServiceClient(\n            account_url=account_url,\n            credential=credential\n        )\n        \n        # List containers with details\n        list_containers_detailed(blob_service_client)\n        \n        print(\"\\n\u2705 Operation completed successfully!\")\n        \n    except ClientAuthenticationError as e:\n        print(f\"\\n\u274c Authentication failed: {e.message}\", file=sys.stderr)\n        print(\"\\nRun 'az login' or set service principal environment variables.\", file=sys.stderr)\n        sys.exit(1)\n    \n    except HttpResponseError as e:\n        print(f\"\\n\u274c HTTP error: {e.message} (Status: {e.status_code})\", file=sys.stderr)\n        sys.exit(1)\n    \n    except Exception as e:\n        print(f\"\\n\u274c Error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Installation Requirements\n\n```bash\n# requirements.txt\nazure-identity==1.19.0\nazure-storage-blob==12.24.0\n```\n\nInstall dependencies:\n```bash\npip install -r requirements.txt\n```\n\n## Usage Examples\n\n### 1. Local Development (Azure CLI)\n```bash\n# Login first\naz login\n\n# Run script\npython blob_list.py mystorageaccount\n```\n\n### 2. Service Principal\n```bash\n# Set environment variables\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\n\n# Run script\npython blob_list.py mystorageaccount\n```\n\n### 3. Managed Identity (Azure VM/App Service)\n```bash\n# No authentication needed - runs automatically\npython blob_list.py mystorageaccount\n```\n\n### 4. Using Environment Variable\n```bash\nexport AZURE_STORAGE_ACCOUNT_NAME=\"mystorageaccount\"\npython blob_list.py\n```\n\n## Required Azure Permissions\n\nGrant the identity (user, service principal, or managed identity) the following role:\n\n```bash\naz role assignment create \\\n  --role \"Storage Blob Data Reader\" \\\n  --assignee <user-or-sp-",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10828,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Python script that authenticates to Azure using DefaultAzureCredential and lists blob containers with proper error handling.\n\n```python\n\"\"\"Azure Blob Storage container listing using DefaultAzureCredential.\"\"\"\nimport logging\nimport sys\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import ClientAuthenticationError\nfrom azure.storage.blob import BlobServiceClient\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\ndef list_blob_containers(storage_account_name: str) -> None:\n    \"\"\"\n    List all containers in an Azure Storage account using DefaultAzureCredential.\n    \n    Args:\n        storage_account_name: Name of the Azure Storage account\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n        Exception: For other Azure service errors\n    \"\"\"\n    account_url = f\"https://{storage_account_name}.blob.core.windows.net\"\n    \n    try:\n        # Create DefaultAzureCredential\n        # This will try multiple authentication methods in order:\n        # 1. Environment variables\n        # 2. Managed Identity\n        # 3. Azure CLI\n        # 4. Azure PowerShell\n        logger.info(\"Initializing DefaultAzureCredential...\")\n        credential = DefaultAzureCredential()\n        \n        # Create BlobServiceClient\n        logger.info(f\"Connecting to storage account: {storage_account_name}\")\n        blob_service_client = BlobServiceClient(\n            account_url=account_url,\n            credential=credential\n        )\n        \n        # List containers\n        logger.info(\"Listing containers...\")\n        containers = blob_service_client.list_containers()\n        \n        container_count = 0\n        for container in containers:\n            container_count += 1\n            logger.info(f\"Container {container_count}: {container.name}\")\n            logger.info(f\"  Last modified: {container.last_modified}\")\n            logger.info(f\"  Public access: {container.public_access or 'None'}\")\n        \n        if container_count == 0:\n            logger.info(\"No containers found in storage account\")\n        else:\n            logger.info(f\"Total containers: {container_count}\")\n            \n    except ClientAuthenticationError as e:\n        logger.error(\"Authentication failed: %s\", str(e))\n        logger.error(\"Please ensure you are authenticated via one of:\")\n        logger.error(\"  - Environment variables (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET)\")\n        logger.error(\"  - Managed Identity (if running on Azure)\")\n        logger.error(\"  - Azure CLI (run 'az login')\")\n        logger.error(\"  - Azure PowerShell (run 'Connect-AzAccount')\")\n        raise\n        \n    except Exception as e:\n        logger.error(\"Error accessing storage account: %s\", str(e))\n        logger.error(\"Ensure the storage account exists and you have permissions\")\n        raise\n        \n    finally:\n        # Clean up credential\n        if 'credential' in locals():\n            credential.close()\n\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    if len(sys.argv) != 2:\n        print(\"Usage: python list_containers.py <storage_account_name>\")\n        print(\"Example: python list_containers.py mystorageaccount\")\n        sys.exit(1)\n    \n    storage_account_name = sys.argv[1]\n    \n    try:\n        list_blob_containers(storage_account_name)\n    except ClientAuthenticationError:\n        sys.exit(1)\n    except Exception as e:\n        logger.error(\"Unexpected error: %s\", str(e))\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis script:\n\n\u2705 **Uses DefaultAzureCredential** - Tries multiple auth methods automatically\n\u2705 **Creates BlobServiceClient** - Connects to Azure Blob Storage\n\u2705 **Lists containers** - Iterates through all containers with metadata\n\u2705 **Handles authentication errors** - Catches `ClientAuthenticationError` specifically\n\u2705 **Provides helpful error messages** - Guides users on authentication options\n\u2705 **Proper cleanup** - Closes credential in finally block\n\u2705 **Logging** - Uses Python logging module for structured output\n\u2705 **Command-line interface** - Takes storage account name as argument\n\n**Usage:**\n```bash\n# Install dependencies\npip install azure-identity azure-storage-blob\n\n# Run with storage account name\npython list_containers.py mystorageaccount\n\n# Or set environment variables for service principal\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\npython list_containers.py mystorageaccount\n\n# Or use Azure CLI authentication\naz login\npython list_containers.py mystorageaccount\n```\n\nThe script follows Azure Identity best practices by using `DefaultAzureCredential`, which automatically tries different authentication methods in the recommended order.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11354,
            "output_tokens": 1262,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Azure Blob Storage Authentication and Container Listing Script\n\nHere's a complete Python script that demonstrates Azure authentication and blob storage operations:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Blob Storage Container Listing Script\nAuthenticates using DefaultAzureCredential and lists all containers in a storage account.\n\"\"\"\n\nimport sys\nfrom typing import List\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    HttpResponseError,\n    ServiceRequestError\n)\nfrom azure.storage.blob import BlobServiceClient, ContainerProperties\n\n\ndef authenticate_and_list_containers(storage_account_name: str) -> None:\n    \"\"\"\n    Authenticate to Azure and list all containers in the specified storage account.\n    \n    Args:\n        storage_account_name: Name of the Azure storage account\n    \"\"\"\n    \n    # Construct the storage account URL\n    account_url = f\"https://{storage_account_name}.blob.core.windows.net\"\n    \n    print(f\"Attempting to connect to: {account_url}\")\n    print(\"-\" * 60)\n    \n    try:\n        # Create DefaultAzureCredential instance\n        # This will try multiple authentication methods in order:\n        # 1. Environment variables\n        # 2. Managed Identity\n        # 3. Visual Studio Code\n        # 4. Azure CLI\n        # 5. Azure PowerShell\n        # 6. Interactive browser\n        print(\"Authenticating using DefaultAzureCredential...\")\n        credential = DefaultAzureCredential()\n        \n        # Create BlobServiceClient\n        blob_service_client = BlobServiceClient(\n            account_url=account_url,\n            credential=credential\n        )\n        \n        print(\"\u2713 Authentication successful!\")\n        print(\"-\" * 60)\n        \n        # List all containers\n        print(\"Listing containers in storage account...\")\n        print(\"-\" * 60)\n        \n        containers: List[ContainerProperties] = list(\n            blob_service_client.list_containers(include_metadata=True)\n        )\n        \n        if not containers:\n            print(\"No containers found in this storage account.\")\n        else:\n            print(f\"Found {len(containers)} container(s):\\n\")\n            \n            for idx, container in enumerate(containers, 1):\n                print(f\"{idx}. Container Name: {container.name}\")\n                print(f\"   Last Modified: {container.last_modified}\")\n                print(f\"   Public Access: {container.public_access or 'Private'}\")\n                \n                if container.metadata:\n                    print(f\"   Metadata: {container.metadata}\")\n                \n                # Get additional container properties\n                container_client = blob_service_client.get_container_client(\n                    container.name\n                )\n                properties = container_client.get_container_properties()\n                print(f\"   Lease Status: {properties.lease.status}\")\n                print()\n        \n        print(\"-\" * 60)\n        print(\"\u2713 Operation completed successfully!\")\n        \n    except ClientAuthenticationError as auth_error:\n        print(\"\u274c Authentication Error!\")\n        print(\"-\" * 60)\n        print(\"Failed to authenticate to Azure.\")\n        print(\"\\nPossible solutions:\")\n        print(\"1. Run 'az login' to authenticate via Azure CLI\")\n        print(\"2. Set environment variables:\")\n        print(\"   - AZURE_CLIENT_ID\")\n        print(\"   - AZURE_CLIENT_SECRET\")\n        print(\"   - AZURE_TENANT_ID\")\n        print(\"3. Use Managed Identity if running on Azure resources\")\n        print(f\"\\nError details: {str(auth_error)}\")\n        sys.exit(1)\n        \n    except HttpResponseError as http_error:\n        print(\"\u274c HTTP Error!\")\n        print(\"-\" * 60)\n        \n        if http_error.status_code == 403:\n            print(\"Access Denied (403 Forbidden)\")\n            print(\"\\nPossible causes:\")\n            print(\"1. Insufficient permissions on the storage account\")\n            print(\"2. Required role: 'Storage Blob Data Reader' or higher\")\n            print(\"3. Firewall rules blocking access\")\n            print(\"4. Storage account may not exist\")\n        elif http_error.status_code == 404:\n            print(\"Storage Account Not Found (404)\")\n            print(f\"\\nThe storage account '{storage_account_name}' does not exist\")\n            print(\"or is not accessible from this location.\")\n        else:\n            print(f\"HTTP Status Code: {http_error.status_code}\")\n            print(f\"Error: {http_error.message}\")\n        \n        print(f\"\\nError details: {str(http_error)}\")\n        sys.exit(1)\n        \n    except ServiceRequestError as request_error:\n        print(\"\u274c Service Request Error!\")\n        print(\"-\" * 60)\n        print(\"Failed to connect to Azure Storage service.\")\n        print(\"\\nPossible causes:\")\n        print(\"1. Network connectivity issues\")\n        print(\"2. Invalid storage account name\")\n        print(\"3. DNS resolution problems\")\n        print(f\"\\nError details: {str(request_error)}\")\n        sys.exit(1)\n        \n    except Exception as error:\n        print(\"\u274c Unexpected Error!\")\n        print(\"-\" * 60)\n        print(f\"An unexpected error occurred: {type(error).__name__}\")\n        print(f\"Error details: {str(error)}\")\n        sys.exit(1)\n        \n    finally:\n        # Clean up credential resources\n        if 'credential' in locals():\n            credential.close()\n\n\ndef main():\n    \"\"\"Main entry point for the script.\"\"\"\n    \n    print(\"=\" * 60)\n    print(\"Azure Blob Storage Container Listing Tool\")\n    print(\"=\" * 60)\n    print()\n    \n    # Get storage account name from command line or prompt\n    if len(sys.argv) > 1:\n        storage_account_name = sys.argv[1]\n    else:\n        storage_account_name = input(\"Enter storage account name: \").strip()\n    \n    if not storage_account_name:\n        print(\"\u274c Error: Storage account name is required!\")\n        print(\"\\nUsage: python script.py <storage_account_name>\")\n        sys.exit(1)\n    \n    print()\n    authenticate_and_list_containers(storage_account_name)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Installation Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nazure-identity>=1.15.0\nazure-storage-blob>=12.19.0\nazure-core>=1.29.0\n```\n\nInstall dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n## Usage Examples\n\n### 1. Basic Usage\n\n```bash\n# Using command line argument\npython azure_blob_list.py mystorageaccount\n\n# Interactive mode\npython azure_blob_list.py\n```\n\n### 2. Authentication Methods\n\n**Azure CLI (Recommended for local development):**\n```bash\naz login\npython azure_blob_list.py mystorageaccount\n```\n\n**Environment Variables:**\n```bash\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\npython azure_blob_list.py mystorageaccount\n```\n\n**Managed Identity (for Azure VMs/App Services):**\n```bash\n# No additional setup needed - runs automatically\npython azure_blob_list.py mystorageaccount\n```\n\n## Required Azure Permissions\n\nThe authenticated identity needs one of these roles:\n- **Storage Blob Data Reader** (minimum)\n- **Storage Blob Data Contributor**\n- **Storage Blob Data Owner**\n\nAssign role using Azure CLI:\n```bash\naz role assignment create \\\n    --role \"Storage Blob Data Reader\" \\\n    --assignee <user-email-or-service-principal-id> \\\n    --scope /subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.Storage/storageAccounts/<storage-account>\n```\n\n## Enhanced Version with Additional Features\n\nHere's an extended version with more functionality:\n\n```python\n#!/usr/bin/env python3\n\"\"\"Enhanced version with blob listing and filtering capabilities.\"\"\"\n\nimport sys\nfrom datetime import datetime, timedelta\nfrom azure.identity import DefaultAzureCredential\nfrom azure.storage.blob import BlobServiceClient\nfrom azure.core.exceptions import AzureError\n\n\ndef list_blobs_in_container(blob_service_client: BlobServiceClient, \n                            container_name: str, \n                            max_results: int = 10) -> None:\n    \"\"\"List blobs in a specific container.\"\"\"\n    try:\n        container_client = blob_service_client.get_container_client(container_name)\n        \n        print(f\"\\nBlobs in container '{container_name}' (showing first {max_results}):\")\n        print(\"-\" * 60)\n        \n        blob_list = container_client.list_blobs()\n        \n        for idx, blob in enumerate(blob_list, 1):\n            if idx > max_results:\n                print(f\"... and more (showing first {max_results} only)\")\n                break\n                \n            size_mb = blob.size / (1024 * 1024)\n            print(f\"{idx}. {blob.name}\")\n            print(f\"   Size: {size_mb:.2f} MB\")\n            print(f\"   Last Modified: {blob.last_modified}\")\n            print(f\"   Content Type: {blob.content_settings.content_type}\")\n            print()\n            \n    except AzureError as error:\n        print(f\"Error listing blobs: {str(error)}\")\n\n\ndef filter_recent_containers(blob_service_client: BlobServiceClient, \n                             days: int = 7) -> None:\n    \"\"\"Filter containers modified in the last N days.\"\"\"\n    cutoff_date = datetime.now(datetime.timezone.utc) - timedelta(days=days)\n    \n    print(f\"\\nContainers modified in the last {days} days:\")\n    print(\"-\" * 60)\n    \n    recent_containers = [\n        container for container in blob_service_client.list_containers()\n        if container.last_modified > cutoff_date\n    ]\n    \n    if recent_containers:\n        for container in recent_containers:\n            print(f\"- {container.name} (modified: {container.last_modified})\")\n    else:\n        print(f\"No containers modified in the last {days} days.\")\n\n\nif __name__ == \"__main__\":\n    # Example usage of enhanced features\n    if len(sys.argv) > 1:\n        storage_account = sys.argv[1]\n        account_url = f\"https://{storage_account}.blob.core.windows.net\"\n        \n        with DefaultAzureCredential() as credential:\n            client = BlobServiceClient(account_url, credential=credential)\n            \n            # List containers\n            containers = list(client.list_containers())\n            print(f\"Total containers: {len(containers)}\")\n            \n            # Show recent containers\n            filter_recent_containers(client, days=30)\n            \n            # List blobs in first container\n            if containers:\n                list_blobs_in_container(client, containers[0].name)\n```\n\nThis script provides comprehensive error handling, multiple authentication methods, and clear feedback for troubleshooting authentication issues with Azure Blob Storage.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 51,
            "output_tokens": 2798,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Blob Storage Authentication with DefaultAzureCredential\n\nHere's a complete Python script that demonstrates Azure authentication and blob storage operations:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Blob Storage Authentication Example\nDemonstrates using DefaultAzureCredential to authenticate and list containers.\n\"\"\"\n\nimport sys\nimport os\nfrom typing import Optional\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    HttpResponseError,\n    ServiceRequestError\n)\nfrom azure.storage.blob import BlobServiceClient\n\n\ndef list_containers(storage_account_name: str) -> None:\n    \"\"\"\n    Authenticate to Azure and list all containers in a storage account.\n    \n    Args:\n        storage_account_name: Name of the Azure Storage account\n    \"\"\"\n    # Construct the storage account URL\n    account_url = f\"https://{storage_account_name}.blob.core.windows.net\"\n    \n    print(f\"Authenticating to Azure Storage account: {storage_account_name}\")\n    print(f\"Account URL: {account_url}\\n\")\n    \n    try:\n        # Create DefaultAzureCredential\n        # This will try multiple authentication methods in order:\n        # 1. Environment variables (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET)\n        # 2. Managed Identity (if running in Azure)\n        # 3. Azure CLI (if logged in via 'az login')\n        # 4. Azure PowerShell\n        # 5. Interactive browser (if enabled)\n        credential = DefaultAzureCredential()\n        \n        print(\"\u2713 DefaultAzureCredential created successfully\")\n        \n        # Create BlobServiceClient using the credential\n        blob_service_client = BlobServiceClient(\n            account_url=account_url,\n            credential=credential\n        )\n        \n        print(\"\u2713 BlobServiceClient created successfully\\n\")\n        \n        # List all containers\n        print(\"Listing containers:\")\n        print(\"-\" * 60)\n        \n        container_count = 0\n        for container in blob_service_client.list_containers():\n            container_count += 1\n            print(f\"{container_count}. {container.name}\")\n            print(f\"   Last Modified: {container.last_modified}\")\n            print(f\"   Public Access: {container.public_access or 'None'}\")\n            \n            # Optional: List blob count in each container\n            container_client = blob_service_client.get_container_client(container.name)\n            try:\n                blob_count = sum(1 for _ in container_client.list_blobs())\n                print(f\"   Blob Count: {blob_count}\")\n            except Exception as e:\n                print(f\"   Blob Count: Unable to retrieve ({str(e)[:50]})\")\n            \n            print()\n        \n        print(\"-\" * 60)\n        print(f\"\\nTotal containers found: {container_count}\")\n        \n        if container_count == 0:\n            print(\"\\nNote: No containers found in this storage account.\")\n            print(\"You may need to create containers first.\")\n    \n    except ClientAuthenticationError as e:\n        print(\"\\n\u274c Authentication Error:\")\n        print(f\"   {str(e)}\")\n        print(\"\\nPossible solutions:\")\n        print(\"   1. Run 'az login' if using Azure CLI\")\n        print(\"   2. Set environment variables: AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET\")\n        print(\"   3. Enable Managed Identity if running in Azure\")\n        print(\"   4. Ensure your account has proper permissions (Storage Blob Data Reader/Contributor)\")\n        sys.exit(1)\n    \n    except HttpResponseError as e:\n        print(\"\\n\u274c HTTP Error:\")\n        print(f\"   Status Code: {e.status_code}\")\n        print(f\"   Error Code: {e.error.code if hasattr(e, 'error') else 'Unknown'}\")\n        print(f\"   Message: {str(e)}\")\n        \n        if e.status_code == 403:\n            print(\"\\nPermission denied. Ensure you have one of these roles:\")\n            print(\"   - Storage Blob Data Reader (read-only)\")\n            print(\"   - Storage Blob Data Contributor (read/write)\")\n            print(\"   - Storage Blob Data Owner (full access)\")\n        elif e.status_code == 404:\n            print(\"\\nStorage account not found. Verify:\")\n            print(f\"   - Account name is correct: {storage_account_name}\")\n            print(\"   - Account exists in your subscription\")\n        \n        sys.exit(1)\n    \n    except ServiceRequestError as e:\n        print(\"\\n\u274c Network Error:\")\n        print(f\"   {str(e)}\")\n        print(\"\\nCheck your network connection and firewall settings.\")\n        sys.exit(1)\n    \n    except Exception as e:\n        print(f\"\\n\u274c Unexpected Error: {type(e).__name__}\")\n        print(f\"   {str(e)}\")\n        sys.exit(1)\n    \n    finally:\n        # Clean up credential\n        if 'credential' in locals():\n            credential.close()\n\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    # Get storage account name from environment variable or command line\n    storage_account_name = os.getenv(\"AZURE_STORAGE_ACCOUNT\")\n    \n    if len(sys.argv) > 1:\n        storage_account_name = sys.argv[1]\n    \n    if not storage_account_name:\n        print(\"Usage: python script.py <storage-account-name>\")\n        print(\"   Or set AZURE_STORAGE_ACCOUNT environment variable\")\n        print(\"\\nExample:\")\n        print(\"   python script.py mystorageaccount\")\n        print(\"   export AZURE_STORAGE_ACCOUNT=mystorageaccount && python script.py\")\n        sys.exit(1)\n    \n    list_containers(storage_account_name)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Installation Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nazure-identity==1.19.0\nazure-storage-blob==12.23.1\n```\n\nInstall dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n## Usage Examples\n\n### 1. Using Azure CLI Authentication (Local Development)\n\n```bash\n# Login to Azure\naz login\n\n# Run the script\npython script.py mystorageaccount\n```\n\n### 2. Using Environment Variables (Service Principal)\n\n```bash\n# Set environment variables\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\nexport AZURE_STORAGE_ACCOUNT=\"mystorageaccount\"\n\n# Run the script\npython script.py\n```\n\n### 3. Using Managed Identity (Azure VM/App Service)\n\n```bash\n# No authentication needed - automatically uses managed identity\npython script.py mystorageaccount\n```\n\n## Enhanced Version with Additional Features\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nEnhanced Azure Blob Storage Authentication Example\nIncludes container creation, blob operations, and detailed error handling.\n\"\"\"\n\nimport sys\nimport os\nfrom datetime import datetime\nfrom typing import Optional, List\n\nfrom azure.identity import (\n    DefaultAzureCredential,\n    AzureCliCredential,\n    ManagedIdentityCredential,\n    EnvironmentCredential\n)\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    HttpResponseError,\n    ResourceExistsError,\n    ResourceNotFoundError\n)\nfrom azure.storage.blob import (\n    BlobServiceClient,\n    ContainerClient,\n    BlobClient,\n    PublicAccess\n)\n\n\nclass AzureBlobManager:\n    \"\"\"Manages Azure Blob Storage operations with proper authentication.\"\"\"\n    \n    def __init__(self, storage_account_name: str, use_cli_only: bool = False):\n        \"\"\"\n        Initialize the blob manager.\n        \n        Args:\n            storage_account_name: Name of the Azure Storage account\n            use_cli_only: If True, only use Azure CLI credential\n        \"\"\"\n        self.storage_account_name = storage_account_name\n        self.account_url = f\"https://{storage_account_name}.blob.core.windows.net\"\n        self.credential = None\n        self.blob_service_client = None\n        \n        self._authenticate(use_cli_only)\n    \n    def _authenticate(self, use_cli_only: bool) -> None:\n        \"\"\"Authenticate to Azure using appropriate credential.\"\"\"\n        try:\n            if use_cli_only:\n                print(\"Using Azure CLI credential only...\")\n                self.credential = AzureCliCredential()\n            else:\n                print(\"Using DefaultAzureCredential (tries multiple methods)...\")\n                self.credential = DefaultAzureCredential(\n                    exclude_interactive_browser_credential=True  # Disable browser popup\n                )\n            \n            # Create BlobServiceClient\n            self.blob_service_client = BlobServiceClient(\n                account_url=self.account_url,\n                credential=self.credential\n            )\n            \n            # Test authentication by getting account info\n            account_info = self.blob_service_client.get_account_information()\n            print(f\"\u2713 Successfully authenticated to storage account\")\n            print(f\"  Account Kind: {account_info.get('account_kind', 'Unknown')}\")\n            print(f\"  SKU: {account_info.get('sku_name', 'Unknown')}\\n\")\n            \n        except ClientAuthenticationError as e:\n            print(f\"\\n\u274c Authentication failed: {str(e)}\")\n            self._print_auth_help()\n            raise\n        except Exception as e:\n            print(f\"\\n\u274c Failed to initialize: {str(e)}\")\n            raise\n    \n    def _print_auth_help(self) -> None:\n        \"\"\"Print authentication troubleshooting help.\"\"\"\n        print(\"\\n\ud83d\udd27 Authentication Troubleshooting:\")\n        print(\"\\n1. Azure CLI (Recommended for local development):\")\n        print(\"   az login\")\n        print(\"   az account show  # Verify logged in\")\n        \n        print(\"\\n2. Service Principal (CI/CD):\")\n        print(\"   export AZURE_TENANT_ID='your-tenant-id'\")\n        print(\"   export AZURE_CLIENT_ID='your-client-id'\")\n        print(\"   export AZURE_CLIENT_SECRET='your-client-secret'\")\n        \n        print(\"\\n3. Managed Identity (Azure-hosted apps):\")\n        print(\"   - Enable system-assigned or user-assigned managed identity\")\n        print(\"   - Assign 'Storage Blob Data Contributor' role\")\n        \n        print(\"\\n4. Required Azure RBAC Roles:\")\n        print(\"   - Storage Blob Data Reader (read-only)\")\n        print(\"   - Storage Blob Data Contributor (read/write)\")\n        print(\"   - Storage Blob Data Owner (full access)\")\n    \n    def list_containers(self, show_details: bool = True) -> List[str]:\n        \"\"\"\n        List all containers in the storage account.\n        \n        Args:\n            show_details: If True, show detailed information\n            \n        Returns:\n            List of container names\n        \"\"\"\n        print(\"\ud83d\udce6 Listing containers:\")\n        print(\"-\" * 70)\n        \n        container_names = []\n        \n        try:\n            for idx, container in enumerate(self.blob_service_client.list_containers(), 1):\n                container_names.append(container.name)\n                \n                if show_details:\n                    print(f\"\\n{idx}. {container.name}\")\n                    print(f\"   Created: {container.last_modified}\")\n                    print(f\"   Public Access: {container.public_access or 'Private'}\")\n                    \n                    # Get blob count\n                    try:\n                        container_client = self.blob_service_client.get_container_client(\n                            container.name\n                        )\n                        blob_count = sum(1 for _ in container_client.list_blobs())\n                        print(f\"   Blobs: {blob_count}\")\n                    except Exception:\n                        print(f\"   Blobs: Unable to count\")\n                else:\n                    print(f\"{idx}. {container.name}\")\n            \n            print(\"\\n\" + \"-\" * 70)\n            print(f\"Total: {len(container_names)} container(s)\")\n            \n            return container_names\n            \n        except HttpResponseError as e:\n            if e.status_code == 403:\n                print(\"\\n\u274c Permission denied. Required role: Storage Blob Data Reader\")\n            else:\n                print(f\"\\n\u274c Error listing containers: {str(e)}\")\n            raise\n    \n    def create_container(self, container_name: str, \n                        public_access: Optional[PublicAccess] = None) -> bool:\n        \"\"\"\n        Create a new container.\n        \n        Args:\n            container_name: Name of the container to create\n            public_access: Public access level (None, 'blob', or 'container')\n            \n        Returns:\n            True if created, False if already exists\n        \"\"\"\n        try:\n            container_client = self.blob_service_client.create_container(\n                name=container_name,\n                public_access=public_access\n            )\n            print(f\"\u2713 Created container: {container_name}\")\n            return True\n            \n        except ResourceExistsError:\n            print(f\"\u2139 Container already exists: {container_name}\")\n            return False\n        except HttpResponseError as e:\n            if e.status_code == 403:\n                print(f\"\u274c Permission denied. Required role: Storage Blob Data Contributor\")\n            else:\n                print(f\"\u274c Error creating container: {str(e)}\")\n            raise\n    \n    def upload_blob(self, container_name: str, blob_name: str, \n                   data: bytes) -> None:\n        \"\"\"\n        Upload a blob to a container.\n        \n        Args:\n            container_name: Container name\n            blob_name: Blob name\n            data: Blob data as bytes\n        \"\"\"\n        try:\n            blob_client = self.blob_service_client.get_blob_client(\n                container=container_name,\n                blob=blob_name\n            )\n            blob_client.upload_blob(data, overwrite=True)\n            print(f\"\u2713 Uploaded blob: {blob_name} to {container_name}\")\n            \n        except ResourceNotFoundError:\n            print(f\"\u274c Container not found: {container_name}\")\n            raise\n        except HttpResponseError as e:\n            print(f\"\u274c Error uploading blob: {str(e)}\")\n            raise\n    \n    def list_blobs(self, container_name: str) -> List[str]:\n        \"\"\"\n        List all blobs in a container.\n        \n        Args:\n            container_name: Container name\n            \n        Returns:\n            List of blob names\n        \"\"\"\n        try:\n            container_client = self.blob_service_client.get_container_client(\n                container_name\n            )\n            \n            print(f\"\\n\ud83d\udcc4 Blobs in '{container_name}':\")\n            print(\"-\" * 70)\n            \n            blob_names = []\n            for idx, blob in enumerate(container_client.list_blobs(), 1):\n                blob_names.append(blob.name)\n                size_kb = blob.size / 1024\n                print(f\"{idx}. {blob.name}\")\n                print(f\"   Size: {size_kb:.2f} KB\")\n                print(f\"   Modified: {blob.last_modified}\")\n                print(f\"   Content Type: {blob.content_settings.content_type or 'Unknown'}\")\n                print()\n            \n            print(f\"Total: {len(blob_names)} blob(s)\")\n            return blob_names\n            \n        except ResourceNotFoundError:\n            print(f\"\u274c Container not found: {container_name}\")\n            raise\n        except HttpResponseError as e:\n            print(f\"\u274c Error listing blobs: {str(e)}\")\n            raise\n    \n    def close(self) -> None:\n        \"\"\"Clean up resources.\"\"\"\n        if self.credential:\n            self.credential.close()\n\n\ndef main():\n    \"\"\"Main entry point with interactive menu.\"\"\"\n    # Get storage account name\n    storage_account_name = os.getenv(\"AZURE_STORAGE_ACCOUNT\")\n    \n    if len(sys.argv) > 1:\n        ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10828,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Python script that authenticates to Azure using DefaultAzureCredential and lists blob containers with proper error handling.\n\n```python\n\"\"\"Azure Blob Storage container listing using DefaultAzureCredential.\"\"\"\nimport logging\nimport sys\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import ClientAuthenticationError\nfrom azure.storage.blob import BlobServiceClient\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\ndef list_blob_containers(storage_account_name: str) -> None:\n    \"\"\"\n    List all containers in an Azure Storage account using DefaultAzureCredential.\n    \n    Args:\n        storage_account_name: Name of the Azure Storage account\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n        Exception: For other Azure service errors\n    \"\"\"\n    account_url = f\"https://{storage_account_name}.blob.core.windows.net\"\n    \n    try:\n        # Create DefaultAzureCredential\n        # This will try multiple authentication methods in order:\n        # 1. EnvironmentCredential\n        # 2. ManagedIdentityCredential\n        # 3. AzureCliCredential\n        # 4. AzurePowerShellCredential\n        logger.info(\"Initializing DefaultAzureCredential...\")\n        credential = DefaultAzureCredential()\n        \n        # Create BlobServiceClient\n        logger.info(f\"Connecting to storage account: {storage_account_name}\")\n        blob_service_client = BlobServiceClient(\n            account_url=account_url,\n            credential=credential\n        )\n        \n        # List containers\n        logger.info(\"Listing containers...\")\n        containers = blob_service_client.list_containers()\n        \n        container_count = 0\n        for container in containers:\n            container_count += 1\n            logger.info(f\"Container {container_count}: {container.name}\")\n            logger.info(f\"  Last modified: {container.last_modified}\")\n            logger.info(f\"  Public access: {container.public_access or 'None'}\")\n        \n        if container_count == 0:\n            logger.info(\"No containers found in storage account\")\n        else:\n            logger.info(f\"Total containers: {container_count}\")\n            \n    except ClientAuthenticationError as e:\n        logger.error(\"Authentication failed. Ensure you are logged in via Azure CLI or have proper credentials configured.\")\n        logger.error(f\"Error details: {e.message}\")\n        logger.error(\"\\nTo authenticate, try one of these methods:\")\n        logger.error(\"  1. Run 'az login' for Azure CLI authentication\")\n        logger.error(\"  2. Set environment variables: AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_CLIENT_SECRET\")\n        logger.error(\"  3. Use managed identity if running on Azure (App Service, VM, etc.)\")\n        sys.exit(1)\n        \n    except Exception as e:\n        logger.error(f\"An error occurred: {type(e).__name__}\")\n        logger.error(f\"Error details: {str(e)}\")\n        sys.exit(1)\n        \n    finally:\n        # Clean up credential\n        if 'credential' in locals():\n            credential.close()\n            logger.info(\"Credential closed\")\n\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    import os\n    \n    # Get storage account name from environment variable or command line\n    storage_account_name = os.getenv(\"AZURE_STORAGE_ACCOUNT_NAME\")\n    \n    if not storage_account_name:\n        if len(sys.argv) > 1:\n            storage_account_name = sys.argv[1]\n        else:\n            logger.error(\"Storage account name not provided\")\n            logger.error(\"Usage: python list_containers.py <storage-account-name>\")\n            logger.error(\"Or set environment variable: AZURE_STORAGE_ACCOUNT_NAME\")\n            sys.exit(1)\n    \n    logger.info(f\"Starting Azure Blob Storage container listing\")\n    list_blob_containers(storage_account_name)\n    logger.info(\"Script completed successfully\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis script:\n\n\u2705 **Uses DefaultAzureCredential** - Tries multiple auth methods automatically\n\u2705 **Creates BlobServiceClient** - Connects to Azure Blob Storage\n\u2705 **Lists containers** - Iterates through all containers with metadata\n\u2705 **Handles authentication errors** - Catches `ClientAuthenticationError` specifically\n\u2705 **Provides helpful error messages** - Suggests authentication methods\n\u2705 **Proper cleanup** - Closes credential in finally block\n\u2705 **Logging** - Uses Python logging for visibility\n\u2705 **Flexible input** - Accepts storage account name from env var or CLI arg\n\n**Required dependencies** (add to `pyproject.toml`):\n```toml\n[tool.poetry.dependencies]\nazure-identity = \"^1.15.0\"\nazure-storage-blob = \"^12.19.0\"\n```\n\n**Usage:**\n```bash\n# Install dependencies\npoetry add azure-identity azure-storage-blob\n\n# Run with Azure CLI authentication (after 'az login')\npython list_containers.py mystorageaccount\n\n# Or set environment variable\nexport AZURE_STORAGE_ACCOUNT_NAME=mystorageaccount\npython list_containers.py\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11354,
            "output_tokens": 1341,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-identity-java-03",
      "task_type": "similar_syntax",
      "target_language": "java",
      "expected_patterns": [
        "ChainedTokenCredentialBuilder",
        "ManagedIdentityCredentialBuilder",
        "AzureCliCredentialBuilder",
        "addFirst|addLast",
        "\\.build\\(\\)",
        "CosmosClient|cosmosClient"
      ],
      "anti_patterns": [
        "DefaultAzureCredential\\b(?!Builder)",
        "from azure\\.identity",
        "azidentity\\.NewChainedTokenCredential",
        "@azure/identity",
        "ChainedTokenCredential\\.new"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.chainedtokencredentialbuilder",
          "description": "Java ChainedTokenCredentialBuilder API reference - source of new ChainedTokenCredentialBuilder(), addFirst(), addLast(), and build() methods for custom credential chains"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.managedidentitycredentialbuilder",
          "description": "Java ManagedIdentityCredentialBuilder API reference - source of ManagedIdentityCredentialBuilder for production managed identity authentication"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.azureclicredentialbuilder",
          "description": "Java AzureCliCredentialBuilder API reference - source of AzureCliCredentialBuilder for local development authentication"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.cosmos.cosmosclient",
          "description": "Java CosmosClient API reference - source of CosmosClient class for Azure Cosmos DB database operations"
        },
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-identity/azure.identity.chainedtokencredential",
          "description": "Anti-patterns: Python from azure.identity import ChainedTokenCredential pattern"
        },
        {
          "url": "https://pkg.go.dev/github.com/Azure/azure-sdk-for-go/sdk/azidentity",
          "description": "Anti-patterns: Go azidentity.NewChainedTokenCredential function"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Azure Cosmos DB Authentication with ChainedTokenCredential\n\nHere's a complete Java application demonstrating authentication to Azure Cosmos DB using ChainedTokenCredential:\n\n## 1. Maven Dependencies (pom.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>cosmos-chained-auth</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>1.11.1</version>\n        </dependency>\n\n        <!-- Azure Cosmos DB -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-cosmos</artifactId>\n            <version>4.51.0</version>\n        </dependency>\n\n        <!-- SLF4J for logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Main Application\n\n```java\npackage com.example.cosmos;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosClientBuilder;\nimport com.azure.cosmos.CosmosContainer;\nimport com.azure.cosmos.CosmosDatabase;\nimport com.azure.cosmos.models.CosmosQueryRequestOptions;\nimport com.azure.cosmos.util.CosmosPagedIterable;\nimport com.azure.identity.AzureCliCredential;\nimport com.azure.identity.AzureCliCredentialBuilder;\nimport com.azure.identity.ChainedTokenCredential;\nimport com.azure.identity.ChainedTokenCredentialBuilder;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.ManagedIdentityCredential;\nimport com.azure.identity.ManagedIdentityCredentialBuilder;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Azure Cosmos DB application using ChainedTokenCredential for authentication.\n * Supports both production (Managed Identity) and local development (Azure CLI).\n */\npublic class CosmosChainedAuthApp {\n    \n    private static final Logger logger = LoggerFactory.getLogger(CosmosChainedAuthApp.class);\n    \n    // Configuration - Replace with your values\n    private static final String COSMOS_ENDPOINT = \"https://your-cosmos-account.documents.azure.com:443/\";\n    private static final String DATABASE_NAME = \"SampleDB\";\n    private static final String CONTAINER_NAME = \"SampleContainer\";\n    \n    public static void main(String[] args) {\n        CosmosChainedAuthApp app = new CosmosChainedAuthApp();\n        \n        try {\n            // Create chained credential\n            ChainedTokenCredential credential = app.createChainedCredential();\n            \n            // Test credential before using it\n            if (!app.testCredential(credential)) {\n                logger.error(\"No credential in the chain could authenticate successfully\");\n                System.exit(1);\n            }\n            \n            // Create Cosmos client\n            CosmosClient client = app.createCosmosClient(credential);\n            \n            // Perform operations\n            app.performCosmosOperations(client);\n            \n            // Cleanup\n            client.close();\n            logger.info(\"Application completed successfully\");\n            \n        } catch (Exception e) {\n            logger.error(\"Application failed with error: {}\", e.getMessage(), e);\n            System.exit(1);\n        }\n    }\n    \n    /**\n     * Creates a ChainedTokenCredential combining ManagedIdentityCredential and AzureCliCredential.\n     * The chain tries credentials in order until one succeeds.\n     */\n    public ChainedTokenCredential createChainedCredential() {\n        logger.info(\"Creating ChainedTokenCredential...\");\n        \n        // Build ManagedIdentityCredential (for production on Azure)\n        ManagedIdentityCredential managedIdentityCredential = new ManagedIdentityCredentialBuilder()\n                .maxRetry(2)\n                .build();\n        \n        // Build AzureCliCredential (for local development)\n        AzureCliCredential azureCliCredential = new AzureCliCredentialBuilder()\n                .build();\n        \n        // Chain the credentials - order matters!\n        // ManagedIdentity first (production), then AzureCli (local dev)\n        ChainedTokenCredential chainedCredential = new ChainedTokenCredentialBuilder()\n                .addLast(managedIdentityCredential)\n                .addLast(azureCliCredential)\n                .build();\n        \n        logger.info(\"ChainedTokenCredential created with ManagedIdentity and AzureCli\");\n        return chainedCredential;\n    }\n    \n    /**\n     * Tests if the credential can successfully authenticate.\n     * This helps catch authentication issues early.\n     */\n    public boolean testCredential(ChainedTokenCredential credential) {\n        logger.info(\"Testing credential authentication...\");\n        \n        try {\n            // Request a token for Azure Cosmos DB scope\n            String scope = \"https://cosmos.azure.com/.default\";\n            var tokenRequest = new com.azure.core.credential.TokenRequestContext()\n                    .addScopes(scope);\n            \n            var token = credential.getToken(tokenRequest).block();\n            \n            if (token != null && token.getToken() != null) {\n                logger.info(\"Credential authentication successful\");\n                logger.debug(\"Token expires at: {}\", token.getExpiresAt());\n                return true;\n            } else {\n                logger.error(\"Credential returned null token\");\n                return false;\n            }\n            \n        } catch (CredentialUnavailableException e) {\n            logger.error(\"No credential in the chain is available: {}\", e.getMessage());\n            logger.error(\"Ensure you're either:\");\n            logger.error(\"  1. Running on Azure with Managed Identity enabled, OR\");\n            logger.error(\"  2. Logged in via Azure CLI (run 'az login')\");\n            return false;\n            \n        } catch (Exception e) {\n            logger.error(\"Credential test failed: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n    \n    /**\n     * Creates a CosmosClient using the ChainedTokenCredential.\n     */\n    public CosmosClient createCosmosClient(ChainedTokenCredential credential) {\n        logger.info(\"Creating Cosmos DB client...\");\n        \n        try {\n            CosmosClient client = new CosmosClientBuilder()\n                    .endpoint(COSMOS_ENDPOINT)\n                    .credential(credential)\n                    .consistencyLevel(com.azure.cosmos.ConsistencyLevel.SESSION)\n                    .contentResponseOnWriteEnabled(true)\n                    .buildClient();\n            \n            logger.info(\"Cosmos DB client created successfully\");\n            return client;\n            \n        } catch (Exception e) {\n            logger.error(\"Failed to create Cosmos DB client: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Could not create Cosmos DB client\", e);\n        }\n    }\n    \n    /**\n     * Performs basic Cosmos DB operations to demonstrate the authentication.\n     */\n    public void performCosmosOperations(CosmosClient client) {\n        logger.info(\"Starting Cosmos DB operations...\");\n        \n        try {\n            // Get database\n            CosmosDatabase database = client.getDatabase(DATABASE_NAME);\n            logger.info(\"Connected to database: {}\", DATABASE_NAME);\n            \n            // Get container\n            CosmosContainer container = database.getContainer(CONTAINER_NAME);\n            logger.info(\"Connected to container: {}\", CONTAINER_NAME);\n            \n            // Perform a simple query\n            String query = \"SELECT * FROM c\";\n            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n            \n            logger.info(\"Executing query: {}\", query);\n            CosmosPagedIterable<SampleItem> items = container.queryItems(\n                    query, \n                    options, \n                    SampleItem.class\n            );\n            \n            // Process results\n            List<SampleItem> results = new ArrayList<>();\n            int count = 0;\n            \n            for (SampleItem item : items) {\n                results.add(item);\n                count++;\n                logger.info(\"Retrieved item: id={}, name={}\", item.getId(), item.getName());\n                \n                // Limit output for demo purposes\n                if (count >= 10) {\n                    logger.info(\"Limiting output to first 10 items...\");\n                    break;\n                }\n            }\n            \n            logger.info(\"Query completed. Total items retrieved: {}\", count);\n            \n            if (count == 0) {\n                logger.warn(\"No items found in container. Container might be empty.\");\n            }\n            \n        } catch (com.azure.cosmos.CosmosException e) {\n            logger.error(\"Cosmos DB operation failed with status code {}: {}\", \n                    e.getStatusCode(), e.getMessage());\n            \n            if (e.getStatusCode() == 403) {\n                logger.error(\"Access denied. Ensure the identity has proper RBAC roles:\");\n                logger.error(\"  - Cosmos DB Built-in Data Reader (for read operations)\");\n                logger.error(\"  - Cosmos DB Built-in Data Contributor (for write operations)\");\n            }\n            \n            throw e;\n            \n        } catch (Exception e) {\n            logger.error(\"Unexpected error during Cosmos DB operations: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Cosmos DB operations failed\", e);\n        }\n    }\n    \n    /**\n     * Sample POJO class for Cosmos DB items.\n     */\n    public static class SampleItem {\n        @JsonProperty(\"id\")\n        private String id;\n        \n        @JsonProperty(\"name\")\n        private String name;\n        \n        @JsonProperty(\"description\")\n        private String description;\n        \n        @JsonProperty(\"category\")\n        private String category;\n        \n        // Constructors\n        public SampleItem() {\n        }\n        \n        public SampleItem(String id, String name, String description, String category) {\n            this.id = id;\n            this.name = name;\n            this.description = description;\n            this.category = category;\n        }\n        \n        // Getters and Setters\n        public String getId() {\n            return id;\n        }\n        \n        public void setId(String id) {\n            this.id = id;\n        }\n        \n        public String getName() {\n            return name;\n        }\n        \n        public void setName(String name) {\n            this.name = name;\n        }\n        \n        public String getDescription() {\n            return description;\n        }\n        \n        public void setDescription(String description) {\n            this.description = description;\n        }\n        \n        public String getCategory() {\n            return category;\n        }\n        \n        public void setCategory(String category) {\n            this.category = category;\n        }\n        \n        @Override\n        public String toString() {\n            return \"SampleItem{\" +\n                    \"id='\" + id + '\\'' +\n                    \", name='\" + name + '\\'' +\n                    \", description='\" + description + '\\'' +\n                    \", category='\" + category + '\\'' +\n                    '}';\n        }\n    }\n}\n```\n\n## 3. Configuration File (application.properties)\n\n```properties\n# Azure Cosmos DB Configuration\ncosmos.endpoint=https://your-cosmos-account.documents.azure.com:443/\ncosmos.database=SampleDB\ncosmos.container=SampleContainer\n\n# Logging Configuration\nlogging.level.com.azure=INFO\nlogging.level.com.example=DEBUG\n```\n\n## 4. Enhanced Version with Configuration Management\n\n```java\npackage com.example.cosmos;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.identity.ChainedTokenCredential;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\n/**\n * Configuration-driven version of the Cosmos DB application.\n */\npublic class CosmosChainedAuthAppConfigurable {\n    \n    private static final Logger logger = LoggerFactory.getLogger(CosmosChainedAuthAppConfigurable.class);\n    \n    private final String cosmosEndpoint;\n    private final String databaseName;\n    private final String containerName;\n    \n    public CosmosChainedAuthAppConfigurable() {\n        Properties props = loadConfiguration();\n        this.cosmosEndpoint = props.getProperty(\"cosmos.endpoint\");\n        this.databaseName = props.getProperty(\"cosmos.database\");\n        this.containerName = props.getProperty(\"cosmos.container\");\n        \n        validateConfiguration();\n    }\n    \n    private Properties loadConfiguration() {\n        Properties props = new Properties();\n        \n        // Try to load from classpath\n        try (InputStream input = getClass().getClassLoader()\n                .getResourceAsStream(\"application.properties\")) {\n            \n            if (input != null) {\n                props.load(input);\n                logger.info(\"Configuration loaded from application.properties\");\n            } else {\n                logger.warn(\"application.properties not found, using environment variables\");\n            }\n        } catch (IOException e) {\n            logger.warn(\"Error loading application.properties: {}\", e.getMessage());\n        }\n        \n        // Override with environment variables if present\n        String envEndpoint = System.getenv(\"COSMOS_ENDPOINT\");\n        if (envEndpoint != null) {\n            props.setProperty(\"cosmos.endpoint\", envEndpoint);\n        }\n        \n        String envDatabase = System.getenv(\"COSMOS_DATABASE\");\n        if (envDatabase != null) {\n            props.setProperty(\"cosmos.database\", envDatabase);\n        }\n        \n        String envContainer = System.getenv(\"COSMOS_CONTAINER\");\n        if (envContainer != null) {\n            props.setProperty(\"cosmos.container\", envContainer);\n        }\n        \n        return props;\n    }\n    \n    private void validateConfiguration() {\n        if (cosmosEndpoint == null || cosmosEndpoint.isEmpty()) {\n            throw new IllegalStateException(\"Cosmos DB endpoint is not configured\");\n        }\n        if (databaseName == null || databaseName.isEmpty()) {\n            throw new IllegalStateException(\"Database name is not configured\");\n        }\n        if (containerName == null || containerName.isEmpty()) {\n            throw new IllegalStateException(\"Container name is not configured\");\n        }\n        \n        logger.info(\"Configuration validated successfully\");\n        logger.debug(\"Endpoint: {}\", cosmosEndpoint);\n        logger.debug(\"Database: {}\", databaseName);\n        logger.debug(\"Container: {}\", containerName);\n    }\n    \n    public void run() {\n        CosmosChainedAuthApp app = new CosmosChainedAuthApp();\n        \n        try {\n            ChainedTokenCredential credential = app.createChainedCredential();\n            \n            if (!app.testCredential",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 73,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Identity ChainedTokenCredential with Cosmos DB\n\nI'll create a complete Java application that demonstrates using ChainedTokenCredential with ManagedIdentityCredential and AzureCliCredential to authenticate to Azure Cosmos DB.\n\n## Project Structure\n\n```\ncosmos-identity-demo/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 identity/\n\u2502       \u2502               \u2514\u2500\u2500 demo/\n\u2502       \u2502                   \u251c\u2500\u2500 CosmosDbApp.java\n\u2502       \u2502                   \u251c\u2500\u2500 CredentialManager.java\n\u2502       \u2502                   \u251c\u2500\u2500 CosmosDbService.java\n\u2502       \u2502                   \u2514\u2500\u2500 model/\n\u2502       \u2502                       \u2514\u2500\u2500 Product.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u2514\u2500\u2500 application.properties\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.identity.demo</groupId>\n    <artifactId>cosmos-identity-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Identity ChainedTokenCredential Demo</name>\n    <description>Demo of ChainedTokenCredential with Cosmos DB</description>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <azure.sdk.version>1.2.29</azure.sdk.version>\n    </properties>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.azure</groupId>\n                <artifactId>azure-sdk-bom</artifactId>\n                <version>${azure.sdk.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n        </dependency>\n\n        <!-- Azure Cosmos DB -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-cosmos</artifactId>\n        </dependency>\n\n        <!-- SLF4J for logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n\n        <!-- Jackson for JSON -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.15.3</version>\n        </dependency>\n\n        <!-- JUnit for testing -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.10.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.identity.demo.CosmosDbApp</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## CredentialManager.java\n\n```java\npackage com.azure.identity.demo;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.identity.AzureCliCredential;\nimport com.azure.identity.AzureCliCredentialBuilder;\nimport com.azure.identity.ChainedTokenCredential;\nimport com.azure.identity.ChainedTokenCredentialBuilder;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.ManagedIdentityCredential;\nimport com.azure.identity.ManagedIdentityCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Manages credential creation with a chain of ManagedIdentity and AzureCli credentials.\n * This allows the application to work both in Azure (production) and locally (development).\n */\npublic class CredentialManager {\n    private static final Logger logger = LoggerFactory.getLogger(CredentialManager.class);\n    \n    private final String managedIdentityClientId;\n    \n    /**\n     * Creates a CredentialManager.\n     * \n     * @param managedIdentityClientId Optional client ID for user-assigned managed identity.\n     *                                Pass null for system-assigned managed identity.\n     */\n    public CredentialManager(String managedIdentityClientId) {\n        this.managedIdentityClientId = managedIdentityClientId;\n    }\n    \n    /**\n     * Creates a ChainedTokenCredential that tries:\n     * 1. ManagedIdentityCredential (for Azure production environments)\n     * 2. AzureCliCredential (for local development with 'az login')\n     * \n     * @return ChainedTokenCredential configured for production and development\n     */\n    public ChainedTokenCredential createCredential() {\n        logger.info(\"Creating ChainedTokenCredential...\");\n        \n        // Create ManagedIdentityCredential\n        ManagedIdentityCredential managedIdentityCredential = createManagedIdentityCredential();\n        \n        // Create AzureCliCredential\n        AzureCliCredential azureCliCredential = createAzureCliCredential();\n        \n        // Chain them together - ManagedIdentity first (for production), then AzureCli (for dev)\n        ChainedTokenCredential chainedCredential = new ChainedTokenCredentialBuilder()\n            .addFirst(managedIdentityCredential)\n            .addLast(azureCliCredential)\n            .build();\n        \n        logger.info(\"ChainedTokenCredential created successfully\");\n        logger.info(\"Authentication will try: 1) Managed Identity, 2) Azure CLI\");\n        \n        return chainedCredential;\n    }\n    \n    /**\n     * Creates a ManagedIdentityCredential.\n     * Supports both system-assigned and user-assigned managed identities.\n     */\n    private ManagedIdentityCredential createManagedIdentityCredential() {\n        ManagedIdentityCredentialBuilder builder = new ManagedIdentityCredentialBuilder();\n        \n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            logger.info(\"Configuring user-assigned managed identity with client ID: {}\", \n                       maskClientId(managedIdentityClientId));\n            builder.clientId(managedIdentityClientId);\n        } else {\n            logger.info(\"Configuring system-assigned managed identity\");\n        }\n        \n        return builder.build();\n    }\n    \n    /**\n     * Creates an AzureCliCredential for local development.\n     * Requires 'az login' to be run first.\n     */\n    private AzureCliCredential createAzureCliCredential() {\n        logger.info(\"Configuring Azure CLI credential for local development\");\n        return new AzureCliCredentialBuilder().build();\n    }\n    \n    /**\n     * Tests if the credential chain can successfully authenticate.\n     * \n     * @param credential The credential to test\n     * @return true if authentication succeeds, false otherwise\n     */\n    public boolean testCredential(TokenCredential credential) {\n        logger.info(\"Testing credential authentication...\");\n        \n        try {\n            // Try to get a token for Azure Resource Manager\n            // This is a lightweight test that doesn't require specific resource access\n            var tokenRequestContext = new com.azure.core.credential.TokenRequestContext()\n                .addScopes(\"https://management.azure.com/.default\");\n            \n            var token = credential.getToken(tokenRequestContext).block();\n            \n            if (token != null) {\n                logger.info(\"\u2713 Authentication successful!\");\n                logger.info(\"Token expires at: {}\", token.getExpiresAt());\n                return true;\n            } else {\n                logger.error(\"\u2717 Authentication failed: No token received\");\n                return false;\n            }\n            \n        } catch (CredentialUnavailableException e) {\n            logger.error(\"\u2717 No credential in the chain could authenticate\");\n            logger.error(\"Details: {}\", e.getMessage());\n            logTroubleshootingSteps();\n            return false;\n            \n        } catch (Exception e) {\n            logger.error(\"\u2717 Authentication error: {}\", e.getMessage());\n            logger.error(\"Error type: {}\", e.getClass().getSimpleName());\n            return false;\n        }\n    }\n    \n    /**\n     * Logs troubleshooting steps when authentication fails.\n     */\n    private void logTroubleshootingSteps() {\n        logger.info(\"\");\n        logger.info(\"=== Troubleshooting Steps ===\");\n        logger.info(\"1. For local development:\");\n        logger.info(\"   - Run 'az login' to authenticate with Azure CLI\");\n        logger.info(\"   - Verify with 'az account show'\");\n        logger.info(\"\");\n        logger.info(\"2. For Azure production environments:\");\n        logger.info(\"   - Ensure managed identity is enabled on the resource\");\n        logger.info(\"   - Verify the managed identity has required permissions\");\n        logger.info(\"   - Check if AZURE_CLIENT_ID is set for user-assigned identity\");\n        logger.info(\"\");\n        logger.info(\"3. Check network connectivity to Azure endpoints\");\n        logger.info(\"4. Review application logs for detailed error messages\");\n        logger.info(\"=============================\");\n        logger.info(\"\");\n    }\n    \n    /**\n     * Masks a client ID for logging (shows first 8 and last 4 characters).\n     */\n    private String maskClientId(String clientId) {\n        if (clientId == null || clientId.length() < 12) {\n            return \"****\";\n        }\n        return clientId.substring(0, 8) + \"****\" + clientId.substring(clientId.length() - 4);\n    }\n}\n```\n\n## Product.java\n\n```java\npackage com.azure.identity.demo.model;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Represents a product in the Cosmos DB database.\n */\npublic class Product {\n    @JsonProperty(\"id\")\n    private String id;\n    \n    @JsonProperty(\"name\")\n    private String name;\n    \n    @JsonProperty(\"category\")\n    private String category;\n    \n    @JsonProperty(\"price\")\n    private double price;\n    \n    @JsonProperty(\"description\")\n    private String description;\n    \n    // Default constructor for Jackson\n    public Product() {\n    }\n    \n    public Product(String id, String name, String category, double price, String description) {\n        this.id = id;\n        this.name = name;\n        this.category = category;\n        this.price = price;\n        this.description = description;\n    }\n    \n    // Getters and setters\n    public String getId() {\n        return id;\n    }\n    \n    public void setId(String id) {\n        this.id = id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public String getCategory() {\n        return category;\n    }\n    \n    public void setCategory(String category) {\n        this.category = category;\n    }\n    \n    public double getPrice() {\n        return price;\n    }\n    \n    public void setPrice(double price) {\n        this.price = price;\n    }\n    \n    public String getDescription() {\n        return description;\n    }\n    \n    public void setDescription(String description) {\n        this.description = description;\n    }\n    \n    @Override\n    public String toString() {\n        return String.format(\"Product{id='%s', name='%s', category='%s', price=%.2f, description='%s'}\",\n                           id, name, category, price, description);\n    }\n}\n```\n\n## CosmosDbService.java\n\n```java\npackage com.azure.identity.demo;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.cosmos.ConsistencyLevel;\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosClientBuilder;\nimport com.azure.cosmos.CosmosContainer;\nimport com.azure.cosmos.CosmosDatabase;\nimport com.azure.cosmos.models.CosmosItemRequestOptions;\nimport com.azure.cosmos.models.CosmosItemResponse;\nimport com.azure.cosmos.models.CosmosQueryRequestOptions;\nimport com.azure.cosmos.models.PartitionKey;\nimport com.azure.cosmos.util.CosmosPagedIterable;\nimport com.azure.identity.demo.model.Product;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Service class for interacting with Azure Cosmos DB.\n */\npublic class CosmosDbService implements AutoCloseable {\n    private static final Logger logger = LoggerFactory.getLogger(CosmosDbService.class);\n    \n    private final CosmosClient client;\n    private final String databaseName;\n    private final String containerName;\n    \n    /**\n     * Creates a CosmosDbService with the specified credential and configuration.\n     * \n     * @param credential The TokenCredential to use for authentication\n     * @param endpoint The Cosmos DB endpoint URL\n     * @param databaseName The database name\n     * @param containerName The container name\n     */\n    public CosmosDbService(TokenCredential credential, String endpoint, \n                          String databaseName, String containerName) {\n        logger.info(\"Initializing Cosmos DB client...\");\n        logger.info(\"Endpoint: {}\", endpoint);\n        logger.info(\"Database: {}\", databaseName);\n        logger.info(\"Container: {}\", containerName);\n        \n        this.databaseName = databaseName;\n        this.containerName = containerName;\n        \n        ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10850,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses ChainedTokenCredential for Azure Cosmos DB authentication with proper error handling.\n\n```java\npackage com.example.app.config;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosClientBuilder;\nimport com.azure.identity.AzureCliCredential;\nimport com.azure.identity.AzureCliCredentialBuilder;\nimport com.azure.identity.ChainedTokenCredential;\nimport com.azure.identity.ChainedTokenCredentialBuilder;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.ManagedIdentityCredential;\nimport com.azure.identity.ManagedIdentityCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class CosmosDbConfig {\n    private static final Logger log = LoggerFactory.getLogger(CosmosDbConfig.class);\n\n    @Value(\"${azure.cosmos.endpoint}\")\n    private String cosmosEndpoint;\n\n    @Value(\"${azure.cosmos.managed-identity-client-id:#{null}}\")\n    private String managedIdentityClientId;\n\n    @Bean\n    public ChainedTokenCredential azureCredential() {\n        log.info(\"Creating ChainedTokenCredential for Azure authentication\");\n\n        // First credential: ManagedIdentityCredential (for production on Azure)\n        ManagedIdentityCredentialBuilder miBuilder = new ManagedIdentityCredentialBuilder();\n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            log.info(\"Configuring user-assigned managed identity with client ID\");\n            miBuilder.clientId(managedIdentityClientId);\n        } else {\n            log.info(\"Using system-assigned managed identity\");\n        }\n        ManagedIdentityCredential managedIdentityCredential = miBuilder.build();\n\n        // Second credential: AzureCliCredential (for local development)\n        AzureCliCredential azureCliCredential = new AzureCliCredentialBuilder()\n            .build();\n\n        // Chain credentials: try ManagedIdentity first, then AzureCli\n        ChainedTokenCredential credential = new ChainedTokenCredentialBuilder()\n            .addFirst(managedIdentityCredential)\n            .addLast(azureCliCredential)\n            .build();\n\n        log.info(\"ChainedTokenCredential created successfully\");\n        return credential;\n    }\n\n    @Bean\n    public CosmosClient cosmosClient(ChainedTokenCredential credential) {\n        try {\n            log.info(\"Creating Cosmos DB client with endpoint: {}\", cosmosEndpoint);\n            \n            CosmosClient client = new CosmosClientBuilder()\n                .endpoint(cosmosEndpoint)\n                .credential(credential)\n                .buildClient();\n\n            log.info(\"Cosmos DB client created successfully\");\n            return client;\n\n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential in the chain could authenticate. \" +\n                     \"Ensure you're either running on Azure with Managed Identity \" +\n                     \"or logged in via 'az login' for local development.\", e);\n            throw new IllegalStateException(\n                \"Failed to authenticate to Azure. No valid credential found.\", e);\n        } catch (Exception e) {\n            log.error(\"Failed to create Cosmos DB client\", e);\n            throw new IllegalStateException(\"Failed to initialize Cosmos DB client\", e);\n        }\n    }\n}\n```\n\n```java\npackage com.example.app.service;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosContainer;\nimport com.azure.cosmos.CosmosDatabase;\nimport com.azure.cosmos.models.CosmosQueryRequestOptions;\nimport com.azure.cosmos.util.CosmosPagedIterable;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n@Service\npublic class CosmosDbService {\n    private static final Logger log = LoggerFactory.getLogger(CosmosDbService.class);\n\n    private final CosmosClient cosmosClient;\n\n    @Value(\"${azure.cosmos.database-name}\")\n    private String databaseName;\n\n    @Value(\"${azure.cosmos.container-name}\")\n    private String containerName;\n\n    public CosmosDbService(CosmosClient cosmosClient) {\n        this.cosmosClient = cosmosClient;\n    }\n\n    /**\n     * Performs a basic query on the Cosmos DB container.\n     * Handles authentication failures gracefully.\n     */\n    public List<Map<String, Object>> queryItems(String query) {\n        try {\n            log.info(\"Executing Cosmos DB query: {}\", query);\n\n            CosmosDatabase database = cosmosClient.getDatabase(databaseName);\n            CosmosContainer container = database.getContainer(containerName);\n\n            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n            \n            CosmosPagedIterable<Map> results = container.queryItems(\n                query,\n                options,\n                Map.class\n            );\n\n            List<Map<String, Object>> items = new ArrayList<>();\n            results.forEach(item -> {\n                @SuppressWarnings(\"unchecked\")\n                Map<String, Object> typedItem = (Map<String, Object>) item;\n                items.add(typedItem);\n            });\n\n            log.info(\"Query returned {} items\", items.size());\n            return items;\n\n        } catch (CredentialUnavailableException e) {\n            log.error(\"Authentication failed: No credential in the chain could authenticate. \" +\n                     \"If running locally, ensure you're logged in via 'az login'. \" +\n                     \"If running on Azure, verify Managed Identity is configured.\", e);\n            throw new IllegalStateException(\n                \"Failed to authenticate to Cosmos DB. No valid credential available.\", e);\n\n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed: Invalid credentials or insufficient permissions. \" +\n                     \"Verify the identity has 'Cosmos DB Built-in Data Reader' role.\", e);\n            throw new IllegalStateException(\n                \"Authentication to Cosmos DB failed. Check credentials and permissions.\", e);\n\n        } catch (Exception e) {\n            log.error(\"Failed to execute Cosmos DB query\", e);\n            throw new RuntimeException(\"Error querying Cosmos DB\", e);\n        }\n    }\n\n    /**\n     * Retrieves all items from the container (with limit for safety).\n     */\n    public List<Map<String, Object>> getAllItems(int maxItems) {\n        String query = String.format(\"SELECT TOP %d * FROM c\", maxItems);\n        return queryItems(query);\n    }\n\n    /**\n     * Retrieves an item by ID.\n     */\n    public Map<String, Object> getItemById(String id) {\n        String query = String.format(\"SELECT * FROM c WHERE c.id = '%s'\", id);\n        List<Map<String, Object>> results = queryItems(query);\n        \n        if (results.isEmpty()) {\n            log.warn(\"No item found with id: {}\", id);\n            return null;\n        }\n        \n        return results.get(0);\n    }\n\n    /**\n     * Tests the connection and authentication.\n     */\n    public boolean testConnection() {\n        try {\n            log.info(\"Testing Cosmos DB connection...\");\n            \n            CosmosDatabase database = cosmosClient.getDatabase(databaseName);\n            database.read(); // This will fail if authentication doesn't work\n            \n            log.info(\"Cosmos DB connection test successful\");\n            return true;\n\n        } catch (CredentialUnavailableException e) {\n            log.error(\"Connection test failed: No credential could authenticate\", e);\n            return false;\n\n        } catch (ClientAuthenticationException e) {\n            log.error(\"Connection test failed: Authentication error\", e);\n            return false;\n\n        } catch (Exception e) {\n            log.error(\"Connection test failed\", e);\n            return false;\n        }\n    }\n}\n```\n\n```java\npackage com.example.app.controller;\n\nimport com.example.app.service.CosmosDbService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/api/cosmos\")\npublic class CosmosDbController {\n    private static final Logger log = LoggerFactory.getLogger(CosmosDbController.class);\n\n    private final CosmosDbService cosmosDbService;\n\n    public CosmosDbController(CosmosDbService cosmosDbService) {\n        this.cosmosDbService = cosmosDbService;\n    }\n\n    @GetMapping(\"/test\")\n    public ResponseEntity<Map<String, Object>> testConnection() {\n        log.info(\"Testing Cosmos DB connection\");\n        \n        boolean success = cosmosDbService.testConnection();\n        \n        if (success) {\n            return ResponseEntity.ok(Map.of(\n                \"status\", \"success\",\n                \"message\", \"Successfully authenticated to Cosmos DB\"\n            ));\n        } else {\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of(\n                \"status\", \"error\",\n                \"message\", \"Failed to authenticate. Check logs for details.\"\n            ));\n        }\n    }\n\n    @GetMapping(\"/items\")\n    public ResponseEntity<?> getAllItems(\n            @RequestParam(defaultValue = \"100\") int limit) {\n        try {\n            log.info(\"Fetching up to {} items from Cosmos DB\", limit);\n            List<Map<String, Object>> items = cosmosDbService.getAllItems(limit);\n            \n            return ResponseEntity.ok(Map.of(\n                \"count\", items.size(),\n                \"items\", items\n            ));\n\n        } catch (IllegalStateException e) {\n            log.error(\"Authentication error\", e);\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of(\n                \"error\", \"Authentication failed\",\n                \"message\", e.getMessage()\n            ));\n\n        } catch (Exception e) {\n            log.error(\"Error fetching items\", e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(\n                \"error\", \"Internal server error\",\n                \"message\", e.getMessage()\n            ));\n        }\n    }\n\n    @GetMapping(\"/items/{id}\")\n    public ResponseEntity<?> getItemById(@PathVariable String id) {\n        try {\n            log.info(\"Fetching item with id: {}\", id);\n            Map<String, Object> item = cosmosDbService.getItemById(id);\n            \n            if (item == null) {\n                return ResponseEntity.notFound().build();\n            }\n            \n            return ResponseEntity.ok(item);\n\n        } catch (IllegalStateException e) {\n            log.error(\"Authentication error\", e);\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of(\n                \"error\", \"Authentication failed\",\n                \"message\", e.getMessage()\n            ));\n\n        } catch (Exception e) {\n            log.error(\"Error fetching item\", e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(\n                \"error\", \"Internal server error\",\n                \"message\", e.getMessage()\n            ));\n        }\n    }\n\n    @PostMapping(\"/query\")\n    public ResponseEntity<?> executeQuery(@RequestBody Map<String, String> request) {\n        try {\n            String query = request.get(\"query\");\n            if (query == null || query.isEmpty()) {\n                return ResponseEntity.badRequest().body(Map.of(\n                    \"error\", \"Missing query parameter\"\n                ));\n            }\n\n            log.info(\"Executing custom query\");\n            List<Map<String, Object>> results = cosmosDbService.queryItems(query);\n            \n            return ResponseEntity.ok(Map.of(\n                \"count\", results.size(),\n                \"results\", results\n            ));\n\n        } catch (IllegalStateException e) {\n            log.error(\"Authentication error\", e);\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of(\n                \"error\", \"Authentication failed\",\n                \"message\", e.getMessage()\n            ));\n\n        } catch (Exception e) {\n            log.error(\"Error executing query\", e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(\n                \"error\", \"Internal server error\",\n                \"message\", e.getMessage()\n            ));\n        }\n    }\n}\n```\n\n```properties\n# src/main/resources/application.properties\n\n# Azure Cosmos DB Configuration\nazure.cosmos.endpoint=https://your-cosmos-account.documents.azure.com:443/\nazure.cosmos.database-name=your-database-name\nazure.cosmos.container-name=your-container-name\n\n# Optional: User-assigned Managed Identity Client ID\n# Leave empty for system-assigned managed identity\nazure.cosmos.managed-identity-client-id=\n\n# Logging\nlogging.level.com.example.app=INFO\nlogging.level.com.azure.identity=DEBUG\nlogging.level.com.azure.cosmos=INFO\n```\n\n```xml\n<!-- Add to pom.xml -->\n<dependencies>\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.18.2</version>\n    </dependency>\n\n    <!-- Azure Cosmos DB -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-cosmos</artifactId>\n        <version>4.53.0</version>\n    </dependency>\n</dependencies>\n```\n\n```java\npackage com.example.app;\n\nimport com.example.app.service.CosmosDbService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\n\nimport java.util.List;\nimport java.util.Map;\n\n@SpringBootApplication\npublic class Application {\n    private static final Logger log = LoggerFactory.getLogger(Application.class);\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    public CommandLineRunner demo(CosmosDbService cosmosDbService) {\n        return args -> {\n            log.info(\"=== Testing Cosmos DB Authentication ===\");\n            \n            // Test connection\n            boolean connected = cosmosDbService.testConnection();\n            if (!connected) {\n                log.error(\"Failed to connect to Cosmos DB. Check authentication.\");\n                return;\n            }\n\n            // Query items\n            try {\n                log.info(\"Fetching items from Cosmos DB...\");\n                List<Map<String, Object>> items = cosmosDbService.getAllItems(10);\n                log.info(\"Successfully retrieved {} items\", items.size());\n                \n                items.forEach(item -> \n                    log.info(\"Item: {}\", item.get(\"id\"))\n                );\n\n            } catch (Exception e) {\n                log.error(\"Error during demo execution\", e);\n            }\n        };\n    }\n}\n```\n\n## Key Features:\n\n1. **ChainedTokenCredential** - Tries ManagedIdentity first (production), then AzureCli (local dev)\n2. **Proper Error Handling** - Catches `CredentialUnavailableException` and `ClientAuthenticationException`\n3. **Logging** - Detailed logs for troubleshooting authentication issues\n4. **REST API** - Endpoints to test connection and query data\n5. **Configuration** - Externalized settings via application.properties\n\n## Usage:\n\n**Local Development:**\n```bash\n# Login via Azure CLI\naz login\n\n# Run the application\nmvn spring-boot:run\n```\n\n**Production (Azure):**\n- Deploy to Azure App Service, AKS, or VM with Managed Identity enabled\n- Assign \"",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11375,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Azure Cosmos DB Authentication with ChainedTokenCredential\n\nHere's a complete Java application that demonstrates using `ChainedTokenCredential` to authenticate to Azure Cosmos DB:\n\n## 1. Maven Dependencies (pom.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>cosmosdb-chained-auth</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>1.11.1</version>\n        </dependency>\n\n        <!-- Azure Cosmos DB -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-cosmos</artifactId>\n            <version>4.51.0</version>\n        </dependency>\n\n        <!-- SLF4J for logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Main Application\n\n```java\npackage com.example.cosmosdb;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosClientBuilder;\nimport com.azure.cosmos.CosmosContainer;\nimport com.azure.cosmos.CosmosDatabase;\nimport com.azure.cosmos.models.CosmosQueryRequestOptions;\nimport com.azure.cosmos.util.CosmosPagedIterable;\nimport com.azure.identity.AzureCliCredential;\nimport com.azure.identity.AzureCliCredentialBuilder;\nimport com.azure.identity.ChainedTokenCredential;\nimport com.azure.identity.ChainedTokenCredentialBuilder;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.ManagedIdentityCredential;\nimport com.azure.identity.ManagedIdentityCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Azure Cosmos DB application using ChainedTokenCredential for authentication.\n * Supports both production (Managed Identity) and local development (Azure CLI).\n */\npublic class CosmosDbChainedAuthApp {\n    \n    private static final Logger logger = LoggerFactory.getLogger(CosmosDbChainedAuthApp.class);\n    \n    // Configuration - Replace with your values\n    private static final String COSMOS_ENDPOINT = System.getenv(\"COSMOS_ENDPOINT\");\n    private static final String DATABASE_NAME = System.getenv(\"COSMOS_DATABASE_NAME\");\n    private static final String CONTAINER_NAME = System.getenv(\"COSMOS_CONTAINER_NAME\");\n    \n    // Optional: Managed Identity Client ID (if using user-assigned managed identity)\n    private static final String MANAGED_IDENTITY_CLIENT_ID = System.getenv(\"MANAGED_IDENTITY_CLIENT_ID\");\n\n    public static void main(String[] args) {\n        CosmosDbChainedAuthApp app = new CosmosDbChainedAuthApp();\n        \n        try {\n            app.run();\n        } catch (Exception e) {\n            logger.error(\"Application failed with error: {}\", e.getMessage(), e);\n            System.exit(1);\n        }\n    }\n\n    public void run() {\n        // Validate configuration\n        validateConfiguration();\n        \n        // Create chained credential\n        ChainedTokenCredential credential = createChainedCredential();\n        \n        // Test credential before using it\n        if (!testCredential(credential)) {\n            logger.error(\"No credential in the chain could authenticate successfully.\");\n            throw new RuntimeException(\"Authentication failed - no valid credentials available\");\n        }\n        \n        // Create Cosmos DB client\n        CosmosClient client = null;\n        try {\n            client = createCosmosClient(credential);\n            logger.info(\"Successfully created Cosmos DB client\");\n            \n            // Perform database operations\n            performDatabaseOperations(client);\n            \n        } catch (Exception e) {\n            logger.error(\"Error during Cosmos DB operations: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Cosmos DB operation failed\", e);\n        } finally {\n            if (client != null) {\n                client.close();\n                logger.info(\"Cosmos DB client closed\");\n            }\n        }\n    }\n\n    /**\n     * Creates a ChainedTokenCredential with ManagedIdentityCredential and AzureCliCredential.\n     * The order matters - credentials are tried in sequence until one succeeds.\n     */\n    private ChainedTokenCredential createChainedCredential() {\n        logger.info(\"Creating ChainedTokenCredential...\");\n        \n        // Build Managed Identity Credential (for production on Azure)\n        ManagedIdentityCredentialBuilder miBuilder = new ManagedIdentityCredentialBuilder();\n        \n        // If using user-assigned managed identity, specify the client ID\n        if (MANAGED_IDENTITY_CLIENT_ID != null && !MANAGED_IDENTITY_CLIENT_ID.isEmpty()) {\n            logger.info(\"Using user-assigned managed identity with client ID: {}\", \n                       MANAGED_IDENTITY_CLIENT_ID);\n            miBuilder.clientId(MANAGED_IDENTITY_CLIENT_ID);\n        } else {\n            logger.info(\"Using system-assigned managed identity\");\n        }\n        \n        ManagedIdentityCredential managedIdentityCredential = miBuilder.build();\n        \n        // Build Azure CLI Credential (for local development)\n        AzureCliCredential azureCliCredential = new AzureCliCredentialBuilder()\n            .build();\n        \n        // Chain the credentials - ManagedIdentity first (production), then AzureCLI (local dev)\n        ChainedTokenCredential chainedCredential = new ChainedTokenCredentialBuilder()\n            .addLast(managedIdentityCredential)\n            .addLast(azureCliCredential)\n            .build();\n        \n        logger.info(\"ChainedTokenCredential created with ManagedIdentity and AzureCLI\");\n        return chainedCredential;\n    }\n\n    /**\n     * Tests the credential by attempting to get a token.\n     * Returns true if any credential in the chain can authenticate.\n     */\n    private boolean testCredential(ChainedTokenCredential credential) {\n        logger.info(\"Testing credential chain...\");\n        \n        try {\n            // Try to get a token for Cosmos DB scope\n            // The scope for Cosmos DB is \"https://cosmos.azure.com/.default\"\n            var tokenRequest = com.azure.core.credential.TokenRequestContext\n                .builder()\n                .addScopes(\"https://cosmos.azure.com/.default\")\n                .build();\n            \n            var token = credential.getToken(tokenRequest).block();\n            \n            if (token != null && token.getToken() != null) {\n                logger.info(\"Successfully authenticated with credential chain\");\n                logger.debug(\"Token expires at: {}\", token.getExpiresAt());\n                return true;\n            }\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"No credentials in the chain are available: {}\", e.getMessage());\n            logCredentialTroubleshooting();\n            return false;\n        } catch (Exception e) {\n            logger.error(\"Error testing credential: {}\", e.getMessage(), e);\n            return false;\n        }\n        \n        return false;\n    }\n\n    /**\n     * Creates a Cosmos DB client using the chained credential.\n     */\n    private CosmosClient createCosmosClient(ChainedTokenCredential credential) {\n        logger.info(\"Creating Cosmos DB client for endpoint: {}\", COSMOS_ENDPOINT);\n        \n        return new CosmosClientBuilder()\n            .endpoint(COSMOS_ENDPOINT)\n            .credential(credential)\n            .consistencyLevel(com.azure.cosmos.ConsistencyLevel.SESSION)\n            .buildClient();\n    }\n\n    /**\n     * Performs basic database operations including a query.\n     */\n    private void performDatabaseOperations(CosmosClient client) {\n        logger.info(\"Starting database operations...\");\n        \n        // Get database reference\n        CosmosDatabase database = client.getDatabase(DATABASE_NAME);\n        logger.info(\"Connected to database: {}\", DATABASE_NAME);\n        \n        // Get container reference\n        CosmosContainer container = database.getContainer(CONTAINER_NAME);\n        logger.info(\"Connected to container: {}\", CONTAINER_NAME);\n        \n        // Perform a basic query\n        performQuery(container);\n        \n        // Optional: Create a sample document\n        // createSampleDocument(container);\n    }\n\n    /**\n     * Performs a basic query on the Cosmos DB container.\n     */\n    private void performQuery(CosmosContainer container) {\n        logger.info(\"Executing query on container...\");\n        \n        String query = \"SELECT * FROM c\";\n        CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n        \n        try {\n            CosmosPagedIterable<CosmosDocument> items = container.queryItems(\n                query, \n                options, \n                CosmosDocument.class\n            );\n            \n            List<CosmosDocument> results = new ArrayList<>();\n            int count = 0;\n            \n            for (CosmosDocument item : items) {\n                results.add(item);\n                count++;\n                logger.debug(\"Retrieved document: {}\", item.getId());\n                \n                // Limit output for demonstration\n                if (count >= 10) {\n                    break;\n                }\n            }\n            \n            logger.info(\"Query completed. Retrieved {} documents (max 10 shown)\", count);\n            \n            // Display results\n            if (results.isEmpty()) {\n                logger.info(\"No documents found in container\");\n            } else {\n                logger.info(\"Sample documents:\");\n                results.forEach(doc -> \n                    logger.info(\"  - ID: {}, Data: {}\", doc.getId(), doc.toString())\n                );\n            }\n            \n        } catch (Exception e) {\n            logger.error(\"Error executing query: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Query execution failed\", e);\n        }\n    }\n\n    /**\n     * Creates a sample document in the container (optional).\n     */\n    private void createSampleDocument(CosmosContainer container) {\n        logger.info(\"Creating sample document...\");\n        \n        try {\n            CosmosDocument document = new CosmosDocument();\n            document.setId(java.util.UUID.randomUUID().toString());\n            document.setName(\"Sample Document\");\n            document.setDescription(\"Created by ChainedTokenCredential demo\");\n            document.setTimestamp(java.time.Instant.now().toString());\n            \n            container.createItem(document);\n            logger.info(\"Sample document created with ID: {}\", document.getId());\n            \n        } catch (Exception e) {\n            logger.error(\"Error creating sample document: {}\", e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Validates required configuration.\n     */\n    private void validateConfiguration() {\n        List<String> missingConfig = new ArrayList<>();\n        \n        if (COSMOS_ENDPOINT == null || COSMOS_ENDPOINT.isEmpty()) {\n            missingConfig.add(\"COSMOS_ENDPOINT\");\n        }\n        if (DATABASE_NAME == null || DATABASE_NAME.isEmpty()) {\n            missingConfig.add(\"COSMOS_DATABASE_NAME\");\n        }\n        if (CONTAINER_NAME == null || CONTAINER_NAME.isEmpty()) {\n            missingConfig.add(\"COSMOS_CONTAINER_NAME\");\n        }\n        \n        if (!missingConfig.isEmpty()) {\n            String message = \"Missing required environment variables: \" + \n                           String.join(\", \", missingConfig);\n            logger.error(message);\n            throw new IllegalStateException(message);\n        }\n        \n        logger.info(\"Configuration validated successfully\");\n    }\n\n    /**\n     * Logs troubleshooting information when credentials fail.\n     */\n    private void logCredentialTroubleshooting() {\n        logger.error(\"=== Credential Troubleshooting ===\");\n        logger.error(\"1. ManagedIdentityCredential:\");\n        logger.error(\"   - Ensure you're running on Azure (VM, App Service, Function, etc.)\");\n        logger.error(\"   - Verify managed identity is enabled for your resource\");\n        logger.error(\"   - Check that the managed identity has appropriate Cosmos DB permissions\");\n        logger.error(\"   - Required role: 'Cosmos DB Built-in Data Contributor' or similar\");\n        logger.error(\"\");\n        logger.error(\"2. AzureCliCredential:\");\n        logger.error(\"   - Ensure Azure CLI is installed: https://docs.microsoft.com/cli/azure/install-azure-cli\");\n        logger.error(\"   - Run 'az login' to authenticate\");\n        logger.error(\"   - Verify login status with 'az account show'\");\n        logger.error(\"   - Ensure your account has access to the Cosmos DB resource\");\n        logger.error(\"================================\");\n    }\n}\n```\n\n## 3. Document Model Class\n\n```java\npackage com.example.cosmosdb;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Simple document model for Cosmos DB.\n */\npublic class CosmosDocument {\n    \n    @JsonProperty(\"id\")\n    private String id;\n    \n    @JsonProperty(\"name\")\n    private String name;\n    \n    @JsonProperty(\"description\")\n    private String description;\n    \n    @JsonProperty(\"timestamp\")\n    private String timestamp;\n    \n    @JsonProperty(\"_etag\")\n    private String etag;\n\n    public CosmosDocument() {\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public String getTimestamp() {\n        return timestamp;\n    }\n\n    public void setTimestamp(String timestamp) {\n        this.timestamp = timestamp;\n    }\n\n    public String getEtag() {\n        return etag;\n    }\n\n    public void setEtag(String etag) {\n        this.etag = etag;\n    }\n\n    @Override\n    public String toString() {\n        return \"CosmosDocument{\" +\n                \"id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", description='\" + description + '\\'' +\n                \", timestamp='\" + timestamp + '\\'' +\n                '}';\n    }\n}\n```\n\n## 4. Configuration File (application.properties)\n\n```properties\n# Logging configuration\norg.slf4j.simpleLogger.defaultLogLevel=info\norg.slf4j.simpleLogger.log.com.example.cosmosdb=debug\norg.slf4j.simpleLogger.showDateTime=true\norg.slf4j.simpleLogger.dateTimeFormat=yyyy-",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 73,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Identity ChainedTokenCredential with Cosmos DB\n\nI'll create a complete Java application that demonstrates using `ChainedTokenCredential` with Cosmos DB, including proper error handling.\n\n## Project Structure\n\n```\ncosmos-identity-demo/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/main/java/com/example/\n\u2502   \u251c\u2500\u2500 CosmosIdentityDemo.java\n\u2502   \u251c\u2500\u2500 config/\n\u2502   \u2502   \u2514\u2500\u2500 CosmosConfig.java\n\u2502   \u251c\u2500\u2500 credential/\n\u2502   \u2502   \u2514\u2500\u2500 CredentialProvider.java\n\u2502   \u2514\u2500\u2500 service/\n\u2502       \u2514\u2500\u2500 CosmosService.java\n\u2514\u2500\u2500 src/main/resources/\n    \u2514\u2500\u2500 application.properties\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>cosmos-identity-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Cosmos DB Identity Demo</name>\n    <description>Demo of ChainedTokenCredential with Azure Cosmos DB</description>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.sdk.version>1.2.29</azure.sdk.version>\n    </properties>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.azure</groupId>\n                <artifactId>azure-sdk-bom</artifactId>\n                <version>${azure.sdk.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n        </dependency>\n\n        <!-- Azure Cosmos DB -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-cosmos</artifactId>\n        </dependency>\n\n        <!-- SLF4J for logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n\n        <!-- JUnit for testing -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.10.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.example.CosmosIdentityDemo</mainClass>\n                                </transformer>\n                            </transformers>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## application.properties\n\n```properties\n# Azure Cosmos DB Configuration\ncosmos.endpoint=https://YOUR-COSMOS-ACCOUNT.documents.azure.com:443/\ncosmos.database=SampleDB\ncosmos.container=Items\n\n# Managed Identity Configuration (optional - for user-assigned MI)\n# azure.managed.identity.client.id=YOUR-USER-ASSIGNED-MI-CLIENT-ID\n\n# Logging\norg.slf4j.simpleLogger.defaultLogLevel=info\norg.slf4j.simpleLogger.log.com.azure=debug\n```\n\n## CredentialProvider.java\n\n```java\npackage com.example.credential;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.identity.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Provides a ChainedTokenCredential that works in both production and development.\n * Production: Uses ManagedIdentityCredential\n * Development: Uses AzureCliCredential\n */\npublic class CredentialProvider {\n    private static final Logger logger = LoggerFactory.getLogger(CredentialProvider.class);\n    \n    private final String managedIdentityClientId;\n    \n    public CredentialProvider() {\n        this(null);\n    }\n    \n    public CredentialProvider(String managedIdentityClientId) {\n        this.managedIdentityClientId = managedIdentityClientId;\n    }\n    \n    /**\n     * Creates a ChainedTokenCredential that tries:\n     * 1. ManagedIdentityCredential (for Azure-hosted apps)\n     * 2. AzureCliCredential (for local development)\n     */\n    public TokenCredential createCredential() {\n        logger.info(\"Creating ChainedTokenCredential...\");\n        \n        // Build ManagedIdentityCredential\n        ManagedIdentityCredentialBuilder miBuilder = new ManagedIdentityCredentialBuilder();\n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            logger.info(\"Configuring user-assigned managed identity: {}\", managedIdentityClientId);\n            miBuilder.clientId(managedIdentityClientId);\n        } else {\n            logger.info(\"Configuring system-assigned managed identity\");\n        }\n        ManagedIdentityCredential managedIdentityCredential = miBuilder.build();\n        \n        // Build AzureCliCredential\n        logger.info(\"Configuring Azure CLI credential for local development\");\n        AzureCliCredential azureCliCredential = new AzureCliCredentialBuilder().build();\n        \n        // Create the chain\n        ChainedTokenCredential credential = new ChainedTokenCredentialBuilder()\n            .addFirst(managedIdentityCredential)\n            .addLast(azureCliCredential)\n            .build();\n        \n        logger.info(\"ChainedTokenCredential created successfully\");\n        logger.info(\"Authentication will try: 1) Managed Identity, 2) Azure CLI\");\n        \n        return credential;\n    }\n    \n    /**\n     * Creates a credential with explicit error handling and validation\n     */\n    public TokenCredential createCredentialWithValidation() throws CredentialUnavailableException {\n        TokenCredential credential = createCredential();\n        \n        // Test the credential by requesting a token\n        try {\n            logger.info(\"Validating credential by requesting test token...\");\n            credential.getToken(new com.azure.core.credential.TokenRequestContext()\n                .addScopes(\"https://management.azure.com/.default\"))\n                .block();\n            logger.info(\"Credential validation successful\");\n            return credential;\n        } catch (Exception e) {\n            logger.error(\"Credential validation failed\", e);\n            throw new CredentialUnavailableException(\n                \"No credential in the chain could authenticate. \" +\n                \"Ensure you're either running on Azure with Managed Identity enabled, \" +\n                \"or have run 'az login' for local development.\", e);\n        }\n    }\n}\n```\n\n## CosmosConfig.java\n\n```java\npackage com.example.config;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\n/**\n * Configuration class for Cosmos DB settings\n */\npublic class CosmosConfig {\n    private final String endpoint;\n    private final String database;\n    private final String container;\n    private final String managedIdentityClientId;\n    \n    public CosmosConfig() {\n        Properties props = loadProperties();\n        this.endpoint = getRequiredProperty(props, \"cosmos.endpoint\");\n        this.database = getRequiredProperty(props, \"cosmos.database\");\n        this.container = getRequiredProperty(props, \"cosmos.container\");\n        this.managedIdentityClientId = props.getProperty(\"azure.managed.identity.client.id\");\n    }\n    \n    public CosmosConfig(String endpoint, String database, String container) {\n        this(endpoint, database, container, null);\n    }\n    \n    public CosmosConfig(String endpoint, String database, String container, String managedIdentityClientId) {\n        this.endpoint = endpoint;\n        this.database = database;\n        this.container = container;\n        this.managedIdentityClientId = managedIdentityClientId;\n    }\n    \n    private Properties loadProperties() {\n        Properties props = new Properties();\n        try (InputStream input = getClass().getClassLoader()\n                .getResourceAsStream(\"application.properties\")) {\n            if (input == null) {\n                throw new RuntimeException(\"Unable to find application.properties\");\n            }\n            props.load(input);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to load application.properties\", e);\n        }\n        return props;\n    }\n    \n    private String getRequiredProperty(Properties props, String key) {\n        String value = props.getProperty(key);\n        if (value == null || value.trim().isEmpty()) {\n            throw new IllegalStateException(\"Required property '\" + key + \"' is not set\");\n        }\n        return value.trim();\n    }\n    \n    public String getEndpoint() {\n        return endpoint;\n    }\n    \n    public String getDatabase() {\n        return database;\n    }\n    \n    public String getContainer() {\n        return container;\n    }\n    \n    public String getManagedIdentityClientId() {\n        return managedIdentityClientId;\n    }\n    \n    @Override\n    public String toString() {\n        return \"CosmosConfig{\" +\n                \"endpoint='\" + endpoint + '\\'' +\n                \", database='\" + database + '\\'' +\n                \", container='\" + container + '\\'' +\n                \", managedIdentityClientId='\" + \n                (managedIdentityClientId != null ? \"***\" : \"null\") + '\\'' +\n                '}';\n    }\n}\n```\n\n## CosmosService.java\n\n```java\npackage com.example.service;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.cosmos.*;\nimport com.azure.cosmos.models.*;\nimport com.azure.cosmos.util.CosmosPagedIterable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * Service class for Cosmos DB operations\n */\npublic class CosmosService implements AutoCloseable {\n    private static final Logger logger = LoggerFactory.getLogger(CosmosService.class);\n    \n    private final CosmosClient client;\n    private final String databaseName;\n    private final String containerName;\n    \n    public CosmosService(String endpoint, TokenCredential credential, \n                        String databaseName, String containerName) {\n        logger.info(\"Initializing Cosmos DB client...\");\n        logger.info(\"Endpoint: {}\", endpoint);\n        logger.info(\"Database: {}\", databaseName);\n        logger.info(\"Container: {}\", containerName);\n        \n        this.databaseName = databaseName;\n        this.containerName = containerName;\n        \n        // Create Cosmos client with token credential\n        this.client = new CosmosClientBuilder()\n            .endpoint(endpoint)\n            .credential(credential)\n            .consistencyLevel(ConsistencyLevel.SESSION)\n            .contentResponseOnWriteEnabled(true)\n            .buildClient();\n        \n        logger.info(\"Cosmos DB client initialized successfully\");\n    }\n    \n    /**\n     * Ensures database and container exist\n     */\n    public void initializeDatabase() {\n        logger.info(\"Initializing database and container...\");\n        \n        try {\n            // Create database if not exists\n            CosmosDatabaseResponse databaseResponse = client.createDatabaseIfNotExists(databaseName);\n            CosmosDatabase database = client.getDatabase(databaseName);\n            logger.info(\"Database '{}' ready (status: {})\", \n                databaseName, databaseResponse.getStatusCode());\n            \n            // Create container if not exists\n            CosmosContainerProperties containerProperties = \n                new CosmosContainerProperties(containerName, \"/id\");\n            \n            CosmosContainerResponse containerResponse = \n                database.createContainerIfNotExists(containerProperties);\n            logger.info(\"Container '{}' ready (status: {})\", \n                containerName, containerResponse.getStatusCode());\n            \n        } catch (CosmosException e) {\n            logger.error(\"Failed to initialize database/container\", e);\n            throw new RuntimeException(\"Database initialization failed\", e);\n        }\n    }\n    \n    /**\n     * Creates a sample item in the container\n     */\n    public SampleItem createSampleItem(String name, String category) {\n        logger.info(\"Creating sample item: name={}, category={}\", name, category);\n        \n        CosmosContainer container = client.getDatabase(databaseName)\n            .getContainer(containerName);\n        \n        SampleItem item = new SampleItem(\n            UUID.randomUUID().toString(),\n            name,\n            category,\n            System.currentTimeMillis()\n        );\n        \n        try {\n            CosmosItemResponse<SampleItem> response = container.createItem(item);\n            logger.info(\"Item created successfully (RU: {})\", \n                response.getRequestCharge());\n            return response.getItem();\n        } catch (CosmosException e) {\n            logger.error(\"Failed to create item\", e);\n            throw new RuntimeException(\"Failed to create item\", e);\n        }\n    }\n    \n    /**\n     * Queries items by category\n     */\n    public List<SampleItem> queryItemsByCategory(String category) {\n        logger.info(\"Querying items by category: {}\", category);\n        \n        CosmosContainer container = client.getDatabase(databaseName)\n            .getContainer(containerName);\n        \n        String query = \"SELECT * FROM c WHERE c.category = @category\";\n        CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n        \n        CosmosPagedIterable<SampleItem> items = container.queryItems(\n            query,\n            options,\n            SampleItem.class\n        );\n        \n        List<SampleItem> results = new ArrayList<>();\n        items.forEach(results::add);\n        \n        logger.info(\"Query returned {} items\", results.size());\n        return results;\n    }\n    \n    /**\n     * Gets all items in the container\n     */\n    public List<SampleItem> getAllItems() {\n        logger.info(\"Retrieving all items...\");\n        \n        CosmosContainer container = client.getDatabase(databaseName)\n            .getContainer(containerName);\n        \n        CosmosPagedIterable<SampleItem> items = container.readAllItems(\n            new PartitionKey(\"*\"),\n            SampleItem.class\n        );\n        \n        List<SampleItem> results = new ArrayList<>();\n        items.forEach(results::add);\n        \n        logger.info",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10850,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses ChainedTokenCredential to authenticate to Azure Cosmos DB with fallback between Managed Identity and Azure CLI.\n\n<write_to_file>\n<path>src/main/java/com/example/app/config/AzureCosmosConfig.java</path>\n<content>package com.example.app.config;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosClientBuilder;\nimport com.azure.identity.AzureCliCredential;\nimport com.azure.identity.AzureCliCredentialBuilder;\nimport com.azure.identity.ChainedTokenCredential;\nimport com.azure.identity.ChainedTokenCredentialBuilder;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.ManagedIdentityCredential;\nimport com.azure.identity.ManagedIdentityCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AzureCosmosConfig {\n    \n    private static final Logger log = LoggerFactory.getLogger(AzureCosmosConfig.class);\n    \n    @Value(\"${azure.cosmos.endpoint}\")\n    private String cosmosEndpoint;\n    \n    @Value(\"${azure.cosmos.database}\")\n    private String databaseName;\n    \n    @Value(\"${azure.cosmos.container}\")\n    private String containerName;\n    \n    @Bean\n    public ChainedTokenCredential azureCredential() {\n        log.info(\"Creating ChainedTokenCredential with ManagedIdentity and AzureCli\");\n        \n        // First try Managed Identity (for production on Azure)\n        ManagedIdentityCredential managedIdentityCredential = new ManagedIdentityCredentialBuilder()\n            .build();\n        \n        // Fallback to Azure CLI (for local development)\n        AzureCliCredential azureCliCredential = new AzureCliCredentialBuilder()\n            .build();\n        \n        ChainedTokenCredential credential = new ChainedTokenCredentialBuilder()\n            .addFirst(managedIdentityCredential)\n            .addLast(azureCliCredential)\n            .build();\n        \n        log.info(\"ChainedTokenCredential created successfully\");\n        return credential;\n    }\n    \n    @Bean\n    public CosmosClient cosmosClient(ChainedTokenCredential credential) {\n        log.info(\"Creating Cosmos DB client for endpoint: {}\", cosmosEndpoint);\n        \n        try {\n            CosmosClient client = new CosmosClientBuilder()\n                .endpoint(cosmosEndpoint)\n                .credential(credential)\n                .buildClient();\n            \n            log.info(\"Cosmos DB client created successfully\");\n            return client;\n            \n        } catch (Exception e) {\n            log.error(\"Failed to create Cosmos DB client\", e);\n            throw new RuntimeException(\"Unable to create Cosmos DB client\", e);\n        }\n    }\n    \n    @Bean\n    public String databaseName() {\n        return databaseName;\n    }\n    \n    @Bean\n    public String containerName() {\n        return containerName;\n    }\n}\n</content>\n</write_to_file>\n\n<write_to_file>\n<path>src/main/java/com/example/app/model/Product.java</path>\n<content>package com.example.app.model;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class Product {\n    \n    @JsonProperty(\"id\")\n    private String id;\n    \n    @JsonProperty(\"name\")\n    private String name;\n    \n    @JsonProperty(\"category\")\n    private String category;\n    \n    @JsonProperty(\"price\")\n    private Double price;\n    \n    @JsonProperty(\"description\")\n    private String description;\n    \n    public Product() {\n    }\n    \n    public Product(String id, String name, String category, Double price, String description) {\n        this.id = id;\n        this.name = name;\n        this.category = category;\n        this.price = price;\n        this.description = description;\n    }\n    \n    public String getId() {\n        return id;\n    }\n    \n    public void setId(String id) {\n        this.id = id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public String getCategory() {\n        return category;\n    }\n    \n    public void setCategory(String category) {\n        this.category = category;\n    }\n    \n    public Double getPrice() {\n        return price;\n    }\n    \n    public void setPrice(Double price) {\n        this.price = price;\n    }\n    \n    public String getDescription() {\n        return description;\n    }\n    \n    public void setDescription(String description) {\n        this.description = description;\n    }\n    \n    @Override\n    public String toString() {\n        return \"Product{\" +\n                \"id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", category='\" + category + '\\'' +\n                \", price=\" + price +\n                \", description='\" + description + '\\'' +\n                '}';\n    }\n}\n</content>\n</write_to_file>\n\n<write_to_file>\n<path>src/main/java/com/example/app/service/CosmosDbService.java</path>\n<content>package com.example.app.service;\n\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosContainer;\nimport com.azure.cosmos.CosmosDatabase;\nimport com.azure.cosmos.models.CosmosQueryRequestOptions;\nimport com.azure.cosmos.util.CosmosPagedIterable;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.example.app.model.Product;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Service\npublic class CosmosDbService {\n    \n    private static final Logger log = LoggerFactory.getLogger(CosmosDbService.class);\n    \n    private final CosmosClient cosmosClient;\n    private final String databaseName;\n    private final String containerName;\n    \n    public CosmosDbService(CosmosClient cosmosClient, String databaseName, String containerName) {\n        this.cosmosClient = cosmosClient;\n        this.databaseName = databaseName;\n        this.containerName = containerName;\n    }\n    \n    /**\n     * Query products from Cosmos DB with authentication error handling\n     */\n    public List<Product> queryProducts(String category) {\n        try {\n            log.info(\"Querying products for category: {}\", category);\n            \n            CosmosDatabase database = cosmosClient.getDatabase(databaseName);\n            CosmosContainer container = database.getContainer(containerName);\n            \n            String query = \"SELECT * FROM c WHERE c.category = @category\";\n            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n            \n            CosmosPagedIterable<Product> results = container.queryItems(\n                query,\n                options,\n                Product.class\n            );\n            \n            List<Product> products = new ArrayList<>();\n            results.forEach(products::add);\n            \n            log.info(\"Successfully retrieved {} products\", products.size());\n            return products;\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential in the chain could authenticate. \" +\n                     \"Ensure either Managed Identity is configured (Azure) or Azure CLI is logged in (local).\", e);\n            throw new RuntimeException(\"Authentication failed: No valid credential available. \" +\n                \"Please run 'az login' for local development or configure Managed Identity for Azure deployment.\", e);\n            \n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed with available credentials\", e);\n            throw new RuntimeException(\"Authentication error: \" + e.getMessage(), e);\n            \n        } catch (Exception e) {\n            log.error(\"Error querying Cosmos DB\", e);\n            throw new RuntimeException(\"Failed to query Cosmos DB: \" + e.getMessage(), e);\n        }\n    }\n    \n    /**\n     * Get all products from Cosmos DB\n     */\n    public List<Product> getAllProducts() {\n        try {\n            log.info(\"Retrieving all products from Cosmos DB\");\n            \n            CosmosDatabase database = cosmosClient.getDatabase(databaseName);\n            CosmosContainer container = database.getContainer(containerName);\n            \n            String query = \"SELECT * FROM c\";\n            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n            \n            CosmosPagedIterable<Product> results = container.queryItems(\n                query,\n                options,\n                Product.class\n            );\n            \n            List<Product> products = new ArrayList<>();\n            results.forEach(products::add);\n            \n            log.info(\"Successfully retrieved {} products\", products.size());\n            return products;\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential in the chain could authenticate\", e);\n            throw new RuntimeException(\"Authentication failed: No valid credential available. \" +\n                \"Please run 'az login' for local development or configure Managed Identity for Azure deployment.\", e);\n            \n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed with available credentials\", e);\n            throw new RuntimeException(\"Authentication error: \" + e.getMessage(), e);\n            \n        } catch (Exception e) {\n            log.error(\"Error querying Cosmos DB\", e);\n            throw new RuntimeException(\"Failed to query Cosmos DB: \" + e.getMessage(), e);\n        }\n    }\n    \n    /**\n     * Create a new product in Cosmos DB\n     */\n    public Product createProduct(Product product) {\n        try {\n            log.info(\"Creating product: {}\", product.getName());\n            \n            CosmosDatabase database = cosmosClient.getDatabase(databaseName);\n            CosmosContainer container = database.getContainer(containerName);\n            \n            container.createItem(product);\n            \n            log.info(\"Successfully created product with id: {}\", product.getId());\n            return product;\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential in the chain could authenticate\", e);\n            throw new RuntimeException(\"Authentication failed: No valid credential available\", e);\n            \n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed with available credentials\", e);\n            throw new RuntimeException(\"Authentication error: \" + e.getMessage(), e);\n            \n        } catch (Exception e) {\n            log.error(\"Error creating product in Cosmos DB\", e);\n            throw new RuntimeException(\"Failed to create product: \" + e.getMessage(), e);\n        }\n    }\n    \n    /**\n     * Test the connection and authentication to Cosmos DB\n     */\n    public boolean testConnection() {\n        try {\n            log.info(\"Testing Cosmos DB connection and authentication\");\n            \n            CosmosDatabase database = cosmosClient.getDatabase(databaseName);\n            database.read();\n            \n            log.info(\"Successfully connected to Cosmos DB database: {}\", databaseName);\n            return true;\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential in the chain could authenticate. \" +\n                     \"Tried: ManagedIdentityCredential, AzureCliCredential\", e);\n            log.error(\"For local development, ensure you are logged in via 'az login'\");\n            log.error(\"For Azure deployment, ensure Managed Identity is configured and has proper permissions\");\n            return false;\n            \n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed: {}\", e.getMessage());\n            return false;\n            \n        } catch (Exception e) {\n            log.error(\"Connection test failed\", e);\n            return false;\n        }\n    }\n}\n</content>\n</write_to_file>\n\n<write_to_file>\n<path>src/main/java/com/example/app/controller/ProductController.java</path>\n<content>package com.example.app.controller;\n\nimport com.example.app.model.Product;\nimport com.example.app.service.CosmosDbService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/api/products\")\npublic class ProductController {\n    \n    private static final Logger log = LoggerFactory.getLogger(ProductController.class);\n    \n    private final CosmosDbService cosmosDbService;\n    \n    public ProductController(CosmosDbService cosmosDbService) {\n        this.cosmosDbService = cosmosDbService;\n    }\n    \n    @GetMapping\n    public ResponseEntity<?> getAllProducts() {\n        try {\n            List<Product> products = cosmosDbService.getAllProducts();\n            return ResponseEntity.ok(products);\n        } catch (RuntimeException e) {\n            log.error(\"Failed to retrieve products\", e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(Map.of(\"error\", e.getMessage()));\n        }\n    }\n    \n    @GetMapping(\"/category/{category}\")\n    public ResponseEntity<?> getProductsByCategory(@PathVariable String category) {\n        try {\n            List<Product> products = cosmosDbService.queryProducts(category);\n            return ResponseEntity.ok(products);\n        } catch (RuntimeException e) {\n            log.error(\"Failed to query products by category\", e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(Map.of(\"error\", e.getMessage()));\n        }\n    }\n    \n    @PostMapping\n    public ResponseEntity<?> createProduct(@RequestBody Product product) {\n        try {\n            Product created = cosmosDbService.createProduct(product);\n            return ResponseEntity.status(HttpStatus.CREATED).body(created);\n        } catch (RuntimeException e) {\n            log.error(\"Failed to create product\", e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(Map.of(\"error\", e.getMessage()));\n        }\n    }\n    \n    @GetMapping(\"/test-connection\")\n    public ResponseEntity<?> testConnection() {\n        boolean connected = cosmosDbService.testConnection();\n        if (connected) {\n            return ResponseEntity.ok(Map.of(\n                \"status\", \"connected\",\n                \"message\", \"Successfully authenticated to Cosmos DB\"\n            ));\n        } else {\n            return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)\n                .body(Map.of(\n                    \"status\", \"failed\",\n                    \"message\", \"Failed to authenticate. Check logs for details.\"\n                ));\n        }\n    }\n}\n</content>\n</write_to_file>\n\n<write_to_file>\n<path>src/main/resources/application.properties</path>\n<content># Azure Cosmos DB Configuration\nazure.cosmos.endpoint=${AZURE_COSMOS_ENDPOINT:https://your-cosmos-account.documents.azure.com:443/}\nazure.cosmos.database=${AZURE_COSMOS_DATABASE:products-db}\nazure.cosmos.container=${AZURE_COSMOS_CONTAINER:products}\n\n# Logging\nlogging.level.com.example.app=INFO\nlogging.level.com.azure.identity=DEBUG\nlogging.level.com.azure.cosmos=INFO\n\n# Server\nserver.port=8080\n</content>\n</write_to_file>\n\n<write_to_file>\n<path>pom.xml</path>\n<content><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n         http://maven.apache.org/xsd",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11375,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Azure Cosmos DB Authentication with ChainedTokenCredential\n\nHere's a complete Java application demonstrating authentication using ChainedTokenCredential with fallback mechanisms:\n\n## 1. Maven Dependencies (pom.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>cosmos-chained-auth</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>1.11.1</version>\n        </dependency>\n\n        <!-- Azure Cosmos DB -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-cosmos</artifactId>\n            <version>4.51.0</version>\n        </dependency>\n\n        <!-- Logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Main Application\n\n```java\npackage com.example.cosmos;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosClientBuilder;\nimport com.azure.cosmos.CosmosContainer;\nimport com.azure.cosmos.CosmosDatabase;\nimport com.azure.cosmos.models.CosmosQueryRequestOptions;\nimport com.azure.cosmos.util.CosmosPagedIterable;\nimport com.azure.identity.AzureCliCredential;\nimport com.azure.identity.AzureCliCredentialBuilder;\nimport com.azure.identity.ChainedTokenCredential;\nimport com.azure.identity.ChainedTokenCredentialBuilder;\nimport com.azure.identity.ManagedIdentityCredential;\nimport com.azure.identity.ManagedIdentityCredentialBuilder;\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.exception.AzureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Azure Cosmos DB application demonstrating ChainedTokenCredential authentication\n * with ManagedIdentity (production) and AzureCLI (local development) fallback.\n */\npublic class CosmosChainedAuthApp {\n    \n    private static final Logger logger = LoggerFactory.getLogger(CosmosChainedAuthApp.class);\n    \n    // Configuration - Replace with your values\n    private static final String COSMOS_ENDPOINT = System.getenv(\"COSMOS_ENDPOINT\");\n    private static final String DATABASE_NAME = System.getenv(\"COSMOS_DATABASE_NAME\");\n    private static final String CONTAINER_NAME = System.getenv(\"COSMOS_CONTAINER_NAME\");\n    \n    public static void main(String[] args) {\n        CosmosChainedAuthApp app = new CosmosChainedAuthApp();\n        \n        try {\n            // Validate configuration\n            app.validateConfiguration();\n            \n            // Create chained credential\n            TokenCredential credential = app.createChainedCredential();\n            \n            // Create Cosmos client\n            CosmosClient cosmosClient = app.createCosmosClient(credential);\n            \n            // Perform operations\n            app.performCosmosOperations(cosmosClient);\n            \n            // Cleanup\n            cosmosClient.close();\n            logger.info(\"Application completed successfully\");\n            \n        } catch (CredentialAuthenticationException e) {\n            logger.error(\"Authentication failed: {}\", e.getMessage());\n            logger.error(\"Please ensure you are logged in via Azure CLI (az login) \" +\n                        \"or running on Azure with Managed Identity enabled\");\n            System.exit(1);\n            \n        } catch (Exception e) {\n            logger.error(\"Application error: {}\", e.getMessage(), e);\n            System.exit(1);\n        }\n    }\n    \n    /**\n     * Validates that required configuration is present\n     */\n    private void validateConfiguration() {\n        if (COSMOS_ENDPOINT == null || COSMOS_ENDPOINT.isEmpty()) {\n            throw new IllegalStateException(\"COSMOS_ENDPOINT environment variable is not set\");\n        }\n        if (DATABASE_NAME == null || DATABASE_NAME.isEmpty()) {\n            throw new IllegalStateException(\"COSMOS_DATABASE_NAME environment variable is not set\");\n        }\n        if (CONTAINER_NAME == null || CONTAINER_NAME.isEmpty()) {\n            throw new IllegalStateException(\"COSMOS_CONTAINER_NAME environment variable is not set\");\n        }\n        \n        logger.info(\"Configuration validated successfully\");\n        logger.info(\"Cosmos Endpoint: {}\", COSMOS_ENDPOINT);\n        logger.info(\"Database: {}\", DATABASE_NAME);\n        logger.info(\"Container: {}\", CONTAINER_NAME);\n    }\n    \n    /**\n     * Creates a ChainedTokenCredential with ManagedIdentity and AzureCLI credentials\n     */\n    private TokenCredential createChainedCredential() {\n        logger.info(\"Creating ChainedTokenCredential...\");\n        \n        // Create ManagedIdentityCredential (for production on Azure)\n        ManagedIdentityCredential managedIdentityCredential = new ManagedIdentityCredentialBuilder()\n                .maxRetry(2)\n                .build();\n        \n        logger.info(\"\u2713 ManagedIdentityCredential created (for Azure production environment)\");\n        \n        // Create AzureCliCredential (for local development)\n        AzureCliCredential azureCliCredential = new AzureCliCredentialBuilder()\n                .build();\n        \n        logger.info(\"\u2713 AzureCliCredential created (for local development)\");\n        \n        // Chain the credentials - ManagedIdentity will be tried first, then AzureCLI\n        ChainedTokenCredential chainedCredential = new ChainedTokenCredentialBuilder()\n                .addLast(managedIdentityCredential)\n                .addLast(azureCliCredential)\n                .build();\n        \n        logger.info(\"\u2713 ChainedTokenCredential created successfully\");\n        logger.info(\"  Authentication order: ManagedIdentity \u2192 AzureCLI\");\n        \n        return chainedCredential;\n    }\n    \n    /**\n     * Creates a CosmosClient using the provided credential\n     */\n    private CosmosClient createCosmosClient(TokenCredential credential) {\n        logger.info(\"Creating Cosmos DB client...\");\n        \n        try {\n            CosmosClient client = new CosmosClientBuilder()\n                    .endpoint(COSMOS_ENDPOINT)\n                    .credential(credential)\n                    .consistencyLevel(com.azure.cosmos.ConsistencyLevel.SESSION)\n                    .buildClient();\n            \n            logger.info(\"\u2713 Cosmos DB client created successfully\");\n            return client;\n            \n        } catch (Exception e) {\n            if (isAuthenticationError(e)) {\n                throw new CredentialAuthenticationException(\n                    \"Failed to authenticate with any credential in the chain. \" +\n                    \"Ensure you're logged in via Azure CLI or running on Azure with Managed Identity.\", e);\n            }\n            throw e;\n        }\n    }\n    \n    /**\n     * Performs basic Cosmos DB operations\n     */\n    private void performCosmosOperations(CosmosClient cosmosClient) {\n        logger.info(\"\\n=== Performing Cosmos DB Operations ===\\n\");\n        \n        try {\n            // Get database\n            CosmosDatabase database = cosmosClient.getDatabase(DATABASE_NAME);\n            logger.info(\"\u2713 Connected to database: {}\", DATABASE_NAME);\n            \n            // Get container\n            CosmosContainer container = database.getContainer(CONTAINER_NAME);\n            logger.info(\"\u2713 Connected to container: {}\", CONTAINER_NAME);\n            \n            // Perform a simple query\n            performQuery(container);\n            \n            // Get container properties\n            getContainerInfo(container);\n            \n        } catch (Exception e) {\n            logger.error(\"Error during Cosmos DB operations: {}\", e.getMessage(), e);\n            throw e;\n        }\n    }\n    \n    /**\n     * Performs a basic query on the container\n     */\n    private void performQuery(CosmosContainer container) {\n        logger.info(\"\\n--- Executing Query ---\");\n        \n        String query = \"SELECT TOP 5 * FROM c\";\n        CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n        \n        try {\n            CosmosPagedIterable<Object> items = container.queryItems(\n                    query,\n                    options,\n                    Object.class\n            );\n            \n            AtomicInteger count = new AtomicInteger(0);\n            items.forEach(item -> {\n                count.incrementAndGet();\n                logger.info(\"Item {}: {}\", count.get(), item);\n            });\n            \n            if (count.get() == 0) {\n                logger.info(\"No items found in container (container may be empty)\");\n            } else {\n                logger.info(\"\u2713 Query completed successfully. Retrieved {} items\", count.get());\n            }\n            \n        } catch (Exception e) {\n            logger.error(\"Query execution failed: {}\", e.getMessage(), e);\n            throw e;\n        }\n    }\n    \n    /**\n     * Retrieves and displays container information\n     */\n    private void getContainerInfo(CosmosContainer container) {\n        logger.info(\"\\n--- Container Information ---\");\n        \n        try {\n            var properties = container.read().getProperties();\n            \n            logger.info(\"Container ID: {}\", properties.getId());\n            logger.info(\"Partition Key Path: {}\", \n                       properties.getPartitionKeyDefinition().getPaths());\n            logger.info(\"Default TTL: {}\", \n                       properties.getDefaultTimeToLiveInSeconds() != null ? \n                       properties.getDefaultTimeToLiveInSeconds() : \"Not set\");\n            \n            logger.info(\"\u2713 Container information retrieved successfully\");\n            \n        } catch (Exception e) {\n            logger.error(\"Failed to retrieve container information: {}\", e.getMessage(), e);\n            throw e;\n        }\n    }\n    \n    /**\n     * Checks if an exception is related to authentication failure\n     */\n    private boolean isAuthenticationError(Exception e) {\n        String message = e.getMessage() != null ? e.getMessage().toLowerCase() : \"\";\n        Throwable cause = e.getCause();\n        String causeMessage = cause != null && cause.getMessage() != null ? \n                             cause.getMessage().toLowerCase() : \"\";\n        \n        return message.contains(\"authentication\") || \n               message.contains(\"unauthorized\") ||\n               message.contains(\"credential\") ||\n               causeMessage.contains(\"authentication\") ||\n               causeMessage.contains(\"unauthorized\") ||\n               e instanceof AzureException;\n    }\n}\n```\n\n## 3. Custom Exception Class\n\n```java\npackage com.example.cosmos;\n\n/**\n * Custom exception for credential authentication failures\n */\npublic class CredentialAuthenticationException extends RuntimeException {\n    \n    public CredentialAuthenticationException(String message) {\n        super(message);\n    }\n    \n    public CredentialAuthenticationException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n```\n\n## 4. Sample Document Model (Optional)\n\n```java\npackage com.example.cosmos;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Sample document model for Cosmos DB\n */\npublic class SampleDocument {\n    \n    @JsonProperty(\"id\")\n    private String id;\n    \n    @JsonProperty(\"name\")\n    private String name;\n    \n    @JsonProperty(\"description\")\n    private String description;\n    \n    @JsonProperty(\"category\")\n    private String category;\n    \n    // Constructors\n    public SampleDocument() {\n    }\n    \n    public SampleDocument(String id, String name, String description, String category) {\n        this.id = id;\n        this.name = name;\n        this.description = description;\n        this.category = category;\n    }\n    \n    // Getters and Setters\n    public String getId() {\n        return id;\n    }\n    \n    public void setId(String id) {\n        this.id = id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public String getDescription() {\n        return description;\n    }\n    \n    public void setDescription(String description) {\n        this.description = description;\n    }\n    \n    public String getCategory() {\n        return category;\n    }\n    \n    public void setCategory(String category) {\n        this.category = category;\n    }\n    \n    @Override\n    public String toString() {\n        return \"SampleDocument{\" +\n                \"id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", description='\" + description + '\\'' +\n                \", category='\" + category + '\\'' +\n                '}';\n    }\n}\n```\n\n## 5. Configuration File (application.properties)\n\n```properties\n# Logging configuration\norg.slf4j.simpleLogger.defaultLogLevel=info\norg.slf4j.simpleLogger.log.com.azure=warn\norg.slf4j.simpleLogger.showDateTime=true\norg.slf4j.simpleLogger.dateTimeFormat=yyyy-MM-dd HH:mm:ss\n```\n\n## 6. Setup Script (setup.sh)\n\n```bash\n#!/bin/bash\n\n# Setup script for local development\n\necho \"=== Azure Cosmos DB ChainedTokenCredential Setup ===\"\necho \"\"\n\n# Check if Azure CLI is installed\nif ! command -v az &> /dev/null; then\n    echo \"\u274c Azure CLI is not installed\"\n    echo \"Please install from: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli\"\n    exit 1\nfi\n\necho \"\u2713 Azure CLI is installed\"\n\n# Check if logged in\nif ! az account show &> /dev/null; then\n    echo \"\u274c Not logged in to Azure CLI\"\n    echo \"Please run: az login\"\n    exit 1\nfi\n\necho \"\u2713 Logged in to Azure CLI\"\n\n# Set environment variables\necho \"\"\necho \"Please provide the following information:\"\nread -p \"Cosmos DB Endpoint (e.g., https://myaccount.documents.azure.com:443/): \" ENDPOINT\nread -p \"Database Name: \" DATABASE\nread -p \"Container Name: \" CONTAINER\n\nexport COSMOS_ENDPOINT=\"$ENDPOINT\"\nexport COSMOS_DATABASE_NAME=\"$DATABASE\"\nexport COSMOS_CONTAINER_NAME=\"$CONTAINER\"\n\necho \"\"\necho \"Environment variables set:\"\necho \"  COSMOS_ENDPOINT=$COSMOS_ENDPOINT\"\necho \"  COSMOS_DATABASE_NAME=$COSMOS_DATABASE_NAME\"\necho \"  COSMOS_CONTAINER_NAME=$COSMOS_CONTAINER_NAME\"\necho \"\"\necho \"To persist these, add to your ~/.bashrc or ~/.zshrc:\"\necho \"  export COSMOS_ENDPOINT=\\\"$COSMOS_ENDPOINT\\\"\"\necho \"  export COSMOS",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 73,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Identity ChainedTokenCredential with Cosmos DB\n\nI'll create a complete Java application demonstrating ChainedTokenCredential with proper error handling and Cosmos DB integration.\n\n## Project Structure\n\n```\ncosmos-identity-demo/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 identity/\n\u2502       \u2502               \u2514\u2500\u2500 demo/\n\u2502       \u2502                   \u251c\u2500\u2500 CosmosIdentityDemo.java\n\u2502       \u2502                   \u251c\u2500\u2500 config/\n\u2502       \u2502                   \u2502   \u2514\u2500\u2500 CosmosConfig.java\n\u2502       \u2502                   \u251c\u2500\u2500 model/\n\u2502       \u2502                   \u2502   \u2514\u2500\u2500 Product.java\n\u2502       \u2502                   \u2514\u2500\u2500 service/\n\u2502       \u2502                       \u2514\u2500\u2500 CosmosService.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u2514\u2500\u2500 application.properties\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.identity.demo</groupId>\n    <artifactId>cosmos-identity-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Identity ChainedTokenCredential Demo</name>\n    <description>Demo of ChainedTokenCredential with Cosmos DB</description>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <azure.sdk.bom.version>1.2.29</azure.sdk.bom.version>\n    </properties>\n\n    <dependencyManagement>\n        <dependencies>\n            <!-- Azure SDK BOM for version management -->\n            <dependency>\n                <groupId>com.azure</groupId>\n                <artifactId>azure-sdk-bom</artifactId>\n                <version>${azure.sdk.bom.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n        </dependency>\n\n        <!-- Azure Cosmos DB -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-cosmos</artifactId>\n        </dependency>\n\n        <!-- SLF4J API -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n\n        <!-- Logback for logging -->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.4.14</version>\n        </dependency>\n\n        <!-- Jackson for JSON -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.16.1</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n\n            <!-- Maven Shade Plugin for creating executable JAR -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.identity.demo.CosmosIdentityDemo</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## application.properties\n\n```properties\n# Azure Cosmos DB Configuration\nazure.cosmos.endpoint=${COSMOS_ENDPOINT:https://your-cosmos-account.documents.azure.com:443/}\nazure.cosmos.database=${COSMOS_DATABASE:demo-db}\nazure.cosmos.container=${COSMOS_CONTAINER:products}\n\n# Managed Identity Configuration (optional - for user-assigned MI)\nazure.managed.identity.client.id=${AZURE_CLIENT_ID:}\n\n# Logging\nlogging.level.com.azure=INFO\nlogging.level.com.azure.identity=DEBUG\n```\n\n## CosmosConfig.java\n\n```java\npackage com.azure.identity.demo.config;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\n/**\n * Configuration class for loading application properties.\n */\npublic class CosmosConfig {\n    private static final String PROPERTIES_FILE = \"application.properties\";\n    private final Properties properties;\n\n    public CosmosConfig() {\n        this.properties = new Properties();\n        loadProperties();\n    }\n\n    private void loadProperties() {\n        try (InputStream input = getClass().getClassLoader()\n                .getResourceAsStream(PROPERTIES_FILE)) {\n            if (input == null) {\n                System.err.println(\"Unable to find \" + PROPERTIES_FILE);\n                return;\n            }\n            properties.load(input);\n        } catch (IOException e) {\n            System.err.println(\"Error loading properties: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Gets a property value, with environment variable override support.\n     */\n    private String getProperty(String key, String defaultValue) {\n        // First check environment variables\n        String envKey = key.replace(\".\", \"_\").toUpperCase();\n        String envValue = System.getenv(envKey);\n        if (envValue != null && !envValue.isEmpty()) {\n            return envValue;\n        }\n\n        // Then check system properties\n        String sysValue = System.getProperty(key);\n        if (sysValue != null && !sysValue.isEmpty()) {\n            return sysValue;\n        }\n\n        // Finally check properties file\n        return properties.getProperty(key, defaultValue);\n    }\n\n    public String getCosmosEndpoint() {\n        return getProperty(\"azure.cosmos.endpoint\", \n            \"https://your-cosmos-account.documents.azure.com:443/\");\n    }\n\n    public String getCosmosDatabase() {\n        return getProperty(\"azure.cosmos.database\", \"demo-db\");\n    }\n\n    public String getCosmosContainer() {\n        return getProperty(\"azure.cosmos.container\", \"products\");\n    }\n\n    public String getManagedIdentityClientId() {\n        return getProperty(\"azure.managed.identity.client.id\", \"\");\n    }\n\n    public void printConfiguration() {\n        System.out.println(\"=== Configuration ===\");\n        System.out.println(\"Cosmos Endpoint: \" + maskEndpoint(getCosmosEndpoint()));\n        System.out.println(\"Database: \" + getCosmosDatabase());\n        System.out.println(\"Container: \" + getCosmosContainer());\n        String clientId = getManagedIdentityClientId();\n        if (!clientId.isEmpty()) {\n            System.out.println(\"Managed Identity Client ID: \" + maskClientId(clientId));\n        }\n        System.out.println(\"====================\\n\");\n    }\n\n    private String maskEndpoint(String endpoint) {\n        if (endpoint.length() > 20) {\n            return endpoint.substring(0, 20) + \"...\";\n        }\n        return endpoint;\n    }\n\n    private String maskClientId(String clientId) {\n        if (clientId.length() > 8) {\n            return clientId.substring(0, 8) + \"...\";\n        }\n        return clientId;\n    }\n}\n```\n\n## Product.java\n\n```java\npackage com.azure.identity.demo.model;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Product model for Cosmos DB.\n */\npublic class Product {\n    @JsonProperty(\"id\")\n    private String id;\n\n    @JsonProperty(\"name\")\n    private String name;\n\n    @JsonProperty(\"category\")\n    private String category;\n\n    @JsonProperty(\"price\")\n    private double price;\n\n    @JsonProperty(\"description\")\n    private String description;\n\n    public Product() {\n    }\n\n    public Product(String id, String name, String category, double price, String description) {\n        this.id = id;\n        this.name = name;\n        this.category = category;\n        this.price = price;\n        this.description = description;\n    }\n\n    // Getters and Setters\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getCategory() {\n        return category;\n    }\n\n    public void setCategory(String category) {\n        this.category = category;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Product{id='%s', name='%s', category='%s', price=%.2f, description='%s'}\",\n                id, name, category, price, description);\n    }\n}\n```\n\n## CosmosService.java\n\n```java\npackage com.azure.identity.demo.service;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosContainer;\nimport com.azure.cosmos.CosmosDatabase;\nimport com.azure.cosmos.models.CosmosItemRequestOptions;\nimport com.azure.cosmos.models.CosmosItemResponse;\nimport com.azure.cosmos.models.CosmosQueryRequestOptions;\nimport com.azure.cosmos.models.PartitionKey;\nimport com.azure.cosmos.util.CosmosPagedIterable;\nimport com.azure.identity.demo.model.Product;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Service class for Cosmos DB operations.\n */\npublic class CosmosService {\n    private static final Logger logger = LoggerFactory.getLogger(CosmosService.class);\n    \n    private final CosmosClient cosmosClient;\n    private final String databaseName;\n    private final String containerName;\n    private CosmosContainer container;\n\n    public CosmosService(CosmosClient cosmosClient, String databaseName, String containerName) {\n        this.cosmosClient = cosmosClient;\n        this.databaseName = databaseName;\n        this.containerName = containerName;\n    }\n\n    /**\n     * Initializes the database and container, creating them if they don't exist.\n     */\n    public void initialize() {\n        try {\n            logger.info(\"Initializing Cosmos DB connection...\");\n            \n            // Get or create database\n            CosmosDatabase database = cosmosClient.getDatabase(databaseName);\n            logger.info(\"Connected to database: {}\", databaseName);\n\n            // Get container\n            container = database.getContainer(containerName);\n            logger.info(\"Connected to container: {}\", containerName);\n            \n            logger.info(\"Cosmos DB initialization successful\");\n        } catch (Exception e) {\n            logger.error(\"Failed to initialize Cosmos DB\", e);\n            throw new RuntimeException(\"Cosmos DB initialization failed\", e);\n        }\n    }\n\n    /**\n     * Creates a product in Cosmos DB.\n     */\n    public Product createProduct(Product product) {\n        try {\n            logger.info(\"Creating product: {}\", product.getId());\n            \n            CosmosItemResponse<Product> response = container.createItem(\n                product,\n                new PartitionKey(product.getCategory()),\n                new CosmosItemRequestOptions()\n            );\n            \n            logger.info(\"Product created successfully. RU charge: {}\", \n                response.getRequestCharge());\n            \n            return response.getItem();\n        } catch (Exception e) {\n            logger.error(\"Failed to create product: {}\", product.getId(), e);\n            throw new RuntimeException(\"Failed to create product\", e);\n        }\n    }\n\n    /**\n     * Reads a product by ID and partition key.\n     */\n    public Product readProduct(String id, String category) {\n        try {\n            logger.info(\"Reading product: {} in category: {}\", id, category);\n            \n            CosmosItemResponse<Product> response = container.readItem(\n                id,\n                new PartitionKey(category),\n                Product.class\n            );\n            \n            logger.info(\"Product read successfully. RU charge: {}\", \n                response.getRequestCharge());\n            \n            return response.getItem();\n        } catch (Exception e) {\n            logger.error(\"Failed to read product: {}\", id, e);\n            return null;\n        }\n    }\n\n    /**\n     * Queries products by category.\n     */\n    public List<Product> queryProductsByCategory(String category) {\n        try {\n            logger.info(\"Querying products in category: {}\", category);\n            \n            String query = \"SELECT * FROM c WHERE c.category = @category\";\n            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n            \n            CosmosPagedIterable<Product> results = container.queryItems(\n                query,\n                options,\n                Product.class\n            );\n            \n            List<Product> products = new ArrayList<>();\n            results.forEach(products::add);\n            \n            logger.info(\"Query returned {} products\", products.size());\n            return products;\n        } catch (Exception e) {\n            logger.error(\"Failed to query products by category: {}\", category, e);\n            throw new RuntimeException(\"Failed to query products\", e);\n        }\n    }\n\n    /**\n     * Queries all products with price greater than specified amount.\n     */\n    public List<Product> queryProductsByMinPrice(double minPrice) {\n        try {\n            logger.info(\"Querying products with price >= {}\", minPrice);\n            \n            String query = \"SELECT * FROM c WHERE c.price >= @minPrice ORDER BY c.price\";\n            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n            \n            CosmosPagedIterable<Product> results = container.queryItems(\n                query,\n                options,\n                Product.class\n            );\n            \n            List<Product> products = new ArrayList<>();\n            results.forEach(products::add);\n            \n            logger.info(\"Query returned {} products\", products.size());\n            return products;\n        } catch (Exception e) {",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10850,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses ChainedTokenCredential for Azure Cosmos DB authentication with proper error handling.\n\nFirst, let me check the current project structure and dependencies:\n\n<read_file>\n<path>pom.xml</path>\n</read_file>\n\nNow I'll create the complete solution:\n\n<write_file>\n<path>pom.xml</path>\n<content>\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.2.0</version>\n        <relativePath/>\n    </parent>\n\n    <groupId>com.example</groupId>\n    <artifactId>app</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <properties>\n        <java.version>21</java.version>\n        <maven.compiler.source>21</maven.compiler.source>\n        <maven.compiler.target>21</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure-identity.version>1.18.2</azure-identity.version>\n        <azure-cosmos.version>4.53.1</azure-cosmos.version>\n    </properties>\n\n    <dependencies>\n        <!-- Spring Boot Starter -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure-identity.version}</version>\n        </dependency>\n\n        <!-- Azure Cosmos DB -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-cosmos</artifactId>\n            <version>${azure-cosmos.version}</version>\n        </dependency>\n\n        <!-- Logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n        </dependency>\n\n        <!-- Testing -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n</content>\n</write_file>\n\n<write_file>\n<path>src/main/java/com/example/app/config/CosmosDbConfig.java</path>\n<content>\npackage com.example.app.config;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosClientBuilder;\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.identity.AzureCliCredential;\nimport com.azure.identity.AzureCliCredentialBuilder;\nimport com.azure.identity.ChainedTokenCredential;\nimport com.azure.identity.ChainedTokenCredentialBuilder;\nimport com.azure.identity.ManagedIdentityCredential;\nimport com.azure.identity.ManagedIdentityCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Configuration for Azure Cosmos DB client with ChainedTokenCredential.\n * Uses ManagedIdentity for production (Azure) and AzureCli for local development.\n */\n@Configuration\npublic class CosmosDbConfig {\n    \n    private static final Logger log = LoggerFactory.getLogger(CosmosDbConfig.class);\n\n    @Value(\"${azure.cosmos.endpoint}\")\n    private String cosmosEndpoint;\n\n    @Value(\"${azure.cosmos.database}\")\n    private String databaseName;\n\n    @Value(\"${azure.managed-identity.client-id:#{null}}\")\n    private String managedIdentityClientId;\n\n    /**\n     * Creates a ChainedTokenCredential that tries:\n     * 1. ManagedIdentityCredential (for Azure-hosted apps)\n     * 2. AzureCliCredential (for local development with 'az login')\n     */\n    @Bean\n    public TokenCredential azureCredential() {\n        log.info(\"Creating ChainedTokenCredential for Azure authentication\");\n\n        // Create ManagedIdentityCredential\n        ManagedIdentityCredentialBuilder miBuilder = new ManagedIdentityCredentialBuilder();\n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            log.info(\"Configuring user-assigned managed identity with client ID: {}\", \n                     managedIdentityClientId);\n            miBuilder.clientId(managedIdentityClientId);\n        } else {\n            log.info(\"Configuring system-assigned managed identity\");\n        }\n        ManagedIdentityCredential managedIdentityCredential = miBuilder.build();\n\n        // Create AzureCliCredential\n        AzureCliCredential azureCliCredential = new AzureCliCredentialBuilder()\n            .build();\n\n        // Chain credentials: try ManagedIdentity first, then AzureCli\n        ChainedTokenCredential credential = new ChainedTokenCredentialBuilder()\n            .addFirst(managedIdentityCredential)\n            .addLast(azureCliCredential)\n            .build();\n\n        log.info(\"ChainedTokenCredential created successfully\");\n        return credential;\n    }\n\n    /**\n     * Creates Azure Cosmos DB client using the chained credential.\n     */\n    @Bean\n    public CosmosClient cosmosClient(TokenCredential credential) {\n        log.info(\"Creating Cosmos DB client for endpoint: {}\", cosmosEndpoint);\n\n        CosmosClient client = new CosmosClientBuilder()\n            .endpoint(cosmosEndpoint)\n            .credential(credential)\n            .buildClient();\n\n        log.info(\"Cosmos DB client created successfully\");\n        return client;\n    }\n\n    @Bean\n    public String cosmosDatabaseName() {\n        return databaseName;\n    }\n}\n</content>\n</write_file>\n\n<write_file>\n<path>src/main/java/com/example/app/model/Product.java</path>\n<content>\npackage com.example.app.model;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Product entity for Cosmos DB.\n */\npublic class Product {\n    \n    @JsonProperty(\"id\")\n    private String id;\n    \n    @JsonProperty(\"name\")\n    private String name;\n    \n    @JsonProperty(\"category\")\n    private String category;\n    \n    @JsonProperty(\"price\")\n    private Double price;\n    \n    @JsonProperty(\"description\")\n    private String description;\n\n    // Cosmos DB requires a partition key\n    @JsonProperty(\"partitionKey\")\n    private String partitionKey;\n\n    public Product() {\n    }\n\n    public Product(String id, String name, String category, Double price, String description) {\n        this.id = id;\n        this.name = name;\n        this.category = category;\n        this.price = price;\n        this.description = description;\n        this.partitionKey = category; // Using category as partition key\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getCategory() {\n        return category;\n    }\n\n    public void setCategory(String category) {\n        this.category = category;\n        this.partitionKey = category;\n    }\n\n    public Double getPrice() {\n        return price;\n    }\n\n    public void setPrice(Double price) {\n        this.price = price;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public String getPartitionKey() {\n        return partitionKey;\n    }\n\n    public void setPartitionKey(String partitionKey) {\n        this.partitionKey = partitionKey;\n    }\n\n    @Override\n    public String toString() {\n        return \"Product{\" +\n                \"id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", category='\" + category + '\\'' +\n                \", price=\" + price +\n                \", description='\" + description + '\\'' +\n                '}';\n    }\n}\n</content>\n</write_file>\n\n<write_file>\n<path>src/main/java/com/example/app/service/CosmosDbService.java</path>\n<content>\npackage com.example.app.service;\n\nimport com.azure.cosmos.CosmosClient;\nimport com.azure.cosmos.CosmosContainer;\nimport com.azure.cosmos.CosmosDatabase;\nimport com.azure.cosmos.models.CosmosItemRequestOptions;\nimport com.azure.cosmos.models.CosmosItemResponse;\nimport com.azure.cosmos.models.CosmosQueryRequestOptions;\nimport com.azure.cosmos.models.PartitionKey;\nimport com.azure.cosmos.util.CosmosPagedIterable;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.example.app.model.Product;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Service for interacting with Azure Cosmos DB.\n * Handles authentication errors from ChainedTokenCredential.\n */\n@Service\npublic class CosmosDbService {\n    \n    private static final Logger log = LoggerFactory.getLogger(CosmosDbService.class);\n\n    private final CosmosClient cosmosClient;\n    private final String databaseName;\n    \n    @Value(\"${azure.cosmos.container}\")\n    private String containerName;\n\n    public CosmosDbService(CosmosClient cosmosClient, String cosmosDatabaseName) {\n        this.cosmosClient = cosmosClient;\n        this.databaseName = cosmosDatabaseName;\n    }\n\n    /**\n     * Gets the Cosmos DB container with proper error handling.\n     */\n    private CosmosContainer getContainer() {\n        try {\n            CosmosDatabase database = cosmosClient.getDatabase(databaseName);\n            return database.getContainer(containerName);\n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential in the chain could authenticate. \" +\n                     \"Ensure you're either running on Azure with Managed Identity \" +\n                     \"or logged in via 'az login' for local development.\", e);\n            throw new RuntimeException(\"Authentication failed: No valid credential available\", e);\n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed with the available credentials. \" +\n                     \"Check your Azure permissions and credential configuration.\", e);\n            throw new RuntimeException(\"Authentication failed: \" + e.getMessage(), e);\n        } catch (Exception e) {\n            log.error(\"Failed to get Cosmos DB container\", e);\n            throw new RuntimeException(\"Failed to access Cosmos DB\", e);\n        }\n    }\n\n    /**\n     * Creates a new product in Cosmos DB.\n     */\n    public Product createProduct(Product product) {\n        try {\n            log.info(\"Creating product: {}\", product.getName());\n            CosmosContainer container = getContainer();\n            \n            CosmosItemResponse<Product> response = container.createItem(\n                product,\n                new PartitionKey(product.getPartitionKey()),\n                new CosmosItemRequestOptions()\n            );\n            \n            Product createdProduct = response.getItem();\n            log.info(\"Product created successfully with id: {}\", createdProduct.getId());\n            return createdProduct;\n            \n        } catch (Exception e) {\n            log.error(\"Failed to create product: {}\", product.getName(), e);\n            throw new RuntimeException(\"Failed to create product\", e);\n        }\n    }\n\n    /**\n     * Retrieves a product by ID and partition key.\n     */\n    public Product getProduct(String id, String partitionKey) {\n        try {\n            log.info(\"Retrieving product with id: {} and partition key: {}\", id, partitionKey);\n            CosmosContainer container = getContainer();\n            \n            CosmosItemResponse<Product> response = container.readItem(\n                id,\n                new PartitionKey(partitionKey),\n                Product.class\n            );\n            \n            Product product = response.getItem();\n            log.info(\"Product retrieved successfully: {}\", product);\n            return product;\n            \n        } catch (Exception e) {\n            log.error(\"Failed to retrieve product with id: {}\", id, e);\n            throw new RuntimeException(\"Failed to retrieve product\", e);\n        }\n    }\n\n    /**\n     * Queries products by category using SQL query.\n     */\n    public List<Product> queryProductsByCategory(String category) {\n        try {\n            log.info(\"Querying products by category: {}\", category);\n            CosmosContainer container = getContainer();\n            \n            String query = \"SELECT * FROM c WHERE c.category = @category\";\n            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n            options.setPartitionKey(new PartitionKey(category));\n            \n            CosmosPagedIterable<Product> results = container.queryItems(\n                query,\n                options,\n                Product.class\n            );\n            \n            List<Product> products = new ArrayList<>();\n            results.forEach(products::add);\n            \n            log.info(\"Found {} products in category: {}\", products.size(), category);\n            return products;\n            \n        } catch (Exception e) {\n            log.error(\"Failed to query products by category: {}\", category, e);\n            throw new RuntimeException(\"Failed to query products\", e);\n        }\n    }\n\n    /**\n     * Queries all products with price greater than specified amount.\n     */\n    public List<Product> queryProductsByMinPrice(Double minPrice) {\n        try {\n            log.info(\"Querying products with price >= {}\", minPrice);\n            CosmosContainer container = getContainer();\n            \n            String query = \"SELECT * FROM c WHERE c.price >= @minPrice\";\n            CosmosQueryRequestOptions options = new CosmosQueryRequestOptions();\n            \n            CosmosPagedIterable<Product> results = container.queryItems(\n                query,\n                options,\n                Product.class\n            );\n            \n            List<Product> products = new ArrayList<>();\n            results.forEach(products::add);\n            \n            log.info(\"Found {} products with price >= {}\", products.size(), minPrice);\n            return products;\n            \n        } catch (Exception e) {\n            log.error(\"Failed to query products by price\", e);\n            throw new RuntimeException(\"Failed to query products\",",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11375,
            "output_tokens": 4096,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-identity-java-04",
      "task_type": "grounded",
      "target_language": "java",
      "expected_patterns": [
        "DefaultAzureCredentialBuilder\\(\\)",
        "\\.build\\(\\)",
        "new DefaultAzureCredentialBuilder\\(\\)\\.build\\(\\)",
        "try.*catch|throws",
        "SecretClientBuilder"
      ],
      "anti_patterns": [
        "new DefaultAzureCredential\\(\\)(?!\\.)",
        "from azure\\.identity",
        "credential\\s*=\\s*DefaultAzureCredential\\(\\)",
        "SecretClient\\.create|secret_client"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.defaultazurecredentialbuilder",
          "description": "Java DefaultAzureCredentialBuilder: must use new DefaultAzureCredentialBuilder().build(), not direct constructor"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclientbuilder",
          "description": "Java SecretClientBuilder: vaultUrl, credential, build() pattern"
        },
        {
          "url": "https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html",
          "description": "Java exception handling - source of try/catch blocks and throws keyword for proper error handling in fixes"
        },
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-identity/azure.identity.defaultazurecredential",
          "description": "Anti-patterns: Python DefaultAzureCredential() direct instantiation, from azure.identity"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Fixed Java Code with Proper Azure Authentication\n\nHere's the corrected code with proper authentication handling for both CI/CD and Azure environments:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.AzureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretService {\n    private static final Logger logger = LoggerFactory.getLogger(SecretService.class);\n    \n    public String getSecret(String vaultUrl, String secretName) {\n        try {\n            // Build credential with proper configuration\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .build();\n            \n            SecretClient client = new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(credential)\n                .buildClient();\n            \n            return client.getSecret(secretName).getValue();\n            \n        } catch (AzureException e) {\n            logger.error(\"Failed to retrieve secret '{}' from vault '{}': {}\", \n                secretName, vaultUrl, e.getMessage());\n            throw new RuntimeException(\"Authentication or secret retrieval failed\", e);\n        }\n    }\n}\n```\n\n## Key Issues Fixed:\n\n1. **Missing Builder Pattern**: Changed `new DefaultAzureCredential()` to `new DefaultAzureCredentialBuilder().build()`\n\n2. **Wrong Build Method**: Changed `.build()` to `.buildClient()` for `SecretClientBuilder`\n\n3. **Added Error Handling**: Included try-catch for better debugging\n\n## Enhanced Version with Custom Configuration:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.AzureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretService {\n    private static final Logger logger = LoggerFactory.getLogger(SecretService.class);\n    private final SecretClient secretClient;\n    \n    public SecretService(String vaultUrl) {\n        this.secretClient = createSecretClient(vaultUrl);\n    }\n    \n    private SecretClient createSecretClient(String vaultUrl) {\n        try {\n            // DefaultAzureCredential tries credentials in this order:\n            // 1. Environment variables (for CI/CD)\n            // 2. Managed Identity (for Azure resources)\n            // 3. Azure CLI\n            // 4. IntelliJ/VS Code\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .managedIdentityClientId(System.getenv(\"AZURE_CLIENT_ID\")) // Optional: specific managed identity\n                .build();\n            \n            logger.info(\"Initializing SecretClient for vault: {}\", vaultUrl);\n            \n            return new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(credential)\n                .buildClient();\n                \n        } catch (Exception e) {\n            logger.error(\"Failed to create SecretClient for vault '{}': {}\", vaultUrl, e.getMessage());\n            throw new RuntimeException(\"Failed to initialize Azure Key Vault client\", e);\n        }\n    }\n    \n    public String getSecret(String secretName) {\n        try {\n            logger.debug(\"Retrieving secret: {}\", secretName);\n            String secretValue = secretClient.getSecret(secretName).getValue();\n            logger.debug(\"Successfully retrieved secret: {}\", secretName);\n            return secretValue;\n            \n        } catch (AzureException e) {\n            logger.error(\"Failed to retrieve secret '{}': {}\", secretName, e.getMessage());\n            throw new RuntimeException(\"Secret retrieval failed: \" + secretName, e);\n        }\n    }\n}\n```\n\n## Environment Variables for CI/CD:\n\nSet these environment variables in your CI/CD pipeline:\n\n```bash\n# For Service Principal authentication\nAZURE_CLIENT_ID=<your-client-id>\nAZURE_CLIENT_SECRET=<your-client-secret>\nAZURE_TENANT_ID=<your-tenant-id>\n```\n\n## Maven Dependencies:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-secrets</artifactId>\n        <version>4.6.0</version>\n    </dependency>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.11.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n        <version>2.0.9</version>\n    </dependency>\n</dependencies>\n```\n\n## Usage Example:\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String vaultUrl = \"https://your-keyvault.vault.azure.net/\";\n        SecretService secretService = new SecretService(vaultUrl);\n        \n        String secret = secretService.getSecret(\"my-secret-name\");\n        System.out.println(\"Secret retrieved successfully\");\n    }\n}\n```\n\nThe `DefaultAzureCredential` will automatically handle authentication for both CI/CD (using environment variables) and Azure environments (using Managed Identity).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 210,
            "output_tokens": 1412,
            "cached": false
          },
          "with_skill": {
            "output": "# Fixed Java Code with Proper Authentication\n\nHere's the corrected code with proper error handling, credential configuration, and best practices:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\n\npublic class SecretService {\n    private final SecretClient client;\n    \n    /**\n     * Constructor that initializes the SecretClient with DefaultAzureCredential.\n     * Works with environment variables in CI/CD and managed identity in Azure.\n     */\n    public SecretService(String vaultUrl) {\n        // Use DefaultAzureCredentialBuilder (not direct constructor)\n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n            .build();\n        \n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n    \n    /**\n     * Constructor with user-assigned managed identity support\n     */\n    public SecretService(String vaultUrl, String managedIdentityClientId) {\n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n            .managedIdentityClientId(managedIdentityClientId)\n            .build();\n        \n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n    \n    /**\n     * Retrieves a secret from Key Vault with proper error handling\n     */\n    public String getSecret(String secretName) {\n        try {\n            return client.getSecret(secretName).getValue();\n        } catch (CredentialUnavailableException e) {\n            throw new RuntimeException(\n                \"No credential available. Ensure environment variables are set \" +\n                \"(AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_CLIENT_SECRET) or \" +\n                \"managed identity is configured.\", e);\n        } catch (ClientAuthenticationException e) {\n            throw new RuntimeException(\n                \"Authentication failed: \" + e.getMessage(), e);\n        }\n    }\n}\n```\n\n## Key Issues Fixed\n\n### 1. **Incorrect Credential Instantiation**\n\u274c **Wrong:**\n```java\nDefaultAzureCredential credential = new DefaultAzureCredential();\n```\n\n\u2705 **Correct:**\n```java\nDefaultAzureCredential credential = new DefaultAzureCredentialBuilder().build();\n```\n\n### 2. **Missing Error Handling**\nThe original code had no error handling for authentication failures.\n\n### 3. **Client Recreation on Every Call**\nCreating a new credential and client for each method call is inefficient.\n\n## Environment Variables for CI/CD\n\nSet these environment variables in your CI/CD pipeline:\n\n```bash\n# For Service Principal authentication\nAZURE_TENANT_ID=<your-tenant-id>\nAZURE_CLIENT_ID=<your-client-id>\nAZURE_CLIENT_SECRET=<your-client-secret>\n\n# Optional: For user-assigned managed identity\nAZURE_CLIENT_ID=<user-assigned-mi-client-id>\n```\n\n## Usage Examples\n\n### Basic Usage (System-Assigned Managed Identity or Environment Variables)\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String vaultUrl = \"https://myvault.vault.azure.net\";\n        SecretService service = new SecretService(vaultUrl);\n        \n        try {\n            String secretValue = service.getSecret(\"my-secret\");\n            System.out.println(\"Secret retrieved successfully\");\n        } catch (RuntimeException e) {\n            System.err.println(\"Failed to retrieve secret: \" + e.getMessage());\n        }\n    }\n}\n```\n\n### With User-Assigned Managed Identity\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String vaultUrl = \"https://myvault.vault.azure.net\";\n        String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n        \n        SecretService service = new SecretService(vaultUrl, clientId);\n        String secretValue = service.getSecret(\"my-secret\");\n    }\n}\n```\n\n## Advanced: Custom Credential Chain\n\nIf you need more control over the authentication order:\n\n```java\nimport com.azure.identity.ChainedTokenCredential;\nimport com.azure.identity.ChainedTokenCredentialBuilder;\nimport com.azure.identity.ManagedIdentityCredentialBuilder;\nimport com.azure.identity.EnvironmentCredentialBuilder;\n\npublic class SecretService {\n    private final SecretClient client;\n    \n    public SecretService(String vaultUrl) {\n        // Try managed identity first, then environment variables\n        ChainedTokenCredential credential = new ChainedTokenCredentialBuilder()\n            .addFirst(new ManagedIdentityCredentialBuilder().build())\n            .addLast(new EnvironmentCredentialBuilder().build())\n            .build();\n        \n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n    \n    public String getSecret(String secretName) {\n        try {\n            return client.getSecret(secretName).getValue();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to retrieve secret: \" + e.getMessage(), e);\n        }\n    }\n}\n```\n\n## Maven Dependencies\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.15.0</version>\n    </dependency>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-secrets</artifactId>\n        <version>4.9.0</version>\n    </dependency>\n</dependencies>\n```\n\n## Troubleshooting\n\n### Enable Logging\n\n```java\n// Set environment variable\nSystem.setProperty(\"AZURE_LOG_LEVEL\", \"verbose\");\n\n// Or via environment\n// AZURE_LOG_LEVEL=verbose\n```\n\n### Test Authentication\n\n```java\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.core.credential.AccessToken;\n\nDefaultAzureCredential credential = new DefaultAzureCredentialBuilder().build();\ntry {\n    AccessToken token = credential.getToken(\n        new TokenRequestContext().addScopes(\"https://vault.azure.net/.default\")\n    ).block();\n    System.out.println(\"Authentication successful!\");\n} catch (Exception e) {\n    System.err.println(\"Authentication failed: \" + e.getMessage());\n}\n```\n\nThe fixed code now properly:\n- Uses `DefaultAzureCredentialBuilder` instead of direct constructor\n- Handles authentication errors gracefully\n- Reuses the client instance for efficiency\n- Supports both environment variables and managed identity\n- Provides clear error messages for troubleshooting",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10987,
            "output_tokens": 1751,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "Here's the fixed code with proper authentication setup:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretService {\n    private static final Logger log = LoggerFactory.getLogger(SecretService.class);\n    private final DefaultAzureCredential credential;\n\n    public SecretService() {\n        // Build credential properly using builder pattern\n        this.credential = new DefaultAzureCredentialBuilder()\n            .managedIdentityClientId(System.getenv(\"AZURE_CLIENT_ID\"))  // For user-assigned MI\n            .build();\n        \n        log.info(\"DefaultAzureCredential initialized\");\n    }\n\n    public String getSecret(String vaultUrl, String secretName) {\n        try {\n            SecretClient client = new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(credential)\n                .buildClient();  // Use buildClient() instead of build()\n            \n            String secretValue = client.getSecret(secretName).getValue();\n            log.info(\"Successfully retrieved secret: {}\", secretName);\n            return secretValue;\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential available for authentication: {}\", e.getMessage());\n            throw new RuntimeException(\"Authentication failed - no credential available\", e);\n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed: {}\", e.getMessage());\n            throw new RuntimeException(\"Authentication failed\", e);\n        }\n    }\n}\n```\n\n## Key Fixes:\n\n1. **Use Builder Pattern**: Changed `new DefaultAzureCredential()` to `new DefaultAzureCredentialBuilder().build()`\n\n2. **Support User-Assigned Managed Identity**: Added `.managedIdentityClientId()` to support user-assigned MI in Azure (reads from `AZURE_CLIENT_ID` env var)\n\n3. **Reuse Credential**: Moved credential to constructor to avoid recreating it on every call\n\n4. **Correct Method Name**: Changed `.build()` to `.buildClient()` for `SecretClientBuilder`\n\n5. **Error Handling**: Added proper exception handling for authentication failures\n\n6. **Logging**: Added logging for debugging authentication issues\n\n## Environment Variables for CI/CD:\n\n```bash\n# Service Principal with Secret\nAZURE_TENANT_ID=<tenant-id>\nAZURE_CLIENT_ID=<client-id>\nAZURE_CLIENT_SECRET=<client-secret>\n\n# Or Service Principal with Certificate\nAZURE_TENANT_ID=<tenant-id>\nAZURE_CLIENT_ID=<client-id>\nAZURE_CLIENT_CERTIFICATE_PATH=/path/to/cert.pem\n```\n\n## For Azure Managed Identity:\n\n- **System-assigned**: No env vars needed, works automatically\n- **User-assigned**: Set `AZURE_CLIENT_ID` to the managed identity client ID\n\nThe `DefaultAzureCredential` will automatically try authentication methods in this order:\n1. Environment variables (CI/CD)\n2. Managed Identity (Azure)\n3. Azure CLI (local dev)\n4. Other methods...",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11512,
            "output_tokens": 843,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Fixed Java Code with Proper Authentication\n\nHere's the corrected code with proper authentication handling for both CI/CD and Azure environments:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.AzureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretService {\n    private static final Logger logger = LoggerFactory.getLogger(SecretService.class);\n    \n    public String getSecret(String vaultUrl, String secretName) {\n        try {\n            // Build DefaultAzureCredential with proper configuration\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .build();\n            \n            SecretClient client = new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(credential)\n                .build();\n                \n            return client.getSecret(secretName).getValue();\n            \n        } catch (AzureException e) {\n            logger.error(\"Failed to retrieve secret '{}' from vault '{}': {}\", \n                secretName, vaultUrl, e.getMessage());\n            throw new RuntimeException(\"Authentication or secret retrieval failed\", e);\n        }\n    }\n}\n```\n\n## Key Issues Fixed\n\n### 1. **Using DefaultAzureCredentialBuilder**\n```java\n// \u274c Wrong - doesn't use builder pattern\nDefaultAzureCredential credential = new DefaultAzureCredential();\n\n// \u2705 Correct - uses builder\nDefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n    .build();\n```\n\n### 2. **Enhanced Configuration for Different Environments**\n\nFor more control over the authentication chain:\n\n```java\npublic class SecretService {\n    private static final Logger logger = LoggerFactory.getLogger(SecretService.class);\n    \n    private DefaultAzureCredential createCredential() {\n        return new DefaultAzureCredentialBuilder()\n            // Exclude certain credential types if needed\n            // .excludeEnvironmentCredential()\n            // .excludeManagedIdentityCredential()\n            \n            // Set managed identity client ID if using user-assigned identity\n            .managedIdentityClientId(System.getenv(\"AZURE_CLIENT_ID\"))\n            \n            // Enable additional logging for troubleshooting\n            .build();\n    }\n    \n    public String getSecret(String vaultUrl, String secretName) {\n        try {\n            DefaultAzureCredential credential = createCredential();\n            \n            SecretClient client = new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(credential)\n                .build();\n                \n            String secretValue = client.getSecret(secretName).getValue();\n            logger.info(\"Successfully retrieved secret: {}\", secretName);\n            return secretValue;\n            \n        } catch (AzureException e) {\n            logger.error(\"Failed to retrieve secret '{}': {}\", secretName, e.getMessage(), e);\n            throw new RuntimeException(\"Authentication or secret retrieval failed\", e);\n        }\n    }\n}\n```\n\n## Environment Variables for CI/CD\n\nSet these environment variables in your CI/CD pipeline:\n\n```bash\n# For Service Principal authentication\nAZURE_CLIENT_ID=<your-client-id>\nAZURE_CLIENT_SECRET=<your-client-secret>\nAZURE_TENANT_ID=<your-tenant-id>\n```\n\n## Maven Dependencies\n\nEnsure you have the correct dependencies:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-secrets</artifactId>\n        <version>4.6.0</version>\n    </dependency>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.11.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n        <version>2.0.9</version>\n    </dependency>\n</dependencies>\n```\n\n## Authentication Chain Order\n\n`DefaultAzureCredential` tries these methods in order:\n1. **Environment Variables** (CI/CD)\n2. **Managed Identity** (Azure resources)\n3. **Azure CLI** (local development)\n4. **IntelliJ/VS Code** (IDE authentication)\n\nThis ensures it works in both CI/CD and Azure environments automatically.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 210,
            "output_tokens": 1147,
            "cached": false
          },
          "with_skill": {
            "output": "# Fixed Java Code with Proper Authentication\n\nHere's the corrected code with proper error handling, credential configuration, and best practices:\n\n## \u2705 Fixed Code\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\n\npublic class SecretService {\n    private final SecretClient client;\n    \n    public SecretService(String vaultUrl) {\n        // Use builder pattern - DefaultAzureCredential() constructor is deprecated\n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n            .build();\n        \n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n    \n    public String getSecret(String secretName) {\n        try {\n            return client.getSecret(secretName).getValue();\n        } catch (CredentialUnavailableException e) {\n            throw new RuntimeException(\"No credential available for authentication: \" + e.getMessage(), e);\n        } catch (ClientAuthenticationException e) {\n            throw new RuntimeException(\"Authentication failed: \" + e.getMessage(), e);\n        }\n    }\n}\n```\n\n## \ud83d\udd27 Key Issues Fixed\n\n1. **\u274c Wrong Constructor**: `new DefaultAzureCredential()` is deprecated\n   - **\u2705 Fixed**: Use `new DefaultAzureCredentialBuilder().build()`\n\n2. **\u274c No Error Handling**: Silent failures on authentication errors\n   - **\u2705 Fixed**: Added proper exception handling\n\n3. **\u274c Client Recreation**: Creating new client on every call is inefficient\n   - **\u2705 Fixed**: Reuse client instance\n\n4. **\u274c No Configuration**: Can't customize credential behavior\n   - **\u2705 Fixed**: Builder pattern allows configuration\n\n## \ud83c\udfaf Enhanced Version with Configuration\n\nFor production use with more control:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretService {\n    private static final Logger logger = LoggerFactory.getLogger(SecretService.class);\n    private final SecretClient client;\n    \n    public SecretService(String vaultUrl) {\n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n            // Optional: Specify user-assigned managed identity\n            .managedIdentityClientId(System.getenv(\"AZURE_CLIENT_ID\"))\n            // Optional: Limit to specific tenant\n            .tenantId(System.getenv(\"AZURE_TENANT_ID\"))\n            .build();\n        \n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n        \n        logger.info(\"SecretService initialized for vault: {}\", vaultUrl);\n    }\n    \n    public String getSecret(String secretName) {\n        try {\n            logger.debug(\"Retrieving secret: {}\", secretName);\n            String value = client.getSecret(secretName).getValue();\n            logger.debug(\"Successfully retrieved secret: {}\", secretName);\n            return value;\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"No credential available for authentication\", e);\n            throw new RuntimeException(\"Authentication configuration error: \" + e.getMessage(), e);\n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Authentication failed\", e);\n            throw new RuntimeException(\"Failed to authenticate with Azure: \" + e.getMessage(), e);\n        } catch (Exception e) {\n            logger.error(\"Failed to retrieve secret: {}\", secretName, e);\n            throw new RuntimeException(\"Failed to retrieve secret: \" + e.getMessage(), e);\n        }\n    }\n}\n```\n\n## \ud83d\udd10 Environment Variables Setup\n\n### For CI/CD (Service Principal with Secret):\n```bash\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\n```\n\n### For CI/CD (Service Principal with Certificate):\n```bash\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_CERTIFICATE_PATH=\"/path/to/cert.pem\"\n```\n\n### For Azure (User-Assigned Managed Identity):\n```bash\nexport AZURE_CLIENT_ID=\"your-managed-identity-client-id\"\n```\n\n## \ud83d\udcdd Usage Example\n\n```java\npublic class Application {\n    public static void main(String[] args) {\n        String vaultUrl = \"https://your-vault.vault.azure.net\";\n        SecretService secretService = new SecretService(vaultUrl);\n        \n        try {\n            String dbPassword = secretService.getSecret(\"database-password\");\n            System.out.println(\"Successfully retrieved secret\");\n            // Use the secret...\n        } catch (RuntimeException e) {\n            System.err.println(\"Failed to get secret: \" + e.getMessage());\n            System.exit(1);\n        }\n    }\n}\n```\n\n## \ud83e\uddea Testing with Different Credentials\n\n```java\nimport com.azure.identity.*;\n\npublic class SecretServiceTest {\n    \n    // For local development with Azure CLI\n    public static SecretService createWithAzureCli(String vaultUrl) {\n        AzureCliCredential credential = new AzureCliCredentialBuilder().build();\n        return new SecretService(vaultUrl, credential);\n    }\n    \n    // For testing with specific service principal\n    public static SecretService createWithServicePrincipal(\n            String vaultUrl, String tenantId, String clientId, String clientSecret) {\n        ClientSecretCredential credential = new ClientSecretCredentialBuilder()\n            .tenantId(tenantId)\n            .clientId(clientId)\n            .clientSecret(clientSecret)\n            .build();\n        return new SecretService(vaultUrl, credential);\n    }\n    \n    // Modified SecretService constructor to accept any credential\n    public SecretService(String vaultUrl, TokenCredential credential) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n}\n```\n\n## \ud83c\udfaf Authentication Flow\n\n`DefaultAzureCredential` tries these methods **in order**:\n\n1. \u2705 **EnvironmentCredential** - CI/CD with env vars\n2. \u2705 **WorkloadIdentityCredential** - AKS workload identity\n3. \u2705 **ManagedIdentityCredential** - Azure-hosted apps\n4. \u2705 **AzureCliCredential** - Local dev with `az login`\n5. \u2705 **AzurePowerShellCredential** - Local dev with PowerShell\n\nThis ensures your code works seamlessly in both CI/CD and Azure environments!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10987,
            "output_tokens": 1851,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "Here's the fixed code with proper authentication setup:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretService {\n    private static final Logger log = LoggerFactory.getLogger(SecretService.class);\n    private final DefaultAzureCredential credential;\n\n    public SecretService() {\n        // Build credential properly using builder pattern\n        this.credential = new DefaultAzureCredentialBuilder()\n            .managedIdentityClientId(System.getenv(\"AZURE_CLIENT_ID\"))  // For user-assigned MI\n            .build();\n        \n        log.info(\"DefaultAzureCredential initialized\");\n    }\n\n    public String getSecret(String vaultUrl, String secretName) {\n        try {\n            SecretClient client = new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(credential)\n                .buildClient();  // Use buildClient() not build()\n            \n            String secretValue = client.getSecret(secretName).getValue();\n            log.info(\"Successfully retrieved secret: {}\", secretName);\n            return secretValue;\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential available for authentication: {}\", e.getMessage());\n            throw new RuntimeException(\"Authentication failed - no credential available\", e);\n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed: {}\", e.getMessage());\n            throw new RuntimeException(\"Authentication failed\", e);\n        }\n    }\n}\n```\n\n## Key fixes:\n\n1. **Use `DefaultAzureCredentialBuilder()`** - The constructor was called incorrectly\n2. **Configure for user-assigned managed identity** - Added `managedIdentityClientId()` to support user-assigned MI in Azure\n3. **Use `buildClient()` not `build()`** - Correct method for SecretClientBuilder\n4. **Reuse credential instance** - Create once in constructor, not per request\n5. **Add proper error handling** - Catch `CredentialUnavailableException` and `ClientAuthenticationException`\n6. **Add logging** - Track authentication success/failure\n\n## Environment variables needed:\n\n**For CI/CD (EnvironmentCredential):**\n```bash\nAZURE_TENANT_ID=<tenant-id>\nAZURE_CLIENT_ID=<client-id>\nAZURE_CLIENT_SECRET=<client-secret>\n```\n\n**For Azure with user-assigned managed identity:**\n```bash\nAZURE_CLIENT_ID=<user-assigned-mi-client-id>\n```\n\nThe `DefaultAzureCredential` will automatically try authentication methods in this order:\n1. Environment variables (CI/CD)\n2. Workload Identity (AKS)\n3. Managed Identity (Azure App Service, Functions, VMs)\n4. Azure CLI (local development)\n\nThis works seamlessly across all environments without code changes.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11512,
            "output_tokens": 794,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Fixed Java Code with Proper Azure Authentication\n\nHere's the corrected code with proper authentication handling for both CI/CD and Azure environments:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.AzureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretService {\n    private static final Logger logger = LoggerFactory.getLogger(SecretService.class);\n    \n    public String getSecret(String vaultUrl, String secretName) {\n        try {\n            // Build credential with proper configuration\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .build();\n            \n            SecretClient client = new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(credential)\n                .buildClient();\n            \n            return client.getSecret(secretName).getValue();\n            \n        } catch (AzureException e) {\n            logger.error(\"Failed to retrieve secret '{}' from vault '{}': {}\", \n                secretName, vaultUrl, e.getMessage());\n            throw new RuntimeException(\"Secret retrieval failed\", e);\n        }\n    }\n}\n```\n\n## Key Issues Fixed:\n\n1. **Missing Builder Pattern**: Changed `new DefaultAzureCredential()` to `new DefaultAzureCredentialBuilder().build()`\n\n2. **Wrong Build Method**: Changed `.build()` to `.buildClient()` for `SecretClientBuilder`\n\n3. **Added Error Handling**: Included try-catch for better debugging\n\n## Enhanced Version with Configuration Options:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.AzureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretService {\n    private static final Logger logger = LoggerFactory.getLogger(SecretService.class);\n    private final SecretClient secretClient;\n    \n    public SecretService(String vaultUrl) {\n        this.secretClient = createSecretClient(vaultUrl);\n    }\n    \n    private SecretClient createSecretClient(String vaultUrl) {\n        try {\n            // DefaultAzureCredential tries authentication methods in this order:\n            // 1. Environment variables (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET)\n            // 2. Managed Identity\n            // 3. Azure CLI\n            // 4. IntelliJ/VS Code\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .managedIdentityClientId(System.getenv(\"AZURE_CLIENT_ID\")) // Optional: specify managed identity\n                .build();\n            \n            logger.info(\"Creating SecretClient for vault: {}\", vaultUrl);\n            \n            return new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(credential)\n                .buildClient();\n                \n        } catch (Exception e) {\n            logger.error(\"Failed to create SecretClient for vault '{}': {}\", \n                vaultUrl, e.getMessage());\n            throw new RuntimeException(\"SecretClient initialization failed\", e);\n        }\n    }\n    \n    public String getSecret(String secretName) {\n        try {\n            logger.debug(\"Retrieving secret: {}\", secretName);\n            String secretValue = secretClient.getSecret(secretName).getValue();\n            logger.debug(\"Successfully retrieved secret: {}\", secretName);\n            return secretValue;\n            \n        } catch (AzureException e) {\n            logger.error(\"Failed to retrieve secret '{}': {}\", secretName, e.getMessage());\n            throw new RuntimeException(\"Secret retrieval failed: \" + secretName, e);\n        }\n    }\n}\n```\n\n## Required Environment Variables for CI/CD:\n\n```bash\n# Service Principal Authentication (CI/CD)\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\n```\n\n## Maven Dependencies:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-secrets</artifactId>\n        <version>4.6.0</version>\n    </dependency>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.11.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n        <version>2.0.9</version>\n    </dependency>\n</dependencies>\n```\n\n## Usage Example:\n\n```java\npublic class Application {\n    public static void main(String[] args) {\n        String vaultUrl = \"https://your-keyvault.vault.azure.net/\";\n        SecretService secretService = new SecretService(vaultUrl);\n        \n        String secret = secretService.getSecret(\"my-secret-name\");\n        System.out.println(\"Secret retrieved successfully\");\n    }\n}\n```\n\nThe fixed code now properly authenticates using environment variables in CI/CD pipelines and automatically falls back to Managed Identity when running in Azure.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 210,
            "output_tokens": 1411,
            "cached": false
          },
          "with_skill": {
            "output": "# Fixed Java Authentication Code\n\nHere's the corrected code with proper error handling, credential configuration, and best practices:\n\n## \u2705 Corrected Implementation\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\n\npublic class SecretService {\n    private final SecretClient client;\n    \n    /**\n     * Constructor that initializes the SecretClient with proper credential configuration\n     */\n    public SecretService(String vaultUrl) {\n        // Build credential with proper configuration\n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n            .managedIdentityClientId(System.getenv(\"AZURE_CLIENT_ID\"))  // For user-assigned MI\n            .build();\n        \n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n    \n    /**\n     * Retrieves a secret from Key Vault with proper error handling\n     */\n    public String getSecret(String secretName) {\n        try {\n            return client.getSecret(secretName).getValue();\n        } catch (CredentialUnavailableException e) {\n            throw new RuntimeException(\"No credential available for authentication: \" + e.getMessage(), e);\n        } catch (ClientAuthenticationException e) {\n            throw new RuntimeException(\"Authentication failed: \" + e.getMessage(), e);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to retrieve secret '\" + secretName + \"': \" + e.getMessage(), e);\n        }\n    }\n}\n```\n\n## \ud83d\udd27 Key Issues Fixed\n\n### 1. **Incorrect Credential Instantiation**\n**Problem:** Using `new DefaultAzureCredential()` instead of builder pattern\n```java\n// \u274c WRONG\nDefaultAzureCredential credential = new DefaultAzureCredential();\n\n// \u2705 CORRECT\nDefaultAzureCredential credential = new DefaultAzureCredentialBuilder().build();\n```\n\n### 2. **Missing User-Assigned Managed Identity Support**\n```java\n// \u2705 Now supports user-assigned MI via AZURE_CLIENT_ID env var\nDefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n    .managedIdentityClientId(System.getenv(\"AZURE_CLIENT_ID\"))\n    .build();\n```\n\n### 3. **No Error Handling**\nAdded proper exception handling for authentication failures.\n\n### 4. **Client Instantiation in Method**\nMoved client creation to constructor for better performance and reusability.\n\n## \ud83d\udccb Required Environment Variables\n\n### For CI/CD (Service Principal with Secret):\n```bash\nAZURE_TENANT_ID=<tenant-id>\nAZURE_CLIENT_ID=<client-id>\nAZURE_CLIENT_SECRET=<client-secret>\n```\n\n### For CI/CD (Service Principal with Certificate):\n```bash\nAZURE_TENANT_ID=<tenant-id>\nAZURE_CLIENT_ID=<client-id>\nAZURE_CLIENT_CERTIFICATE_PATH=/path/to/cert.pem\nAZURE_CLIENT_CERTIFICATE_PASSWORD=<optional-password>\n```\n\n### For Azure Managed Identity (User-Assigned):\n```bash\nAZURE_CLIENT_ID=<user-assigned-identity-client-id>\n```\n\n### For Azure Managed Identity (System-Assigned):\nNo environment variables needed - works automatically in Azure.\n\n## \ud83c\udfaf Usage Examples\n\n### Basic Usage\n```java\npublic class Application {\n    public static void main(String[] args) {\n        String vaultUrl = \"https://myvault.vault.azure.net\";\n        SecretService secretService = new SecretService(vaultUrl);\n        \n        String dbPassword = secretService.getSecret(\"database-password\");\n        System.out.println(\"Retrieved secret successfully\");\n    }\n}\n```\n\n### With Configuration\n```java\npublic class Application {\n    public static void main(String[] args) {\n        // Vault URL from environment or config\n        String vaultUrl = System.getenv(\"KEY_VAULT_URL\");\n        if (vaultUrl == null) {\n            throw new IllegalStateException(\"KEY_VAULT_URL environment variable not set\");\n        }\n        \n        SecretService secretService = new SecretService(vaultUrl);\n        \n        try {\n            String apiKey = secretService.getSecret(\"api-key\");\n            // Use the secret...\n        } catch (RuntimeException e) {\n            System.err.println(\"Failed to retrieve secret: \" + e.getMessage());\n            System.exit(1);\n        }\n    }\n}\n```\n\n## \ud83d\udd12 Advanced: Custom Credential Chain\n\nIf you need more control over the authentication chain:\n\n```java\nimport com.azure.identity.ChainedTokenCredential;\nimport com.azure.identity.ChainedTokenCredentialBuilder;\nimport com.azure.identity.ManagedIdentityCredentialBuilder;\nimport com.azure.identity.EnvironmentCredentialBuilder;\n\npublic class SecretService {\n    private final SecretClient client;\n    \n    public SecretService(String vaultUrl) {\n        // Custom chain: Try managed identity first, then environment variables\n        ChainedTokenCredential credential = new ChainedTokenCredentialBuilder()\n            .addFirst(new ManagedIdentityCredentialBuilder()\n                .clientId(System.getenv(\"AZURE_CLIENT_ID\"))\n                .build())\n            .addLast(new EnvironmentCredentialBuilder().build())\n            .build();\n        \n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n    \n    public String getSecret(String secretName) {\n        try {\n            return client.getSecret(secretName).getValue();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to retrieve secret: \" + e.getMessage(), e);\n        }\n    }\n}\n```\n\n## \ud83e\uddea Testing with Different Credentials\n\n```java\nimport com.azure.identity.AzureCliCredentialBuilder;\n\npublic class SecretService {\n    private final SecretClient client;\n    \n    // Constructor for production (DefaultAzureCredential)\n    public SecretService(String vaultUrl) {\n        this(vaultUrl, new DefaultAzureCredentialBuilder().build());\n    }\n    \n    // Constructor for testing (inject credential)\n    public SecretService(String vaultUrl, TokenCredential credential) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n    \n    public String getSecret(String secretName) {\n        try {\n            return client.getSecret(secretName).getValue();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to retrieve secret: \" + e.getMessage(), e);\n        }\n    }\n}\n\n// Usage in tests\nSecretService service = new SecretService(\n    vaultUrl, \n    new AzureCliCredentialBuilder().build()  // Use Azure CLI for local testing\n);\n```\n\n## \ud83d\udce6 Maven Dependencies\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.15.0</version>\n    </dependency>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-secrets</artifactId>\n        <version>4.9.1</version>\n    </dependency>\n</dependencies>\n```\n\n## \u2705 Authentication Flow\n\n**DefaultAzureCredential** tries these methods in order:\n\n1. **EnvironmentCredential** - Reads `AZURE_TENANT_ID`, `AZURE_CLIENT_ID`, `AZURE_CLIENT_SECRET`\n2. **WorkloadIdentityCredential** - For AKS workload identity\n3. **ManagedIdentityCredential** - For Azure-hosted apps (App Service, Functions, VMs)\n4. **AzureCliCredential** - For local development with `az login`\n5. **AzurePowerShellCredential** - For local development with PowerShell\n\nThis ensures your code works seamlessly in both CI/CD and Azure environments! \ud83d\ude80",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10987,
            "output_tokens": 2098,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "Here's the fixed code with proper authentication setup:\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretService {\n    private static final Logger log = LoggerFactory.getLogger(SecretService.class);\n    \n    public String getSecret(String vaultUrl, String secretName) {\n        try {\n            // Use builder pattern - DefaultAzureCredential() constructor is deprecated\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .build();\n            \n            SecretClient client = new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(credential)\n                .buildClient();  // Use buildClient() instead of build()\n            \n            return client.getSecret(secretName).getValue();\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"No credential available for authentication: {}\", e.getMessage());\n            throw new RuntimeException(\"Authentication failed - no credential available\", e);\n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed: {}\", e.getMessage());\n            throw new RuntimeException(\"Authentication failed\", e);\n        }\n    }\n}\n```\n\n## Key fixes:\n\n1. **Use `DefaultAzureCredentialBuilder()`** - The no-arg constructor is deprecated\n2. **Call `buildClient()`** - Not just `build()` on `SecretClientBuilder`\n3. **Add error handling** - Catch `CredentialUnavailableException` and `ClientAuthenticationException`\n4. **Add logging** - For troubleshooting authentication issues\n\n## How it works:\n\n**DefaultAzureCredential** automatically tries authentication methods in this order:\n1. **EnvironmentCredential** (CI/CD) - Reads `AZURE_TENANT_ID`, `AZURE_CLIENT_ID`, `AZURE_CLIENT_SECRET`\n2. **WorkloadIdentityCredential** (AKS)\n3. **ManagedIdentityCredential** (Azure App Service, Functions, VMs)\n4. **AzureCliCredential** (local dev with `az login`)\n\n## Environment variables for CI/CD:\n\n```bash\nAZURE_TENANT_ID=<tenant-id>\nAZURE_CLIENT_ID=<client-id>\nAZURE_CLIENT_SECRET=<client-secret>\n```\n\nThe credential will automatically use managed identity when deployed to Azure (no env vars needed).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11512,
            "output_tokens": 687,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-identity-java-05",
      "task_type": "adjacent_domain",
      "target_language": "java",
      "expected_patterns": [
        "WorkloadIdentityCredentialBuilder",
        "tenantId\\(",
        "clientId\\(",
        "tokenFilePath\\(",
        "TokenRequestContext",
        "management\\.azure\\.com",
        "AZURE_LOG_LEVEL|enableAccountIdentifierLogging"
      ],
      "anti_patterns": [
        "DefaultAzureCredentialBuilder",
        "ClientSecretCredentialBuilder",
        "from azure\\.identity",
        "azidentity\\.NewWorkloadIdentityCredential",
        "WorkloadIdentityCredential\\.new"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.workloadidentitycredentialbuilder",
          "description": "Java WorkloadIdentityCredentialBuilder API reference - source of new WorkloadIdentityCredentialBuilder(), tenantId(), clientId(), and tokenFilePath() methods for AKS workload identity configuration with code examples"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.core.credential.tokenrequestcontext",
          "description": "Java TokenRequestContext API reference - source of TokenRequestContext class for specifying Azure Management API scope (https://management.azure.com/.default)"
        },
        {
          "url": "https://learn.microsoft.com/en-us/azure/developer/java/sdk/logging-overview",
          "description": "Java Azure SDK logging overview - source of AZURE_LOG_LEVEL environment variable for default logger configuration"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.defaultazurecredentialbuilder",
          "description": "Java DefaultAzureCredentialBuilder API reference - source of enableAccountIdentifierLogging() method inherited from CredentialBuilderBase for verbose authentication logging"
        },
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-identity/azure.identity.workloadidentitycredential",
          "description": "Anti-patterns: Python from azure.identity import WorkloadIdentityCredential pattern"
        },
        {
          "url": "https://pkg.go.dev/github.com/Azure/azure-sdk-for-go/sdk/azidentity",
          "description": "Anti-patterns: Go azidentity.NewWorkloadIdentityCredential function"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Azure AKS Workload Identity Authentication Application\n\nI'll create a comprehensive Java application that demonstrates using WorkloadIdentityCredential to authenticate from an AKS pod with workload identity.\n\n## Project Structure\n\n```\nazure-aks-workload-identity/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 aks/\n\u2502       \u2502               \u251c\u2500\u2500 AksWorkloadIdentityApp.java\n\u2502       \u2502               \u251c\u2500\u2500 config/\n\u2502       \u2502               \u2502   \u251c\u2500\u2500 WorkloadIdentityConfig.java\n\u2502       \u2502               \u2502   \u2514\u2500\u2500 LoggingConfig.java\n\u2502       \u2502               \u251c\u2500\u2500 service/\n\u2502       \u2502               \u2502   \u251c\u2500\u2500 TokenService.java\n\u2502       \u2502               \u2502   \u2514\u2500\u2500 AzureManagementService.java\n\u2502       \u2502               \u2514\u2500\u2500 util/\n\u2502       \u2502                   \u2514\u2500\u2500 CredentialHelper.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u251c\u2500\u2500 application.properties\n\u2502           \u2514\u2500\u2500 logback.xml\n\u251c\u2500\u2500 kubernetes/\n\u2502   \u251c\u2500\u2500 deployment.yaml\n\u2502   \u251c\u2500\u2500 service-account.yaml\n\u2502   \u2514\u2500\u2500 federated-identity.yaml\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.aks</groupId>\n    <artifactId>azure-aks-workload-identity</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure AKS Workload Identity Application</name>\n    <description>Java application using WorkloadIdentityCredential in AKS</description>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.identity.version>1.11.1</azure.identity.version>\n        <azure.core.version>1.45.1</azure.core.version>\n        <azure.resourcemanager.version>2.33.0</azure.resourcemanager.version>\n        <slf4j.version>2.0.9</slf4j.version>\n        <logback.version>1.4.14</logback.version>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure.identity.version}</version>\n        </dependency>\n\n        <!-- Azure Core -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n            <version>${azure.core.version}</version>\n        </dependency>\n\n        <!-- Azure Core HTTP Netty -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core-http-netty</artifactId>\n            <version>1.14.0</version>\n        </dependency>\n\n        <!-- Azure Resource Manager -->\n        <dependency>\n            <groupId>com.azure.resourcemanager</groupId>\n            <artifactId>azure-resourcemanager</artifactId>\n            <version>${azure.resourcemanager.version}</version>\n        </dependency>\n\n        <!-- Logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <!-- JSON Processing -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.16.1</version>\n        </dependency>\n\n        <!-- HTTP Client -->\n        <dependency>\n            <groupId>com.squareup.okhttp3</groupId>\n            <artifactId>okhttp</artifactId>\n            <version>4.12.0</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.aks.AksWorkloadIdentityApp</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## Main Application\n\n```java\n// src/main/java/com/azure/aks/AksWorkloadIdentityApp.java\npackage com.azure.aks;\n\nimport com.azure.aks.config.LoggingConfig;\nimport com.azure.aks.config.WorkloadIdentityConfig;\nimport com.azure.aks.service.AzureManagementService;\nimport com.azure.aks.service.TokenService;\nimport com.azure.aks.util.CredentialHelper;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Main application demonstrating Azure Workload Identity authentication from AKS\n */\npublic class AksWorkloadIdentityApp {\n    private static final Logger logger = LoggerFactory.getLogger(AksWorkloadIdentityApp.class);\n    \n    private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\n    public static void main(String[] args) {\n        try {\n            // Configure verbose logging\n            LoggingConfig.configureVerboseLogging();\n            \n            logger.info(\"=\".repeat(80));\n            logger.info(\"Starting Azure AKS Workload Identity Application\");\n            logger.info(\"=\".repeat(80));\n\n            // Display environment information\n            displayEnvironmentInfo();\n\n            // Method 1: Using environment variables\n            logger.info(\"\\n\" + \"=\".repeat(80));\n            logger.info(\"METHOD 1: Authentication using Environment Variables\");\n            logger.info(\"=\".repeat(80));\n            authenticateWithEnvironmentVariables();\n\n            // Method 2: Using explicit configuration\n            logger.info(\"\\n\" + \"=\".repeat(80));\n            logger.info(\"METHOD 2: Authentication using Explicit Configuration\");\n            logger.info(\"=\".repeat(80));\n            authenticateWithExplicitConfig();\n\n            // Method 3: Using configuration from properties\n            logger.info(\"\\n\" + \"=\".repeat(80));\n            logger.info(\"METHOD 3: Authentication using Configuration Object\");\n            logger.info(\"=\".repeat(80));\n            authenticateWithConfigObject();\n\n            // Start token refresh monitoring\n            startTokenRefreshMonitoring();\n\n            // Keep application running\n            logger.info(\"\\nApplication is running. Press Ctrl+C to exit.\");\n            Thread.currentThread().join();\n\n        } catch (Exception e) {\n            logger.error(\"Application failed with error\", e);\n            System.exit(1);\n        }\n    }\n\n    /**\n     * Display environment information for debugging\n     */\n    private static void displayEnvironmentInfo() {\n        logger.info(\"Environment Information:\");\n        logger.info(\"  Java Version: {}\", System.getProperty(\"java.version\"));\n        logger.info(\"  OS: {} {}\", System.getProperty(\"os.name\"), System.getProperty(\"os.version\"));\n        \n        // Display relevant environment variables (without sensitive data)\n        String[] envVars = {\n            \"AZURE_TENANT_ID\",\n            \"AZURE_CLIENT_ID\",\n            \"AZURE_FEDERATED_TOKEN_FILE\",\n            \"AZURE_AUTHORITY_HOST\",\n            \"AZURE_ADDITIONALLY_ALLOWED_TENANTS\"\n        };\n        \n        logger.info(\"  Environment Variables:\");\n        for (String var : envVars) {\n            String value = System.getenv(var);\n            if (value != null) {\n                if (var.contains(\"TOKEN\")) {\n                    logger.info(\"    {}: [SET - {} chars]\", var, value.length());\n                } else {\n                    logger.info(\"    {}: {}\", var, value);\n                }\n            } else {\n                logger.info(\"    {}: [NOT SET]\", var);\n            }\n        }\n    }\n\n    /**\n     * Method 1: Authenticate using environment variables\n     */\n    private static void authenticateWithEnvironmentVariables() {\n        try {\n            logger.info(\"Creating WorkloadIdentityCredential from environment variables...\");\n            \n            // This will automatically use:\n            // - AZURE_TENANT_ID\n            // - AZURE_CLIENT_ID\n            // - AZURE_FEDERATED_TOKEN_FILE\n            WorkloadIdentityCredential credential = CredentialHelper\n                .createCredentialFromEnvironment();\n\n            logger.info(\"Credential created successfully\");\n\n            // Test the credential\n            TokenService tokenService = new TokenService(credential);\n            tokenService.retrieveAndDisplayToken();\n\n            // Use with Azure Management API\n            AzureManagementService managementService = new AzureManagementService(credential);\n            managementService.listSubscriptions();\n            managementService.listResourceGroups();\n\n        } catch (Exception e) {\n            logger.error(\"Failed to authenticate with environment variables\", e);\n        }\n    }\n\n    /**\n     * Method 2: Authenticate using explicit parameters\n     */\n    private static void authenticateWithExplicitConfig() {\n        try {\n            // Get configuration from environment or use defaults\n            String tenantId = System.getenv(\"AZURE_TENANT_ID\");\n            String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n            String tokenFilePath = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n\n            if (tenantId == null || clientId == null || tokenFilePath == null) {\n                logger.warn(\"Required environment variables not set. Skipping explicit config method.\");\n                return;\n            }\n\n            logger.info(\"Creating WorkloadIdentityCredential with explicit parameters:\");\n            logger.info(\"  Tenant ID: {}\", tenantId);\n            logger.info(\"  Client ID: {}\", clientId);\n            logger.info(\"  Token File: {}\", tokenFilePath);\n\n            WorkloadIdentityCredential credential = CredentialHelper\n                .createCredentialWithExplicitConfig(tenantId, clientId, tokenFilePath);\n\n            logger.info(\"Credential created successfully\");\n\n            // Test the credential\n            TokenService tokenService = new TokenService(credential);\n            tokenService.retrieveAndDisplayToken();\n\n        } catch (Exception e) {\n            logger.error(\"Failed to authenticate with explicit configuration\", e);\n        }\n    }\n\n    /**\n     * Method 3: Authenticate using configuration object\n     */\n    private static void authenticateWithConfigObject() {\n        try {\n            WorkloadIdentityConfig config = WorkloadIdentityConfig.fromEnvironment();\n            \n            logger.info(\"Configuration loaded:\");\n            logger.info(\"  Tenant ID: {}\", config.getTenantId());\n            logger.info(\"  Client ID: {}\", config.getClientId());\n            logger.info(\"  Token File: {}\", config.getTokenFilePath());\n            logger.info(\"  Authority Host: {}\", config.getAuthorityHost());\n\n            WorkloadIdentityCredential credential = CredentialHelper\n                .createCredentialFromConfig(config);\n\n            logger.info(\"Credential created successfully\");\n\n            // Test the credential with different scopes\n            TokenService tokenService = new TokenService(credential);\n            \n            // Azure Management API\n            tokenService.retrieveTokenForScope(\"https://management.azure.com/.default\");\n            \n            // Azure Storage\n            tokenService.retrieveTokenForScope(\"https://storage.azure.com/.default\");\n            \n            // Microsoft Graph\n            tokenService.retrieveTokenForScope(\"https://graph.microsoft.com/.default\");\n\n        } catch (Exception e) {\n            logger.error(\"Failed to authenticate with configuration object\", e);\n        }\n    }\n\n    /**\n     * Start monitoring token refresh\n     */\n    private static void startTokenRefreshMonitoring() {\n        try {\n            WorkloadIdentityCredential credential = CredentialHelper\n                .createCredentialFromEnvironment();\n            TokenService tokenService = new TokenService(credential);\n\n            // Schedule token refresh every 30 minutes\n            scheduler.scheduleAtFixedRate(() -> {\n                try {\n                    logger.info(\"\\n\" + \"=\".repeat(80));\n                    logger.info(\"Scheduled Token Refresh Check\");\n                    logger.info(\"=\".repeat(80));\n                    tokenService.retrieveAndDisplayToken();\n                } catch (Exception e) {\n                    logger.error(\"Token refresh failed\", e);\n                }\n            }, 30, 30, TimeUnit.MINUTES);\n\n            logger.info(\"Token refresh monitoring started (every 30 minutes)\");\n\n        } catch (Exception e) {\n            logger.error(\"Failed to start token refresh monitoring\", e);\n        }\n    }\n}\n```\n\n## Configuration Classes\n\n```java\n// src/main/java/com/azure/aks/config/WorkloadIdentityConfig.java\npackage com.azure.aks.config;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Configuration class for Workload Identity\n */\npublic class WorkloadIdentityConfig {\n    private static final Logger logger = LoggerFactory.getLogger(WorkloadIdentityConfig.class);\n\n    private String tenantId;\n    private String clientId;\n    private String tokenFilePath;\n    private String authorityHost;\n    private String[] additionallyAllowedTenants;\n\n    public WorkloadIdentityConfig() {\n    }\n\n    public WorkloadIdentityConfig(String tenantId, String clientId, String tokenFilePath) {\n        this.tenantId = tenantId;\n        this.clientId = clientId;\n        this.tokenFilePath = tokenFilePath;\n        this.authorityHost = \"https://login.microsoftonline.com/\";\n    }\n\n    /**\n     * Create configuration from environment variables\n     */\n    public static WorkloadIdentityConfig fromEnvironment() {\n        logger.info(\"Loading Workload Identity configuration from environment\");\n\n        WorkloadIdentityConfig config = new WorkloadIdentityConfig();\n        \n        config.tenantId = getRequiredEnv(\"AZURE_TENANT_ID\");\n        config.clientId = getRequiredEnv(\"AZURE_CLIENT_ID\");\n        config.tokenFilePath = getRequiredEnv(\"AZURE_",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 62,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Workload Identity Authentication from AKS\n\nI'll create a comprehensive Java application that demonstrates WorkloadIdentityCredential usage in AKS with both environment variable and explicit configuration approaches.\n\n## Project Structure\n\n```\nworkload-identity-demo/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 identity/\n\u2502       \u2502               \u2514\u2500\u2500 demo/\n\u2502       \u2502                   \u251c\u2500\u2500 WorkloadIdentityDemo.java\n\u2502       \u2502                   \u251c\u2500\u2500 TokenManager.java\n\u2502       \u2502                   \u2514\u2500\u2500 ConfigurationValidator.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u2514\u2500\u2500 logback.xml\n\u251c\u2500\u2500 kubernetes/\n\u2502   \u251c\u2500\u2500 deployment.yaml\n\u2502   \u251c\u2500\u2500 service-account.yaml\n\u2502   \u2514\u2500\u2500 federated-identity.yaml\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.identity.demo</groupId>\n    <artifactId>workload-identity-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Workload Identity Demo</name>\n    <description>Demo application for WorkloadIdentityCredential in AKS</description>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <azure.sdk.version>1.2.29</azure.sdk.version>\n        <azure.identity.version>1.15.0</azure.identity.version>\n        <slf4j.version>2.0.9</slf4j.version>\n        <logback.version>1.4.14</logback.version>\n    </properties>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.azure</groupId>\n                <artifactId>azure-sdk-bom</artifactId>\n                <version>${azure.sdk.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n        </dependency>\n\n        <!-- Azure Core for HTTP client -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n        </dependency>\n\n        <!-- Azure Resource Manager (for testing token) -->\n        <dependency>\n            <groupId>com.azure.resourcemanager</groupId>\n            <artifactId>azure-resourcemanager</artifactId>\n        </dependency>\n\n        <!-- Logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <!-- JSON processing -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.16.1</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            \n            <!-- Create executable JAR with dependencies -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.identity.demo.WorkloadIdentityDemo</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## ConfigurationValidator.java\n\n```java\npackage com.azure.identity.demo;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Validates and displays workload identity configuration.\n */\npublic class ConfigurationValidator {\n    private static final Logger logger = LoggerFactory.getLogger(ConfigurationValidator.class);\n\n    // Required environment variables for WorkloadIdentityCredential\n    private static final String AZURE_TENANT_ID = \"AZURE_TENANT_ID\";\n    private static final String AZURE_CLIENT_ID = \"AZURE_CLIENT_ID\";\n    private static final String AZURE_FEDERATED_TOKEN_FILE = \"AZURE_FEDERATED_TOKEN_FILE\";\n    private static final String AZURE_AUTHORITY_HOST = \"AZURE_AUTHORITY_HOST\";\n\n    /**\n     * Validates the workload identity configuration.\n     * \n     * @return true if configuration is valid, false otherwise\n     */\n    public static boolean validateConfiguration() {\n        logger.info(\"=== Validating Workload Identity Configuration ===\");\n        \n        Map<String, String> config = getConfiguration();\n        boolean isValid = true;\n\n        // Check required environment variables\n        String tenantId = config.get(AZURE_TENANT_ID);\n        String clientId = config.get(AZURE_CLIENT_ID);\n        String tokenFile = config.get(AZURE_FEDERATED_TOKEN_FILE);\n\n        if (tenantId == null || tenantId.isEmpty()) {\n            logger.error(\"Missing required environment variable: {}\", AZURE_TENANT_ID);\n            isValid = false;\n        } else {\n            logger.info(\"\u2713 {} is set: {}\", AZURE_TENANT_ID, maskSensitiveValue(tenantId));\n        }\n\n        if (clientId == null || clientId.isEmpty()) {\n            logger.error(\"Missing required environment variable: {}\", AZURE_CLIENT_ID);\n            isValid = false;\n        } else {\n            logger.info(\"\u2713 {} is set: {}\", AZURE_CLIENT_ID, maskSensitiveValue(clientId));\n        }\n\n        if (tokenFile == null || tokenFile.isEmpty()) {\n            logger.error(\"Missing required environment variable: {}\", AZURE_FEDERATED_TOKEN_FILE);\n            isValid = false;\n        } else {\n            logger.info(\"\u2713 {} is set: {}\", AZURE_FEDERATED_TOKEN_FILE, tokenFile);\n            \n            // Validate token file exists and is readable\n            File file = new File(tokenFile);\n            if (!file.exists()) {\n                logger.error(\"Token file does not exist: {}\", tokenFile);\n                isValid = false;\n            } else if (!file.canRead()) {\n                logger.error(\"Token file is not readable: {}\", tokenFile);\n                isValid = false;\n            } else {\n                logger.info(\"\u2713 Token file exists and is readable\");\n                logger.info(\"  File size: {} bytes\", file.length());\n            }\n        }\n\n        // Check optional authority host\n        String authorityHost = config.get(AZURE_AUTHORITY_HOST);\n        if (authorityHost != null && !authorityHost.isEmpty()) {\n            logger.info(\"\u2713 {} is set: {}\", AZURE_AUTHORITY_HOST, authorityHost);\n        } else {\n            logger.info(\"\u2139 {} not set, using default (Azure Public Cloud)\", AZURE_AUTHORITY_HOST);\n        }\n\n        // Display Kubernetes service account information\n        displayKubernetesInfo();\n\n        logger.info(\"=== Configuration Validation {} ===\", \n            isValid ? \"PASSED\" : \"FAILED\");\n        \n        return isValid;\n    }\n\n    /**\n     * Gets the current configuration from environment variables.\n     */\n    public static Map<String, String> getConfiguration() {\n        Map<String, String> config = new HashMap<>();\n        config.put(AZURE_TENANT_ID, System.getenv(AZURE_TENANT_ID));\n        config.put(AZURE_CLIENT_ID, System.getenv(AZURE_CLIENT_ID));\n        config.put(AZURE_FEDERATED_TOKEN_FILE, System.getenv(AZURE_FEDERATED_TOKEN_FILE));\n        config.put(AZURE_AUTHORITY_HOST, System.getenv(AZURE_AUTHORITY_HOST));\n        return config;\n    }\n\n    /**\n     * Displays Kubernetes-specific information.\n     */\n    private static void displayKubernetesInfo() {\n        logger.info(\"=== Kubernetes Environment ===\");\n        \n        String namespace = System.getenv(\"KUBERNETES_NAMESPACE\");\n        String podName = System.getenv(\"HOSTNAME\");\n        String serviceAccount = System.getenv(\"KUBERNETES_SERVICE_ACCOUNT\");\n        \n        if (namespace != null) {\n            logger.info(\"Namespace: {}\", namespace);\n        }\n        if (podName != null) {\n            logger.info(\"Pod Name: {}\", podName);\n        }\n        if (serviceAccount != null) {\n            logger.info(\"Service Account: {}\", serviceAccount);\n        }\n\n        // Check for service account token mount\n        File saTokenFile = new File(\"/var/run/secrets/kubernetes.io/serviceaccount/token\");\n        if (saTokenFile.exists()) {\n            logger.info(\"\u2713 Kubernetes service account token mounted\");\n        }\n    }\n\n    /**\n     * Masks sensitive values for logging.\n     */\n    private static String maskSensitiveValue(String value) {\n        if (value == null || value.length() <= 8) {\n            return \"****\";\n        }\n        return value.substring(0, 4) + \"****\" + value.substring(value.length() - 4);\n    }\n\n    /**\n     * Displays all relevant environment variables for debugging.\n     */\n    public static void displayAllEnvironmentVariables() {\n        logger.debug(\"=== All Azure-related Environment Variables ===\");\n        System.getenv().entrySet().stream()\n            .filter(e -> e.getKey().startsWith(\"AZURE_\") || \n                        e.getKey().startsWith(\"KUBERNETES_\"))\n            .forEach(e -> logger.debug(\"{} = {}\", e.getKey(), \n                e.getKey().contains(\"SECRET\") || e.getKey().contains(\"TOKEN\") \n                    ? \"****\" \n                    : e.getValue()));\n    }\n}\n```\n\n## TokenManager.java\n\n```java\npackage com.azure.identity.demo;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.OffsetDateTime;\nimport java.util.Base64;\n\n/**\n * Manages token acquisition and validation using WorkloadIdentityCredential.\n */\npublic class TokenManager {\n    private static final Logger logger = LoggerFactory.getLogger(TokenManager.class);\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    // Azure Management API scope\n    public static final String MANAGEMENT_SCOPE = \"https://management.azure.com/.default\";\n    \n    // Other common scopes\n    public static final String STORAGE_SCOPE = \"https://storage.azure.com/.default\";\n    public static final String KEYVAULT_SCOPE = \"https://vault.azure.net/.default\";\n    public static final String GRAPH_SCOPE = \"https://graph.microsoft.com/.default\";\n\n    private final WorkloadIdentityCredential credential;\n\n    public TokenManager(WorkloadIdentityCredential credential) {\n        this.credential = credential;\n    }\n\n    /**\n     * Acquires an access token for the specified scope.\n     * \n     * @param scope The scope to request the token for\n     * @return The access token\n     */\n    public AccessToken getToken(String scope) {\n        logger.info(\"=== Acquiring Access Token ===\");\n        logger.info(\"Scope: {}\", scope);\n\n        try {\n            TokenRequestContext context = new TokenRequestContext()\n                .addScopes(scope);\n\n            long startTime = System.currentTimeMillis();\n            AccessToken token = credential.getToken(context).block();\n            long duration = System.currentTimeMillis() - startTime;\n\n            if (token == null) {\n                logger.error(\"Failed to acquire token: null token returned\");\n                return null;\n            }\n\n            logger.info(\"\u2713 Token acquired successfully in {} ms\", duration);\n            displayTokenInfo(token);\n\n            return token;\n\n        } catch (Exception e) {\n            logger.error(\"Failed to acquire token\", e);\n            throw new RuntimeException(\"Token acquisition failed\", e);\n        }\n    }\n\n    /**\n     * Displays information about the acquired token.\n     */\n    private void displayTokenInfo(AccessToken token) {\n        logger.info(\"=== Token Information ===\");\n        \n        // Display expiration\n        OffsetDateTime expiresAt = token.getExpiresAt();\n        logger.info(\"Expires At: {}\", expiresAt);\n        \n        Duration timeUntilExpiry = Duration.between(OffsetDateTime.now(), expiresAt);\n        logger.info(\"Valid For: {} minutes\", timeUntilExpiry.toMinutes());\n\n        // Parse and display token claims (without exposing the full token)\n        try {\n            String tokenValue = token.getToken();\n            String[] parts = tokenValue.split(\"\\\\.\");\n            \n            if (parts.length >= 2) {\n                // Decode JWT payload (second part)\n                String payload = new String(Base64.getUrlDecoder().decode(parts[1]));\n                JsonNode claims = objectMapper.readTree(payload);\n                \n                logger.info(\"=== Token Claims ===\");\n                \n                if (claims.has(\"aud\")) {\n                    logger.info(\"Audience (aud): {}\", claims.get(\"aud\").asText());\n                }\n                if (claims.has(\"iss\")) {\n                    logger.info(\"Issuer (iss): {}\", claims.get(\"iss\").asText());\n                }\n                if (claims.has(\"sub\")) {\n                    logger.info(\"Subject (sub): {}\", maskValue(claims.get(\"sub\").asText()));\n                }\n                if (claims.has(\"tid\")) {\n                    logger.info(\"Tenant ID (tid): {}\", maskValue(claims.get(\"tid\").asText()));\n                }\n                if (claims.has(\"oid\")) {\n                    logger.info(\"Object",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10839,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses WorkloadIdentityCredential for AKS authentication with Azure Management API.\n\n```java\npackage com.example.app.azure;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport com.azure.identity.WorkloadIdentityCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\n/**\n * Azure Workload Identity authentication for AKS pods.\n * Authenticates using federated identity tokens and retrieves Azure Management API tokens.\n */\n@Component\npublic class AksWorkloadIdentityClient {\n    private static final Logger log = LoggerFactory.getLogger(AksWorkloadIdentityClient.class);\n    private static final String AZURE_MANAGEMENT_SCOPE = \"https://management.azure.com/.default\";\n    \n    private final WorkloadIdentityCredential credential;\n\n    public AksWorkloadIdentityClient() {\n        // Enable verbose logging for authentication debugging\n        System.setProperty(\"AZURE_LOG_LEVEL\", \"verbose\");\n        \n        this.credential = createWorkloadIdentityCredential();\n        log.info(\"AksWorkloadIdentityClient initialized with WorkloadIdentityCredential\");\n    }\n\n    /**\n     * Creates WorkloadIdentityCredential using environment variables.\n     * Required environment variables:\n     * - AZURE_TENANT_ID: Azure AD tenant ID\n     * - AZURE_CLIENT_ID: Application (client) ID\n     * - AZURE_FEDERATED_TOKEN_FILE: Path to federated token file (typically /var/run/secrets/azure/tokens/azure-identity-token)\n     */\n    private WorkloadIdentityCredential createWorkloadIdentityCredential() {\n        String tenantId = System.getenv(\"AZURE_TENANT_ID\");\n        String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n        String tokenFilePath = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n\n        log.info(\"Creating WorkloadIdentityCredential with:\");\n        log.info(\"  Tenant ID: {}\", tenantId != null ? tenantId : \"from environment\");\n        log.info(\"  Client ID: {}\", clientId != null ? clientId : \"from environment\");\n        log.info(\"  Token File: {}\", tokenFilePath != null ? tokenFilePath : \"from environment\");\n\n        if (tenantId != null && clientId != null && tokenFilePath != null) {\n            // Explicit configuration\n            return new WorkloadIdentityCredentialBuilder()\n                .tenantId(tenantId)\n                .clientId(clientId)\n                .tokenFilePath(tokenFilePath)\n                .build();\n        } else {\n            // Use environment variables (recommended for AKS)\n            return new WorkloadIdentityCredentialBuilder().build();\n        }\n    }\n\n    /**\n     * Retrieves an access token for Azure Management API.\n     * \n     * @return AccessToken for Azure Management API\n     * @throws com.azure.identity.CredentialUnavailableException if credential is not available\n     * @throws com.azure.core.exception.ClientAuthenticationException if authentication fails\n     */\n    public AccessToken getManagementApiToken() {\n        log.info(\"Requesting access token for Azure Management API\");\n        \n        TokenRequestContext context = new TokenRequestContext()\n            .addScopes(AZURE_MANAGEMENT_SCOPE);\n\n        AccessToken token = credential.getToken(context).block();\n        \n        if (token != null) {\n            log.info(\"Successfully acquired token. Expires at: {}\", token.getExpiresAt());\n            log.debug(\"Token (first 20 chars): {}...\", \n                token.getToken().substring(0, Math.min(20, token.getToken().length())));\n        } else {\n            log.error(\"Failed to acquire token - null response\");\n        }\n        \n        return token;\n    }\n\n    /**\n     * Retrieves an access token for a custom scope.\n     * \n     * @param scope The Azure resource scope (e.g., \"https://storage.azure.com/.default\")\n     * @return AccessToken for the specified scope\n     */\n    public AccessToken getTokenForScope(String scope) {\n        log.info(\"Requesting access token for scope: {}\", scope);\n        \n        TokenRequestContext context = new TokenRequestContext()\n            .addScopes(scope);\n\n        AccessToken token = credential.getToken(context).block();\n        \n        if (token != null) {\n            log.info(\"Successfully acquired token for scope: {}. Expires at: {}\", scope, token.getExpiresAt());\n        }\n        \n        return token;\n    }\n\n    /**\n     * Gets the WorkloadIdentityCredential instance for use with Azure SDK clients.\n     * \n     * @return WorkloadIdentityCredential instance\n     */\n    public WorkloadIdentityCredential getCredential() {\n        return credential;\n    }\n}\n```\n\n```java\npackage com.example.app.azure;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Profile;\n\n/**\n * Demo application showing WorkloadIdentityCredential usage in AKS.\n * Run with --spring.profiles.active=aks-demo to execute the demo.\n */\n@SpringBootApplication\npublic class AksWorkloadIdentityDemo {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AksWorkloadIdentityDemo.class, args);\n    }\n\n    @Bean\n    @Profile(\"aks-demo\")\n    public CommandLineRunner demoRunner(AksWorkloadIdentityClient client) {\n        return args -> {\n            System.out.println(\"\\n=== AKS Workload Identity Demo ===\\n\");\n            \n            try {\n                // Retrieve Azure Management API token\n                System.out.println(\"1. Retrieving Azure Management API token...\");\n                AccessToken managementToken = client.getManagementApiToken();\n                \n                if (managementToken != null) {\n                    System.out.println(\"\u2713 Successfully acquired Management API token\");\n                    System.out.println(\"  Token expires at: \" + managementToken.getExpiresAt());\n                    System.out.println(\"  Token preview: \" + \n                        managementToken.getToken().substring(0, Math.min(30, managementToken.getToken().length())) + \"...\");\n                }\n                \n                System.out.println();\n                \n                // Retrieve token for different scope (e.g., Storage)\n                System.out.println(\"2. Retrieving Azure Storage token...\");\n                AccessToken storageToken = client.getTokenForScope(\"https://storage.azure.com/.default\");\n                \n                if (storageToken != null) {\n                    System.out.println(\"\u2713 Successfully acquired Storage token\");\n                    System.out.println(\"  Token expires at: \" + storageToken.getExpiresAt());\n                }\n                \n                System.out.println();\n                System.out.println(\"=== Demo completed successfully ===\\n\");\n                \n            } catch (CredentialUnavailableException e) {\n                System.err.println(\"\u2717 Credential not available: \" + e.getMessage());\n                System.err.println(\"\\nEnsure the following environment variables are set:\");\n                System.err.println(\"  - AZURE_TENANT_ID\");\n                System.err.println(\"  - AZURE_CLIENT_ID\");\n                System.err.println(\"  - AZURE_FEDERATED_TOKEN_FILE\");\n                System.err.println(\"\\nIn AKS, these are typically set by the workload identity webhook.\");\n                \n            } catch (ClientAuthenticationException e) {\n                System.err.println(\"\u2717 Authentication failed: \" + e.getMessage());\n                System.err.println(\"\\nPossible causes:\");\n                System.err.println(\"  - Invalid tenant ID or client ID\");\n                System.err.println(\"  - Federated credential not properly configured\");\n                System.err.println(\"  - Service account not linked to managed identity\");\n                \n            } catch (Exception e) {\n                System.err.println(\"\u2717 Unexpected error: \" + e.getMessage());\n                e.printStackTrace();\n            }\n        };\n    }\n}\n```\n\n```java\npackage com.example.app.azure;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.time.OffsetDateTime;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * REST controller for testing WorkloadIdentityCredential in AKS.\n */\n@RestController\n@RequestMapping(\"/api/azure/auth\")\npublic class AksAuthController {\n\n    private final AksWorkloadIdentityClient client;\n\n    public AksAuthController(AksWorkloadIdentityClient client) {\n        this.client = client;\n    }\n\n    /**\n     * Health check endpoint to verify workload identity configuration.\n     * GET /api/azure/auth/health\n     */\n    @GetMapping(\"/health\")\n    public Map<String, Object> healthCheck() {\n        Map<String, Object> response = new HashMap<>();\n        \n        String tenantId = System.getenv(\"AZURE_TENANT_ID\");\n        String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n        String tokenFile = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n        \n        response.put(\"workloadIdentityConfigured\", \n            tenantId != null && clientId != null && tokenFile != null);\n        response.put(\"tenantIdSet\", tenantId != null);\n        response.put(\"clientIdSet\", clientId != null);\n        response.put(\"tokenFileSet\", tokenFile != null);\n        response.put(\"timestamp\", OffsetDateTime.now());\n        \n        return response;\n    }\n\n    /**\n     * Retrieves an access token for Azure Management API.\n     * GET /api/azure/auth/token\n     */\n    @GetMapping(\"/token\")\n    public Map<String, Object> getToken() {\n        AccessToken token = client.getManagementApiToken();\n        \n        Map<String, Object> response = new HashMap<>();\n        response.put(\"success\", true);\n        response.put(\"expiresAt\", token.getExpiresAt());\n        response.put(\"tokenPreview\", token.getToken().substring(0, Math.min(30, token.getToken().length())) + \"...\");\n        response.put(\"timestamp\", OffsetDateTime.now());\n        \n        return response;\n    }\n\n    /**\n     * Retrieves an access token for a custom scope.\n     * GET /api/azure/auth/token/custom?scope=https://storage.azure.com/.default\n     */\n    @GetMapping(\"/token/custom\")\n    public Map<String, Object> getCustomToken(@RequestParam String scope) {\n        AccessToken token = client.getTokenForScope(scope);\n        \n        Map<String, Object> response = new HashMap<>();\n        response.put(\"success\", true);\n        response.put(\"scope\", scope);\n        response.put(\"expiresAt\", token.getExpiresAt());\n        response.put(\"tokenPreview\", token.getToken().substring(0, Math.min(30, token.getToken().length())) + \"...\");\n        response.put(\"timestamp\", OffsetDateTime.now());\n        \n        return response;\n    }\n}\n```\n\n```yaml\n# kubernetes/deployment.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: workload-identity-sa\n  namespace: default\n  annotations:\n    azure.workload.identity/client-id: \"${AZURE_CLIENT_ID}\"\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: java-workload-identity-app\n  namespace: default\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: java-workload-identity-app\n  template:\n    metadata:\n      labels:\n        app: java-workload-identity-app\n        azure.workload.identity/use: \"true\"\n    spec:\n      serviceAccountName: workload-identity-sa\n      containers:\n      - name: app\n        image: your-registry/java-workload-identity-app:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: AZURE_CLIENT_ID\n          value: \"${AZURE_CLIENT_ID}\"\n        - name: AZURE_TENANT_ID\n          value: \"${AZURE_TENANT_ID}\"\n        - name: AZURE_FEDERATED_TOKEN_FILE\n          value: \"/var/run/secrets/azure/tokens/azure-identity-token\"\n        - name: AZURE_LOG_LEVEL\n          value: \"verbose\"\n        - name: SPRING_PROFILES_ACTIVE\n          value: \"aks-demo\"\n        volumeMounts:\n        - name: azure-identity-token\n          mountPath: /var/run/secrets/azure/tokens\n          readOnly: true\n      volumes:\n      - name: azure-identity-token\n        projected:\n          sources:\n          - serviceAccountToken:\n              path: azure-identity-token\n              expirationSeconds: 3600\n              audience: api://AzureADTokenExchange\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: java-workload-identity-service\n  namespace: default\nspec:\n  selector:\n    app: java-workload-identity-app\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n  type: LoadBalancer\n```\n\n```bash\n#!/bin/bash\n# scripts/setup-aks-workload-identity.sh\n\n# Setup script for AKS Workload Identity\n# Prerequisites: Azure CLI, kubectl, jq\n\nset -e\n\n# Configuration\nRESOURCE_GROUP=\"my-resource-group\"\nAKS_CLUSTER=\"my-aks-cluster\"\nLOCATION=\"eastus\"\nIDENTITY_NAME=\"java-app-identity\"\nNAMESPACE=\"default\"\nSERVICE_ACCOUNT=\"workload-identity-sa\"\n\necho \"=== Setting up AKS Workload Identity ===\"\n\n# 1. Get AKS OIDC Issuer URL\necho \"1. Getting AKS OIDC Issuer URL...\"\nOIDC_ISSUER=$(az aks show \\\n  --resource-group $RESOURCE_GROUP \\\n  --name $AKS_CLUSTER \\\n  --query \"oidcIssuerProfile.issuerUrl\" \\\n  --output tsv)\n\necho \"   OIDC Issuer: $OIDC_ISSUER\"\n\n# 2. Create User-Assigned Managed Identity\necho \"2. Creating managed identity...\"\naz identity create \\\n  --name $IDENTITY_NAME \\\n  --resource-group $RESOURCE_GROUP \\\n  --location $LOCATION\n\n# 3. Get identity details\nIDENTITY_CLIENT_ID=$(az identity show \\\n  --name $IDENTITY_NAME \\\n  --resource-group $RESOURCE_GROUP \\\n  --query clientId \\\n  --output tsv)\n\nIDENTITY_OBJECT_ID=$(az identity show \\\n  --name $IDENTITY_NAME \\\n  --resource-group $RESOURCE_GROUP \\\n  --query principalId \\\n  --output tsv)\n\necho \"   Client ID: $IDENTITY_CLIENT_ID\"\necho \"   Object ID: $IDENTITY_OBJECT_ID\"\n\n# 4. Create federated credential\necho \"3. Creating federated credential...\"\naz identity federated-credential create \\\n  --name \"aks-federated-credential\" \\\n  --identity-name $IDENTITY_NAME \\\n  --resource-group $RESOURCE_GROUP \\\n  --issuer $OIDC_ISSUER \\\n  --subject \"system:serviceaccount:${NAMESPACE}:${SERVICE_ACCOUNT}\"\n\n# 5. Grant permissions (example: Reader on subscription)\necho \"4. Granting permissions...\"\nSUBSCRIPTION_ID=$(az account show --query id --output tsv)\n\naz role assignment create \\\n  --assignee $IDENTITY_OBJECT_ID \\",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11364,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Azure AKS Workload Identity Authentication Application\n\nI'll create a comprehensive Java application that demonstrates using WorkloadIdentityCredential to authenticate from an AKS pod.\n\n## Project Structure\n\n```\nazure-aks-workload-identity/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 aks/\n\u2502       \u2502               \u251c\u2500\u2500 WorkloadIdentityApp.java\n\u2502       \u2502               \u251c\u2500\u2500 TokenRetriever.java\n\u2502       \u2502               \u2514\u2500\u2500 config/\n\u2502       \u2502                   \u2514\u2500\u2500 AzureConfig.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u251c\u2500\u2500 application.properties\n\u2502           \u2514\u2500\u2500 logback.xml\n\u2514\u2500\u2500 kubernetes/\n    \u251c\u2500\u2500 deployment.yaml\n    \u2514\u2500\u2500 service-account.yaml\n```\n\n## 1. Maven Configuration (pom.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.aks</groupId>\n    <artifactId>workload-identity-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure AKS Workload Identity Demo</name>\n    <description>Demo application for Azure Workload Identity in AKS</description>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.identity.version>1.11.1</azure.identity.version>\n        <azure.core.version>1.45.1</azure.core.version>\n        <slf4j.version>2.0.9</slf4j.version>\n        <logback.version>1.4.14</logback.version>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure.identity.version}</version>\n        </dependency>\n\n        <!-- Azure Core -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n            <version>${azure.core.version}</version>\n        </dependency>\n\n        <!-- Azure Resource Manager -->\n        <dependency>\n            <groupId>com.azure.resourcemanager</groupId>\n            <artifactId>azure-resourcemanager</artifactId>\n            <version>2.32.0</version>\n        </dependency>\n\n        <!-- Logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <!-- JSON Processing -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.16.0</version>\n        </dependency>\n\n        <!-- Apache HTTP Client -->\n        <dependency>\n            <groupId>org.apache.httpcomponents</groupId>\n            <artifactId>httpclient</artifactId>\n            <version>4.5.14</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.aks.WorkloadIdentityApp</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Configuration Class\n\n```java\npackage com.azure.aks.config;\n\nimport java.util.Optional;\n\n/**\n * Configuration class for Azure Workload Identity settings\n */\npublic class AzureConfig {\n    \n    // Environment variable names for Workload Identity\n    public static final String AZURE_TENANT_ID = \"AZURE_TENANT_ID\";\n    public static final String AZURE_CLIENT_ID = \"AZURE_CLIENT_ID\";\n    public static final String AZURE_FEDERATED_TOKEN_FILE = \"AZURE_FEDERATED_TOKEN_FILE\";\n    public static final String AZURE_AUTHORITY_HOST = \"AZURE_AUTHORITY_HOST\";\n    \n    // Default values\n    private static final String DEFAULT_AUTHORITY_HOST = \"https://login.microsoftonline.com/\";\n    private static final String DEFAULT_TOKEN_FILE = \"/var/run/secrets/azure/tokens/azure-identity-token\";\n    \n    // Azure Management API scope\n    public static final String MANAGEMENT_SCOPE = \"https://management.azure.com/.default\";\n    \n    private final String tenantId;\n    private final String clientId;\n    private final String tokenFile;\n    private final String authorityHost;\n    \n    /**\n     * Constructor that reads from environment variables\n     */\n    public AzureConfig() {\n        this.tenantId = getEnvOrThrow(AZURE_TENANT_ID);\n        this.clientId = getEnvOrThrow(AZURE_CLIENT_ID);\n        this.tokenFile = getEnvOrDefault(AZURE_FEDERATED_TOKEN_FILE, DEFAULT_TOKEN_FILE);\n        this.authorityHost = getEnvOrDefault(AZURE_AUTHORITY_HOST, DEFAULT_AUTHORITY_HOST);\n    }\n    \n    /**\n     * Constructor with explicit parameters\n     */\n    public AzureConfig(String tenantId, String clientId, String tokenFile, String authorityHost) {\n        this.tenantId = tenantId;\n        this.clientId = clientId;\n        this.tokenFile = tokenFile != null ? tokenFile : DEFAULT_TOKEN_FILE;\n        this.authorityHost = authorityHost != null ? authorityHost : DEFAULT_AUTHORITY_HOST;\n    }\n    \n    private String getEnvOrThrow(String key) {\n        return Optional.ofNullable(System.getenv(key))\n                .orElseThrow(() -> new IllegalStateException(\n                        \"Required environment variable not set: \" + key));\n    }\n    \n    private String getEnvOrDefault(String key, String defaultValue) {\n        return Optional.ofNullable(System.getenv(key))\n                .orElse(defaultValue);\n    }\n    \n    public String getTenantId() {\n        return tenantId;\n    }\n    \n    public String getClientId() {\n        return clientId;\n    }\n    \n    public String getTokenFile() {\n        return tokenFile;\n    }\n    \n    public String getAuthorityHost() {\n        return authorityHost;\n    }\n    \n    @Override\n    public String toString() {\n        return \"AzureConfig{\" +\n                \"tenantId='\" + maskValue(tenantId) + '\\'' +\n                \", clientId='\" + maskValue(clientId) + '\\'' +\n                \", tokenFile='\" + tokenFile + '\\'' +\n                \", authorityHost='\" + authorityHost + '\\'' +\n                '}';\n    }\n    \n    private String maskValue(String value) {\n        if (value == null || value.length() < 8) {\n            return \"****\";\n        }\n        return value.substring(0, 4) + \"****\" + value.substring(value.length() - 4);\n    }\n}\n```\n\n## 3. Token Retriever Class\n\n```java\npackage com.azure.aks;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport com.azure.identity.WorkloadIdentityCredentialBuilder;\nimport com.azure.aks.config.AzureConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.OffsetDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.concurrent.CompletableFuture;\n\n/**\n * Handles token retrieval using WorkloadIdentityCredential\n */\npublic class TokenRetriever {\n    \n    private static final Logger logger = LoggerFactory.getLogger(TokenRetriever.class);\n    private final AzureConfig config;\n    \n    public TokenRetriever(AzureConfig config) {\n        this.config = config;\n    }\n    \n    /**\n     * Creates WorkloadIdentityCredential using environment variables\n     */\n    public WorkloadIdentityCredential createCredentialFromEnvironment() {\n        logger.info(\"Creating WorkloadIdentityCredential from environment variables\");\n        logger.debug(\"Configuration: {}\", config);\n        \n        try {\n            WorkloadIdentityCredential credential = new WorkloadIdentityCredentialBuilder()\n                    .build();\n            \n            logger.info(\"Successfully created WorkloadIdentityCredential from environment\");\n            return credential;\n            \n        } catch (Exception e) {\n            logger.error(\"Failed to create credential from environment\", e);\n            throw new RuntimeException(\"Failed to create WorkloadIdentityCredential\", e);\n        }\n    }\n    \n    /**\n     * Creates WorkloadIdentityCredential using explicit parameters\n     */\n    public WorkloadIdentityCredential createCredentialWithExplicitParams() {\n        logger.info(\"Creating WorkloadIdentityCredential with explicit parameters\");\n        logger.debug(\"Tenant ID: {}\", config.getTenantId());\n        logger.debug(\"Client ID: {}\", config.getClientId());\n        logger.debug(\"Token File: {}\", config.getTokenFile());\n        logger.debug(\"Authority Host: {}\", config.getAuthorityHost());\n        \n        try {\n            WorkloadIdentityCredential credential = new WorkloadIdentityCredentialBuilder()\n                    .tenantId(config.getTenantId())\n                    .clientId(config.getClientId())\n                    .tokenFilePath(config.getTokenFile())\n                    .authorityHost(config.getAuthorityHost())\n                    .build();\n            \n            logger.info(\"Successfully created WorkloadIdentityCredential with explicit parameters\");\n            return credential;\n            \n        } catch (Exception e) {\n            logger.error(\"Failed to create credential with explicit parameters\", e);\n            throw new RuntimeException(\"Failed to create WorkloadIdentityCredential\", e);\n        }\n    }\n    \n    /**\n     * Retrieves access token synchronously\n     */\n    public AccessToken getToken(WorkloadIdentityCredential credential, String scope) {\n        logger.info(\"Requesting access token for scope: {}\", scope);\n        \n        try {\n            TokenRequestContext request = new TokenRequestContext()\n                    .addScopes(scope);\n            \n            long startTime = System.currentTimeMillis();\n            AccessToken token = credential.getToken(request).block();\n            long duration = System.currentTimeMillis() - startTime;\n            \n            if (token != null) {\n                logger.info(\"Successfully retrieved access token in {}ms\", duration);\n                logTokenDetails(token);\n                return token;\n            } else {\n                logger.error(\"Received null token from credential\");\n                throw new RuntimeException(\"Failed to retrieve access token\");\n            }\n            \n        } catch (Exception e) {\n            logger.error(\"Error retrieving access token\", e);\n            throw new RuntimeException(\"Failed to retrieve access token\", e);\n        }\n    }\n    \n    /**\n     * Retrieves access token asynchronously\n     */\n    public CompletableFuture<AccessToken> getTokenAsync(\n            WorkloadIdentityCredential credential, String scope) {\n        \n        logger.info(\"Requesting access token asynchronously for scope: {}\", scope);\n        \n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                TokenRequestContext request = new TokenRequestContext()\n                        .addScopes(scope);\n                \n                long startTime = System.currentTimeMillis();\n                AccessToken token = credential.getToken(request).block();\n                long duration = System.currentTimeMillis() - startTime;\n                \n                if (token != null) {\n                    logger.info(\"Successfully retrieved access token asynchronously in {}ms\", duration);\n                    logTokenDetails(token);\n                    return token;\n                } else {\n                    throw new RuntimeException(\"Failed to retrieve access token\");\n                }\n                \n            } catch (Exception e) {\n                logger.error(\"Error retrieving access token asynchronously\", e);\n                throw new RuntimeException(\"Failed to retrieve access token\", e);\n            }\n        });\n    }\n    \n    /**\n     * Validates and logs token details\n     */\n    private void logTokenDetails(AccessToken token) {\n        OffsetDateTime expiresAt = token.getExpiresAt();\n        OffsetDateTime now = OffsetDateTime.now();\n        \n        logger.info(\"Token Details:\");\n        logger.info(\"  Expires At: {}\", \n                expiresAt.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));\n        logger.info(\"  Valid For: {} seconds\", \n                java.time.Duration.between(now, expiresAt).getSeconds());\n        logger.info(\"  Token Prefix: {}...\", \n                token.getToken().substring(0, Math.min(20, token.getToken().length())));\n        \n        if (expiresAt.isBefore(now)) {\n            logger.warn(\"WARNING: Token is already expired!\");\n        } else if (java.time.Duration.between(now, expiresAt).getSeconds() < 300) {\n            logger.warn(\"WARNING: Token expires in less than 5 minutes!\");\n        }\n    }\n    \n    /**\n     * Validates token by checking expiration\n     */\n    public boolean isTokenValid(AccessToken token) {\n        if (token == null) {\n            logger.warn(\"Token is null\");\n            return false;\n        }\n        \n        boolean valid = token.getExpiresAt().isAfter(OffsetDateTime.now());\n        logger.debug(\"Token valid: {}\", valid);\n        return valid;\n    }\n}\n```\n\n## 4. Main Application Class\n\n```java\npackage com.azure.aks;\n\nimport com.azure.aks.config.AzureConfig;\nimport com.azure.core.credential.AccessToken;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport com.azure.resourcemanager.AzureResourceManager;\nimport com.azure.core.management.AzureEnvironment;\nimport com.azure.core.management.profile.AzureProfile;\nimport org.slf4j.Logger",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 62,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure AKS Workload Identity Authentication Application\n\nI'll create a comprehensive Java application that demonstrates WorkloadIdentityCredential usage in AKS with both configuration methods.\n\n## Project Structure\n\n```\naks-workload-identity-demo/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/main/java/com/azure/identity/demo/\n\u2502   \u251c\u2500\u2500 AksWorkloadIdentityApp.java\n\u2502   \u251c\u2500\u2500 TokenService.java\n\u2502   \u2514\u2500\u2500 config/\n\u2502       \u2514\u2500\u2500 WorkloadIdentityConfig.java\n\u251c\u2500\u2500 src/main/resources/\n\u2502   \u251c\u2500\u2500 application.properties\n\u2502   \u2514\u2500\u2500 logback.xml\n\u2514\u2500\u2500 kubernetes/\n    \u251c\u2500\u2500 deployment.yaml\n    \u251c\u2500\u2500 service-account.yaml\n    \u2514\u2500\u2500 federated-identity.yaml\n```\n\n## 1. Maven Configuration (pom.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.identity.demo</groupId>\n    <artifactId>aks-workload-identity-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>AKS Workload Identity Demo</name>\n    <description>Demo application for Azure Workload Identity in AKS</description>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.sdk.version>1.2.29</azure.sdk.version>\n        <slf4j.version>2.0.9</slf4j.version>\n        <logback.version>1.4.14</logback.version>\n    </properties>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.azure</groupId>\n                <artifactId>azure-sdk-bom</artifactId>\n                <version>${azure.sdk.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n        </dependency>\n\n        <!-- Azure Core -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n        </dependency>\n\n        <!-- Azure Resource Manager (for Management API) -->\n        <dependency>\n            <groupId>com.azure.resourcemanager</groupId>\n            <artifactId>azure-resourcemanager</artifactId>\n            <version>2.33.0</version>\n        </dependency>\n\n        <!-- Logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <!-- JSON Processing -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.16.1</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.identity.demo.AksWorkloadIdentityApp</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Configuration Class\n\n```java\npackage com.azure.identity.demo.config;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\n/**\n * Configuration class for Workload Identity settings\n */\npublic class WorkloadIdentityConfig {\n    private static final Logger logger = LoggerFactory.getLogger(WorkloadIdentityConfig.class);\n\n    // Environment variable names\n    private static final String ENV_TENANT_ID = \"AZURE_TENANT_ID\";\n    private static final String ENV_CLIENT_ID = \"AZURE_CLIENT_ID\";\n    private static final String ENV_FEDERATED_TOKEN_FILE = \"AZURE_FEDERATED_TOKEN_FILE\";\n    private static final String ENV_AUTHORITY_HOST = \"AZURE_AUTHORITY_HOST\";\n\n    // Default values\n    private static final String DEFAULT_TOKEN_FILE_PATH = \n        \"/var/run/secrets/azure/tokens/azure-identity-token\";\n    private static final String DEFAULT_AUTHORITY_HOST = \n        \"https://login.microsoftonline.com/\";\n\n    private final String tenantId;\n    private final String clientId;\n    private final String tokenFilePath;\n    private final String authorityHost;\n    private final boolean useEnvironmentVariables;\n\n    private WorkloadIdentityConfig(Builder builder) {\n        this.tenantId = builder.tenantId;\n        this.clientId = builder.clientId;\n        this.tokenFilePath = builder.tokenFilePath;\n        this.authorityHost = builder.authorityHost;\n        this.useEnvironmentVariables = builder.useEnvironmentVariables;\n    }\n\n    public String getTenantId() {\n        return tenantId;\n    }\n\n    public String getClientId() {\n        return clientId;\n    }\n\n    public String getTokenFilePath() {\n        return tokenFilePath;\n    }\n\n    public String getAuthorityHost() {\n        return authorityHost;\n    }\n\n    public boolean isUseEnvironmentVariables() {\n        return useEnvironmentVariables;\n    }\n\n    /**\n     * Validates the configuration\n     */\n    public void validate() {\n        logger.info(\"Validating Workload Identity configuration...\");\n\n        if (!useEnvironmentVariables) {\n            if (tenantId == null || tenantId.isEmpty()) {\n                throw new IllegalStateException(\"Tenant ID is required\");\n            }\n            if (clientId == null || clientId.isEmpty()) {\n                throw new IllegalStateException(\"Client ID is required\");\n            }\n        }\n\n        // Validate token file exists\n        Path tokenPath = Paths.get(tokenFilePath);\n        if (!Files.exists(tokenPath)) {\n            logger.warn(\"Token file does not exist: {}\", tokenFilePath);\n            logger.warn(\"This is expected if running outside AKS\");\n        } else {\n            logger.info(\"Token file found: {}\", tokenFilePath);\n            try {\n                long fileSize = Files.size(tokenPath);\n                logger.info(\"Token file size: {} bytes\", fileSize);\n            } catch (IOException e) {\n                logger.error(\"Error reading token file\", e);\n            }\n        }\n\n        logger.info(\"Configuration validation complete\");\n    }\n\n    /**\n     * Logs the current configuration (without sensitive data)\n     */\n    public void logConfiguration() {\n        logger.info(\"=== Workload Identity Configuration ===\");\n        logger.info(\"Use Environment Variables: {}\", useEnvironmentVariables);\n        logger.info(\"Tenant ID: {}\", maskSensitiveData(tenantId));\n        logger.info(\"Client ID: {}\", maskSensitiveData(clientId));\n        logger.info(\"Token File Path: {}\", tokenFilePath);\n        logger.info(\"Authority Host: {}\", authorityHost);\n        logger.info(\"======================================\");\n    }\n\n    private String maskSensitiveData(String data) {\n        if (data == null || data.length() < 8) {\n            return \"****\";\n        }\n        return data.substring(0, 4) + \"****\" + data.substring(data.length() - 4);\n    }\n\n    public static class Builder {\n        private String tenantId;\n        private String clientId;\n        private String tokenFilePath = DEFAULT_TOKEN_FILE_PATH;\n        private String authorityHost = DEFAULT_AUTHORITY_HOST;\n        private boolean useEnvironmentVariables = false;\n\n        /**\n         * Load configuration from environment variables\n         */\n        public Builder fromEnvironment() {\n            this.useEnvironmentVariables = true;\n            this.tenantId = System.getenv(ENV_TENANT_ID);\n            this.clientId = System.getenv(ENV_CLIENT_ID);\n            \n            String envTokenFile = System.getenv(ENV_FEDERATED_TOKEN_FILE);\n            if (envTokenFile != null && !envTokenFile.isEmpty()) {\n                this.tokenFilePath = envTokenFile;\n            }\n            \n            String envAuthority = System.getenv(ENV_AUTHORITY_HOST);\n            if (envAuthority != null && !envAuthority.isEmpty()) {\n                this.authorityHost = envAuthority;\n            }\n            \n            return this;\n        }\n\n        public Builder tenantId(String tenantId) {\n            this.tenantId = tenantId;\n            return this;\n        }\n\n        public Builder clientId(String clientId) {\n            this.clientId = clientId;\n            return this;\n        }\n\n        public Builder tokenFilePath(String tokenFilePath) {\n            this.tokenFilePath = tokenFilePath;\n            return this;\n        }\n\n        public Builder authorityHost(String authorityHost) {\n            this.authorityHost = authorityHost;\n            return this;\n        }\n\n        public WorkloadIdentityConfig build() {\n            return new WorkloadIdentityConfig(this);\n        }\n    }\n}\n```\n\n## 3. Token Service\n\n```java\npackage com.azure.identity.demo;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport com.azure.identity.WorkloadIdentityCredentialBuilder;\nimport com.azure.identity.demo.config.WorkloadIdentityConfig;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.OffsetDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Base64;\n\n/**\n * Service for managing token acquisition using Workload Identity\n */\npublic class TokenService {\n    private static final Logger logger = LoggerFactory.getLogger(TokenService.class);\n\n    // Azure Management API scope\n    public static final String MANAGEMENT_SCOPE = \"https://management.azure.com/.default\";\n    \n    // Other common scopes\n    public static final String STORAGE_SCOPE = \"https://storage.azure.com/.default\";\n    public static final String KEYVAULT_SCOPE = \"https://vault.azure.net/.default\";\n    public static final String GRAPH_SCOPE = \"https://graph.microsoft.com/.default\";\n\n    private final WorkloadIdentityCredential credential;\n    private final WorkloadIdentityConfig config;\n\n    public TokenService(WorkloadIdentityConfig config) {\n        this.config = config;\n        this.credential = createCredential();\n    }\n\n    /**\n     * Creates WorkloadIdentityCredential based on configuration\n     */\n    private WorkloadIdentityCredential createCredential() {\n        logger.info(\"Creating WorkloadIdentityCredential...\");\n\n        WorkloadIdentityCredentialBuilder builder = new WorkloadIdentityCredentialBuilder();\n\n        if (config.isUseEnvironmentVariables()) {\n            logger.info(\"Using environment variables for credential configuration\");\n            // When using environment variables, the builder automatically reads:\n            // - AZURE_TENANT_ID\n            // - AZURE_CLIENT_ID\n            // - AZURE_FEDERATED_TOKEN_FILE\n            // - AZURE_AUTHORITY_HOST (optional)\n        } else {\n            logger.info(\"Using explicit parameters for credential configuration\");\n            builder.tenantId(config.getTenantId())\n                   .clientId(config.getClientId())\n                   .tokenFilePath(config.getTokenFilePath());\n            \n            if (config.getAuthorityHost() != null) {\n                builder.authorityHost(config.getAuthorityHost());\n            }\n        }\n\n        WorkloadIdentityCredential credential = builder.build();\n        logger.info(\"WorkloadIdentityCredential created successfully\");\n        \n        return credential;\n    }\n\n    /**\n     * Acquires an access token for the specified scope\n     */\n    public AccessToken getToken(String scope) {\n        logger.info(\"Requesting access token for scope: {}\", scope);\n\n        try {\n            TokenRequestContext context = new TokenRequestContext()\n                .addScopes(scope);\n\n            AccessToken token = credential.getToken(context).block();\n\n            if (token != null) {\n                logger.info(\"\u2713 Token acquired successfully\");\n                logTokenDetails(token);\n                return token;\n            } else {\n                logger.error(\"\u2717 Token acquisition returned null\");\n                throw new RuntimeException(\"Token acquisition returned null\");\n            }\n\n        } catch (CredentialUnavailableException e) {\n            logger.error(\"\u2717 Credential unavailable: {}\", e.getMessage());\n            logger.error(\"This typically means the workload identity is not properly configured\");\n            throw e;\n        } catch (ClientAuthenticationException e) {\n            logger.error(\"\u2717 Authentication failed: {}\", e.getMessage());\n            logger.error(\"Check tenant ID, client ID, and federated identity configuration\");\n            throw e;\n        } catch (Exception e) {\n            logger.error(\"\u2717 Unexpected error during token acquisition\", e);\n            throw new RuntimeException(\"Token acquisition failed\", e);\n        }\n    }\n\n    /**\n     * Acquires a token for Azure Management API\n     */\n    public AccessToken getManagementToken() {\n        return getToken(MANAGEMENT_SCOPE);\n    }\n\n    /**\n     * Logs token details (without exposing the actual token)\n     */\n    private void logTokenDetails(AccessToken token) {\n        logger.info(\"=== Token Details ===\");\n        logger.info(\"Token acquired at: {}\", \n            OffsetDateTime.now().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));\n        logger.info(\"Token expires at: {}\", \n            token.getExpiresAt().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));\n        logger.info(\"Time until expiration: {} seconds\", \n            java.time.Duration.between(OffsetDateTime.now(), token.getExpiresAt()).getSeconds());\n        \n        // Decode",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10839,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses WorkloadIdentityCredential for AKS authentication with Azure Management API.\n\n```java\npackage com.example.app.azure;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport com.azure.identity.WorkloadIdentityCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\nimport java.time.OffsetDateTime;\n\n@Component\npublic class AksWorkloadIdentityAuthenticator {\n    private static final Logger log = LoggerFactory.getLogger(AksWorkloadIdentityAuthenticator.class);\n    private static final String AZURE_MANAGEMENT_SCOPE = \"https://management.azure.com/.default\";\n\n    /**\n     * Authenticates using WorkloadIdentityCredential with environment variables.\n     * Requires:\n     * - AZURE_TENANT_ID\n     * - AZURE_CLIENT_ID\n     * - AZURE_FEDERATED_TOKEN_FILE (typically /var/run/secrets/azure/tokens/azure-identity-token)\n     */\n    public AccessToken authenticateWithEnvironmentVariables() {\n        log.info(\"Authenticating with WorkloadIdentityCredential using environment variables\");\n        \n        // Enable verbose logging\n        System.setProperty(\"AZURE_LOG_LEVEL\", \"verbose\");\n        \n        try {\n            WorkloadIdentityCredential credential = new WorkloadIdentityCredentialBuilder()\n                .build();\n            \n            log.info(\"WorkloadIdentityCredential created successfully from environment\");\n            \n            return getAccessToken(credential);\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"Workload identity credential unavailable: {}\", e.getMessage());\n            throw new RuntimeException(\"Failed to create workload identity credential\", e);\n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed: {}\", e.getMessage());\n            throw new RuntimeException(\"Failed to authenticate with workload identity\", e);\n        }\n    }\n\n    /**\n     * Authenticates using WorkloadIdentityCredential with explicit parameters.\n     */\n    public AccessToken authenticateWithExplicitParameters(\n            String tenantId, \n            String clientId, \n            String tokenFilePath) {\n        \n        log.info(\"Authenticating with WorkloadIdentityCredential using explicit parameters\");\n        log.info(\"Tenant ID: {}\", tenantId);\n        log.info(\"Client ID: {}\", clientId);\n        log.info(\"Token file path: {}\", tokenFilePath);\n        \n        // Enable verbose logging\n        System.setProperty(\"AZURE_LOG_LEVEL\", \"verbose\");\n        \n        try {\n            WorkloadIdentityCredential credential = new WorkloadIdentityCredentialBuilder()\n                .tenantId(tenantId)\n                .clientId(clientId)\n                .tokenFilePath(tokenFilePath)\n                .build();\n            \n            log.info(\"WorkloadIdentityCredential created successfully with explicit parameters\");\n            \n            return getAccessToken(credential);\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"Workload identity credential unavailable: {}\", e.getMessage());\n            throw new RuntimeException(\"Failed to create workload identity credential\", e);\n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed: {}\", e.getMessage());\n            throw new RuntimeException(\"Failed to authenticate with workload identity\", e);\n        }\n    }\n\n    /**\n     * Gets an access token for the Azure Management API scope.\n     */\n    private AccessToken getAccessToken(WorkloadIdentityCredential credential) {\n        TokenRequestContext context = new TokenRequestContext()\n            .addScopes(AZURE_MANAGEMENT_SCOPE);\n        \n        log.info(\"Requesting access token for scope: {}\", AZURE_MANAGEMENT_SCOPE);\n        \n        AccessToken token = credential.getToken(context).block();\n        \n        if (token != null) {\n            OffsetDateTime expiresAt = token.getExpiresAt();\n            log.info(\"Access token acquired successfully\");\n            log.info(\"Token expires at: {}\", expiresAt);\n            log.info(\"Token value (first 20 chars): {}...\", \n                token.getToken().substring(0, Math.min(20, token.getToken().length())));\n            \n            return token;\n        } else {\n            throw new RuntimeException(\"Failed to acquire access token\");\n        }\n    }\n\n    /**\n     * Validates that required environment variables are set.\n     */\n    public void validateEnvironmentVariables() {\n        String tenantId = System.getenv(\"AZURE_TENANT_ID\");\n        String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n        String tokenFile = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n        \n        log.info(\"Validating environment variables for WorkloadIdentityCredential\");\n        log.info(\"AZURE_TENANT_ID: {}\", tenantId != null ? \"SET\" : \"NOT SET\");\n        log.info(\"AZURE_CLIENT_ID: {}\", clientId != null ? \"SET\" : \"NOT SET\");\n        log.info(\"AZURE_FEDERATED_TOKEN_FILE: {}\", tokenFile != null ? tokenFile : \"NOT SET\");\n        \n        if (tenantId == null || clientId == null || tokenFile == null) {\n            throw new IllegalStateException(\n                \"Required environment variables not set. Need: AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_FEDERATED_TOKEN_FILE\");\n        }\n    }\n}\n```\n\n```java\npackage com.example.app.azure;\n\nimport com.azure.core.credential.AccessToken;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\n\n@SpringBootApplication\npublic class WorkloadIdentityApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(WorkloadIdentityApplication.class, args);\n    }\n\n    @Bean\n    public CommandLineRunner run(AksWorkloadIdentityAuthenticator authenticator) {\n        return args -> {\n            System.out.println(\"=== Azure Workload Identity Authentication Demo ===\\n\");\n            \n            // Method 1: Using environment variables\n            System.out.println(\"Method 1: Authentication using environment variables\");\n            System.out.println(\"---------------------------------------------------\");\n            \n            try {\n                authenticator.validateEnvironmentVariables();\n                AccessToken token1 = authenticator.authenticateWithEnvironmentVariables();\n                System.out.println(\"\u2713 Successfully authenticated using environment variables\");\n                System.out.println(\"Token expires at: \" + token1.getExpiresAt());\n            } catch (Exception e) {\n                System.err.println(\"\u2717 Failed to authenticate using environment variables: \" + e.getMessage());\n            }\n            \n            System.out.println(\"\\n\");\n            \n            // Method 2: Using explicit parameters\n            System.out.println(\"Method 2: Authentication using explicit parameters\");\n            System.out.println(\"--------------------------------------------------\");\n            \n            String tenantId = System.getenv(\"AZURE_TENANT_ID\");\n            String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n            String tokenFilePath = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n            \n            if (tenantId != null && clientId != null && tokenFilePath != null) {\n                try {\n                    AccessToken token2 = authenticator.authenticateWithExplicitParameters(\n                        tenantId, clientId, tokenFilePath);\n                    System.out.println(\"\u2713 Successfully authenticated using explicit parameters\");\n                    System.out.println(\"Token expires at: \" + token2.getExpiresAt());\n                } catch (Exception e) {\n                    System.err.println(\"\u2717 Failed to authenticate using explicit parameters: \" + e.getMessage());\n                }\n            } else {\n                System.err.println(\"\u2717 Environment variables not set for explicit parameter test\");\n            }\n            \n            System.out.println(\"\\n=== Demo Complete ===\");\n        };\n    }\n}\n```\n\n```xml\n<!-- Add to pom.xml -->\n<dependencies>\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.15.0</version>\n    </dependency>\n    \n    <!-- Azure Core -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-core</artifactId>\n        <version>1.54.0</version>\n    </dependency>\n    \n    <!-- Spring Boot Starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    \n    <!-- SLF4J Logging -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n    </dependency>\n</dependencies>\n```\n\n```yaml\n# kubernetes-deployment.yaml\n# Example Kubernetes deployment with workload identity\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: workload-identity-sa\n  namespace: default\n  annotations:\n    azure.workload.identity/client-id: \"<YOUR_CLIENT_ID>\"\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: workload-identity-app\n  namespace: default\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: workload-identity-app\n  template:\n    metadata:\n      labels:\n        app: workload-identity-app\n        azure.workload.identity/use: \"true\"\n    spec:\n      serviceAccountName: workload-identity-sa\n      containers:\n      - name: app\n        image: your-registry/workload-identity-app:latest\n        env:\n        - name: AZURE_TENANT_ID\n          value: \"<YOUR_TENANT_ID>\"\n        - name: AZURE_CLIENT_ID\n          value: \"<YOUR_CLIENT_ID>\"\n        - name: AZURE_FEDERATED_TOKEN_FILE\n          value: \"/var/run/secrets/azure/tokens/azure-identity-token\"\n        volumeMounts:\n        - name: azure-identity-token\n          mountPath: /var/run/secrets/azure/tokens\n          readOnly: true\n      volumes:\n      - name: azure-identity-token\n        projected:\n          sources:\n          - serviceAccountToken:\n              path: azure-identity-token\n              expirationSeconds: 3600\n              audience: api://AzureADTokenExchange\n```\n\n```properties\n# application.properties\n# Enable verbose logging for Azure Identity\nlogging.level.com.azure.identity=DEBUG\nlogging.level.com.azure.core=DEBUG\nlogging.level.com.example.app.azure=DEBUG\n\n# Application name\nspring.application.name=workload-identity-app\n```\n\n```java\npackage com.example.app.azure;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport com.azure.identity.WorkloadIdentityCredentialBuilder;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass AksWorkloadIdentityAuthenticatorTest {\n\n    private AksWorkloadIdentityAuthenticator authenticator;\n\n    @BeforeEach\n    void setUp() {\n        authenticator = new AksWorkloadIdentityAuthenticator();\n    }\n\n    @Test\n    @EnabledIfEnvironmentVariable(named = \"AZURE_TENANT_ID\", matches = \".+\")\n    @EnabledIfEnvironmentVariable(named = \"AZURE_CLIENT_ID\", matches = \".+\")\n    @EnabledIfEnvironmentVariable(named = \"AZURE_FEDERATED_TOKEN_FILE\", matches = \".+\")\n    void testAuthenticateWithEnvironmentVariables() {\n        // This test only runs if environment variables are set\n        assertDoesNotThrow(() -> {\n            authenticator.validateEnvironmentVariables();\n            AccessToken token = authenticator.authenticateWithEnvironmentVariables();\n            assertNotNull(token);\n            assertNotNull(token.getToken());\n            assertNotNull(token.getExpiresAt());\n        });\n    }\n\n    @Test\n    void testValidateEnvironmentVariablesThrowsWhenNotSet() {\n        // Clear environment (in real scenario, would use mocking)\n        // This test verifies the validation logic\n        if (System.getenv(\"AZURE_TENANT_ID\") == null) {\n            assertThrows(IllegalStateException.class, \n                () -> authenticator.validateEnvironmentVariables());\n        }\n    }\n}\n```\n\n```dockerfile\n# Dockerfile\nFROM eclipse-temurin:21-jre-alpine\n\nWORKDIR /app\n\n# Copy the JAR file\nCOPY target/workload-identity-app.jar app.jar\n\n# Create directory for Azure tokens\nRUN mkdir -p /var/run/secrets/azure/tokens\n\n# Run as non-root user\nRUN addgroup -g 1000 appuser && \\\n    adduser -D -u 1000 -G appuser appuser && \\\n    chown -R appuser:appuser /app\n\nUSER appuser\n\nEXPOSE 8080\n\nENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]\n```\n\n## Key Features:\n\n1. **WorkloadIdentityCredential** - Uses federated identity tokens from AKS\n2. **Two authentication methods**:\n   - Environment variables (automatic)\n   - Explicit parameters (manual configuration)\n3. **Azure Management API scope** - `https://management.azure.com/.default`\n4. **Verbose logging** - Set via `AZURE_LOG_LEVEL=verbose`\n5. **Token validation** - Checks expiration and logs token info\n6. **Environment validation** - Ensures required variables are set\n7. **Kubernetes deployment** - Complete YAML with service account and workload identity annotations\n\nThe application demonstrates both approaches and includes proper error handling, logging, and Kubernetes configuration for AKS workload identity.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11364,
            "output_tokens": 3591,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Azure AKS Workload Identity Authentication Application\n\nI'll create a comprehensive Java application that demonstrates using WorkloadIdentityCredential to authenticate from an AKS pod.\n\n## Project Structure\n\n```\nazure-aks-workload-identity/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 aks/\n\u2502       \u2502               \u251c\u2500\u2500 AksWorkloadIdentityApp.java\n\u2502       \u2502               \u251c\u2500\u2500 config/\n\u2502       \u2502               \u2502   \u251c\u2500\u2500 WorkloadIdentityConfig.java\n\u2502       \u2502               \u2502   \u2514\u2500\u2500 LoggingConfig.java\n\u2502       \u2502               \u251c\u2500\u2500 auth/\n\u2502       \u2502               \u2502   \u251c\u2500\u2500 WorkloadIdentityAuthenticator.java\n\u2502       \u2502               \u2502   \u2514\u2500\u2500 TokenManager.java\n\u2502       \u2502               \u2514\u2500\u2500 service/\n\u2502       \u2502                   \u2514\u2500\u2500 AzureManagementService.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u251c\u2500\u2500 application.properties\n\u2502           \u2514\u2500\u2500 logback.xml\n\u251c\u2500\u2500 kubernetes/\n\u2502   \u251c\u2500\u2500 deployment.yaml\n\u2502   \u251c\u2500\u2500 service-account.yaml\n\u2502   \u2514\u2500\u2500 federated-identity.yaml\n\u2514\u2500\u2500 README.md\n```\n\n## 1. Maven Configuration (pom.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.aks</groupId>\n    <artifactId>azure-aks-workload-identity</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure AKS Workload Identity</name>\n    <description>Azure AKS Workload Identity Authentication Demo</description>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.identity.version>1.11.1</azure.identity.version>\n        <azure.core.version>1.45.1</azure.core.version>\n        <azure.resourcemanager.version>2.33.0</azure.resourcemanager.version>\n        <slf4j.version>2.0.9</slf4j.version>\n        <logback.version>1.4.14</logback.version>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure.identity.version}</version>\n        </dependency>\n\n        <!-- Azure Core -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n            <version>${azure.core.version}</version>\n        </dependency>\n\n        <!-- Azure Resource Manager -->\n        <dependency>\n            <groupId>com.azure.resourcemanager</groupId>\n            <artifactId>azure-resourcemanager</artifactId>\n            <version>${azure.resourcemanager.version}</version>\n        </dependency>\n\n        <!-- Azure Core HTTP Netty -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core-http-netty</artifactId>\n            <version>1.14.0</version>\n        </dependency>\n\n        <!-- Logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <!-- JSON Processing -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.16.1</version>\n        </dependency>\n\n        <!-- Apache Commons -->\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-lang3</artifactId>\n            <version>3.14.0</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.aks.AksWorkloadIdentityApp</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Main Application\n\n```java\npackage com.azure.aks;\n\nimport com.azure.aks.auth.WorkloadIdentityAuthenticator;\nimport com.azure.aks.config.LoggingConfig;\nimport com.azure.aks.config.WorkloadIdentityConfig;\nimport com.azure.aks.service.AzureManagementService;\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.OffsetDateTime;\n\n/**\n * Main application demonstrating Azure Workload Identity authentication from AKS\n */\npublic class AksWorkloadIdentityApp {\n    private static final Logger logger = LoggerFactory.getLogger(AksWorkloadIdentityApp.class);\n\n    public static void main(String[] args) {\n        try {\n            logger.info(\"=\".repeat(80));\n            logger.info(\"Azure AKS Workload Identity Authentication Demo\");\n            logger.info(\"=\".repeat(80));\n\n            // Configure verbose logging\n            LoggingConfig.configureVerboseLogging();\n\n            // Display environment information\n            displayEnvironmentInfo();\n\n            // Method 1: Using environment variables\n            logger.info(\"\\n\" + \"=\".repeat(80));\n            logger.info(\"METHOD 1: Authentication using Environment Variables\");\n            logger.info(\"=\".repeat(80));\n            authenticateWithEnvironmentVariables();\n\n            // Method 2: Using explicit parameters\n            logger.info(\"\\n\" + \"=\".repeat(80));\n            logger.info(\"METHOD 2: Authentication using Explicit Parameters\");\n            logger.info(\"=\".repeat(80));\n            authenticateWithExplicitParameters();\n\n            // Method 3: Using configuration object\n            logger.info(\"\\n\" + \"=\".repeat(80));\n            logger.info(\"METHOD 3: Authentication using Configuration Object\");\n            logger.info(\"=\".repeat(80));\n            authenticateWithConfiguration();\n\n            // Demonstrate Azure Management API calls\n            logger.info(\"\\n\" + \"=\".repeat(80));\n            logger.info(\"AZURE MANAGEMENT API OPERATIONS\");\n            logger.info(\"=\".repeat(80));\n            demonstrateManagementApiCalls();\n\n            logger.info(\"\\n\" + \"=\".repeat(80));\n            logger.info(\"Application completed successfully!\");\n            logger.info(\"=\".repeat(80));\n\n        } catch (Exception e) {\n            logger.error(\"Application failed with error\", e);\n            System.exit(1);\n        }\n    }\n\n    private static void displayEnvironmentInfo() {\n        logger.info(\"\\nEnvironment Information:\");\n        logger.info(\"-\".repeat(80));\n\n        String[] envVars = {\n            \"AZURE_TENANT_ID\",\n            \"AZURE_CLIENT_ID\",\n            \"AZURE_FEDERATED_TOKEN_FILE\",\n            \"AZURE_AUTHORITY_HOST\",\n            \"HOSTNAME\",\n            \"KUBERNETES_SERVICE_HOST\"\n        };\n\n        for (String envVar : envVars) {\n            String value = System.getenv(envVar);\n            if (value != null) {\n                // Mask sensitive information\n                if (envVar.contains(\"TOKEN\") || envVar.contains(\"SECRET\")) {\n                    logger.info(\"{}: {}...{}\", envVar, \n                        value.substring(0, Math.min(10, value.length())),\n                        value.length() > 10 ? \"***\" : \"\");\n                } else {\n                    logger.info(\"{}: {}\", envVar, value);\n                }\n            } else {\n                logger.warn(\"{}: NOT SET\", envVar);\n            }\n        }\n        logger.info(\"-\".repeat(80));\n    }\n\n    private static void authenticateWithEnvironmentVariables() {\n        try {\n            logger.info(\"Creating WorkloadIdentityCredential using environment variables...\");\n            \n            WorkloadIdentityAuthenticator authenticator = \n                WorkloadIdentityAuthenticator.fromEnvironment();\n            \n            AccessToken token = authenticator.getToken();\n            displayTokenInfo(token);\n            \n            // Validate token\n            authenticator.validateToken(token);\n            \n        } catch (Exception e) {\n            logger.error(\"Authentication with environment variables failed\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static void authenticateWithExplicitParameters() {\n        try {\n            logger.info(\"Creating WorkloadIdentityCredential with explicit parameters...\");\n            \n            String tenantId = System.getenv(\"AZURE_TENANT_ID\");\n            String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n            String tokenFile = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n            \n            if (tenantId == null || clientId == null || tokenFile == null) {\n                logger.warn(\"Required environment variables not set. Skipping explicit parameter authentication.\");\n                return;\n            }\n            \n            WorkloadIdentityAuthenticator authenticator = \n                WorkloadIdentityAuthenticator.withExplicitParameters(\n                    tenantId, clientId, tokenFile);\n            \n            AccessToken token = authenticator.getToken();\n            displayTokenInfo(token);\n            \n        } catch (Exception e) {\n            logger.error(\"Authentication with explicit parameters failed\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static void authenticateWithConfiguration() {\n        try {\n            logger.info(\"Creating WorkloadIdentityCredential using configuration object...\");\n            \n            WorkloadIdentityConfig config = WorkloadIdentityConfig.fromEnvironment();\n            config.displayConfiguration();\n            \n            WorkloadIdentityAuthenticator authenticator = \n                WorkloadIdentityAuthenticator.fromConfig(config);\n            \n            AccessToken token = authenticator.getToken();\n            displayTokenInfo(token);\n            \n            // Test token refresh\n            logger.info(\"\\nTesting token refresh...\");\n            AccessToken refreshedToken = authenticator.refreshToken();\n            displayTokenInfo(refreshedToken);\n            \n        } catch (Exception e) {\n            logger.error(\"Authentication with configuration failed\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static void demonstrateManagementApiCalls() {\n        try {\n            WorkloadIdentityConfig config = WorkloadIdentityConfig.fromEnvironment();\n            AzureManagementService managementService = new AzureManagementService(config);\n            \n            // List subscriptions\n            managementService.listSubscriptions();\n            \n            // List resource groups (if subscription ID is available)\n            String subscriptionId = System.getenv(\"AZURE_SUBSCRIPTION_ID\");\n            if (subscriptionId != null && !subscriptionId.isEmpty()) {\n                managementService.listResourceGroups(subscriptionId);\n                managementService.listVirtualMachines(subscriptionId);\n            } else {\n                logger.warn(\"AZURE_SUBSCRIPTION_ID not set. Skipping resource group and VM listing.\");\n            }\n            \n        } catch (Exception e) {\n            logger.error(\"Management API calls failed\", e);\n        }\n    }\n\n    private static void displayTokenInfo(AccessToken token) {\n        if (token == null) {\n            logger.error(\"Token is null!\");\n            return;\n        }\n\n        logger.info(\"\\nToken Information:\");\n        logger.info(\"-\".repeat(80));\n        logger.info(\"Token (first 50 chars): {}...\", \n            token.getToken().substring(0, Math.min(50, token.getToken().length())));\n        logger.info(\"Expires At: {}\", token.getExpiresAt());\n        logger.info(\"Is Expired: {}\", token.isExpired());\n        \n        OffsetDateTime now = OffsetDateTime.now();\n        Duration timeUntilExpiry = Duration.between(now, token.getExpiresAt());\n        logger.info(\"Time until expiry: {} minutes\", timeUntilExpiry.toMinutes());\n        logger.info(\"-\".repeat(80));\n    }\n}\n```\n\n## 3. Workload Identity Configuration\n\n```java\npackage com.azure.aks.config;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Configuration class for Azure Workload Identity\n */\npublic class WorkloadIdentityConfig {\n    private static final Logger logger = LoggerFactory.getLogger(WorkloadIdentityConfig.class);\n\n    private String tenantId;\n    private String clientId;\n    private String federatedTokenFile;\n    private String authorityHost;\n    private String subscriptionId;\n    private Map<String, String> additionalProperties;\n\n    // Default values\n    private static final String DEFAULT_AUTHORITY_HOST = \"https://login.microsoftonline.com/\";\n    private static final String DEFAULT_TOKEN_FILE = \"/var/run/secrets/azure/tokens/azure-identity-token\";\n\n    public WorkloadIdentityConfig() {\n        this.additionalProperties = new HashMap<>();\n    }\n\n    /**\n     * Create configuration from environment variables\n     */\n    public static WorkloadIdentityConfig fromEnvironment() {\n        logger.info(\"Loading Workload Identity configuration from environment variables\");\n        \n        WorkloadIdentityConfig config = new WorkloadIdentityConfig();\n        \n        config.tenantId = getRequiredEnv(\"AZURE_TENANT_ID\");\n        config.clientId = getRequiredEnv(\"AZURE_CLIENT_ID\");\n        config.federatedTokenFile = System.getenv().getOrDefault(\n            \"AZURE_FEDERATED_TOKEN_FILE\", DEFAULT_TOKEN_FILE);\n        config.authorityHost = System.getenv().getOrDefault(\n            \"AZURE_AUTHORITY_HOST\", DEFAULT_AUTHORITY_HOST);\n        config.subscriptionId = System.getenv(\"AZURE_SUBSCRIPTION_ID\");\n        \n        // Validate token file exists\n        config.validateTokenFile();\n        \n        return config;\n    }\n\n    /**\n     * Create configuration with explicit parameters\n     */\n    public static WorkloadIdentityConfig",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 62,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Workload Identity Authentication in AKS\n\nI'll create a comprehensive Java application demonstrating WorkloadIdentityCredential usage in AKS with both environment variable and explicit configuration approaches.\n\n## Project Structure\n\n```\nworkload-identity-demo/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 identity/\n\u2502       \u2502               \u2514\u2500\u2500 demo/\n\u2502       \u2502                   \u251c\u2500\u2500 WorkloadIdentityDemo.java\n\u2502       \u2502                   \u251c\u2500\u2500 EnvironmentBasedAuth.java\n\u2502       \u2502                   \u251c\u2500\u2500 ExplicitConfigAuth.java\n\u2502       \u2502                   \u2514\u2500\u2500 TokenValidator.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u2514\u2500\u2500 logback.xml\n\u251c\u2500\u2500 kubernetes/\n\u2502   \u251c\u2500\u2500 deployment.yaml\n\u2502   \u251c\u2500\u2500 service-account.yaml\n\u2502   \u2514\u2500\u2500 federated-identity.yaml\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.identity.demo</groupId>\n    <artifactId>workload-identity-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Workload Identity Demo</name>\n    <description>Demo application for WorkloadIdentityCredential in AKS</description>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <azure.sdk.version>1.2.29</azure.sdk.version>\n        <slf4j.version>2.0.9</slf4j.version>\n        <logback.version>1.4.14</logback.version>\n    </properties>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.azure</groupId>\n                <artifactId>azure-sdk-bom</artifactId>\n                <version>${azure.sdk.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n        </dependency>\n\n        <!-- Azure Core for HTTP client -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n        </dependency>\n\n        <!-- Azure Resource Manager (for management API calls) -->\n        <dependency>\n            <groupId>com.azure.resourcemanager</groupId>\n            <artifactId>azure-resourcemanager</artifactId>\n        </dependency>\n\n        <!-- Logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>${logback.version}</version>\n        </dependency>\n\n        <!-- JSON processing -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            \n            <!-- Create executable JAR with dependencies -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.identity.demo.WorkloadIdentityDemo</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## Main Application\n\n### WorkloadIdentityDemo.java\n\n```java\npackage com.azure.identity.demo;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.OffsetDateTime;\nimport java.util.Arrays;\n\n/**\n * Main application demonstrating WorkloadIdentityCredential usage in AKS.\n * Supports both environment-based and explicit configuration.\n */\npublic class WorkloadIdentityDemo {\n    private static final Logger logger = LoggerFactory.getLogger(WorkloadIdentityDemo.class);\n    \n    // Azure Management API scope\n    private static final String MANAGEMENT_SCOPE = \"https://management.azure.com/.default\";\n    \n    public static void main(String[] args) {\n        // Enable verbose logging\n        enableVerboseLogging();\n        \n        logger.info(\"=\".repeat(80));\n        logger.info(\"Azure Workload Identity Demo - AKS Pod Authentication\");\n        logger.info(\"=\".repeat(80));\n        \n        // Display environment information\n        displayEnvironmentInfo();\n        \n        // Determine authentication mode\n        String authMode = System.getenv().getOrDefault(\"AUTH_MODE\", \"environment\");\n        logger.info(\"Authentication mode: {}\", authMode);\n        \n        try {\n            if (\"explicit\".equalsIgnoreCase(authMode)) {\n                runExplicitConfigAuth();\n            } else {\n                runEnvironmentBasedAuth();\n            }\n            \n            logger.info(\"=\".repeat(80));\n            logger.info(\"Authentication completed successfully!\");\n            logger.info(\"=\".repeat(80));\n            \n        } catch (CredentialUnavailableException e) {\n            logger.error(\"Credential unavailable: {}\", e.getMessage());\n            logger.error(\"This typically means the workload identity is not properly configured.\");\n            logger.error(\"Check: AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_FEDERATED_TOKEN_FILE\");\n            System.exit(1);\n            \n        } catch (ClientAuthenticationException e) {\n            logger.error(\"Authentication failed: {}\", e.getMessage());\n            logger.error(\"Check: Federated identity configuration, service account binding\");\n            System.exit(1);\n            \n        } catch (Exception e) {\n            logger.error(\"Unexpected error: {}\", e.getMessage(), e);\n            System.exit(1);\n        }\n    }\n    \n    /**\n     * Enable verbose logging for Azure SDK\n     */\n    private static void enableVerboseLogging() {\n        // Set Azure SDK logging level to verbose\n        System.setProperty(\"AZURE_LOG_LEVEL\", \"verbose\");\n        \n        // Enable HTTP request/response logging\n        System.setProperty(\"azure.core.http.log.level\", \"BODY_AND_HEADERS\");\n        \n        logger.info(\"Verbose logging enabled for Azure SDK\");\n    }\n    \n    /**\n     * Display current environment information\n     */\n    private static void displayEnvironmentInfo() {\n        logger.info(\"\\n\" + \"=\".repeat(80));\n        logger.info(\"Environment Information:\");\n        logger.info(\"=\".repeat(80));\n        \n        // Workload Identity environment variables\n        String[] envVars = {\n            \"AZURE_TENANT_ID\",\n            \"AZURE_CLIENT_ID\",\n            \"AZURE_FEDERATED_TOKEN_FILE\",\n            \"AZURE_AUTHORITY_HOST\",\n            \"AUTH_MODE\"\n        };\n        \n        for (String envVar : envVars) {\n            String value = System.getenv(envVar);\n            if (value != null) {\n                // Mask sensitive values partially\n                if (envVar.contains(\"TOKEN\") || envVar.contains(\"SECRET\")) {\n                    value = maskValue(value);\n                }\n                logger.info(\"{}: {}\", envVar, value);\n            } else {\n                logger.warn(\"{}: NOT SET\", envVar);\n            }\n        }\n        \n        // Kubernetes service account token\n        String tokenFile = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n        if (tokenFile != null) {\n            java.io.File file = new java.io.File(tokenFile);\n            logger.info(\"Token file exists: {}\", file.exists());\n            if (file.exists()) {\n                logger.info(\"Token file size: {} bytes\", file.length());\n                logger.info(\"Token file readable: {}\", file.canRead());\n            }\n        }\n        \n        logger.info(\"=\".repeat(80) + \"\\n\");\n    }\n    \n    /**\n     * Run authentication using environment variables\n     */\n    private static void runEnvironmentBasedAuth() {\n        logger.info(\"\\n\" + \"=\".repeat(80));\n        logger.info(\"Method 1: Environment-Based Authentication\");\n        logger.info(\"=\".repeat(80));\n        \n        EnvironmentBasedAuth auth = new EnvironmentBasedAuth();\n        AccessToken token = auth.authenticate(MANAGEMENT_SCOPE);\n        \n        displayTokenInfo(token, \"Environment-Based\");\n        validateAndUseToken(token);\n    }\n    \n    /**\n     * Run authentication using explicit configuration\n     */\n    private static void runExplicitConfigAuth() {\n        logger.info(\"\\n\" + \"=\".repeat(80));\n        logger.info(\"Method 2: Explicit Configuration Authentication\");\n        logger.info(\"=\".repeat(80));\n        \n        String tenantId = System.getenv(\"AZURE_TENANT_ID\");\n        String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n        String tokenFilePath = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n        \n        if (tenantId == null || clientId == null || tokenFilePath == null) {\n            throw new IllegalStateException(\n                \"Required environment variables not set for explicit configuration. \" +\n                \"Set AZURE_TENANT_ID, AZURE_CLIENT_ID, and AZURE_FEDERATED_TOKEN_FILE\"\n            );\n        }\n        \n        ExplicitConfigAuth auth = new ExplicitConfigAuth(tenantId, clientId, tokenFilePath);\n        AccessToken token = auth.authenticate(MANAGEMENT_SCOPE);\n        \n        displayTokenInfo(token, \"Explicit Configuration\");\n        validateAndUseToken(token);\n    }\n    \n    /**\n     * Display token information\n     */\n    private static void displayTokenInfo(AccessToken token, String method) {\n        logger.info(\"\\n\" + \"-\".repeat(80));\n        logger.info(\"Token Information ({}):\", method);\n        logger.info(\"-\".repeat(80));\n        logger.info(\"Token acquired successfully!\");\n        logger.info(\"Token (first 20 chars): {}...\", token.getToken().substring(0, 20));\n        logger.info(\"Token length: {} characters\", token.getToken().length());\n        logger.info(\"Expires at: {}\", token.getExpiresAt());\n        \n        OffsetDateTime now = OffsetDateTime.now();\n        Duration timeUntilExpiry = Duration.between(now, token.getExpiresAt());\n        logger.info(\"Time until expiry: {} minutes\", timeUntilExpiry.toMinutes());\n        logger.info(\"Is expired: {}\", token.isExpired());\n        logger.info(\"-\".repeat(80) + \"\\n\");\n    }\n    \n    /**\n     * Validate and use the token\n     */\n    private static void validateAndUseToken(AccessToken token) {\n        TokenValidator validator = new TokenValidator();\n        validator.validateToken(token);\n        validator.demonstrateTokenUsage(token);\n    }\n    \n    /**\n     * Mask sensitive values for logging\n     */\n    private static String maskValue(String value) {\n        if (value == null || value.length() <= 8) {\n            return \"***\";\n        }\n        return value.substring(0, 4) + \"...\" + value.substring(value.length() - 4);\n    }\n}\n```\n\n## Authentication Implementations\n\n### EnvironmentBasedAuth.java\n\n```java\npackage com.azure.identity.demo;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport com.azure.identity.WorkloadIdentityCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Demonstrates WorkloadIdentityCredential using environment variables.\n * Requires: AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_FEDERATED_TOKEN_FILE\n */\npublic class EnvironmentBasedAuth {\n    private static final Logger logger = LoggerFactory.getLogger(EnvironmentBasedAuth.class);\n    \n    /**\n     * Authenticate using environment variables\n     */\n    public AccessToken authenticate(String scope) {\n        logger.info(\"Creating WorkloadIdentityCredential from environment variables...\");\n        \n        // Verify required environment variables\n        verifyEnvironmentVariables();\n        \n        // Create credential - reads from environment automatically\n        WorkloadIdentityCredential credential = new WorkloadIdentityCredentialBuilder()\n            .build();\n        \n        logger.info(\"WorkloadIdentityCredential created successfully\");\n        logger.info(\"Requesting access token for scope: {}\", scope);\n        \n        // Request token\n        TokenRequestContext context = new TokenRequestContext()\n            .addScopes(scope);\n        \n        AccessToken token = credential.getToken(context).block();\n        \n        if (token == null) {\n            throw new IllegalStateException(\"Failed to acquire token\");\n        }\n        \n        logger.info(\"Token acquired successfully using environment variables\");\n        return token;\n    }\n    \n    /**\n     * Verify required environment variables are set\n     */\n    private void verifyEnvironmentVariables() {\n        String[] required = {\n            \"AZURE_TENANT_ID\",\n            \"AZURE_CLIENT_ID\",\n            \"AZURE_FEDERATED_TOKEN_FILE\"\n        };\n        \n        StringBuilder missing = new StringBuilder();\n        for (String var : required) {\n            if (System.getenv(var) == null) {\n                if (missing.length() > 0) {\n                    missing.append(\", \");\n                }\n                missing.append(var);\n            }\n        }\n        \n        if (missing.length() > 0) {\n            throw new IllegalStateException(\n                \"Required environment variables not set: \" + missing.toString()\n            );\n        }\n        \n        logger.info(\"All required environment variables are set\");\n    }\n}\n```\n\n### ExplicitConfigAuth.java\n\n```java\npackage com.azure.identity",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10839,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses WorkloadIdentityCredential for AKS authentication with Azure Management API access.\n\n```java\npackage com.example.app.azure;\n\nimport com.azure.core.credential.AccessToken;\nimport com.azure.core.credential.TokenRequestContext;\nimport com.azure.core.exception.ClientAuthenticationException;\nimport com.azure.identity.CredentialUnavailableException;\nimport com.azure.identity.WorkloadIdentityCredential;\nimport com.azure.identity.WorkloadIdentityCredentialBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\n/**\n * Azure Workload Identity authentication for AKS pods.\n * Authenticates using federated identity tokens and retrieves access tokens\n * for Azure Management API.\n */\n@Component\npublic class AksWorkloadIdentityClient {\n    \n    private static final Logger log = LoggerFactory.getLogger(AksWorkloadIdentityClient.class);\n    private static final String AZURE_MANAGEMENT_SCOPE = \"https://management.azure.com/.default\";\n    \n    private final WorkloadIdentityCredential credential;\n    \n    public AksWorkloadIdentityClient() {\n        this.credential = createWorkloadIdentityCredential();\n    }\n    \n    /**\n     * Creates WorkloadIdentityCredential with both environment variable\n     * and explicit configuration support.\n     */\n    private WorkloadIdentityCredential createWorkloadIdentityCredential() {\n        log.info(\"Initializing WorkloadIdentityCredential for AKS\");\n        \n        // Enable verbose logging\n        System.setProperty(\"AZURE_LOG_LEVEL\", \"verbose\");\n        \n        // Read environment variables\n        String tenantId = System.getenv(\"AZURE_TENANT_ID\");\n        String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n        String tokenFilePath = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n        \n        log.info(\"Environment configuration:\");\n        log.info(\"  AZURE_TENANT_ID: {}\", tenantId != null ? \"***\" + tenantId.substring(Math.max(0, tenantId.length() - 4)) : \"not set\");\n        log.info(\"  AZURE_CLIENT_ID: {}\", clientId != null ? \"***\" + clientId.substring(Math.max(0, clientId.length() - 4)) : \"not set\");\n        log.info(\"  AZURE_FEDERATED_TOKEN_FILE: {}\", tokenFilePath != null ? tokenFilePath : \"not set\");\n        \n        WorkloadIdentityCredentialBuilder builder = new WorkloadIdentityCredentialBuilder();\n        \n        // Configure with explicit parameters if environment variables are set\n        if (tenantId != null && !tenantId.isEmpty()) {\n            builder.tenantId(tenantId);\n            log.debug(\"Configured explicit tenantId\");\n        }\n        \n        if (clientId != null && !clientId.isEmpty()) {\n            builder.clientId(clientId);\n            log.debug(\"Configured explicit clientId\");\n        }\n        \n        if (tokenFilePath != null && !tokenFilePath.isEmpty()) {\n            builder.tokenFilePath(tokenFilePath);\n            log.debug(\"Configured explicit tokenFilePath: {}\", tokenFilePath);\n        }\n        \n        WorkloadIdentityCredential cred = builder.build();\n        log.info(\"WorkloadIdentityCredential created successfully\");\n        \n        return cred;\n    }\n    \n    /**\n     * Retrieves an access token for Azure Management API.\n     * \n     * @return AccessToken for Azure Management API\n     * @throws CredentialUnavailableException if workload identity is not available\n     * @throws ClientAuthenticationException if authentication fails\n     */\n    public AccessToken getManagementApiToken() {\n        log.info(\"Requesting access token for Azure Management API\");\n        \n        try {\n            TokenRequestContext context = new TokenRequestContext()\n                .addScopes(AZURE_MANAGEMENT_SCOPE);\n            \n            AccessToken token = credential.getToken(context).block();\n            \n            if (token != null) {\n                log.info(\"Successfully acquired access token\");\n                log.info(\"Token expires at: {}\", token.getExpiresAt());\n                log.debug(\"Token (first 20 chars): {}...\", \n                    token.getToken().substring(0, Math.min(20, token.getToken().length())));\n                return token;\n            } else {\n                log.error(\"Token acquisition returned null\");\n                throw new ClientAuthenticationException(\"Token acquisition returned null\", null);\n            }\n            \n        } catch (CredentialUnavailableException e) {\n            log.error(\"Workload identity credential unavailable. \" +\n                \"Ensure the pod is configured with workload identity federation.\", e);\n            log.error(\"Check that:\");\n            log.error(\"  1. Service account has azure.workload.identity/client-id annotation\");\n            log.error(\"  2. Pod has azure.workload.identity/use label set to 'true'\");\n            log.error(\"  3. Federated identity credential is configured in Azure\");\n            throw e;\n            \n        } catch (ClientAuthenticationException e) {\n            log.error(\"Authentication failed: {}\", e.getMessage(), e);\n            log.error(\"Verify:\");\n            log.error(\"  1. Tenant ID is correct\");\n            log.error(\"  2. Client ID matches the managed identity\");\n            log.error(\"  3. Federated credential subject matches the service account\");\n            throw e;\n            \n        } catch (Exception e) {\n            log.error(\"Unexpected error during token acquisition\", e);\n            throw new RuntimeException(\"Failed to acquire token\", e);\n        }\n    }\n    \n    /**\n     * Retrieves a token for a custom scope.\n     * \n     * @param scope Azure resource scope (e.g., \"https://storage.azure.com/.default\")\n     * @return AccessToken for the specified scope\n     */\n    public AccessToken getTokenForScope(String scope) {\n        log.info(\"Requesting access token for scope: {}\", scope);\n        \n        try {\n            TokenRequestContext context = new TokenRequestContext()\n                .addScopes(scope);\n            \n            AccessToken token = credential.getToken(context).block();\n            \n            if (token != null) {\n                log.info(\"Successfully acquired token for scope: {}\", scope);\n                log.info(\"Token expires at: {}\", token.getExpiresAt());\n                return token;\n            } else {\n                throw new ClientAuthenticationException(\"Token acquisition returned null\", null);\n            }\n            \n        } catch (Exception e) {\n            log.error(\"Failed to acquire token for scope: {}\", scope, e);\n            throw e;\n        }\n    }\n    \n    /**\n     * Validates the workload identity configuration.\n     * \n     * @return true if configuration is valid, false otherwise\n     */\n    public boolean validateConfiguration() {\n        log.info(\"Validating workload identity configuration\");\n        \n        String tenantId = System.getenv(\"AZURE_TENANT_ID\");\n        String clientId = System.getenv(\"AZURE_CLIENT_ID\");\n        String tokenFilePath = System.getenv(\"AZURE_FEDERATED_TOKEN_FILE\");\n        \n        boolean valid = true;\n        \n        if (tenantId == null || tenantId.isEmpty()) {\n            log.error(\"AZURE_TENANT_ID environment variable is not set\");\n            valid = false;\n        }\n        \n        if (clientId == null || clientId.isEmpty()) {\n            log.error(\"AZURE_CLIENT_ID environment variable is not set\");\n            valid = false;\n        }\n        \n        if (tokenFilePath == null || tokenFilePath.isEmpty()) {\n            log.warn(\"AZURE_FEDERATED_TOKEN_FILE not set, using default: /var/run/secrets/azure/tokens/azure-identity-token\");\n        }\n        \n        if (valid) {\n            log.info(\"Workload identity configuration is valid\");\n        } else {\n            log.error(\"Workload identity configuration is invalid\");\n        }\n        \n        return valid;\n    }\n}\n```\n\n```java\npackage com.example.app.azure;\n\nimport com.azure.core.credential.AccessToken;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Demo application showing WorkloadIdentityCredential usage in AKS.\n */\n@SpringBootApplication\npublic class AksAuthenticationDemo {\n    \n    private static final Logger log = LoggerFactory.getLogger(AksAuthenticationDemo.class);\n    \n    public static void main(String[] args) {\n        SpringApplication.run(AksAuthenticationDemo.class, args);\n    }\n    \n    @Bean\n    public CommandLineRunner demo(AksWorkloadIdentityClient aksClient) {\n        return args -> {\n            log.info(\"=== AKS Workload Identity Authentication Demo ===\");\n            \n            // Validate configuration\n            if (!aksClient.validateConfiguration()) {\n                log.error(\"Configuration validation failed. Exiting.\");\n                return;\n            }\n            \n            try {\n                // Get token for Azure Management API\n                log.info(\"\\n--- Acquiring Azure Management API Token ---\");\n                AccessToken managementToken = aksClient.getManagementApiToken();\n                log.info(\"Management API token acquired successfully\");\n                log.info(\"Token expires at: {}\", managementToken.getExpiresAt());\n                \n                // Get token for Azure Storage\n                log.info(\"\\n--- Acquiring Azure Storage Token ---\");\n                AccessToken storageToken = aksClient.getTokenForScope(\"https://storage.azure.com/.default\");\n                log.info(\"Storage token acquired successfully\");\n                log.info(\"Token expires at: {}\", storageToken.getExpiresAt());\n                \n                // Get token for Key Vault\n                log.info(\"\\n--- Acquiring Key Vault Token ---\");\n                AccessToken keyVaultToken = aksClient.getTokenForScope(\"https://vault.azure.net/.default\");\n                log.info(\"Key Vault token acquired successfully\");\n                log.info(\"Token expires at: {}\", keyVaultToken.getExpiresAt());\n                \n                log.info(\"\\n=== Authentication Demo Completed Successfully ===\");\n                \n            } catch (Exception e) {\n                log.error(\"Authentication demo failed\", e);\n                System.exit(1);\n            }\n        };\n    }\n}\n```\n\n```yaml\n# kubernetes/deployment.yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: workload-identity-sa\n  namespace: default\n  annotations:\n    azure.workload.identity/client-id: \"${AZURE_CLIENT_ID}\"\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: aks-auth-demo\n  namespace: default\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: aks-auth-demo\n  template:\n    metadata:\n      labels:\n        app: aks-auth-demo\n        azure.workload.identity/use: \"true\"\n    spec:\n      serviceAccountName: workload-identity-sa\n      containers:\n      - name: app\n        image: your-registry/aks-auth-demo:latest\n        env:\n        - name: AZURE_TENANT_ID\n          value: \"${AZURE_TENANT_ID}\"\n        - name: AZURE_CLIENT_ID\n          value: \"${AZURE_CLIENT_ID}\"\n        - name: AZURE_FEDERATED_TOKEN_FILE\n          value: \"/var/run/secrets/azure/tokens/azure-identity-token\"\n        - name: AZURE_LOG_LEVEL\n          value: \"verbose\"\n        volumeMounts:\n        - name: azure-identity-token\n          mountPath: /var/run/secrets/azure/tokens\n          readOnly: true\n      volumes:\n      - name: azure-identity-token\n        projected:\n          sources:\n          - serviceAccountToken:\n              path: azure-identity-token\n              expirationSeconds: 3600\n              audience: api://AzureADTokenExchange\n```\n\n```bash\n#!/bin/bash\n# setup-workload-identity.sh\n\nset -e\n\nRESOURCE_GROUP=\"my-rg\"\nAKS_CLUSTER=\"my-aks\"\nIDENTITY_NAME=\"aks-workload-identity\"\nSERVICE_ACCOUNT_NAME=\"workload-identity-sa\"\nSERVICE_ACCOUNT_NAMESPACE=\"default\"\n\necho \"Setting up AKS Workload Identity...\"\n\n# Get AKS OIDC issuer URL\nOIDC_ISSUER=$(az aks show -n $AKS_CLUSTER -g $RESOURCE_GROUP --query \"oidcIssuerProfile.issuerUrl\" -o tsv)\necho \"OIDC Issuer: $OIDC_ISSUER\"\n\n# Create user-assigned managed identity\necho \"Creating managed identity...\"\naz identity create \\\n  --name $IDENTITY_NAME \\\n  --resource-group $RESOURCE_GROUP \\\n  --location eastus\n\n# Get identity details\nCLIENT_ID=$(az identity show --name $IDENTITY_NAME --resource-group $RESOURCE_GROUP --query clientId -o tsv)\nPRINCIPAL_ID=$(az identity show --name $IDENTITY_NAME --resource-group $RESOURCE_GROUP --query principalId -o tsv)\n\necho \"Client ID: $CLIENT_ID\"\necho \"Principal ID: $PRINCIPAL_ID\"\n\n# Create federated identity credential\necho \"Creating federated identity credential...\"\naz identity federated-credential create \\\n  --name \"aks-federated-credential\" \\\n  --identity-name $IDENTITY_NAME \\\n  --resource-group $RESOURCE_GROUP \\\n  --issuer $OIDC_ISSUER \\\n  --subject \"system:serviceaccount:${SERVICE_ACCOUNT_NAMESPACE}:${SERVICE_ACCOUNT_NAME}\" \\\n  --audience \"api://AzureADTokenExchange\"\n\n# Assign roles (example: Reader on subscription)\nSUBSCRIPTION_ID=$(az account show --query id -o tsv)\necho \"Assigning Reader role to managed identity...\"\naz role assignment create \\\n  --role \"Reader\" \\\n  --assignee-object-id $PRINCIPAL_ID \\\n  --assignee-principal-type ServicePrincipal \\\n  --scope \"/subscriptions/$SUBSCRIPTION_ID\"\n\necho \"\"\necho \"Setup complete! Use these values in your deployment:\"\necho \"AZURE_CLIENT_ID=$CLIENT_ID\"\necho \"AZURE_TENANT_ID=$(az account show --query tenantId -o tsv)\"\n```\n\n```xml\n<!-- Add to pom.xml -->\n<dependencies>\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.15.0</version>\n    </dependency>\n    \n    <!-- Azure Core -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-core</artifactId>\n        <version>1.54.0</version>\n    </dependency>\n    \n    <!-- Spring Boot Starter -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    \n    <!-- Logging -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n    </dependency>\n</dependencies>\n```\n\n```properties\n# src/main/resources/application.properties\n\n# Application name\nspring.application.name=aks-auth-demo\n\n# Logging configuration\nlogging.level.root=INFO\nlogging.level.com.example.app.azure=DEBUG\nlogging.level.com.azure.identity=DEBUG\nlogging.level.com.azure.core=DEBUG\n\n# Azure configuration (can be overridden by environment variables)\nazure.tenant-id=${AZURE_TENANT_ID:}\nazure.client-id=${AZURE_CLIENT_ID:}\nazure.federated-token-file=${AZURE_FEDERATED_TOKEN_FILE:/var/run/secrets/azure/tokens/azure-identity-token}\n```\n\n```dockerfile\n# Dockerfile\nFROM eclipse-temurin:21-jre-alpine\n\nWORKDIR /app\n\nCOPY target/aks-auth-demo-*.jar app.jar\n\n# Create directory for Azure identity token\nRUN mkdir -p /var/run/secrets/azure/tokens\n\nEXPOSE 8",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 11364,
            "output_tokens": 4096,
            "cached": false
          }
        }
      ]
    }
  ]
}