{
  "skill_name": "azure-identity-dotnet",
  "generated_at": "2026-02-16T12:09:35.388551+00:00",
  "model": "claude-sonnet-4-5-20250929",
  "temperature": 0.3,
  "runs_per_condition": 3,
  "contamination_score": 0.33,
  "risk_level": "medium",
  "test_category": "net_negative",
  "tasks": [
    {
      "task_id": "azure-identity-dotnet-01",
      "task_type": "direct_target",
      "target_language": "csharp",
      "expected_patterns": [
        "using Azure\\.Identity",
        "DefaultAzureCredential",
        "AddAzureClients|UseCredential",
        "SecretClient|BlobServiceClient",
        "AuthenticationFailedException|CredentialUnavailableException",
        "builder\\.Services|app\\.Map"
      ],
      "anti_patterns": [
        "from azure\\.identity",
        "import azure",
        "DefaultAzureCredential\\(\\)",
        "def\\s+\\w+\\(",
        "pip install",
        "require\\("
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/api/azure.identity.defaultazurecredential",
          "description": "Azure Identity .NET SDK: DefaultAzureCredential class, constructor with DefaultAzureCredentialOptions, AuthenticationFailedException and CredentialUnavailableException exception types, GetToken methods"
        },
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.azure",
          "description": "Microsoft.Extensions.Azure namespace: AddAzureClients extension method for DI, UseCredential configuration patterns, IAzureClientFactory registration"
        },
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/api/azure.security.keyvault.secrets.secretclient",
          "description": "Azure Key Vault Secrets .NET SDK: SecretClient class initialization with TokenCredential, GetSecretAsync method, BlobServiceClient patterns"
        },
        {
          "url": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis",
          "description": "ASP.NET Core Minimal APIs: builder.Services for service registration (builder.Services.AddMemoryCache, etc.) and app.MapGet/app.MapPost/app.Map for endpoint mapping as required by prompt"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "```csharp\nusing Azure;\nusing Azure.Core;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Azure.Storage.Blobs;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Azure;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure Azure clients with dependency injection\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    // Configure DefaultAzureCredential with options\n    var credentialOptions = new DefaultAzureCredentialOptions\n    {\n        ExcludeInteractiveBrowserCredential = true,\n        ExcludeSharedTokenCacheCredential = true, // Optional: exclude for production\n        // Optionally configure retry options\n        Retry =\n        {\n            MaxRetries = 3,\n            Delay = TimeSpan.FromSeconds(2),\n            Mode = RetryMode.Exponential\n        }\n    };\n\n    // Register Key Vault Secret Client\n    var keyVaultUri = builder.Configuration[\"Azure:KeyVault:Uri\"] \n        ?? throw new InvalidOperationException(\"Key Vault URI not configured\");\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri));\n\n    // Register Blob Service Client\n    var storageUri = builder.Configuration[\"Azure:Storage:Uri\"] \n        ?? throw new InvalidOperationException(\"Storage URI not configured\");\n    clientBuilder.AddBlobServiceClient(new Uri(storageUri));\n\n    // Use DefaultAzureCredential for all clients\n    clientBuilder.UseCredential(new DefaultAzureCredential(credentialOptions));\n});\n\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Add logging\nbuilder.Logging.AddConsole();\nbuilder.Logging.AddDebug();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n\n// Controllers\n[ApiController]\n[Route(\"api\")]\npublic class AzureServicesController : ControllerBase\n{\n    private readonly SecretClient _secretClient;\n    private readonly BlobServiceClient _blobServiceClient;\n    private readonly ILogger<AzureServicesController> _logger;\n\n    public AzureServicesController(\n        SecretClient secretClient,\n        BlobServiceClient blobServiceClient,\n        ILogger<AzureServicesController> logger)\n    {\n        _secretClient = secretClient ?? throw new ArgumentNullException(nameof(secretClient));\n        _blobServiceClient = blobServiceClient ?? throw new ArgumentNullException(nameof(blobServiceClient));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    /// <summary>\n    /// Retrieves a secret from Azure Key Vault\n    /// </summary>\n    /// <param name=\"name\">The name of the secret</param>\n    /// <returns>The secret value</returns>\n    [HttpGet(\"secrets/{name}\")]\n    [ProducesResponseType(typeof(SecretResponse), StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetSecret(string name)\n    {\n        try\n        {\n            _logger.LogInformation(\"Retrieving secret: {SecretName}\", name);\n\n            var secret = await _secretClient.GetSecretAsync(name);\n\n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n\n            return Ok(new SecretResponse\n            {\n                Name = secret.Value.Name,\n                Value = secret.Value.Value,\n                ContentType = secret.Value.Properties.ContentType,\n                CreatedOn = secret.Value.Properties.CreatedOn,\n                UpdatedOn = secret.Value.Properties.UpdatedOn\n            });\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving secret: {SecretName}\", name);\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"Authentication Failed\",\n                Message = \"Failed to authenticate with Azure Key Vault. Please check your credentials.\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credentials unavailable while retrieving secret: {SecretName}\", name);\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"Credentials Unavailable\",\n                Message = \"No valid credentials are available for authentication.\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", name);\n            return NotFound(new ErrorResponse\n            {\n                Error = \"Secret Not Found\",\n                Message = $\"The secret '{name}' was not found in Key Vault.\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to secret: {SecretName}\", name);\n            return StatusCode(StatusCodes.Status403Forbidden, new ErrorResponse\n            {\n                Error = \"Access Denied\",\n                Message = \"You don't have permission to access this secret.\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"Internal Server Error\",\n                Message = \"An unexpected error occurred while retrieving the secret.\",\n                Details = ex.Message\n            });\n        }\n    }\n\n    /// <summary>\n    /// Downloads a blob from Azure Blob Storage\n    /// </summary>\n    /// <param name=\"container\">The container name</param>\n    /// <param name=\"name\">The blob name</param>\n    /// <returns>The blob content as a file stream</returns>\n    [HttpGet(\"blobs/{container}/{name}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetBlob(string container, string name)\n    {\n        try\n        {\n            _logger.LogInformation(\"Downloading blob: {BlobName} from container: {ContainerName}\", \n                name, container);\n\n            var containerClient = _blobServiceClient.GetBlobContainerClient(container);\n            var blobClient = containerClient.GetBlobClient(name);\n\n            // Check if blob exists\n            if (!await blobClient.ExistsAsync())\n            {\n                _logger.LogWarning(\"Blob not found: {BlobName} in container: {ContainerName}\", \n                    name, container);\n                return NotFound(new ErrorResponse\n                {\n                    Error = \"Blob Not Found\",\n                    Message = $\"The blob '{name}' was not found in container '{container}'.\",\n                    Details = $\"Container: {container}, Blob: {name}\"\n                });\n            }\n\n            // Get blob properties to set content type\n            var properties = await blobClient.GetPropertiesAsync();\n            \n            // Download blob content\n            var downloadResult = await blobClient.DownloadStreamingAsync();\n\n            _logger.LogInformation(\"Successfully downloaded blob: {BlobName} from container: {ContainerName}\", \n                name, container);\n\n            return File(\n                downloadResult.Value.Content,\n                properties.Value.ContentType ?? \"application/octet-stream\",\n                name\n            );\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while downloading blob: {BlobName} from container: {ContainerName}\", \n                name, container);\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"Authentication Failed\",\n                Message = \"Failed to authenticate with Azure Blob Storage. Please check your credentials.\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credentials unavailable while downloading blob: {BlobName} from container: {ContainerName}\", \n                name, container);\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"Credentials Unavailable\",\n                Message = \"No valid credentials are available for authentication.\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Blob or container not found: {BlobName} in {ContainerName}\", \n                name, container);\n            return NotFound(new ErrorResponse\n            {\n                Error = \"Resource Not Found\",\n                Message = $\"The blob '{name}' or container '{container}' was not found.\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to blob: {BlobName} in container: {ContainerName}\", \n                name, container);\n            return StatusCode(StatusCodes.Status403Forbidden, new ErrorResponse\n            {\n                Error = \"Access Denied\",\n                Message = \"You don't have permission to access this blob.\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error downloading blob: {BlobName} from container: {ContainerName}\", \n                name, container);\n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"Internal Server Error\",\n                Message = \"An unexpected error occurred while downloading the blob.\",\n                Details = ex.Message\n            });\n        }\n    }\n\n    /// <summary>\n    /// Health check endpoint to verify Azure connectivity\n    /// </summary>\n    [HttpGet(\"health\")]\n    [ProducesResponseType(typeof(HealthResponse), StatusCodes.Status200OK)]\n    public async Task<IActionResult> HealthCheck()\n    {\n        var health = new HealthResponse\n        {\n            Status = \"Healthy\",\n            Timestamp = DateTime.UtcNow\n        };\n\n        try\n        {\n            // Test Key Vault connectivity\n            await _secretClient.GetPropertiesOfSecretsAsync().AsPages(pageSizeHint: 1).GetAsyncEnumerator()\n                .MoveNextAsync();\n            health.KeyVaultStatus = \"Connected\";\n        }\n        catch (Exception ex)\n        {\n            health.KeyVaultStatus = $\"Error: {ex.Message}\";\n            health.Status = \"Degraded\";\n        }\n\n        try\n        {\n            // Test Blob Storage connectivity\n            await _blobServiceClient.GetBlobContainersAsync().AsPages(pageSizeHint: 1).GetAsyncEnumerator()\n                .MoveNextAsync();\n            health.BlobStorageStatus = \"Connected\";\n        }\n        catch (Exception ex)\n        {\n            health.BlobStorageStatus = $\"Error: {ex.Message}\";\n            health.Status = \"Degraded\";\n        }\n\n        return Ok(health);\n    }\n}\n\n// Response Models\npublic class SecretResponse\n{\n    public string Name { get; set; } = string.Empty;\n    public string Value { get; set; } = string.Empty;\n    public string? ContentType { get; set; }\n    public DateTimeOffset? CreatedOn { get; set; }\n    public DateTimeOffset? UpdatedOn { get; set; }\n}\n\npublic class ErrorResponse\n{\n    public string Error { get; set; } = string.Empty;\n    public string Message { get; set; } = string.Empty;\n    public string? Details { get; set; }\n    public DateTime Timestamp { get; set; } = DateTime.UtcNow;\n}\n\npublic class HealthResponse\n{\n    public string Status { get; set; } = string.Empty;\n    public string KeyVaultStatus { get; set; } = \"Unknown\";\n    public string BlobStorageStatus { get; set; } = \"Unknown\";\n    public DateTime Timestamp { get; set; }\n}\n```\n\n**appsettings.json:**\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://your-keyvault-name.vault.azure.net/\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://yourstorageaccount.blob.core.windows.net/\"\n    }\n  }\n}\n```\n\n**Required NuGet Packages (.csproj):**\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Azure.Identity\" Version=\"1.10.4\" />\n    <PackageReference Include=\"Azure.Security.KeyVault.Secrets\" Version=\"4.5.0\" />\n    <PackageReference Include=\"Azure.Storage.Blobs\" Version=\"12.19.1\" />\n    <PackageReference Include=\"Microsoft.Extensions.Azure\" Version=\"1.7.1\" />\n    <PackageReference Include=\"Swashbuckle.AspNetCore\" Version=\"6.5.0\" />\n  </ItemGroup>\n\n</Project>\n```\n\nThis service includes:\n\n1. **Dependency Injection** with `Microsoft.Extensions.Azure` for both Key Vault and Blob Storage clients\n2. **DefaultAzureCredential** configured to exclude interactive browser authentication\n3. **Two endpoints** as requested with proper routing\n4. **Comprehensive error handling** for authentication failures and credential unavailability\n5. **Logging** throughout the application\n6. **Health check endpoint** to verify connectivity\n7. **Swagger/OpenAPI** documentation support\n8. **Proper HTTP status codes** and response models\n\nThe service will authenticate using the credential chain (managed identity, environment variables, Azure CLI, etc.) while excluding interactive browser authentication.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 118,
            "output_tokens": 3703,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Identity ASP.NET Core Service\n\nI'll create a complete ASP.NET Core service with Azure Identity authentication for Key Vault and Blob Storage.\n\n## Project Structure\n\n```\nAzureIdentityService/\n\u251c\u2500\u2500 AzureIdentityService.csproj\n\u251c\u2500\u2500 Program.cs\n\u251c\u2500\u2500 Controllers/\n\u2502   \u251c\u2500\u2500 SecretsController.cs\n\u2502   \u2514\u2500\u2500 BlobsController.cs\n\u251c\u2500\u2500 Models/\n\u2502   \u251c\u2500\u2500 SecretResponse.cs\n\u2502   \u2514\u2500\u2500 ErrorResponse.cs\n\u2514\u2500\u2500 appsettings.json\n```\n\n## 1. Project File\n\n**AzureIdentityService.csproj**\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Azure.Identity\" Version=\"1.17.1\" />\n    <PackageReference Include=\"Azure.Security.KeyVault.Secrets\" Version=\"4.6.0\" />\n    <PackageReference Include=\"Azure.Storage.Blobs\" Version=\"12.22.2\" />\n    <PackageReference Include=\"Microsoft.Extensions.Azure\" Version=\"1.7.5\" />\n  </ItemGroup>\n\n</Project>\n```\n\n## 2. Configuration\n\n**appsettings.json**\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure.Identity\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"Azure\": {\n    \"KeyVault\": {\n      \"VaultUri\": \"https://your-keyvault-name.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"BlobServiceUri\": \"https://your-storage-account.blob.core.windows.net\"\n    },\n    \"Identity\": {\n      \"TenantId\": \"\",\n      \"ManagedIdentityClientId\": \"\"\n    }\n  }\n}\n```\n\n**appsettings.Development.json**\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Azure.Identity\": \"Verbose\"\n    }\n  },\n  \"Azure\": {\n    \"KeyVault\": {\n      \"VaultUri\": \"https://your-dev-keyvault.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"BlobServiceUri\": \"https://yourdevstorageaccount.blob.core.windows.net\"\n    }\n  }\n}\n```\n\n## 3. Models\n\n**Models/SecretResponse.cs**\n```csharp\nnamespace AzureIdentityService.Models;\n\npublic class SecretResponse\n{\n    public string Name { get; set; } = string.Empty;\n    public string Value { get; set; } = string.Empty;\n    public DateTimeOffset? CreatedOn { get; set; }\n    public DateTimeOffset? UpdatedOn { get; set; }\n}\n```\n\n**Models/ErrorResponse.cs**\n```csharp\nnamespace AzureIdentityService.Models;\n\npublic class ErrorResponse\n{\n    public string Error { get; set; } = string.Empty;\n    public string Message { get; set; } = string.Empty;\n    public string? Details { get; set; }\n    public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;\n}\n```\n\n## 4. Program.cs\n\n**Program.cs**\n```csharp\nusing Azure.Identity;\nusing Microsoft.Extensions.Azure;\nusing Azure.Core.Diagnostics;\nusing System.Diagnostics.Tracing;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure Azure Event Source Listener for debugging\nusing AzureEventSourceListener listener = new((args, message) =>\n{\n    if (args is { EventSource.Name: \"Azure-Identity\" })\n    {\n        builder.Logging.AddConsole().AddDebug();\n        Console.WriteLine($\"[Azure-Identity] {message}\");\n    }\n}, EventLevel.Verbose);\n\n// Add services to the container\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Configure Azure clients with DefaultAzureCredential\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    // Get configuration values\n    var keyVaultUri = builder.Configuration[\"Azure:KeyVault:VaultUri\"];\n    var blobServiceUri = builder.Configuration[\"Azure:Storage:BlobServiceUri\"];\n    var tenantId = builder.Configuration[\"Azure:Identity:TenantId\"];\n    var managedIdentityClientId = builder.Configuration[\"Azure:Identity:ManagedIdentityClientId\"];\n\n    if (string.IsNullOrEmpty(keyVaultUri))\n    {\n        throw new InvalidOperationException(\"Azure:KeyVault:VaultUri is not configured\");\n    }\n\n    if (string.IsNullOrEmpty(blobServiceUri))\n    {\n        throw new InvalidOperationException(\"Azure:Storage:BlobServiceUri is not configured\");\n    }\n\n    // Register Key Vault Secret Client\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri));\n\n    // Register Blob Service Client\n    clientBuilder.AddBlobServiceClient(new Uri(blobServiceUri));\n\n    // Configure DefaultAzureCredential with options\n    var credentialOptions = new DefaultAzureCredentialOptions\n    {\n        // Exclude interactive browser credential for production scenarios\n        ExcludeInteractiveBrowserCredential = true,\n        \n        // Enable specific credential types\n        ExcludeEnvironmentCredential = false,\n        ExcludeManagedIdentityCredential = false,\n        ExcludeVisualStudioCredential = false,\n        ExcludeVisualStudioCodeCredential = false,\n        ExcludeAzureCliCredential = false,\n        ExcludeAzurePowerShellCredential = false,\n        ExcludeAzureDeveloperCliCredential = false,\n        \n        // Optional: Configure retry policy\n        Retry =\n        {\n            MaxRetries = 3,\n            Delay = TimeSpan.FromSeconds(0.5),\n            MaxDelay = TimeSpan.FromSeconds(60),\n            Mode = Azure.Core.RetryMode.Exponential\n        }\n    };\n\n    // Set tenant ID if provided\n    if (!string.IsNullOrEmpty(tenantId))\n    {\n        credentialOptions.TenantId = tenantId;\n    }\n\n    // Set managed identity client ID if provided (for user-assigned MI)\n    if (!string.IsNullOrEmpty(managedIdentityClientId))\n    {\n        credentialOptions.ManagedIdentityClientId = managedIdentityClientId;\n    }\n\n    // Use DefaultAzureCredential for all clients\n    clientBuilder.UseCredential(new DefaultAzureCredential(credentialOptions));\n});\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n## 5. Controllers\n\n**Controllers/SecretsController.cs**\n```csharp\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing AzureIdentityService.Models;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace AzureIdentityService.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class SecretsController : ControllerBase\n{\n    private readonly SecretClient _secretClient;\n    private readonly ILogger<SecretsController> _logger;\n\n    public SecretsController(\n        SecretClient secretClient,\n        ILogger<SecretsController> logger)\n    {\n        _secretClient = secretClient ?? throw new ArgumentNullException(nameof(secretClient));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    /// <summary>\n    /// Retrieves a secret from Azure Key Vault\n    /// </summary>\n    /// <param name=\"name\">The name of the secret</param>\n    /// <returns>The secret value and metadata</returns>\n    [HttpGet(\"{name}\")]\n    [ProducesResponseType(typeof(SecretResponse), StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetSecret(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            return BadRequest(new ErrorResponse\n            {\n                Error = \"InvalidRequest\",\n                Message = \"Secret name cannot be empty\"\n            });\n        }\n\n        try\n        {\n            _logger.LogInformation(\"Retrieving secret: {SecretName}\", name);\n\n            KeyVaultSecret secret = await _secretClient.GetSecretAsync(name);\n\n            var response = new SecretResponse\n            {\n                Name = secret.Name,\n                Value = secret.Value,\n                CreatedOn = secret.Properties.CreatedOn,\n                UpdatedOn = secret.Properties.UpdatedOn\n            };\n\n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n\n            return Ok(response);\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving secret: {SecretName}\", name);\n\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"AuthenticationFailed\",\n                Message = \"Failed to authenticate with Azure Key Vault\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while retrieving secret: {SecretName}\", name);\n\n            return StatusCode(StatusCodes.Status503ServiceUnavailable, new ErrorResponse\n            {\n                Error = \"CredentialUnavailable\",\n                Message = \"No valid credentials are available for authentication\",\n                Details = ex.Message\n            });\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", name);\n\n            return NotFound(new ErrorResponse\n            {\n                Error = \"SecretNotFound\",\n                Message = $\"Secret '{name}' was not found in the Key Vault\",\n                Details = ex.Message\n            });\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to secret: {SecretName}\", name);\n\n            return StatusCode(StatusCodes.Status403Forbidden, new ErrorResponse\n            {\n                Error = \"AccessDenied\",\n                Message = \"Access denied to the requested secret\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n\n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"InternalServerError\",\n                Message = \"An unexpected error occurred while retrieving the secret\",\n                Details = ex.Message\n            });\n        }\n    }\n\n    /// <summary>\n    /// Lists all secrets in the Key Vault (names only)\n    /// </summary>\n    [HttpGet]\n    [ProducesResponseType(typeof(IEnumerable<string>), StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> ListSecrets()\n    {\n        try\n        {\n            _logger.LogInformation(\"Listing all secrets\");\n\n            var secretNames = new List<string>();\n\n            await foreach (var secretProperties in _secretClient.GetPropertiesOfSecretsAsync())\n            {\n                secretNames.Add(secretProperties.Name);\n            }\n\n            _logger.LogInformation(\"Successfully listed {Count} secrets\", secretNames.Count);\n\n            return Ok(secretNames);\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while listing secrets\");\n\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"AuthenticationFailed\",\n                Message = \"Failed to authenticate with Azure Key Vault\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while listing secrets\");\n\n            return StatusCode(StatusCodes.Status503ServiceUnavailable, new ErrorResponse\n            {\n                Error = \"CredentialUnavailable\",\n                Message = \"No valid credentials are available for authentication\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error listing secrets\");\n\n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"InternalServerError\",\n                Message = \"An unexpected error occurred while listing secrets\",\n                Details = ex.Message\n            });\n        }\n    }\n}\n```\n\n**Controllers/BlobsController.cs**\n```csharp\nusing Azure.Identity;\nusing Azure.Storage.Blobs;\nusing Azure.Storage.Blobs.Models;\nusing AzureIdentityService.Models;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace AzureIdentityService.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class BlobsController : ControllerBase\n{\n    private readonly BlobServiceClient _blobServiceClient;\n    private readonly ILogger<BlobsController> _logger;\n\n    public BlobsController(\n        BlobServiceClient blobServiceClient,\n        ILogger<BlobsController> logger)\n    {\n        _blobServiceClient = blobServiceClient ?? throw new ArgumentNullException(nameof(blobServiceClient));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    /// <summary>\n    /// Downloads a blob from Azure Blob Storage\n    /// </summary>\n    /// <param name=\"container\">The container name</param>\n    /// <param name=\"name\">The blob name</param>\n    /// <returns>The blob content as a file download</returns>\n    [HttpGet(\"{container}/{name}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> DownloadBlob(string container, string name)\n    {\n        if (string.IsNullOrWhiteSpace(container))\n        {\n            return BadRequest(new ErrorResponse\n            {\n                Error = \"InvalidRequest\",\n                Message = \"Container name cannot be empty\"\n            });\n        }\n\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            return BadRequest(new ErrorResponse\n            {\n                Error = \"InvalidRequest\",\n                Message = \"Blob name cannot be empty\"\n            });\n        }\n\n        try\n        {\n            _logger.LogInformation(\"Downloading blob: {BlobName} from container: {ContainerName}\", name, container);\n\n            // Get container client\n            BlobContainerClient containerClient = _blobServiceClient.GetBlobContainerClient(container);\n\n            // Get blob client\n            BlobClient blobClient = containerClient.GetBlobClient(name);\n\n            // Check if blob exists\n            bool exists = await blobClient.ExistsAsync();\n            if (!exists)\n            {\n                _logger.LogWarning(\"Blob not found: {BlobName} in container: {ContainerName}\", name, container);\n\n                return NotFound(new ErrorResponse\n                {\n                    Error = \"BlobNotFound\",\n                    Message =",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5454,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a complete solution with Azure Identity integration for Key Vault and Blob Storage. Let me create the necessary files:\n\n```csharp\n// Services/AzureStorageService.cs\nusing Azure;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Azure.Storage.Blobs;\nusing Microsoft.Extensions.Logging;\n\nnamespace App.Services;\n\npublic class AzureStorageService\n{\n    private readonly SecretClient _secretClient;\n    private readonly BlobServiceClient _blobServiceClient;\n    private readonly ILogger<AzureStorageService> _logger;\n\n    public AzureStorageService(\n        SecretClient secretClient,\n        BlobServiceClient blobServiceClient,\n        ILogger<AzureStorageService> logger)\n    {\n        _secretClient = secretClient;\n        _blobServiceClient = blobServiceClient;\n        _logger = logger;\n    }\n\n    public async Task<string?> GetSecretAsync(string secretName)\n    {\n        try\n        {\n            _logger.LogInformation(\"Retrieving secret: {SecretName}\", secretName);\n            \n            KeyVaultSecret secret = await _secretClient.GetSecretAsync(secretName);\n            \n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", secretName);\n            return secret.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving secret: {SecretName}\", secretName);\n            throw new InvalidOperationException($\"Authentication failed: {ex.Message}\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while retrieving secret: {SecretName}\", secretName);\n            throw new InvalidOperationException($\"Credential unavailable: {ex.Message}\", ex);\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", secretName);\n            return null;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error retrieving secret: {SecretName}\", secretName);\n            throw;\n        }\n    }\n\n    public async Task<Stream?> GetBlobAsync(string containerName, string blobName)\n    {\n        try\n        {\n            _logger.LogInformation(\"Retrieving blob: {Container}/{Blob}\", containerName, blobName);\n            \n            var containerClient = _blobServiceClient.GetBlobContainerClient(containerName);\n            var blobClient = containerClient.GetBlobClient(blobName);\n\n            if (!await blobClient.ExistsAsync())\n            {\n                _logger.LogWarning(\"Blob not found: {Container}/{Blob}\", containerName, blobName);\n                return null;\n            }\n\n            var response = await blobClient.DownloadStreamingAsync();\n            \n            _logger.LogInformation(\"Successfully retrieved blob: {Container}/{Blob}\", containerName, blobName);\n            return response.Value.Content;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving blob: {Container}/{Blob}\", containerName, blobName);\n            throw new InvalidOperationException($\"Authentication failed: {ex.Message}\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while retrieving blob: {Container}/{Blob}\", containerName, blobName);\n            throw new InvalidOperationException($\"Credential unavailable: {ex.Message}\", ex);\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Blob or container not found: {Container}/{Blob}\", containerName, blobName);\n            return null;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error retrieving blob: {Container}/{Blob}\", containerName, blobName);\n            throw;\n        }\n    }\n}\n```\n\n```csharp\n// Controllers/SecretsController.cs\nusing App.Services;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class SecretsController : ControllerBase\n{\n    private readonly AzureStorageService _azureStorageService;\n    private readonly ILogger<SecretsController> _logger;\n\n    public SecretsController(\n        AzureStorageService azureStorageService,\n        ILogger<SecretsController> logger)\n    {\n        _azureStorageService = azureStorageService;\n        _logger = logger;\n    }\n\n    [HttpGet(\"{name}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    [ProducesResponseType(StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetSecret(string name)\n    {\n        try\n        {\n            var secretValue = await _azureStorageService.GetSecretAsync(name);\n            \n            if (secretValue is null)\n            {\n                return NotFound(new { message = $\"Secret '{name}' not found\" });\n            }\n\n            return Ok(new { name, value = secretValue });\n        }\n        catch (InvalidOperationException ex)\n        {\n            _logger.LogError(ex, \"Failed to retrieve secret: {Name}\", name);\n            return StatusCode(StatusCodes.Status500InternalServerError, \n                new { message = ex.Message });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {Name}\", name);\n            return StatusCode(StatusCodes.Status500InternalServerError, \n                new { message = \"An unexpected error occurred\" });\n        }\n    }\n}\n```\n\n```csharp\n// Controllers/BlobsController.cs\nusing App.Services;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class BlobsController : ControllerBase\n{\n    private readonly AzureStorageService _azureStorageService;\n    private readonly ILogger<BlobsController> _logger;\n\n    public BlobsController(\n        AzureStorageService azureStorageService,\n        ILogger<BlobsController> logger)\n    {\n        _azureStorageService = azureStorageService;\n        _logger = logger;\n    }\n\n    [HttpGet(\"{container}/{name}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    [ProducesResponseType(StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetBlob(string container, string name)\n    {\n        try\n        {\n            var blobStream = await _azureStorageService.GetBlobAsync(container, name);\n            \n            if (blobStream is null)\n            {\n                return NotFound(new { message = $\"Blob '{name}' not found in container '{container}'\" });\n            }\n\n            // Return the blob as a file stream\n            return File(blobStream, \"application/octet-stream\", name);\n        }\n        catch (InvalidOperationException ex)\n        {\n            _logger.LogError(ex, \"Failed to retrieve blob: {Container}/{Name}\", container, name);\n            return StatusCode(StatusCodes.Status500InternalServerError, \n                new { message = ex.Message });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving blob: {Container}/{Name}\", container, name);\n            return StatusCode(StatusCodes.Status500InternalServerError, \n                new { message = \"An unexpected error occurred\" });\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Azure.Identity;\nusing Microsoft.Extensions.Azure;\nusing App.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Configure Azure clients with DefaultAzureCredential\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    // Get configuration values\n    var keyVaultUri = builder.Configuration[\"Azure:KeyVault:Uri\"] \n        ?? throw new InvalidOperationException(\"Azure:KeyVault:Uri is not configured\");\n    var storageAccountUri = builder.Configuration[\"Azure:Storage:Uri\"] \n        ?? throw new InvalidOperationException(\"Azure:Storage:Uri is not configured\");\n\n    // Register Key Vault Secret Client\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri));\n\n    // Register Blob Service Client\n    clientBuilder.AddBlobServiceClient(new Uri(storageAccountUri));\n\n    // Configure DefaultAzureCredential with options\n    clientBuilder.UseCredential(new DefaultAzureCredential(\n        new DefaultAzureCredentialOptions\n        {\n            ExcludeInteractiveBrowserCredential = true,\n            ExcludeEnvironmentCredential = false,\n            ExcludeManagedIdentityCredential = false,\n            ExcludeVisualStudioCredential = false,\n            ExcludeAzureCliCredential = false,\n            ExcludeAzurePowerShellCredential = false,\n            ExcludeAzureDeveloperCliCredential = false\n        }));\n});\n\n// Register custom service\nbuilder.Services.AddScoped<AzureStorageService>();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```json\n// appsettings.json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure.Identity\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://myvault.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://myaccount.blob.core.windows.net\"\n    }\n  }\n}\n```\n\n```json\n// appsettings.Development.json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure.Identity\": \"Verbose\"\n    }\n  },\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://dev-vault.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://devaccount.blob.core.windows.net\"\n    }\n  }\n}\n```\n\nNow update the `.csproj` file to include the required packages:\n\n```xml\n<!-- App.csproj -->\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Azure.Identity\" Version=\"1.17.1\" />\n    <PackageReference Include=\"Azure.Security.KeyVault.Secrets\" Version=\"4.6.0\" />\n    <PackageReference Include=\"Azure.Storage.Blobs\" Version=\"12.21.2\" />\n    <PackageReference Include=\"Microsoft.Extensions.Azure\" Version=\"1.7.5\" />\n    <PackageReference Include=\"Swashbuckle.AspNetCore\" Version=\"6.5.0\" />\n  </ItemGroup>\n\n</Project>\n```\n\n## Key Features:\n\n1. **DefaultAzureCredential Configuration**: Excludes interactive browser credential as requested, while keeping other credential types enabled\n2. **Dependency Injection**: Uses `Microsoft.Extensions.Azure` to register both Key Vault and Blob Storage clients\n3. **Proper Error Handling**: Catches `AuthenticationFailedException` and `CredentialUnavailableException` specifically\n4. **Two Endpoints**:\n   - `GET /secrets/{name}` - Retrieves Key Vault secrets\n   - `GET /blobs/{container}/{name}` - Downloads blobs\n5. **Logging**: Comprehensive logging at all levels\n6. **Thread Safety**: Single credential instance shared across all clients\n7. **Configuration**: Environment-specific settings via appsettings files\n\n## Usage:\n\n```bash\n# Install packages\ndotnet restore\n\n# Set environment variables (for local development)\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\n\n# Or use Azure CLI\naz login\n\n# Run the application\ndotnet run\n```\n\nThe service will authenticate using DefaultAzureCredential, trying credentials in this order: Environment \u2192 Managed Identity \u2192 Visual Studio \u2192 Azure CLI \u2192 Azure PowerShell \u2192 Azure Developer CLI.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5960,
            "output_tokens": 3328,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "```csharp\nusing Azure;\nusing Azure.Core;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Azure.Storage.Blobs;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Azure;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure Azure clients with dependency injection\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    // Configure DefaultAzureCredential with options\n    var credentialOptions = new DefaultAzureCredentialOptions\n    {\n        ExcludeInteractiveBrowserCredential = true,\n        ExcludeSharedTokenCacheCredential = true, // Optional: exclude for production\n        Retry =\n        {\n            MaxRetries = 3,\n            Delay = TimeSpan.FromSeconds(2),\n            Mode = RetryMode.Exponential\n        }\n    };\n\n    // Register Key Vault client\n    var keyVaultUri = builder.Configuration[\"Azure:KeyVault:Uri\"] \n        ?? throw new InvalidOperationException(\"Key Vault URI not configured\");\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri));\n\n    // Register Blob Storage client\n    var storageUri = builder.Configuration[\"Azure:Storage:Uri\"] \n        ?? throw new InvalidOperationException(\"Storage URI not configured\");\n    clientBuilder.AddBlobServiceClient(new Uri(storageUri));\n\n    // Use the same credential for all clients\n    clientBuilder.UseCredential(new DefaultAzureCredential(credentialOptions));\n});\n\n// Add services\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\nbuilder.Services.AddLogging();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\n// Endpoint to retrieve Key Vault secret\napp.MapGet(\"/secrets/{name}\", async (\n    string name,\n    SecretClient secretClient,\n    ILogger<Program> logger) =>\n{\n    try\n    {\n        logger.LogInformation(\"Retrieving secret: {SecretName}\", name);\n        \n        KeyVaultSecret secret = await secretClient.GetSecretAsync(name);\n        \n        logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n        \n        return Results.Ok(new\n        {\n            Name = secret.Name,\n            Value = secret.Value,\n            ContentType = secret.Properties.ContentType,\n            CreatedOn = secret.Properties.CreatedOn,\n            UpdatedOn = secret.Properties.UpdatedOn\n        });\n    }\n    catch (AuthenticationFailedException ex)\n    {\n        logger.LogError(ex, \"Authentication failed when accessing Key Vault secret: {SecretName}\", name);\n        return Results.Problem(\n            title: \"Authentication Failed\",\n            detail: \"Failed to authenticate with Azure Key Vault. Please check your credentials and permissions.\",\n            statusCode: StatusCodes.Status401Unauthorized\n        );\n    }\n    catch (CredentialUnavailableException ex)\n    {\n        logger.LogError(ex, \"No credentials available for Key Vault authentication\");\n        return Results.Problem(\n            title: \"Credentials Unavailable\",\n            detail: \"No valid Azure credentials were found. Please configure authentication properly.\",\n            statusCode: StatusCodes.Status500InternalServerError\n        );\n    }\n    catch (RequestFailedException ex) when (ex.Status == 404)\n    {\n        logger.LogWarning(\"Secret not found: {SecretName}\", name);\n        return Results.NotFound(new { Message = $\"Secret '{name}' not found in Key Vault\" });\n    }\n    catch (RequestFailedException ex) when (ex.Status == 403)\n    {\n        logger.LogError(ex, \"Access denied to secret: {SecretName}\", name);\n        return Results.Problem(\n            title: \"Access Denied\",\n            detail: $\"You don't have permission to access the secret '{name}'\",\n            statusCode: StatusCodes.Status403Forbidden\n        );\n    }\n    catch (Exception ex)\n    {\n        logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n        return Results.Problem(\n            title: \"Internal Server Error\",\n            detail: \"An unexpected error occurred while retrieving the secret\",\n            statusCode: StatusCodes.Status500InternalServerError\n        );\n    }\n})\n.WithName(\"GetSecret\")\n.WithOpenApi();\n\n// Endpoint to download blob\napp.MapGet(\"/blobs/{container}/{name}\", async (\n    string container,\n    string name,\n    BlobServiceClient blobServiceClient,\n    ILogger<Program> logger) =>\n{\n    try\n    {\n        logger.LogInformation(\"Downloading blob: {BlobName} from container: {ContainerName}\", name, container);\n        \n        var containerClient = blobServiceClient.GetBlobContainerClient(container);\n        var blobClient = containerClient.GetBlobClient(name);\n\n        // Check if blob exists\n        if (!await blobClient.ExistsAsync())\n        {\n            logger.LogWarning(\"Blob not found: {BlobName} in container: {ContainerName}\", name, container);\n            return Results.NotFound(new { Message = $\"Blob '{name}' not found in container '{container}'\" });\n        }\n\n        // Download blob\n        var downloadResult = await blobClient.DownloadContentAsync();\n        var content = downloadResult.Value.Content.ToArray();\n        var contentType = downloadResult.Value.Details.ContentType ?? \"application/octet-stream\";\n\n        logger.LogInformation(\"Successfully downloaded blob: {BlobName} ({Size} bytes)\", name, content.Length);\n\n        return Results.File(content, contentType, name);\n    }\n    catch (AuthenticationFailedException ex)\n    {\n        logger.LogError(ex, \"Authentication failed when accessing Blob Storage\");\n        return Results.Problem(\n            title: \"Authentication Failed\",\n            detail: \"Failed to authenticate with Azure Blob Storage. Please check your credentials and permissions.\",\n            statusCode: StatusCodes.Status401Unauthorized\n        );\n    }\n    catch (CredentialUnavailableException ex)\n    {\n        logger.LogError(ex, \"No credentials available for Blob Storage authentication\");\n        return Results.Problem(\n            title: \"Credentials Unavailable\",\n            detail: \"No valid Azure credentials were found. Please configure authentication properly.\",\n            statusCode: StatusCodes.Status500InternalServerError\n        );\n    }\n    catch (RequestFailedException ex) when (ex.Status == 404)\n    {\n        logger.LogWarning(\"Container or blob not found: {ContainerName}/{BlobName}\", container, name);\n        return Results.NotFound(new { Message = $\"Container '{container}' or blob '{name}' not found\" });\n    }\n    catch (RequestFailedException ex) when (ex.Status == 403)\n    {\n        logger.LogError(ex, \"Access denied to blob: {ContainerName}/{BlobName}\", container, name);\n        return Results.Problem(\n            title: \"Access Denied\",\n            detail: $\"You don't have permission to access the blob '{name}' in container '{container}'\",\n            statusCode: StatusCodes.Status403Forbidden\n        );\n    }\n    catch (Exception ex)\n    {\n        logger.LogError(ex, \"Unexpected error downloading blob: {ContainerName}/{BlobName}\", container, name);\n        return Results.Problem(\n            title: \"Internal Server Error\",\n            detail: \"An unexpected error occurred while downloading the blob\",\n            statusCode: StatusCodes.Status500InternalServerError\n        );\n    }\n})\n.WithName(\"GetBlob\")\n.WithOpenApi();\n\n// Health check endpoint\napp.MapGet(\"/health\", () => Results.Ok(new { Status = \"Healthy\", Timestamp = DateTime.UtcNow }))\n    .WithName(\"HealthCheck\")\n    .WithOpenApi();\n\napp.Run();\n```\n\n**appsettings.json:**\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://your-keyvault-name.vault.azure.net/\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://your-storage-account.blob.core.windows.net/\"\n    }\n  }\n}\n```\n\n**appsettings.Development.json:**\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Azure\": \"Information\"\n    }\n  },\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://your-dev-keyvault.vault.azure.net/\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://yourdevstorage.blob.core.windows.net/\"\n    }\n  }\n}\n```\n\n**.csproj file (required NuGet packages):**\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Azure.Identity\" Version=\"1.11.0\" />\n    <PackageReference Include=\"Azure.Security.KeyVault.Secrets\" Version=\"4.6.0\" />\n    <PackageReference Include=\"Azure.Storage.Blobs\" Version=\"12.19.1\" />\n    <PackageReference Include=\"Microsoft.Extensions.Azure\" Version=\"1.7.1\" />\n    <PackageReference Include=\"Swashbuckle.AspNetCore\" Version=\"6.5.0\" />\n  </ItemGroup>\n\n</Project>\n```\n\n**Alternative: Service-based approach with controllers:**\n\n```csharp\n// Services/IAzureStorageService.cs\npublic interface IAzureStorageService\n{\n    Task<(byte[] Content, string ContentType)?> DownloadBlobAsync(string containerName, string blobName);\n}\n\n// Services/AzureStorageService.cs\npublic class AzureStorageService : IAzureStorageService\n{\n    private readonly BlobServiceClient _blobServiceClient;\n    private readonly ILogger<AzureStorageService> _logger;\n\n    public AzureStorageService(BlobServiceClient blobServiceClient, ILogger<AzureStorageService> logger)\n    {\n        _blobServiceClient = blobServiceClient;\n        _logger = logger;\n    }\n\n    public async Task<(byte[] Content, string ContentType)?> DownloadBlobAsync(string containerName, string blobName)\n    {\n        var containerClient = _blobServiceClient.GetBlobContainerClient(containerName);\n        var blobClient = containerClient.GetBlobClient(blobName);\n\n        if (!await blobClient.ExistsAsync())\n            return null;\n\n        var downloadResult = await blobClient.DownloadContentAsync();\n        return (downloadResult.Value.Content.ToArray(), \n                downloadResult.Value.Details.ContentType ?? \"application/octet-stream\");\n    }\n}\n\n// Services/IKeyVaultService.cs\npublic interface IKeyVaultService\n{\n    Task<KeyVaultSecret?> GetSecretAsync(string secretName);\n}\n\n// Services/KeyVaultService.cs\npublic class KeyVaultService : IKeyVaultService\n{\n    private readonly SecretClient _secretClient;\n    private readonly ILogger<KeyVaultService> _logger;\n\n    public KeyVaultService(SecretClient secretClient, ILogger<KeyVaultService> logger)\n    {\n        _secretClient = secretClient;\n        _logger = logger;\n    }\n\n    public async Task<KeyVaultSecret?> GetSecretAsync(string secretName)\n    {\n        try\n        {\n            return await _secretClient.GetSecretAsync(secretName);\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            return null;\n        }\n    }\n}\n```\n\nThis implementation provides:\n\n1. **Proper Azure Identity configuration** with `DefaultAzureCredential` excluding interactive browser authentication\n2. **Dependency injection** using `Microsoft.Extensions.Azure`\n3. **Two REST endpoints** for Key Vault secrets and Blob Storage\n4. **Comprehensive error handling** for authentication failures and credential unavailability\n5. **Logging** throughout the application\n6. **Swagger/OpenAPI** documentation\n7. **Production-ready patterns** with proper status codes and error messages\n\nThe service will authenticate using the credential chain (environment variables, managed identity, Azure CLI, etc.) without requiring interactive browser authentication.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 118,
            "output_tokens": 3184,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Identity ASP.NET Core Service\n\nI'll create a complete ASP.NET Core service with Azure Identity authentication for Key Vault and Blob Storage.\n\n## Project Structure\n\n```\nAzureIdentityService/\n\u251c\u2500\u2500 AzureIdentityService.csproj\n\u251c\u2500\u2500 Program.cs\n\u251c\u2500\u2500 Controllers/\n\u2502   \u251c\u2500\u2500 SecretsController.cs\n\u2502   \u2514\u2500\u2500 BlobsController.cs\n\u251c\u2500\u2500 Models/\n\u2502   \u251c\u2500\u2500 SecretResponse.cs\n\u2502   \u2514\u2500\u2500 ErrorResponse.cs\n\u2514\u2500\u2500 appsettings.json\n```\n\n## 1. Project File\n\n**AzureIdentityService.csproj**\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Azure.Identity\" Version=\"1.17.1\" />\n    <PackageReference Include=\"Azure.Security.KeyVault.Secrets\" Version=\"4.7.0\" />\n    <PackageReference Include=\"Azure.Storage.Blobs\" Version=\"12.24.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Azure\" Version=\"1.7.6\" />\n  </ItemGroup>\n\n</Project>\n```\n\n## 2. Configuration\n\n**appsettings.json**\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure.Identity\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"Azure\": {\n    \"KeyVault\": {\n      \"VaultUri\": \"https://your-keyvault.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"BlobServiceUri\": \"https://yourstorageaccount.blob.core.windows.net\"\n    },\n    \"Identity\": {\n      \"TenantId\": \"\",\n      \"ManagedIdentityClientId\": \"\"\n    }\n  }\n}\n```\n\n**appsettings.Development.json**\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Azure.Identity\": \"Verbose\"\n    }\n  },\n  \"Azure\": {\n    \"KeyVault\": {\n      \"VaultUri\": \"https://your-dev-keyvault.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"BlobServiceUri\": \"https://yourdevstorageaccount.blob.core.windows.net\"\n    }\n  }\n}\n```\n\n## 3. Models\n\n**Models/SecretResponse.cs**\n```csharp\nnamespace AzureIdentityService.Models;\n\npublic class SecretResponse\n{\n    public string Name { get; set; } = string.Empty;\n    public string Value { get; set; } = string.Empty;\n    public DateTimeOffset? CreatedOn { get; set; }\n    public DateTimeOffset? UpdatedOn { get; set; }\n}\n```\n\n**Models/ErrorResponse.cs**\n```csharp\nnamespace AzureIdentityService.Models;\n\npublic class ErrorResponse\n{\n    public string Error { get; set; } = string.Empty;\n    public string Message { get; set; } = string.Empty;\n    public string? Details { get; set; }\n    public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;\n}\n```\n\n## 4. Program.cs\n\n**Program.cs**\n```csharp\nusing Azure.Identity;\nusing Azure.Core.Diagnostics;\nusing Microsoft.Extensions.Azure;\nusing System.Diagnostics.Tracing;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure Azure Event Source Listener for debugging\nusing AzureEventSourceListener listener = new((args, message) =>\n{\n    if (args.EventSource.Name == \"Azure-Identity\")\n    {\n        builder.Logging.AddConsole().Services.BuildServiceProvider()\n            .GetRequiredService<ILogger<Program>>()\n            .LogInformation(\"[Azure-Identity] {Message}\", message);\n    }\n}, EventLevel.Verbose);\n\n// Add services to the container\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Configure Azure clients with DefaultAzureCredential\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    var keyVaultUri = builder.Configuration[\"Azure:KeyVault:VaultUri\"];\n    var blobServiceUri = builder.Configuration[\"Azure:Storage:BlobServiceUri\"];\n\n    if (string.IsNullOrEmpty(keyVaultUri))\n    {\n        throw new InvalidOperationException(\"Azure:KeyVault:VaultUri is not configured\");\n    }\n\n    if (string.IsNullOrEmpty(blobServiceUri))\n    {\n        throw new InvalidOperationException(\"Azure:Storage:BlobServiceUri is not configured\");\n    }\n\n    // Register Key Vault Secret Client\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri));\n\n    // Register Blob Service Client\n    clientBuilder.AddBlobServiceClient(new Uri(blobServiceUri));\n\n    // Configure DefaultAzureCredential with custom options\n    var tenantId = builder.Configuration[\"Azure:Identity:TenantId\"];\n    var managedIdentityClientId = builder.Configuration[\"Azure:Identity:ManagedIdentityClientId\"];\n\n    var credentialOptions = new DefaultAzureCredentialOptions\n    {\n        // Exclude interactive browser credential for server applications\n        ExcludeInteractiveBrowserCredential = true,\n        \n        // Keep environment credential for local development with env vars\n        ExcludeEnvironmentCredential = false,\n        \n        // Keep managed identity for Azure-hosted scenarios\n        ExcludeManagedIdentityCredential = false,\n        \n        // Keep Visual Studio credential for local development\n        ExcludeVisualStudioCredential = false,\n        \n        // Keep Azure CLI credential for local development\n        ExcludeAzureCliCredential = false,\n        \n        // Keep Azure PowerShell credential for local development\n        ExcludeAzurePowerShellCredential = false,\n        \n        // Keep Azure Developer CLI credential for local development\n        ExcludeAzureDeveloperCliCredential = false,\n        \n        // Configure retry policy\n        Retry =\n        {\n            MaxRetries = 3,\n            Delay = TimeSpan.FromSeconds(0.5),\n            MaxDelay = TimeSpan.FromSeconds(60),\n            Mode = Azure.Core.RetryMode.Exponential\n        }\n    };\n\n    // Set tenant ID if configured\n    if (!string.IsNullOrEmpty(tenantId))\n    {\n        credentialOptions.TenantId = tenantId;\n    }\n\n    // Set managed identity client ID if configured (for user-assigned MI)\n    if (!string.IsNullOrEmpty(managedIdentityClientId))\n    {\n        credentialOptions.ManagedIdentityClientId = managedIdentityClientId;\n    }\n\n    // Use the configured DefaultAzureCredential\n    clientBuilder.UseCredential(new DefaultAzureCredential(credentialOptions));\n});\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n## 5. Controllers\n\n**Controllers/SecretsController.cs**\n```csharp\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing AzureIdentityService.Models;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace AzureIdentityService.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class SecretsController : ControllerBase\n{\n    private readonly SecretClient _secretClient;\n    private readonly ILogger<SecretsController> _logger;\n\n    public SecretsController(\n        SecretClient secretClient,\n        ILogger<SecretsController> logger)\n    {\n        _secretClient = secretClient ?? throw new ArgumentNullException(nameof(secretClient));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    /// <summary>\n    /// Retrieves a secret from Azure Key Vault\n    /// </summary>\n    /// <param name=\"name\">The name of the secret to retrieve</param>\n    /// <returns>The secret value and metadata</returns>\n    [HttpGet(\"{name}\")]\n    [ProducesResponseType(typeof(SecretResponse), StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetSecret(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            return BadRequest(new ErrorResponse\n            {\n                Error = \"InvalidRequest\",\n                Message = \"Secret name cannot be empty\"\n            });\n        }\n\n        try\n        {\n            _logger.LogInformation(\"Retrieving secret: {SecretName}\", name);\n\n            KeyVaultSecret secret = await _secretClient.GetSecretAsync(name);\n\n            var response = new SecretResponse\n            {\n                Name = secret.Name,\n                Value = secret.Value,\n                CreatedOn = secret.Properties.CreatedOn,\n                UpdatedOn = secret.Properties.UpdatedOn\n            };\n\n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n\n            return Ok(response);\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving secret: {SecretName}\", name);\n            \n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"AuthenticationFailed\",\n                Message = \"Failed to authenticate with Azure Key Vault\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while retrieving secret: {SecretName}\", name);\n            \n            return StatusCode(StatusCodes.Status503ServiceUnavailable, new ErrorResponse\n            {\n                Error = \"CredentialUnavailable\",\n                Message = \"No valid credential is available for authentication\",\n                Details = ex.Message\n            });\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", name);\n            \n            return NotFound(new ErrorResponse\n            {\n                Error = \"SecretNotFound\",\n                Message = $\"Secret '{name}' was not found in the Key Vault\",\n                Details = ex.Message\n            });\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to secret: {SecretName}\", name);\n            \n            return StatusCode(StatusCodes.Status403Forbidden, new ErrorResponse\n            {\n                Error = \"AccessDenied\",\n                Message = \"Access denied to the requested secret\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n            \n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"InternalServerError\",\n                Message = \"An unexpected error occurred while retrieving the secret\",\n                Details = ex.Message\n            });\n        }\n    }\n\n    /// <summary>\n    /// Lists all secrets in the Key Vault (names only, not values)\n    /// </summary>\n    [HttpGet]\n    [ProducesResponseType(typeof(IEnumerable<string>), StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> ListSecrets()\n    {\n        try\n        {\n            _logger.LogInformation(\"Listing all secrets\");\n\n            var secretNames = new List<string>();\n            \n            await foreach (var secretProperties in _secretClient.GetPropertiesOfSecretsAsync())\n            {\n                secretNames.Add(secretProperties.Name);\n            }\n\n            _logger.LogInformation(\"Successfully listed {Count} secrets\", secretNames.Count);\n\n            return Ok(secretNames);\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while listing secrets\");\n            \n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"AuthenticationFailed\",\n                Message = \"Failed to authenticate with Azure Key Vault\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while listing secrets\");\n            \n            return StatusCode(StatusCodes.Status503ServiceUnavailable, new ErrorResponse\n            {\n                Error = \"CredentialUnavailable\",\n                Message = \"No valid credential is available for authentication\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error listing secrets\");\n            \n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"InternalServerError\",\n                Message = \"An unexpected error occurred while listing secrets\",\n                Details = ex.Message\n            });\n        }\n    }\n}\n```\n\n**Controllers/BlobsController.cs**\n```csharp\nusing Azure.Identity;\nusing Azure.Storage.Blobs;\nusing Azure.Storage.Blobs.Models;\nusing AzureIdentityService.Models;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace AzureIdentityService.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class BlobsController : ControllerBase\n{\n    private readonly BlobServiceClient _blobServiceClient;\n    private readonly ILogger<BlobsController> _logger;\n\n    public BlobsController(\n        BlobServiceClient blobServiceClient,\n        ILogger<BlobsController> logger)\n    {\n        _blobServiceClient = blobServiceClient ?? throw new ArgumentNullException(nameof(blobServiceClient));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    /// <summary>\n    /// Downloads a blob from Azure Blob Storage\n    /// </summary>\n    /// <param name=\"container\">The container name</param>\n    /// <param name=\"name\">The blob name</param>\n    /// <returns>The blob content as a file download</returns>\n    [HttpGet(\"{container}/{name}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> DownloadBlob(string container, string name)\n    {\n        if (string.IsNullOrWhiteSpace(container))\n        {\n            return BadRequest(new ErrorResponse\n            {\n                Error = \"InvalidRequest\",\n                Message = \"Container name cannot be empty\"\n            });\n        }\n\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            return BadRequest(new ErrorResponse\n            {\n                Error = \"InvalidRequest\",\n                Message = \"Blob name cannot be empty\"\n            });\n        }\n\n        try\n        {\n            _logger.LogInformation(\"Downloading blob: {BlobName} from container: {ContainerName}\", name, container);\n\n            BlobContainerClient containerClient = _blobServiceClient.GetBlobContainerClient(container);\n            BlobClient blobClient = containerClient.GetBlobClient(name);\n\n            // Check if blob exists\n            if (!await blobClient.ExistsAsync())",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5454,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a complete solution with Azure Identity integration for Key Vault and Blob Storage. Let me create the necessary files:\n\n```csharp\n// Services/AzureStorageService.cs\nusing Azure;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Azure.Storage.Blobs;\nusing Microsoft.Extensions.Logging;\n\nnamespace App.Services;\n\npublic class AzureStorageService\n{\n    private readonly SecretClient _secretClient;\n    private readonly BlobServiceClient _blobServiceClient;\n    private readonly ILogger<AzureStorageService> _logger;\n\n    public AzureStorageService(\n        SecretClient secretClient,\n        BlobServiceClient blobServiceClient,\n        ILogger<AzureStorageService> logger)\n    {\n        _secretClient = secretClient;\n        _blobServiceClient = blobServiceClient;\n        _logger = logger;\n    }\n\n    public async Task<string?> GetSecretAsync(string secretName)\n    {\n        try\n        {\n            _logger.LogInformation(\"Retrieving secret: {SecretName}\", secretName);\n            KeyVaultSecret secret = await _secretClient.GetSecretAsync(secretName);\n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", secretName);\n            return secret.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving secret: {SecretName}\", secretName);\n            throw new InvalidOperationException($\"Authentication failed: {ex.Message}\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while retrieving secret: {SecretName}\", secretName);\n            throw new InvalidOperationException($\"Credential unavailable: {ex.Message}\", ex);\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", secretName);\n            return null;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", secretName);\n            throw;\n        }\n    }\n\n    public async Task<Stream?> GetBlobAsync(string containerName, string blobName)\n    {\n        try\n        {\n            _logger.LogInformation(\"Retrieving blob: {ContainerName}/{BlobName}\", containerName, blobName);\n            \n            BlobContainerClient containerClient = _blobServiceClient.GetBlobContainerClient(containerName);\n            BlobClient blobClient = containerClient.GetBlobClient(blobName);\n\n            if (!await blobClient.ExistsAsync())\n            {\n                _logger.LogWarning(\"Blob not found: {ContainerName}/{BlobName}\", containerName, blobName);\n                return null;\n            }\n\n            var stream = new MemoryStream();\n            await blobClient.DownloadToAsync(stream);\n            stream.Position = 0;\n            \n            _logger.LogInformation(\"Successfully retrieved blob: {ContainerName}/{BlobName}\", containerName, blobName);\n            return stream;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving blob: {ContainerName}/{BlobName}\", \n                containerName, blobName);\n            throw new InvalidOperationException($\"Authentication failed: {ex.Message}\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while retrieving blob: {ContainerName}/{BlobName}\", \n                containerName, blobName);\n            throw new InvalidOperationException($\"Credential unavailable: {ex.Message}\", ex);\n        }\n        catch (RequestFailedException ex)\n        {\n            _logger.LogError(ex, \"Azure request failed for blob: {ContainerName}/{BlobName}\", \n                containerName, blobName);\n            throw new InvalidOperationException($\"Azure request failed: {ex.Message}\", ex);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving blob: {ContainerName}/{BlobName}\", \n                containerName, blobName);\n            throw;\n        }\n    }\n}\n```\n\n```csharp\n// Controllers/SecretsController.cs\nusing App.Services;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class SecretsController : ControllerBase\n{\n    private readonly AzureStorageService _azureStorageService;\n    private readonly ILogger<SecretsController> _logger;\n\n    public SecretsController(\n        AzureStorageService azureStorageService,\n        ILogger<SecretsController> logger)\n    {\n        _azureStorageService = azureStorageService;\n        _logger = logger;\n    }\n\n    [HttpGet(\"{name}\")]\n    public async Task<IActionResult> GetSecret(string name)\n    {\n        try\n        {\n            var secretValue = await _azureStorageService.GetSecretAsync(name);\n            \n            if (secretValue == null)\n            {\n                return NotFound(new { error = $\"Secret '{name}' not found\" });\n            }\n\n            return Ok(new { name, value = secretValue });\n        }\n        catch (InvalidOperationException ex)\n        {\n            _logger.LogError(ex, \"Failed to retrieve secret: {SecretName}\", name);\n            return StatusCode(500, new { error = ex.Message });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n            return StatusCode(500, new { error = \"An unexpected error occurred\" });\n        }\n    }\n}\n```\n\n```csharp\n// Controllers/BlobsController.cs\nusing App.Services;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class BlobsController : ControllerBase\n{\n    private readonly AzureStorageService _azureStorageService;\n    private readonly ILogger<BlobsController> _logger;\n\n    public BlobsController(\n        AzureStorageService azureStorageService,\n        ILogger<BlobsController> logger)\n    {\n        _azureStorageService = azureStorageService;\n        _logger = logger;\n    }\n\n    [HttpGet(\"{container}/{name}\")]\n    public async Task<IActionResult> GetBlob(string container, string name)\n    {\n        try\n        {\n            var blobStream = await _azureStorageService.GetBlobAsync(container, name);\n            \n            if (blobStream == null)\n            {\n                return NotFound(new { error = $\"Blob '{name}' not found in container '{container}'\" });\n            }\n\n            return File(blobStream, \"application/octet-stream\", name);\n        }\n        catch (InvalidOperationException ex)\n        {\n            _logger.LogError(ex, \"Failed to retrieve blob: {Container}/{BlobName}\", container, name);\n            return StatusCode(500, new { error = ex.Message });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving blob: {Container}/{BlobName}\", container, name);\n            return StatusCode(500, new { error = \"An unexpected error occurred\" });\n        }\n    }\n}\n```\n\n```csharp\n// Program.cs\nusing Azure.Identity;\nusing Microsoft.Extensions.Azure;\nusing App.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Configure Azure clients with DefaultAzureCredential\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    // Get configuration values\n    var keyVaultUri = builder.Configuration[\"Azure:KeyVault:Uri\"] \n        ?? throw new InvalidOperationException(\"Azure:KeyVault:Uri is not configured\");\n    var storageAccountUri = builder.Configuration[\"Azure:Storage:Uri\"] \n        ?? throw new InvalidOperationException(\"Azure:Storage:Uri is not configured\");\n\n    // Register Key Vault SecretClient\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri));\n\n    // Register Blob Storage BlobServiceClient\n    clientBuilder.AddBlobServiceClient(new Uri(storageAccountUri));\n\n    // Configure DefaultAzureCredential with options\n    clientBuilder.UseCredential(new DefaultAzureCredential(\n        new DefaultAzureCredentialOptions\n        {\n            ExcludeInteractiveBrowserCredential = true,\n            ExcludeEnvironmentCredential = false,\n            ExcludeManagedIdentityCredential = false,\n            ExcludeVisualStudioCredential = false,\n            ExcludeAzureCliCredential = false,\n            ExcludeAzurePowerShellCredential = false,\n            ExcludeAzureDeveloperCliCredential = false\n        }));\n});\n\n// Register custom services\nbuilder.Services.AddScoped<AzureStorageService>();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n```\n\n```json\n// appsettings.json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure.Identity\": \"Information\",\n      \"Azure.Core\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://your-keyvault-name.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://your-storage-account.blob.core.windows.net\"\n    }\n  }\n}\n```\n\n```json\n// appsettings.Development.json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Microsoft.AspNetCore\": \"Information\",\n      \"Azure.Identity\": \"Verbose\",\n      \"Azure.Core\": \"Information\"\n    }\n  },\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://your-dev-keyvault.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://your-dev-storage.blob.core.windows.net\"\n    }\n  }\n}\n```\n\nNow update your `.csproj` file to include the required packages:\n\n```xml\n<!-- Add to your .csproj file -->\n<ItemGroup>\n  <PackageReference Include=\"Azure.Identity\" Version=\"1.17.1\" />\n  <PackageReference Include=\"Azure.Security.KeyVault.Secrets\" Version=\"4.6.0\" />\n  <PackageReference Include=\"Azure.Storage.Blobs\" Version=\"12.21.2\" />\n  <PackageReference Include=\"Microsoft.Extensions.Azure\" Version=\"1.7.5\" />\n</ItemGroup>\n```\n\n## Key Features:\n\n1. **DefaultAzureCredential Configuration**: Excludes interactive browser credential as requested, while keeping other credential types enabled\n2. **Dependency Injection**: Uses `Microsoft.Extensions.Azure` to register both Key Vault and Blob Storage clients\n3. **Proper Error Handling**: Catches `AuthenticationFailedException` and `CredentialUnavailableException` specifically\n4. **Two Endpoints**:\n   - `GET /secrets/{name}` - Retrieves Key Vault secrets\n   - `GET /blobs/{container}/{name}` - Downloads blobs\n5. **Logging**: Comprehensive logging at all levels\n6. **Configuration**: Uses appsettings.json for Azure resource URIs\n7. **Thread Safety**: Single credential instance shared across all clients\n\n## Usage:\n\n```bash\n# Install packages\ndotnet restore\n\n# Set environment variables (for local development with Azure CLI)\naz login\n\n# Or use environment variables for service principal\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\n\n# Run the application\ndotnet run\n\n# Test endpoints\ncurl https://localhost:5001/secrets/my-secret-name\ncurl https://localhost:5001/blobs/my-container/my-blob.txt\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5960,
            "output_tokens": 3168,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "```csharp\nusing Azure;\nusing Azure.Core;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Azure.Storage.Blobs;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Azure;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure Azure clients with dependency injection\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    // Configure DefaultAzureCredential with options\n    var credentialOptions = new DefaultAzureCredentialOptions\n    {\n        ExcludeInteractiveBrowserCredential = true,\n        ExcludeSharedTokenCacheCredential = true, // Optional: exclude for production\n        // Optional: Configure retry options\n        Retry =\n        {\n            MaxRetries = 3,\n            Delay = TimeSpan.FromSeconds(2),\n            Mode = RetryMode.Exponential\n        }\n    };\n\n    // Register Key Vault Secret Client\n    var keyVaultUri = builder.Configuration[\"Azure:KeyVault:Uri\"] \n        ?? throw new InvalidOperationException(\"Key Vault URI not configured\");\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri));\n\n    // Register Blob Service Client\n    var storageUri = builder.Configuration[\"Azure:Storage:Uri\"] \n        ?? throw new InvalidOperationException(\"Storage URI not configured\");\n    clientBuilder.AddBlobServiceClient(new Uri(storageUri));\n\n    // Use DefaultAzureCredential for all clients\n    clientBuilder.UseCredential(new DefaultAzureCredential(credentialOptions));\n});\n\n// Add logging\nbuilder.Services.AddLogging(logging =>\n{\n    logging.AddConsole();\n    logging.AddDebug();\n});\n\n// Add controllers\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.MapControllers();\n\napp.Run();\n\n// Controllers\n[ApiController]\n[Route(\"api\")]\npublic class AzureServicesController : ControllerBase\n{\n    private readonly SecretClient _secretClient;\n    private readonly BlobServiceClient _blobServiceClient;\n    private readonly ILogger<AzureServicesController> _logger;\n\n    public AzureServicesController(\n        SecretClient secretClient,\n        BlobServiceClient blobServiceClient,\n        ILogger<AzureServicesController> logger)\n    {\n        _secretClient = secretClient ?? throw new ArgumentNullException(nameof(secretClient));\n        _blobServiceClient = blobServiceClient ?? throw new ArgumentNullException(nameof(blobServiceClient));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    /// <summary>\n    /// Retrieves a secret from Azure Key Vault\n    /// </summary>\n    /// <param name=\"name\">The name of the secret</param>\n    /// <returns>The secret value</returns>\n    [HttpGet(\"secrets/{name}\")]\n    [ProducesResponseType(typeof(SecretResponse), StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetSecret(string name)\n    {\n        try\n        {\n            _logger.LogInformation(\"Retrieving secret: {SecretName}\", name);\n\n            var secret = await _secretClient.GetSecretAsync(name);\n\n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n\n            return Ok(new SecretResponse\n            {\n                Name = secret.Value.Name,\n                Value = secret.Value.Value,\n                ContentType = secret.Value.Properties.ContentType,\n                CreatedOn = secret.Value.Properties.CreatedOn,\n                UpdatedOn = secret.Value.Properties.UpdatedOn\n            });\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving secret: {SecretName}\", name);\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"Authentication Failed\",\n                Message = \"Failed to authenticate with Azure Key Vault. Please check your credentials.\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credentials unavailable while retrieving secret: {SecretName}\", name);\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"Credentials Unavailable\",\n                Message = \"No valid credentials are available for authentication.\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", name);\n            return NotFound(new ErrorResponse\n            {\n                Error = \"Secret Not Found\",\n                Message = $\"The secret '{name}' was not found in Key Vault.\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to secret: {SecretName}\", name);\n            return StatusCode(StatusCodes.Status403Forbidden, new ErrorResponse\n            {\n                Error = \"Access Denied\",\n                Message = \"You don't have permission to access this secret.\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"Internal Server Error\",\n                Message = \"An unexpected error occurred while retrieving the secret.\",\n                Details = ex.Message\n            });\n        }\n    }\n\n    /// <summary>\n    /// Downloads a blob from Azure Blob Storage\n    /// </summary>\n    /// <param name=\"container\">The container name</param>\n    /// <param name=\"name\">The blob name</param>\n    /// <returns>The blob content</returns>\n    [HttpGet(\"blobs/{container}/{name}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetBlob(string container, string name)\n    {\n        try\n        {\n            _logger.LogInformation(\"Downloading blob: {BlobName} from container: {ContainerName}\", name, container);\n\n            var containerClient = _blobServiceClient.GetBlobContainerClient(container);\n            var blobClient = containerClient.GetBlobClient(name);\n\n            // Check if blob exists\n            if (!await blobClient.ExistsAsync())\n            {\n                _logger.LogWarning(\"Blob not found: {BlobName} in container: {ContainerName}\", name, container);\n                return NotFound(new ErrorResponse\n                {\n                    Error = \"Blob Not Found\",\n                    Message = $\"The blob '{name}' was not found in container '{container}'.\",\n                    Details = null\n                });\n            }\n\n            // Download blob\n            var download = await blobClient.DownloadAsync();\n            var properties = await blobClient.GetPropertiesAsync();\n\n            _logger.LogInformation(\"Successfully downloaded blob: {BlobName} from container: {ContainerName}\", name, container);\n\n            // Return file with appropriate content type\n            var contentType = properties.Value.ContentType ?? \"application/octet-stream\";\n            return File(download.Value.Content, contentType, name);\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while downloading blob: {BlobName} from container: {ContainerName}\", \n                name, container);\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"Authentication Failed\",\n                Message = \"Failed to authenticate with Azure Blob Storage. Please check your credentials.\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credentials unavailable while downloading blob: {BlobName} from container: {ContainerName}\", \n                name, container);\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"Credentials Unavailable\",\n                Message = \"No valid credentials are available for authentication.\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Blob or container not found: {BlobName} in {ContainerName}\", name, container);\n            return NotFound(new ErrorResponse\n            {\n                Error = \"Resource Not Found\",\n                Message = $\"The blob '{name}' or container '{container}' was not found.\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to blob: {BlobName} in container: {ContainerName}\", name, container);\n            return StatusCode(StatusCodes.Status403Forbidden, new ErrorResponse\n            {\n                Error = \"Access Denied\",\n                Message = \"You don't have permission to access this blob.\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error downloading blob: {BlobName} from container: {ContainerName}\", \n                name, container);\n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"Internal Server Error\",\n                Message = \"An unexpected error occurred while downloading the blob.\",\n                Details = ex.Message\n            });\n        }\n    }\n}\n\n// Response Models\npublic class SecretResponse\n{\n    public string Name { get; set; } = string.Empty;\n    public string Value { get; set; } = string.Empty;\n    public string? ContentType { get; set; }\n    public DateTimeOffset? CreatedOn { get; set; }\n    public DateTimeOffset? UpdatedOn { get; set; }\n}\n\npublic class ErrorResponse\n{\n    public string Error { get; set; } = string.Empty;\n    public string Message { get; set; } = string.Empty;\n    public string? Details { get; set; }\n}\n```\n\n**appsettings.json:**\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://your-keyvault-name.vault.azure.net/\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://your-storage-account.blob.core.windows.net/\"\n    }\n  }\n}\n```\n\n**Required NuGet Packages (.csproj):**\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Azure.Identity\" Version=\"1.10.4\" />\n    <PackageReference Include=\"Azure.Security.KeyVault.Secrets\" Version=\"4.5.0\" />\n    <PackageReference Include=\"Azure.Storage.Blobs\" Version=\"12.19.1\" />\n    <PackageReference Include=\"Microsoft.Extensions.Azure\" Version=\"1.7.1\" />\n    <PackageReference Include=\"Swashbuckle.AspNetCore\" Version=\"6.5.0\" />\n  </ItemGroup>\n</Project>\n```\n\n**Key Features:**\n\n1. **DefaultAzureCredential Configuration**: Excludes interactive browser credential and configures retry policies\n2. **Dependency Injection**: Uses `Microsoft.Extensions.Azure` for proper client registration\n3. **Comprehensive Error Handling**: Catches `AuthenticationFailedException`, `CredentialUnavailableException`, and `RequestFailedException`\n4. **Logging**: Structured logging throughout the application\n5. **RESTful Endpoints**: Two GET endpoints with proper HTTP status codes\n6. **Swagger Documentation**: API documentation with response types\n7. **Type Safety**: Strongly-typed response models\n\n**Authentication Methods (in order of precedence):**\n- Environment variables\n- Managed Identity\n- Visual Studio\n- Azure CLI\n- Azure PowerShell",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 118,
            "output_tokens": 3248,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Identity ASP.NET Core Service\n\nI'll create a complete ASP.NET Core service with Azure Identity authentication for Key Vault and Blob Storage.\n\n## Project Structure\n\n```\nAzureIdentityService/\n\u251c\u2500\u2500 AzureIdentityService.csproj\n\u251c\u2500\u2500 Program.cs\n\u251c\u2500\u2500 Controllers/\n\u2502   \u251c\u2500\u2500 SecretsController.cs\n\u2502   \u2514\u2500\u2500 BlobsController.cs\n\u251c\u2500\u2500 Models/\n\u2502   \u251c\u2500\u2500 SecretResponse.cs\n\u2502   \u2514\u2500\u2500 ErrorResponse.cs\n\u2514\u2500\u2500 appsettings.json\n```\n\n## 1. Project File\n\n**AzureIdentityService.csproj**\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n    <Nullable>enable</Nullable>\n    <ImplicitUsings>enable</ImplicitUsings>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Azure.Identity\" Version=\"1.17.1\" />\n    <PackageReference Include=\"Azure.Security.KeyVault.Secrets\" Version=\"4.8.0\" />\n    <PackageReference Include=\"Azure.Storage.Blobs\" Version=\"12.24.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Azure\" Version=\"1.7.6\" />\n  </ItemGroup>\n\n</Project>\n```\n\n## 2. Configuration\n\n**appsettings.json**\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"Azure\": {\n    \"KeyVault\": {\n      \"VaultUri\": \"https://your-keyvault.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"BlobServiceUri\": \"https://yourstorageaccount.blob.core.windows.net\"\n    },\n    \"Identity\": {\n      \"TenantId\": \"\",\n      \"ManagedIdentityClientId\": \"\"\n    }\n  }\n}\n```\n\n**appsettings.Development.json**\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Microsoft.AspNetCore\": \"Information\",\n      \"Azure\": \"Debug\"\n    }\n  },\n  \"Azure\": {\n    \"KeyVault\": {\n      \"VaultUri\": \"https://your-dev-keyvault.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"BlobServiceUri\": \"https://yourdevstorageaccount.blob.core.windows.net\"\n    }\n  }\n}\n```\n\n## 3. Models\n\n**Models/SecretResponse.cs**\n```csharp\nnamespace AzureIdentityService.Models;\n\npublic class SecretResponse\n{\n    public string Name { get; set; } = string.Empty;\n    public string Value { get; set; } = string.Empty;\n    public DateTimeOffset? CreatedOn { get; set; }\n    public DateTimeOffset? UpdatedOn { get; set; }\n}\n```\n\n**Models/ErrorResponse.cs**\n```csharp\nnamespace AzureIdentityService.Models;\n\npublic class ErrorResponse\n{\n    public string Error { get; set; } = string.Empty;\n    public string Message { get; set; } = string.Empty;\n    public string? Details { get; set; }\n    public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;\n}\n```\n\n## 4. Program.cs\n\n**Program.cs**\n```csharp\nusing Azure.Identity;\nusing Microsoft.Extensions.Azure;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Configure Azure clients with Azure Identity\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    // Get configuration values\n    var keyVaultUri = builder.Configuration[\"Azure:KeyVault:VaultUri\"];\n    var blobServiceUri = builder.Configuration[\"Azure:Storage:BlobServiceUri\"];\n    var tenantId = builder.Configuration[\"Azure:Identity:TenantId\"];\n    var managedIdentityClientId = builder.Configuration[\"Azure:Identity:ManagedIdentityClientId\"];\n\n    if (string.IsNullOrEmpty(keyVaultUri))\n    {\n        throw new InvalidOperationException(\"Azure:KeyVault:VaultUri is not configured\");\n    }\n\n    if (string.IsNullOrEmpty(blobServiceUri))\n    {\n        throw new InvalidOperationException(\"Azure:Storage:BlobServiceUri is not configured\");\n    }\n\n    // Register Key Vault Secret Client\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri));\n\n    // Register Blob Service Client\n    clientBuilder.AddBlobServiceClient(new Uri(blobServiceUri));\n\n    // Configure DefaultAzureCredential with custom options\n    var credentialOptions = new DefaultAzureCredentialOptions\n    {\n        // Exclude interactive browser credential for non-interactive scenarios\n        ExcludeInteractiveBrowserCredential = true,\n        \n        // Keep other credentials enabled for flexibility\n        ExcludeEnvironmentCredential = false,\n        ExcludeManagedIdentityCredential = false,\n        ExcludeVisualStudioCredential = false,\n        ExcludeVisualStudioCodeCredential = false,\n        ExcludeAzureCliCredential = false,\n        ExcludeAzurePowerShellCredential = false,\n        ExcludeAzureDeveloperCliCredential = false,\n        \n        // Configure retry policy\n        Retry =\n        {\n            MaxRetries = 3,\n            Delay = TimeSpan.FromSeconds(0.5),\n            MaxDelay = TimeSpan.FromSeconds(5),\n            Mode = Azure.Core.RetryMode.Exponential\n        }\n    };\n\n    // Set tenant ID if configured\n    if (!string.IsNullOrEmpty(tenantId))\n    {\n        credentialOptions.TenantId = tenantId;\n    }\n\n    // Set managed identity client ID if configured\n    if (!string.IsNullOrEmpty(managedIdentityClientId))\n    {\n        credentialOptions.ManagedIdentityClientId = managedIdentityClientId;\n    }\n\n    // Use the configured DefaultAzureCredential for all clients\n    clientBuilder.UseCredential(new DefaultAzureCredential(credentialOptions));\n});\n\n// Add health checks\nbuilder.Services.AddHealthChecks();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\napp.MapHealthChecks(\"/health\");\n\napp.Run();\n```\n\n## 5. Secrets Controller\n\n**Controllers/SecretsController.cs**\n```csharp\nusing Azure;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing AzureIdentityService.Models;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace AzureIdentityService.Controllers;\n\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class SecretsController : ControllerBase\n{\n    private readonly SecretClient _secretClient;\n    private readonly ILogger<SecretsController> _logger;\n\n    public SecretsController(\n        SecretClient secretClient,\n        ILogger<SecretsController> logger)\n    {\n        _secretClient = secretClient ?? throw new ArgumentNullException(nameof(secretClient));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    /// <summary>\n    /// Retrieves a secret from Azure Key Vault\n    /// </summary>\n    /// <param name=\"name\">The name of the secret</param>\n    /// <returns>The secret value and metadata</returns>\n    [HttpGet(\"{name}\")]\n    [ProducesResponseType(typeof(SecretResponse), StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status503ServiceUnavailable)]\n    public async Task<IActionResult> GetSecret(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            return BadRequest(new ErrorResponse\n            {\n                Error = \"InvalidRequest\",\n                Message = \"Secret name cannot be empty\"\n            });\n        }\n\n        try\n        {\n            _logger.LogInformation(\"Retrieving secret: {SecretName}\", name);\n\n            KeyVaultSecret secret = await _secretClient.GetSecretAsync(name);\n\n            var response = new SecretResponse\n            {\n                Name = secret.Name,\n                Value = secret.Value,\n                CreatedOn = secret.Properties.CreatedOn,\n                UpdatedOn = secret.Properties.UpdatedOn\n            };\n\n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n\n            return Ok(response);\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving secret: {SecretName}\", name);\n\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"AuthenticationFailed\",\n                Message = \"Failed to authenticate with Azure Key Vault\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while retrieving secret: {SecretName}\", name);\n\n            return StatusCode(StatusCodes.Status503ServiceUnavailable, new ErrorResponse\n            {\n                Error = \"CredentialUnavailable\",\n                Message = \"No valid credential is available for authentication\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", name);\n\n            return NotFound(new ErrorResponse\n            {\n                Error = \"SecretNotFound\",\n                Message = $\"Secret '{name}' was not found in the Key Vault\",\n                Details = ex.Message\n            });\n        }\n        catch (RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to secret: {SecretName}\", name);\n\n            return StatusCode(StatusCodes.Status403Forbidden, new ErrorResponse\n            {\n                Error = \"AccessDenied\",\n                Message = \"Access denied to the requested secret\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n\n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"InternalServerError\",\n                Message = \"An unexpected error occurred while retrieving the secret\",\n                Details = ex.Message\n            });\n        }\n    }\n\n    /// <summary>\n    /// Lists all secrets in the Key Vault (names only)\n    /// </summary>\n    [HttpGet]\n    [ProducesResponseType(typeof(IEnumerable<string>), StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> ListSecrets()\n    {\n        try\n        {\n            _logger.LogInformation(\"Listing all secrets\");\n\n            var secretNames = new List<string>();\n\n            await foreach (var secretProperties in _secretClient.GetPropertiesOfSecretsAsync())\n            {\n                secretNames.Add(secretProperties.Name);\n            }\n\n            _logger.LogInformation(\"Successfully listed {Count} secrets\", secretNames.Count);\n\n            return Ok(secretNames);\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while listing secrets\");\n\n            return Unauthorized(new ErrorResponse\n            {\n                Error = \"AuthenticationFailed\",\n                Message = \"Failed to authenticate with Azure Key Vault\",\n                Details = ex.Message\n            });\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while listing secrets\");\n\n            return StatusCode(StatusCodes.Status503ServiceUnavailable, new ErrorResponse\n            {\n                Error = \"CredentialUnavailable\",\n                Message = \"No valid credential is available for authentication\",\n                Details = ex.Message\n            });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error listing secrets\");\n\n            return StatusCode(StatusCodes.Status500InternalServerError, new ErrorResponse\n            {\n                Error = \"InternalServerError\",\n                Message = \"An unexpected error occurred while listing secrets\",\n                Details = ex.Message\n            });\n        }\n    }\n}\n```\n\n## 6. Blobs Controller\n\n**Controllers/BlobsController.cs**\n```csharp\nusing Azure;\nusing Azure.Identity;\nusing Azure.Storage.Blobs;\nusing Azure.Storage.Blobs.Models;\nusing AzureIdentityService.Models;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace AzureIdentityService.Controllers;\n\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class BlobsController : ControllerBase\n{\n    private readonly BlobServiceClient _blobServiceClient;\n    private readonly ILogger<BlobsController> _logger;\n\n    public BlobsController(\n        BlobServiceClient blobServiceClient,\n        ILogger<BlobsController> logger)\n    {\n        _blobServiceClient = blobServiceClient ?? throw new ArgumentNullException(nameof(blobServiceClient));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    /// <summary>\n    /// Downloads a blob from Azure Blob Storage\n    /// </summary>\n    /// <param name=\"container\">The container name</param>\n    /// <param name=\"name\">The blob name</param>\n    /// <returns>The blob content as a file download</returns>\n    [HttpGet(\"{container}/{name}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status401Unauthorized)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status404NotFound)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status500InternalServerError)]\n    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status503ServiceUnavailable)]\n    public async Task<IActionResult> DownloadBlob(string container, string name)\n    {\n        if (string.IsNullOrWhiteSpace(container))\n        {\n            return BadRequest(new ErrorResponse\n            {\n                Error = \"InvalidRequest\",\n                Message = \"Container name cannot be empty\"\n            });\n        }\n\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            return BadRequest(new ErrorResponse\n            {\n                Error = \"InvalidRequest\",\n                Message = \"Blob name cannot be empty\"\n            });\n        }\n\n        try\n        {\n            _logger.LogInformation(\"Downloading blob: {BlobName} from container: {ContainerName}\", name, container);\n\n            // Get container client\n            BlobContainerClient containerClient = _blobServiceClient.GetBlobContainerClient(container);\n\n            // Get blob client\n            BlobClient blobClient = containerClient.GetBlobClient(name);\n\n            // Check if blob exists\n            bool exists = await blobClient.ExistsAsync();\n            if (!exists)\n            {\n                _logger.LogWarning(\"Blob not found: {BlobName} in container: {ContainerName}\", name, container);\n\n                return NotFound(new ErrorResponse\n                {\n                    Error = \"BlobNotFound\",\n                    Message = $\"Blob '{name}' was not found in container '{container}'\"",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5454,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a complete solution with Azure Identity integration for Key Vault and Blob Storage. Let me create the necessary files:\n\n<write_file>\n<path>Services/AzureStorageService.cs</path>\n<content>using Azure;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Azure.Storage.Blobs;\nusing Azure.Storage.Blobs.Models;\nusing Microsoft.Extensions.Logging;\n\nnamespace App.Services;\n\npublic class AzureStorageService\n{\n    private readonly SecretClient _secretClient;\n    private readonly BlobServiceClient _blobServiceClient;\n    private readonly ILogger<AzureStorageService> _logger;\n\n    public AzureStorageService(\n        SecretClient secretClient,\n        BlobServiceClient blobServiceClient,\n        ILogger<AzureStorageService> logger)\n    {\n        _secretClient = secretClient;\n        _blobServiceClient = blobServiceClient;\n        _logger = logger;\n    }\n\n    public async Task<string?> GetSecretAsync(string secretName)\n    {\n        try\n        {\n            _logger.LogInformation(\"Retrieving secret: {SecretName}\", secretName);\n            \n            KeyVaultSecret secret = await _secretClient.GetSecretAsync(secretName);\n            \n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", secretName);\n            return secret.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving secret: {SecretName}\", secretName);\n            throw new InvalidOperationException($\"Authentication failed: {ex.Message}\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while retrieving secret: {SecretName}\", secretName);\n            throw new InvalidOperationException($\"Credential unavailable: {ex.Message}\", ex);\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", secretName);\n            return null;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", secretName);\n            throw;\n        }\n    }\n\n    public async Task<Stream?> GetBlobAsync(string containerName, string blobName)\n    {\n        try\n        {\n            _logger.LogInformation(\"Retrieving blob: {Container}/{Blob}\", containerName, blobName);\n            \n            BlobContainerClient containerClient = _blobServiceClient.GetBlobContainerClient(containerName);\n            BlobClient blobClient = containerClient.GetBlobClient(blobName);\n\n            if (!await blobClient.ExistsAsync())\n            {\n                _logger.LogWarning(\"Blob not found: {Container}/{Blob}\", containerName, blobName);\n                return null;\n            }\n\n            BlobDownloadInfo download = await blobClient.DownloadAsync();\n            \n            _logger.LogInformation(\"Successfully retrieved blob: {Container}/{Blob}\", containerName, blobName);\n            return download.Content;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while retrieving blob: {Container}/{Blob}\", containerName, blobName);\n            throw new InvalidOperationException($\"Authentication failed: {ex.Message}\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable while retrieving blob: {Container}/{Blob}\", containerName, blobName);\n            throw new InvalidOperationException($\"Credential unavailable: {ex.Message}\", ex);\n        }\n        catch (RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Blob or container not found: {Container}/{Blob}\", containerName, blobName);\n            return null;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving blob: {Container}/{Blob}\", containerName, blobName);\n            throw;\n        }\n    }\n}\n</content>\n</write_file>\n\n<write_file>\n<path>Controllers/SecretsController.cs</path>\n<content>using App.Services;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class SecretsController : ControllerBase\n{\n    private readonly AzureStorageService _azureStorageService;\n    private readonly ILogger<SecretsController> _logger;\n\n    public SecretsController(\n        AzureStorageService azureStorageService,\n        ILogger<SecretsController> logger)\n    {\n        _azureStorageService = azureStorageService;\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Retrieves a secret from Azure Key Vault\n    /// </summary>\n    /// <param name=\"name\">The name of the secret</param>\n    /// <returns>The secret value</returns>\n    [HttpGet(\"{name}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    [ProducesResponseType(StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetSecret(string name)\n    {\n        try\n        {\n            _logger.LogInformation(\"GET /secrets/{Name} called\", name);\n\n            var secretValue = await _azureStorageService.GetSecretAsync(name);\n\n            if (secretValue == null)\n            {\n                return NotFound(new { message = $\"Secret '{name}' not found\" });\n            }\n\n            return Ok(new { name, value = secretValue });\n        }\n        catch (InvalidOperationException ex)\n        {\n            _logger.LogError(ex, \"Error retrieving secret: {Name}\", name);\n            return StatusCode(StatusCodes.Status500InternalServerError, \n                new { message = ex.Message });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {Name}\", name);\n            return StatusCode(StatusCodes.Status500InternalServerError, \n                new { message = \"An unexpected error occurred\" });\n        }\n    }\n}\n</content>\n</write_file>\n\n<write_file>\n<path>Controllers/BlobsController.cs</path>\n<content>using App.Services;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class BlobsController : ControllerBase\n{\n    private readonly AzureStorageService _azureStorageService;\n    private readonly ILogger<BlobsController> _logger;\n\n    public BlobsController(\n        AzureStorageService azureStorageService,\n        ILogger<BlobsController> logger)\n    {\n        _azureStorageService = azureStorageService;\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Downloads a blob from Azure Blob Storage\n    /// </summary>\n    /// <param name=\"container\">The container name</param>\n    /// <param name=\"name\">The blob name</param>\n    /// <returns>The blob content as a file stream</returns>\n    [HttpGet(\"{container}/{name}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    [ProducesResponseType(StatusCodes.Status500InternalServerError)]\n    public async Task<IActionResult> GetBlob(string container, string name)\n    {\n        try\n        {\n            _logger.LogInformation(\"GET /blobs/{Container}/{Name} called\", container, name);\n\n            var blobStream = await _azureStorageService.GetBlobAsync(container, name);\n\n            if (blobStream == null)\n            {\n                return NotFound(new { message = $\"Blob '{name}' not found in container '{container}'\" });\n            }\n\n            // Return the blob as a file stream\n            return File(blobStream, \"application/octet-stream\", name);\n        }\n        catch (InvalidOperationException ex)\n        {\n            _logger.LogError(ex, \"Error retrieving blob: {Container}/{Name}\", container, name);\n            return StatusCode(StatusCodes.Status500InternalServerError, \n                new { message = ex.Message });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving blob: {Container}/{Name}\", container, name);\n            return StatusCode(StatusCodes.Status500InternalServerError, \n                new { message = \"An unexpected error occurred\" });\n        }\n    }\n}\n</content>\n</write_file>\n\n<write_file>\n<path>Program.cs</path>\n<content>using Azure.Identity;\nusing Microsoft.Extensions.Azure;\nusing App.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Configure Azure clients with DefaultAzureCredential\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    // Get configuration values\n    var keyVaultUri = builder.Configuration[\"Azure:KeyVault:Uri\"] \n        ?? throw new InvalidOperationException(\"Azure:KeyVault:Uri configuration is required\");\n    var storageAccountUri = builder.Configuration[\"Azure:Storage:Uri\"] \n        ?? throw new InvalidOperationException(\"Azure:Storage:Uri configuration is required\");\n\n    // Add Key Vault Secret Client\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri));\n\n    // Add Blob Service Client\n    clientBuilder.AddBlobServiceClient(new Uri(storageAccountUri));\n\n    // Configure DefaultAzureCredential with options\n    var credentialOptions = new DefaultAzureCredentialOptions\n    {\n        ExcludeInteractiveBrowserCredential = true,\n        ExcludeEnvironmentCredential = false,\n        ExcludeManagedIdentityCredential = false,\n        ExcludeVisualStudioCredential = false,\n        ExcludeAzureCliCredential = false,\n        ExcludeAzurePowerShellCredential = false,\n        ExcludeAzureDeveloperCliCredential = false\n    };\n\n    // Use DefaultAzureCredential for all clients\n    clientBuilder.UseCredential(new DefaultAzureCredential(credentialOptions));\n});\n\n// Register custom services\nbuilder.Services.AddScoped<AzureStorageService>();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n\napp.Run();\n</content>\n</write_file>\n\n<write_file>\n<path>appsettings.json</path>\n<content>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://your-keyvault-name.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://your-storage-account.blob.core.windows.net\"\n    }\n  }\n}\n</content>\n</write_file>\n\n<write_file>\n<path>appsettings.Development.json</path>\n<content>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Azure\": \"Debug\",\n      \"Azure.Identity\": \"Verbose\"\n    }\n  },\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://your-dev-keyvault.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://yourdevstorageaccount.blob.core.windows.net\"\n    }\n  }\n}\n</content>\n</write_file>\n\n<write_file>\n<path>README.Azure.md</path>\n<content># Azure Identity Integration\n\nThis application uses Azure Identity to authenticate with Azure Key Vault and Azure Blob Storage.\n\n## Prerequisites\n\n1. Install required NuGet packages:\n```bash\ndotnet add package Azure.Identity\ndotnet add package Azure.Security.KeyVault.Secrets\ndotnet add package Azure.Storage.Blobs\ndotnet add package Microsoft.Extensions.Azure\n```\n\n2. Configure Azure resources in `appsettings.json`:\n```json\n{\n  \"Azure\": {\n    \"KeyVault\": {\n      \"Uri\": \"https://your-keyvault-name.vault.azure.net\"\n    },\n    \"Storage\": {\n      \"Uri\": \"https://your-storage-account.blob.core.windows.net\"\n    }\n  }\n}\n```\n\n## Authentication Methods\n\nThe application uses `DefaultAzureCredential` which tries the following methods in order:\n\n1. **EnvironmentCredential** - Uses environment variables:\n   - `AZURE_CLIENT_ID`\n   - `AZURE_TENANT_ID`\n   - `AZURE_CLIENT_SECRET`\n\n2. **WorkloadIdentityCredential** - For Kubernetes workload identity\n\n3. **ManagedIdentityCredential** - For Azure-hosted applications (App Service, Functions, VMs)\n\n4. **VisualStudioCredential** - Uses Visual Studio authentication\n\n5. **VisualStudioCodeCredential** - Uses VS Code authentication\n\n6. **AzureCliCredential** - Uses Azure CLI (`az login`)\n\n7. **AzurePowerShellCredential** - Uses Azure PowerShell\n\n8. **AzureDeveloperCliCredential** - Uses Azure Developer CLI (`azd auth login`)\n\n**Note**: `InteractiveBrowserCredential` is explicitly excluded for security.\n\n## Local Development\n\n### Option 1: Azure CLI (Recommended)\n```bash\naz login\naz account set --subscription \"your-subscription-id\"\n```\n\n### Option 2: Environment Variables\n```bash\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\n```\n\n### Option 3: Visual Studio\nSign in to Visual Studio with your Azure account.\n\n## Production Deployment\n\nFor production, use **Managed Identity**:\n\n### Azure App Service / Functions\n1. Enable system-assigned or user-assigned managed identity\n2. Grant the identity access to Key Vault and Storage Account:\n\n```bash\n# Key Vault access\naz keyvault set-policy --name your-keyvault \\\n  --object-id <managed-identity-object-id> \\\n  --secret-permissions get list\n\n# Storage Account access\naz role assignment create \\\n  --role \"Storage Blob Data Reader\" \\\n  --assignee <managed-identity-object-id> \\\n  --scope /subscriptions/<subscription-id>/resourceGroups/<rg>/providers/Microsoft.Storage/storageAccounts/<account>\n```\n\n## API Endpoints\n\n### GET /secrets/{name}\nRetrieves a secret from Azure Key Vault.\n\n**Example:**\n```bash\ncurl https://localhost:5001/secrets/my-secret\n```\n\n**Response:**\n```json\n{\n  \"name\": \"my-secret\",\n  \"value\": \"secret-value\"\n}\n```\n\n### GET /blobs/{container}/{name}\nDownloads a blob from Azure Blob Storage.\n\n**Example:**\n```bash\ncurl https://localhost:5001/blobs/my-container/my-file.txt -o downloaded-file.txt\n```\n\n## Error Handling\n\nThe service handles the following Azure Identity exceptions:\n\n- **AuthenticationFailedException**: Authentication credentials are invalid\n- **CredentialUnavailableException**: No credential is available in the current environment\n- **RequestFailedException**: Azure service request failed (e.g., 404 Not Found)\n\n## Troubleshooting\n\n### Enable Azure Identity Logging\nAdd to `appsettings.Development.json`:\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Azure.Identity\": \"Verbose\"\n    }\n  }",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5960,
            "output_tokens": 4096,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-identity-dotnet-02",
      "task_type": "cross_language",
      "target_language": "python",
      "expected_patterns": [
        "from azure\\.identity import DefaultAzureCredential",
        "from azure\\.keyvault\\.secrets import SecretClient",
        "import asyncio",
        "async def|await",
        "credential = DefaultAzureCredential\\(\\)",
        "def\\s+\\w+\\("
      ],
      "anti_patterns": [
        "using Azure\\.Identity",
        "new DefaultAzureCredential",
        "var\\s+credential",
        "builder\\.Services",
        "AddAzureClients",
        "namespace\\s+"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-identity/azure.identity.defaultazurecredential",
          "description": "Azure Identity Python SDK reference - source of from azure.identity import DefaultAzureCredential pattern"
        },
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-keyvault-secrets/azure.keyvault.secrets.secretclient",
          "description": "Azure Key Vault Secrets Python SDK reference - source of SecretClient Python import and usage patterns"
        },
        {
          "url": "https://docs.python.org/3/library/asyncio.html",
          "description": "Python asyncio library - source of import asyncio, async def function declarations, and await keyword for parallel secret retrieval as specified in prompt"
        },
        {
          "url": "https://docs.python.org/3/tutorial/controlflow.html#defining-functions",
          "description": "Python function definitions - source of def keyword for defining functions as required by prompt ('implement a function')"
        },
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/api/azure.identity.defaultazurecredential",
          "description": "Azure Identity .NET SDK reference - source of anti-pattern using Azure.Identity and new DefaultAzureCredential C# syntax"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "```python\nimport asyncio\nfrom typing import Dict, List, Optional\nfrom azure.identity.aio import DefaultAzureCredential\nfrom azure.keyvault.secrets.aio import SecretClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError,\n    ServiceRequestError\n)\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass AzureKeyVaultClient:\n    \"\"\"\n    A client for retrieving secrets from Azure Key Vault with parallel processing.\n    \"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the Azure Key Vault client.\n        \n        Args:\n            vault_url: The URL of the Azure Key Vault (e.g., https://myvault.vault.azure.net/)\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = None\n        self.client = None\n    \n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=self.vault_url, credential=self.credential)\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with proper cleanup.\"\"\"\n        if self.client:\n            await self.client.close()\n        if self.credential:\n            await self.credential.close()\n    \n    async def get_secret(self, secret_name: str) -> Optional[Dict[str, str]]:\n        \"\"\"\n        Retrieve a single secret from Azure Key Vault.\n        \n        Args:\n            secret_name: The name of the secret to retrieve\n            \n        Returns:\n            Dictionary with secret name and value, or None if retrieval failed\n        \"\"\"\n        try:\n            logger.info(f\"Retrieving secret: {secret_name}\")\n            secret = await self.client.get_secret(secret_name)\n            logger.info(f\"Successfully retrieved secret: {secret_name}\")\n            return {\n                \"name\": secret_name,\n                \"value\": secret.value,\n                \"enabled\": secret.properties.enabled,\n                \"created_on\": secret.properties.created_on,\n                \"updated_on\": secret.properties.updated_on\n            }\n        except ResourceNotFoundError:\n            logger.error(f\"Secret not found: {secret_name}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": \"Secret not found\"\n            }\n        except ClientAuthenticationError as e:\n            logger.error(f\"Authentication failed for secret {secret_name}: {str(e)}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": f\"Authentication failed: {str(e)}\"\n            }\n        except HttpResponseError as e:\n            logger.error(f\"HTTP error retrieving secret {secret_name}: {str(e)}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": f\"HTTP error: {str(e)}\"\n            }\n        except Exception as e:\n            logger.error(f\"Unexpected error retrieving secret {secret_name}: {str(e)}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": f\"Unexpected error: {str(e)}\"\n            }\n    \n    async def get_secrets_parallel(self, secret_names: List[str]) -> Dict[str, Dict]:\n        \"\"\"\n        Retrieve multiple secrets in parallel from Azure Key Vault.\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            \n        Returns:\n            Dictionary mapping secret names to their values and metadata\n        \"\"\"\n        if not secret_names:\n            logger.warning(\"No secret names provided\")\n            return {}\n        \n        logger.info(f\"Retrieving {len(secret_names)} secrets in parallel\")\n        \n        # Create tasks for parallel execution\n        tasks = [self.get_secret(name) for name in secret_names]\n        \n        # Execute all tasks concurrently\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Process results\n        secrets_dict = {}\n        for result in results:\n            if isinstance(result, Exception):\n                logger.error(f\"Task failed with exception: {str(result)}\")\n                continue\n            if result and result.get(\"name\"):\n                secrets_dict[result[\"name\"]] = result\n        \n        logger.info(f\"Successfully processed {len(secrets_dict)} secrets\")\n        return secrets_dict\n    \n    async def list_all_secrets(self) -> List[str]:\n        \"\"\"\n        List all secret names in the Key Vault.\n        \n        Returns:\n            List of secret names\n        \"\"\"\n        try:\n            logger.info(\"Listing all secrets in Key Vault\")\n            secret_names = []\n            async for secret_properties in self.client.list_properties_of_secrets():\n                secret_names.append(secret_properties.name)\n            logger.info(f\"Found {len(secret_names)} secrets\")\n            return secret_names\n        except ClientAuthenticationError as e:\n            logger.error(f\"Authentication failed while listing secrets: {str(e)}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Error listing secrets: {str(e)}\")\n            raise\n\n\nasync def retrieve_secrets(\n    vault_url: str,\n    secret_names: List[str],\n    timeout: int = 30\n) -> Dict[str, Dict]:\n    \"\"\"\n    Main function to retrieve secrets from Azure Key Vault.\n    \n    Args:\n        vault_url: The URL of the Azure Key Vault\n        secret_names: List of secret names to retrieve\n        timeout: Timeout in seconds for the operation\n        \n    Returns:\n        Dictionary mapping secret names to their values and metadata\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n        asyncio.TimeoutError: If operation times out\n    \"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            async with AzureKeyVaultClient(vault_url) as kv_client:\n                secrets = await kv_client.get_secrets_parallel(secret_names)\n                return secrets\n    except asyncio.TimeoutError:\n        logger.error(f\"Operation timed out after {timeout} seconds\")\n        raise\n    except ClientAuthenticationError as e:\n        logger.error(f\"Authentication failed: {str(e)}\")\n        logger.error(\"Please ensure you have proper Azure credentials configured:\")\n        logger.error(\"1. Azure CLI: Run 'az login'\")\n        logger.error(\"2. Environment variables: Set AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET\")\n        logger.error(\"3. Managed Identity: Ensure your resource has proper identity assigned\")\n        raise\n    except ServiceRequestError as e:\n        logger.error(f\"Network error: {str(e)}\")\n        raise\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\")\n        raise\n\n\nasync def retrieve_all_secrets(vault_url: str, timeout: int = 60) -> Dict[str, Dict]:\n    \"\"\"\n    Retrieve all secrets from Azure Key Vault.\n    \n    Args:\n        vault_url: The URL of the Azure Key Vault\n        timeout: Timeout in seconds for the operation\n        \n    Returns:\n        Dictionary mapping secret names to their values and metadata\n    \"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            async with AzureKeyVaultClient(vault_url) as kv_client:\n                # First, list all secrets\n                secret_names = await kv_client.list_all_secrets()\n                \n                # Then retrieve them in parallel\n                if secret_names:\n                    secrets = await kv_client.get_secrets_parallel(secret_names)\n                    return secrets\n                else:\n                    logger.warning(\"No secrets found in Key Vault\")\n                    return {}\n    except Exception as e:\n        logger.error(f\"Error retrieving all secrets: {str(e)}\")\n        raise\n\n\n# Example usage and testing\nasync def main():\n    \"\"\"Example usage of the Azure Key Vault client.\"\"\"\n    \n    # Configuration\n    VAULT_URL = \"https://your-keyvault-name.vault.azure.net/\"\n    SECRET_NAMES = [\n        \"database-password\",\n        \"api-key\",\n        \"connection-string\"\n    ]\n    \n    try:\n        # Example 1: Retrieve specific secrets\n        logger.info(\"=== Example 1: Retrieve specific secrets ===\")\n        secrets = await retrieve_secrets(VAULT_URL, SECRET_NAMES)\n        \n        for secret_name, secret_data in secrets.items():\n            if secret_data.get(\"error\"):\n                print(f\"{secret_name}: ERROR - {secret_data['error']}\")\n            else:\n                print(f\"{secret_name}: {secret_data['value'][:10]}... (truncated)\")\n                print(f\"  Enabled: {secret_data['enabled']}\")\n                print(f\"  Created: {secret_data['created_on']}\")\n        \n        # Example 2: Retrieve all secrets\n        logger.info(\"\\n=== Example 2: Retrieve all secrets ===\")\n        all_secrets = await retrieve_all_secrets(VAULT_URL)\n        print(f\"Retrieved {len(all_secrets)} secrets from Key Vault\")\n        \n        # Example 3: Using context manager directly\n        logger.info(\"\\n=== Example 3: Using context manager ===\")\n        async with AzureKeyVaultClient(VAULT_URL) as kv_client:\n            # List all secrets\n            secret_names = await kv_client.list_all_secrets()\n            print(f\"Available secrets: {secret_names}\")\n            \n            # Get specific secret\n            if secret_names:\n                single_secret = await kv_client.get_secret(secret_names[0])\n                print(f\"Single secret: {single_secret}\")\n        \n    except ClientAuthenticationError as e:\n        logger.error(f\"Authentication failed: {e}\")\n        print(\"\\nAuthentication failed. Please check your Azure credentials.\")\n    except Exception as e:\n        logger.error(f\"Error in main: {e}\")\n        print(f\"\\nAn error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    # Run the async main function\n    asyncio.run(main())\n```\n\nThis script provides a comprehensive solution for retrieving secrets from Azure Key Vault with the following features:\n\n## Key Features:\n\n1. **Async/Await Pattern**: Uses asyncio for parallel secret retrieval\n2. **DefaultAzureCredential**: Automatically tries multiple authentication methods\n3. **Context Manager**: Proper resource cleanup with `__aenter__` and `__aexit__`\n4. **Error Handling**: Comprehensive error handling for various Azure exceptions\n5. **Parallel Processing**: Retrieves multiple secrets concurrently using `asyncio.gather`\n6. **Logging**: Detailed logging for debugging and monitoring\n7. **Timeout Support**: Configurable timeouts to prevent hanging operations\n\n## Usage Examples:\n\n```python\n# Retrieve specific secrets\nsecrets = await retrieve_secrets(\n    \"https://myvault.vault.azure.net/\",\n    [\"secret1\", \"secret2\", \"secret3\"]\n)\n\n# Retrieve all secrets\nall_secrets = await retrieve_all_secrets(\"https://myvault.vault.azure.net/\")\n```\n\n## Required Package Installation:\n\n```bash\npip install azure-identity azure-keyvault-secrets\n```\n\n## Authentication Methods (DefaultAzureCredential tries in order):\n\n1. Environment variables\n2. Managed Identity\n3. Azure CLI\n4. Azure PowerShell\n5. Interactive browser",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 82,
            "output_tokens": 2935,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secret Retrieval with Parallel Async Operations\n\n```python\n\"\"\"\nAzure Key Vault Secret Retrieval Script\nDemonstrates authentication with DefaultAzureCredential and parallel secret retrieval.\n\"\"\"\n\nimport asyncio\nimport sys\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\n\nfrom azure.identity.aio import DefaultAzureCredential\nfrom azure.keyvault.secrets.aio import SecretClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError,\n    ServiceRequestError\n)\n\n\n@dataclass\nclass SecretResult:\n    \"\"\"Result of a secret retrieval operation.\"\"\"\n    name: str\n    value: Optional[str] = None\n    error: Optional[str] = None\n    success: bool = False\n\n\nclass KeyVaultSecretRetriever:\n    \"\"\"\n    Handles authentication and parallel secret retrieval from Azure Key Vault.\n    \"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the Key Vault client.\n        \n        Args:\n            vault_url: The URL of the Azure Key Vault (e.g., https://myvault.vault.azure.net)\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = None\n        self.client = None\n    \n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=self.vault_url, credential=self.credential)\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit - cleanup resources.\"\"\"\n        if self.client:\n            await self.client.close()\n        if self.credential:\n            await self.credential.close()\n    \n    async def get_secret(self, secret_name: str) -> SecretResult:\n        \"\"\"\n        Retrieve a single secret from Key Vault.\n        \n        Args:\n            secret_name: Name of the secret to retrieve\n            \n        Returns:\n            SecretResult containing the secret value or error information\n        \"\"\"\n        try:\n            secret = await self.client.get_secret(secret_name)\n            return SecretResult(\n                name=secret_name,\n                value=secret.value,\n                success=True\n            )\n        \n        except ClientAuthenticationError as e:\n            error_msg = f\"Authentication failed: {str(e)}\"\n            print(f\"\u274c {secret_name}: {error_msg}\", file=sys.stderr)\n            return SecretResult(\n                name=secret_name,\n                error=error_msg,\n                success=False\n            )\n        \n        except ResourceNotFoundError:\n            error_msg = f\"Secret '{secret_name}' not found in vault\"\n            print(f\"\u26a0\ufe0f  {secret_name}: {error_msg}\", file=sys.stderr)\n            return SecretResult(\n                name=secret_name,\n                error=error_msg,\n                success=False\n            )\n        \n        except HttpResponseError as e:\n            error_msg = f\"HTTP error: {e.status_code} - {e.message}\"\n            print(f\"\u274c {secret_name}: {error_msg}\", file=sys.stderr)\n            return SecretResult(\n                name=secret_name,\n                error=error_msg,\n                success=False\n            )\n        \n        except ServiceRequestError as e:\n            error_msg = f\"Service request failed: {str(e)}\"\n            print(f\"\u274c {secret_name}: {error_msg}\", file=sys.stderr)\n            return SecretResult(\n                name=secret_name,\n                error=error_msg,\n                success=False\n            )\n        \n        except Exception as e:\n            error_msg = f\"Unexpected error: {type(e).__name__} - {str(e)}\"\n            print(f\"\u274c {secret_name}: {error_msg}\", file=sys.stderr)\n            return SecretResult(\n                name=secret_name,\n                error=error_msg,\n                success=False\n            )\n    \n    async def get_secrets_parallel(\n        self, \n        secret_names: List[str],\n        max_concurrent: int = 10\n    ) -> Dict[str, Optional[str]]:\n        \"\"\"\n        Retrieve multiple secrets in parallel with concurrency control.\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            max_concurrent: Maximum number of concurrent requests (default: 10)\n            \n        Returns:\n            Dictionary mapping secret names to their values (None if retrieval failed)\n        \"\"\"\n        if not secret_names:\n            return {}\n        \n        # Create semaphore to limit concurrent requests\n        semaphore = asyncio.Semaphore(max_concurrent)\n        \n        async def get_with_semaphore(name: str) -> SecretResult:\n            async with semaphore:\n                return await self.get_secret(name)\n        \n        # Execute all requests in parallel with concurrency limit\n        print(f\"\ud83d\udd04 Retrieving {len(secret_names)} secrets in parallel (max {max_concurrent} concurrent)...\")\n        tasks = [get_with_semaphore(name) for name in secret_names]\n        results = await asyncio.gather(*tasks, return_exceptions=False)\n        \n        # Convert results to dictionary\n        secrets_dict = {}\n        success_count = 0\n        \n        for result in results:\n            secrets_dict[result.name] = result.value\n            if result.success:\n                success_count += 1\n        \n        print(f\"\u2705 Successfully retrieved {success_count}/{len(secret_names)} secrets\")\n        \n        return secrets_dict\n\n\nasync def retrieve_secrets(\n    vault_url: str,\n    secret_names: List[str],\n    max_concurrent: int = 10\n) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Main function to retrieve secrets from Azure Key Vault.\n    \n    Args:\n        vault_url: The URL of the Azure Key Vault\n        secret_names: List of secret names to retrieve\n        max_concurrent: Maximum number of concurrent requests\n        \n    Returns:\n        Dictionary mapping secret names to their values\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n        ValueError: If vault_url or secret_names are invalid\n    \"\"\"\n    if not vault_url:\n        raise ValueError(\"vault_url cannot be empty\")\n    \n    if not secret_names:\n        raise ValueError(\"secret_names list cannot be empty\")\n    \n    if not vault_url.startswith(\"https://\"):\n        raise ValueError(\"vault_url must start with https://\")\n    \n    try:\n        async with KeyVaultSecretRetriever(vault_url) as retriever:\n            return await retriever.get_secrets_parallel(secret_names, max_concurrent)\n    \n    except ClientAuthenticationError as e:\n        print(f\"\\n\u274c AUTHENTICATION FAILED\", file=sys.stderr)\n        print(f\"Error: {str(e)}\", file=sys.stderr)\n        print(\"\\nTroubleshooting steps:\", file=sys.stderr)\n        print(\"1. Ensure you're logged in: az login\", file=sys.stderr)\n        print(\"2. Check environment variables: AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET\", file=sys.stderr)\n        print(\"3. Verify managed identity is enabled (if running in Azure)\", file=sys.stderr)\n        print(\"4. Check Key Vault access policies or RBAC permissions\", file=sys.stderr)\n        raise\n    \n    except Exception as e:\n        print(f\"\\n\u274c UNEXPECTED ERROR: {type(e).__name__}\", file=sys.stderr)\n        print(f\"Details: {str(e)}\", file=sys.stderr)\n        raise\n\n\nasync def main():\n    \"\"\"\n    Example usage of the secret retrieval functionality.\n    \"\"\"\n    # Configuration\n    VAULT_URL = \"https://myvault.vault.azure.net\"\n    SECRET_NAMES = [\n        \"database-connection-string\",\n        \"api-key\",\n        \"storage-account-key\",\n        \"service-bus-connection\",\n        \"redis-password\"\n    ]\n    \n    print(\"=\" * 70)\n    print(\"Azure Key Vault Secret Retrieval Demo\")\n    print(\"=\" * 70)\n    print(f\"\\nVault URL: {VAULT_URL}\")\n    print(f\"Secrets to retrieve: {len(SECRET_NAMES)}\")\n    print()\n    \n    try:\n        # Retrieve secrets\n        secrets = await retrieve_secrets(\n            vault_url=VAULT_URL,\n            secret_names=SECRET_NAMES,\n            max_concurrent=5\n        )\n        \n        # Display results\n        print(\"\\n\" + \"=\" * 70)\n        print(\"RESULTS\")\n        print(\"=\" * 70)\n        \n        for name, value in secrets.items():\n            if value is not None:\n                # Mask the secret value for security\n                masked_value = value[:4] + \"*\" * (len(value) - 8) + value[-4:] if len(value) > 8 else \"****\"\n                print(f\"\u2705 {name}: {masked_value}\")\n            else:\n                print(f\"\u274c {name}: Failed to retrieve\")\n        \n        # Summary\n        successful = sum(1 for v in secrets.values() if v is not None)\n        print(f\"\\n\ud83d\udcca Summary: {successful}/{len(secrets)} secrets retrieved successfully\")\n        \n        return secrets\n    \n    except ClientAuthenticationError:\n        print(\"\\n\u26a0\ufe0f  Authentication failed. Please check your credentials.\", file=sys.stderr)\n        sys.exit(1)\n    \n    except Exception as e:\n        print(f\"\\n\u26a0\ufe0f  An error occurred: {str(e)}\", file=sys.stderr)\n        sys.exit(1)\n\n\n# Alternative: Synchronous version for simpler use cases\ndef retrieve_secrets_sync(vault_url: str, secret_names: List[str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Synchronous wrapper for secret retrieval.\n    \n    Args:\n        vault_url: The URL of the Azure Key Vault\n        secret_names: List of secret names to retrieve\n        \n    Returns:\n        Dictionary mapping secret names to their values\n    \"\"\"\n    return asyncio.run(retrieve_secrets(vault_url, secret_names))\n\n\nif __name__ == \"__main__\":\n    # Run the async main function\n    asyncio.run(main())\n```\n\n## Installation Requirements\n\n```bash\n# Create requirements.txt\ncat > requirements.txt << 'EOF'\nazure-identity>=1.15.0\nazure-keyvault-secrets>=4.8.0\nEOF\n\n# Install dependencies\npip install -r requirements.txt\n```\n\n## Usage Examples\n\n### Example 1: Basic Usage\n\n```python\nimport asyncio\nfrom secret_retriever import retrieve_secrets\n\nasync def example_basic():\n    vault_url = \"https://myvault.vault.azure.net\"\n    secret_names = [\"database-password\", \"api-key\"]\n    \n    secrets = await retrieve_secrets(vault_url, secret_names)\n    \n    # Use the secrets\n    db_password = secrets.get(\"database-password\")\n    api_key = secrets.get(\"api-key\")\n    \n    if db_password and api_key:\n        print(\"All secrets retrieved successfully!\")\n\nasyncio.run(example_basic())\n```\n\n### Example 2: With Error Handling\n\n```python\nimport asyncio\nfrom azure.core.exceptions import ClientAuthenticationError\n\nasync def example_with_error_handling():\n    vault_url = \"https://myvault.vault.azure.net\"\n    secret_names = [\"secret1\", \"secret2\", \"secret3\"]\n    \n    try:\n        secrets = await retrieve_secrets(vault_url, secret_names)\n        \n        # Check which secrets were retrieved\n        for name, value in secrets.items():\n            if value is not None:\n                print(f\"\u2705 {name}: Retrieved\")\n            else:\n                print(f\"\u274c {name}: Failed\")\n    \n    except ClientAuthenticationError as e:\n        print(f\"Authentication failed: {e}\")\n        # Implement fallback or retry logic\n    \n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n\nasyncio.run(example_with_error_handling())\n```\n\n### Example 3: Using Context Manager Directly\n\n```python\nimport asyncio\nfrom secret_retriever import KeyVaultSecretRetriever\n\nasync def example_context_manager():\n    vault_url = \"https://myvault.vault.azure.net\"\n    \n    async with KeyVaultSecretRetriever(vault_url) as retriever:\n        # Retrieve secrets one by one\n        result1 = await retriever.get_secret(\"secret1\")\n        result2 = await retriever.get_secret(\"secret2\")\n        \n        # Or retrieve in parallel\n        secrets = await retriever.get_secrets_parallel(\n            [\"secret3\", \"secret4\", \"secret5\"],\n            max_concurrent=3\n        )\n\nasyncio.run(example_context_manager())\n```\n\n### Example 4: Synchronous Usage\n\n```python\nfrom secret_retriever import retrieve_secrets_sync\n\ndef example_sync():\n    vault_url = \"https://myvault.vault.azure.net\"\n    secret_names = [\"database-password\", \"api-key\"]\n    \n    secrets = retrieve_secrets_sync(vault_url, secret_names)\n    \n    print(f\"Retrieved {len(secrets)} secrets\")\n\nexample_sync()\n```\n\n## Environment Setup\n\n### Option 1: Azure CLI (Development)\n```bash\naz login\naz account set --subscription \"<subscription-id>\"\n```\n\n### Option 2: Service Principal (Production)\n```bash\nexport AZURE_CLIENT_ID=\"<client-id>\"\nexport AZURE_TENANT_ID=\"<tenant-id>\"\nexport AZURE_CLIENT_SECRET=\"<client-secret>\"\n```\n\n### Option 3: Managed Identity (Azure-hosted)\nNo configuration needed - automatically uses the assigned managed identity.\n\n## Key Features\n\n1. **\u2705 DefaultAzureCredential**: Automatically tries multiple authentication methods\n2. **\u2705 Parallel Retrieval**: Uses asyncio for concurrent secret fetching\n3. **\u2705 Concurrency Control**: Semaphore limits simultaneous requests\n4. **\u2705 Comprehensive Error Handling**: Catches and reports all error types\n5. **\u2705 Resource Cleanup**: Proper async context manager implementation\n6. **\u2705 Type Hints**: Full type annotations for better IDE support\n7. **\u2705 Logging**: Clear progress and error messages\n8. **\u2705 Security**: Masks secret values in output\n\n## Error Handling Coverage\n\n- `ClientAuthenticationError`: Authentication failures\n- `ResourceNotFoundError`: Secret doesn't exist\n- `HttpResponseError`: HTTP-level errors\n- `ServiceRequestError`: Network/service issues\n- Generic `Exception`: Unexpected errors\n\nThis implementation follows Azure SDK best practices and provides production-ready secret retrieval with proper error handling and parallel execution.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5418,
            "output_tokens": 3718,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Python script that authenticates with Azure and retrieves secrets from Key Vault using best practices from the azure-identity documentation.\n\n```python\n\"\"\"Azure Key Vault secret retrieval with DefaultAzureCredential.\"\"\"\nimport asyncio\nimport logging\nfrom typing import Dict, List\nfrom azure.identity.aio import DefaultAzureCredential\nfrom azure.keyvault.secrets.aio import SecretClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass KeyVaultSecretRetriever:\n    \"\"\"Retrieves secrets from Azure Key Vault using DefaultAzureCredential.\"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the secret retriever.\n        \n        Args:\n            vault_url: Azure Key Vault URL (e.g., \"https://myvault.vault.azure.net\")\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=vault_url, credential=self.credential)\n    \n    async def get_secret(self, secret_name: str) -> tuple[str, str | None]:\n        \"\"\"\n        Retrieve a single secret from Key Vault.\n        \n        Args:\n            secret_name: Name of the secret to retrieve\n            \n        Returns:\n            Tuple of (secret_name, secret_value) or (secret_name, None) if error\n        \"\"\"\n        try:\n            secret = await self.client.get_secret(secret_name)\n            logger.info(f\"Successfully retrieved secret: {secret_name}\")\n            return (secret_name, secret.value)\n        except ResourceNotFoundError:\n            logger.warning(f\"Secret not found: {secret_name}\")\n            return (secret_name, None)\n        except ClientAuthenticationError as e:\n            logger.error(f\"Authentication failed for secret {secret_name}: {e}\")\n            raise\n        except HttpResponseError as e:\n            logger.error(f\"HTTP error retrieving secret {secret_name}: {e}\")\n            return (secret_name, None)\n        except Exception as e:\n            logger.error(f\"Unexpected error retrieving secret {secret_name}: {e}\")\n            return (secret_name, None)\n    \n    async def get_secrets(self, secret_names: List[str]) -> Dict[str, str | None]:\n        \"\"\"\n        Retrieve multiple secrets from Key Vault in parallel.\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            \n        Returns:\n            Dictionary mapping secret names to their values (or None if not found)\n            \n        Raises:\n            ClientAuthenticationError: If authentication fails\n        \"\"\"\n        if not secret_names:\n            logger.warning(\"No secret names provided\")\n            return {}\n        \n        logger.info(f\"Retrieving {len(secret_names)} secrets from {self.vault_url}\")\n        \n        try:\n            # Retrieve all secrets in parallel\n            tasks = [self.get_secret(name) for name in secret_names]\n            results = await asyncio.gather(*tasks, return_exceptions=True)\n            \n            # Process results and handle exceptions\n            secrets = {}\n            for result in results:\n                if isinstance(result, ClientAuthenticationError):\n                    # Re-raise authentication errors\n                    raise result\n                elif isinstance(result, Exception):\n                    logger.error(f\"Unexpected exception in gather: {result}\")\n                    continue\n                else:\n                    secret_name, secret_value = result\n                    secrets[secret_name] = secret_value\n            \n            successful = sum(1 for v in secrets.values() if v is not None)\n            logger.info(f\"Successfully retrieved {successful}/{len(secret_names)} secrets\")\n            \n            return secrets\n            \n        except ClientAuthenticationError as e:\n            logger.error(f\"Authentication failed: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error during secret retrieval: {e}\")\n            raise\n    \n    async def close(self):\n        \"\"\"Close the credential and client connections.\"\"\"\n        await self.client.close()\n        await self.credential.close()\n    \n    async def __aenter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        await self.close()\n\n\nasync def retrieve_secrets(\n    vault_url: str,\n    secret_names: List[str]\n) -> Dict[str, str | None]:\n    \"\"\"\n    Retrieve secrets from Azure Key Vault.\n    \n    Args:\n        vault_url: Azure Key Vault URL (e.g., \"https://myvault.vault.azure.net\")\n        secret_names: List of secret names to retrieve\n        \n    Returns:\n        Dictionary mapping secret names to their values (or None if not found)\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n        ValueError: If vault_url or secret_names are invalid\n    \"\"\"\n    if not vault_url:\n        raise ValueError(\"vault_url cannot be empty\")\n    \n    if not secret_names:\n        raise ValueError(\"secret_names cannot be empty\")\n    \n    async with KeyVaultSecretRetriever(vault_url) as retriever:\n        return await retriever.get_secrets(secret_names)\n\n\nasync def main():\n    \"\"\"Example usage of the secret retriever.\"\"\"\n    # Configure logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n    \n    # Example configuration\n    vault_url = \"https://myvault.vault.azure.net\"\n    secret_names = [\n        \"database-connection-string\",\n        \"api-key\",\n        \"storage-account-key\",\n        \"non-existent-secret\"  # This will return None\n    ]\n    \n    try:\n        secrets = await retrieve_secrets(vault_url, secret_names)\n        \n        # Display results (mask actual values in production!)\n        print(\"\\nRetrieved secrets:\")\n        for name, value in secrets.items():\n            if value is not None:\n                print(f\"  {name}: {'*' * 10} (length: {len(value)})\")\n            else:\n                print(f\"  {name}: NOT FOUND\")\n                \n    except ClientAuthenticationError as e:\n        print(f\"\\n\u274c Authentication failed: {e}\")\n        print(\"\\nTroubleshooting:\")\n        print(\"1. Ensure you're logged in with Azure CLI: az login\")\n        print(\"2. Check AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_CLIENT_SECRET env vars\")\n        print(\"3. Verify your identity has 'Key Vault Secrets User' role\")\n    except ValueError as e:\n        print(f\"\\n\u274c Invalid input: {e}\")\n    except Exception as e:\n        print(f\"\\n\u274c Unexpected error: {e}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\nThis script follows Azure Identity best practices:\n\n## Key Features:\n\n1. **DefaultAzureCredential** - Uses the recommended credential chain for dev-to-prod scenarios\n2. **Async/Await** - Uses `azure.identity.aio` for async operations\n3. **Parallel Retrieval** - Fetches all secrets concurrently with `asyncio.gather()`\n4. **Proper Error Handling**:\n   - `ClientAuthenticationError` for auth failures (re-raised)\n   - `ResourceNotFoundError` for missing secrets (returns None)\n   - `HttpResponseError` for other HTTP errors\n5. **Context Manager** - Properly closes connections with `async with`\n6. **Logging** - Comprehensive logging for debugging\n7. **Type Hints** - Full type annotations for better IDE support\n\n## Usage:\n\n```python\n# Simple usage\nsecrets = await retrieve_secrets(\n    vault_url=\"https://myvault.vault.azure.net\",\n    secret_names=[\"secret1\", \"secret2\"]\n)\n\n# With context manager for more control\nasync with KeyVaultSecretRetriever(vault_url) as retriever:\n    secrets = await retriever.get_secrets([\"secret1\", \"secret2\"])\n```\n\n## Authentication Methods (in order):\n1. Environment variables (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET)\n2. Managed Identity (in Azure)\n3. Azure CLI (`az login`)\n4. Visual Studio Code\n5. Azure PowerShell\n\nThe script will automatically try these methods until one succeeds!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5944,
            "output_tokens": 2137,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "```python\nimport asyncio\nfrom typing import Dict, List, Optional\nfrom azure.identity.aio import DefaultAzureCredential\nfrom azure.keyvault.secrets.aio import SecretClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError,\n    ServiceRequestError\n)\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass AzureKeyVaultClient:\n    \"\"\"\n    A client for retrieving secrets from Azure Key Vault with parallel processing.\n    \"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the Key Vault client.\n        \n        Args:\n            vault_url: The URL of the Azure Key Vault (e.g., https://myvault.vault.azure.net/)\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = None\n        self.client = None\n    \n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=self.vault_url, credential=self.credential)\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with proper cleanup.\"\"\"\n        if self.client:\n            await self.client.close()\n        if self.credential:\n            await self.credential.close()\n    \n    async def get_secret(self, secret_name: str) -> Optional[Dict[str, str]]:\n        \"\"\"\n        Retrieve a single secret from Key Vault.\n        \n        Args:\n            secret_name: The name of the secret to retrieve\n            \n        Returns:\n            Dictionary with secret name and value, or None if failed\n        \"\"\"\n        try:\n            logger.info(f\"Retrieving secret: {secret_name}\")\n            secret = await self.client.get_secret(secret_name)\n            logger.info(f\"Successfully retrieved secret: {secret_name}\")\n            return {\n                \"name\": secret_name,\n                \"value\": secret.value,\n                \"enabled\": secret.properties.enabled,\n                \"created_on\": secret.properties.created_on,\n                \"updated_on\": secret.properties.updated_on\n            }\n        except ResourceNotFoundError:\n            logger.error(f\"Secret not found: {secret_name}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": \"Secret not found\"\n            }\n        except ClientAuthenticationError as e:\n            logger.error(f\"Authentication failed for secret {secret_name}: {str(e)}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": f\"Authentication failed: {str(e)}\"\n            }\n        except HttpResponseError as e:\n            logger.error(f\"HTTP error retrieving secret {secret_name}: {str(e)}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": f\"HTTP error: {str(e)}\"\n            }\n        except Exception as e:\n            logger.error(f\"Unexpected error retrieving secret {secret_name}: {str(e)}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": f\"Unexpected error: {str(e)}\"\n            }\n    \n    async def get_secrets_parallel(self, secret_names: List[str]) -> Dict[str, Dict]:\n        \"\"\"\n        Retrieve multiple secrets in parallel.\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            \n        Returns:\n            Dictionary mapping secret names to their details\n        \"\"\"\n        if not secret_names:\n            logger.warning(\"No secret names provided\")\n            return {}\n        \n        logger.info(f\"Retrieving {len(secret_names)} secrets in parallel\")\n        \n        # Create tasks for all secrets\n        tasks = [self.get_secret(name) for name in secret_names]\n        \n        # Execute all tasks in parallel\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Process results\n        secrets_dict = {}\n        for result in results:\n            if isinstance(result, Exception):\n                logger.error(f\"Task failed with exception: {str(result)}\")\n                continue\n            if result:\n                secrets_dict[result[\"name\"]] = result\n        \n        logger.info(f\"Successfully retrieved {len(secrets_dict)} secrets\")\n        return secrets_dict\n    \n    async def list_all_secrets(self) -> List[str]:\n        \"\"\"\n        List all secret names in the Key Vault.\n        \n        Returns:\n            List of secret names\n        \"\"\"\n        try:\n            logger.info(\"Listing all secrets in Key Vault\")\n            secret_names = []\n            async for secret_properties in self.client.list_properties_of_secrets():\n                secret_names.append(secret_properties.name)\n            logger.info(f\"Found {len(secret_names)} secrets\")\n            return secret_names\n        except ClientAuthenticationError as e:\n            logger.error(f\"Authentication failed while listing secrets: {str(e)}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Error listing secrets: {str(e)}\")\n            raise\n\n\nasync def retrieve_secrets(\n    vault_url: str,\n    secret_names: List[str],\n    timeout: int = 30\n) -> Dict[str, Dict]:\n    \"\"\"\n    Main function to retrieve secrets from Azure Key Vault.\n    \n    Args:\n        vault_url: The URL of the Azure Key Vault\n        secret_names: List of secret names to retrieve\n        timeout: Timeout in seconds for the operation\n        \n    Returns:\n        Dictionary mapping secret names to their details\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n        asyncio.TimeoutError: If operation times out\n    \"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            async with AzureKeyVaultClient(vault_url) as kv_client:\n                secrets = await kv_client.get_secrets_parallel(secret_names)\n                return secrets\n    except asyncio.TimeoutError:\n        logger.error(f\"Operation timed out after {timeout} seconds\")\n        raise\n    except ClientAuthenticationError as e:\n        logger.error(f\"Authentication failed: {str(e)}\")\n        logger.error(\"Please ensure you have proper Azure credentials configured:\")\n        logger.error(\"  - Azure CLI: Run 'az login'\")\n        logger.error(\"  - Managed Identity: Ensure the identity has Key Vault permissions\")\n        logger.error(\"  - Environment Variables: Set AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET\")\n        raise\n    except ServiceRequestError as e:\n        logger.error(f\"Network error: {str(e)}\")\n        raise\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\")\n        raise\n\n\nasync def main():\n    \"\"\"\n    Example usage of the Azure Key Vault client.\n    \"\"\"\n    # Configuration\n    VAULT_URL = \"https://your-vault-name.vault.azure.net/\"\n    SECRET_NAMES = [\n        \"database-password\",\n        \"api-key\",\n        \"connection-string\",\n        \"storage-account-key\"\n    ]\n    \n    try:\n        logger.info(\"Starting Azure Key Vault secret retrieval\")\n        \n        # Retrieve secrets\n        secrets = await retrieve_secrets(VAULT_URL, SECRET_NAMES)\n        \n        # Display results\n        print(\"\\n\" + \"=\"*50)\n        print(\"RETRIEVED SECRETS\")\n        print(\"=\"*50)\n        \n        for secret_name, secret_data in secrets.items():\n            print(f\"\\nSecret: {secret_name}\")\n            if secret_data.get(\"error\"):\n                print(f\"  Status: FAILED\")\n                print(f\"  Error: {secret_data['error']}\")\n            else:\n                print(f\"  Status: SUCCESS\")\n                print(f\"  Value: {'*' * 10} (hidden)\")\n                print(f\"  Enabled: {secret_data.get('enabled')}\")\n                print(f\"  Created: {secret_data.get('created_on')}\")\n                print(f\"  Updated: {secret_data.get('updated_on')}\")\n        \n        print(\"\\n\" + \"=\"*50)\n        \n        # Example: List all secrets in the vault\n        print(\"\\nListing all secrets in the vault...\")\n        async with AzureKeyVaultClient(VAULT_URL) as kv_client:\n            all_secret_names = await kv_client.list_all_secrets()\n            print(f\"Total secrets in vault: {len(all_secret_names)}\")\n            for name in all_secret_names[:5]:  # Show first 5\n                print(f\"  - {name}\")\n            if len(all_secret_names) > 5:\n                print(f\"  ... and {len(all_secret_names) - 5} more\")\n        \n    except ClientAuthenticationError:\n        print(\"\\n\u274c Authentication failed. Please check your Azure credentials.\")\n        return 1\n    except asyncio.TimeoutError:\n        print(\"\\n\u274c Operation timed out.\")\n        return 1\n    except Exception as e:\n        print(f\"\\n\u274c An error occurred: {str(e)}\")\n        return 1\n    \n    print(\"\\n\u2705 Operation completed successfully\")\n    return 0\n\n\n# Synchronous wrapper for environments that need it\ndef retrieve_secrets_sync(vault_url: str, secret_names: List[str]) -> Dict[str, Dict]:\n    \"\"\"\n    Synchronous wrapper for retrieve_secrets function.\n    \n    Args:\n        vault_url: The URL of the Azure Key Vault\n        secret_names: List of secret names to retrieve\n        \n    Returns:\n        Dictionary mapping secret names to their details\n    \"\"\"\n    return asyncio.run(retrieve_secrets(vault_url, secret_names))\n\n\nif __name__ == \"__main__\":\n    exit_code = asyncio.run(main())\n    exit(exit_code)\n```\n\nThis script provides a comprehensive solution for retrieving secrets from Azure Key Vault with the following features:\n\n## Key Features:\n\n1. **Async/Parallel Processing**: Uses `asyncio` to retrieve multiple secrets concurrently\n2. **Proper Authentication**: Uses `DefaultAzureCredential` which tries multiple authentication methods\n3. **Error Handling**: Comprehensive error handling for various Azure exceptions\n4. **Context Managers**: Proper resource cleanup using async context managers\n5. **Logging**: Detailed logging for debugging and monitoring\n6. **Timeout Support**: Configurable timeout for operations\n7. **Flexible API**: Both async and sync interfaces available\n\n## Usage:\n\n```bash\n# Install required packages\npip install azure-identity azure-keyvault-secrets\n\n# Run the script\npython azure_keyvault_client.py\n```\n\n## Authentication Methods (DefaultAzureCredential tries in order):\n\n1. Environment variables\n2. Managed Identity\n3. Azure CLI\n4. Azure PowerShell\n5. Interactive browser\n\nThe script includes proper error messages to guide users on authentication setup.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 82,
            "output_tokens": 2800,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secret Retrieval Script\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Key Vault Secret Retrieval Script\n\nThis script demonstrates:\n- Authentication using DefaultAzureCredential\n- Parallel secret retrieval using asyncio\n- Proper error handling for authentication and secret access\n- Type hints and comprehensive documentation\n\"\"\"\n\nimport asyncio\nimport sys\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.identity.aio import DefaultAzureCredential as AsyncDefaultAzureCredential\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.keyvault.secrets.aio import SecretClient as AsyncSecretClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError,\n    ServiceRequestError\n)\n\n\n@dataclass\nclass SecretResult:\n    \"\"\"Result of a secret retrieval operation.\"\"\"\n    name: str\n    value: Optional[str] = None\n    error: Optional[str] = None\n    success: bool = False\n\n\nclass AzureKeyVaultClient:\n    \"\"\"Client for retrieving secrets from Azure Key Vault.\"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the Key Vault client.\n        \n        Args:\n            vault_url: The URL of the Azure Key Vault (e.g., https://myvault.vault.azure.net)\n        \n        Raises:\n            ValueError: If vault_url is invalid\n        \"\"\"\n        if not vault_url or not vault_url.startswith(\"https://\"):\n            raise ValueError(f\"Invalid vault URL: {vault_url}\")\n        \n        self.vault_url = vault_url\n        self._credential = None\n        self._async_credential = None\n    \n    def _get_credential(self) -> DefaultAzureCredential:\n        \"\"\"Get or create the synchronous credential instance.\"\"\"\n        if self._credential is None:\n            self._credential = DefaultAzureCredential()\n        return self._credential\n    \n    def _get_async_credential(self) -> AsyncDefaultAzureCredential:\n        \"\"\"Get or create the asynchronous credential instance.\"\"\"\n        if self._async_credential is None:\n            self._async_credential = AsyncDefaultAzureCredential()\n        return self._async_credential\n    \n    def get_secret_sync(self, secret_name: str) -> SecretResult:\n        \"\"\"\n        Retrieve a single secret synchronously.\n        \n        Args:\n            secret_name: Name of the secret to retrieve\n            \n        Returns:\n            SecretResult containing the secret value or error information\n        \"\"\"\n        try:\n            credential = self._get_credential()\n            client = SecretClient(vault_url=self.vault_url, credential=credential)\n            \n            secret = client.get_secret(secret_name)\n            return SecretResult(\n                name=secret_name,\n                value=secret.value,\n                success=True\n            )\n            \n        except ClientAuthenticationError as e:\n            return SecretResult(\n                name=secret_name,\n                error=f\"Authentication failed: {str(e)}\",\n                success=False\n            )\n        except ResourceNotFoundError:\n            return SecretResult(\n                name=secret_name,\n                error=f\"Secret '{secret_name}' not found in vault\",\n                success=False\n            )\n        except HttpResponseError as e:\n            return SecretResult(\n                name=secret_name,\n                error=f\"HTTP error: {e.status_code} - {e.message}\",\n                success=False\n            )\n        except ServiceRequestError as e:\n            return SecretResult(\n                name=secret_name,\n                error=f\"Service request failed: {str(e)}\",\n                success=False\n            )\n        except Exception as e:\n            return SecretResult(\n                name=secret_name,\n                error=f\"Unexpected error: {str(e)}\",\n                success=False\n            )\n    \n    async def get_secret_async(self, secret_name: str) -> SecretResult:\n        \"\"\"\n        Retrieve a single secret asynchronously.\n        \n        Args:\n            secret_name: Name of the secret to retrieve\n            \n        Returns:\n            SecretResult containing the secret value or error information\n        \"\"\"\n        try:\n            credential = self._get_async_credential()\n            async with AsyncSecretClient(\n                vault_url=self.vault_url,\n                credential=credential\n            ) as client:\n                secret = await client.get_secret(secret_name)\n                return SecretResult(\n                    name=secret_name,\n                    value=secret.value,\n                    success=True\n                )\n                \n        except ClientAuthenticationError as e:\n            return SecretResult(\n                name=secret_name,\n                error=f\"Authentication failed: {str(e)}\",\n                success=False\n            )\n        except ResourceNotFoundError:\n            return SecretResult(\n                name=secret_name,\n                error=f\"Secret '{secret_name}' not found in vault\",\n                success=False\n            )\n        except HttpResponseError as e:\n            return SecretResult(\n                name=secret_name,\n                error=f\"HTTP error: {e.status_code} - {e.message}\",\n                success=False\n            )\n        except ServiceRequestError as e:\n            return SecretResult(\n                name=secret_name,\n                error=f\"Service request failed: {str(e)}\",\n                success=False\n            )\n        except Exception as e:\n            return SecretResult(\n                name=secret_name,\n                error=f\"Unexpected error: {str(e)}\",\n                success=False\n            )\n    \n    async def get_secrets_parallel(\n        self,\n        secret_names: List[str]\n    ) -> Dict[str, str]:\n        \"\"\"\n        Retrieve multiple secrets in parallel using asyncio.\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            \n        Returns:\n            Dictionary mapping secret names to their values.\n            Failed retrievals are not included in the result.\n            \n        Raises:\n            ValueError: If secret_names is empty\n            RuntimeError: If all secret retrievals fail\n        \"\"\"\n        if not secret_names:\n            raise ValueError(\"secret_names list cannot be empty\")\n        \n        # Create tasks for parallel execution\n        tasks = [\n            self.get_secret_async(secret_name)\n            for secret_name in secret_names\n        ]\n        \n        # Execute all tasks concurrently\n        results = await asyncio.gather(*tasks, return_exceptions=False)\n        \n        # Process results\n        secrets = {}\n        failed_secrets = []\n        \n        for result in results:\n            if result.success:\n                secrets[result.name] = result.value\n            else:\n                failed_secrets.append((result.name, result.error))\n                print(f\"Warning: Failed to retrieve '{result.name}': {result.error}\", \n                      file=sys.stderr)\n        \n        # Check if all retrievals failed\n        if not secrets and failed_secrets:\n            error_summary = \"\\n\".join([f\"  - {name}: {error}\" \n                                      for name, error in failed_secrets])\n            raise RuntimeError(\n                f\"All secret retrievals failed:\\n{error_summary}\"\n            )\n        \n        return secrets\n    \n    async def close(self):\n        \"\"\"Close the async credential and release resources.\"\"\"\n        if self._async_credential is not None:\n            await self._async_credential.close()\n        if self._credential is not None:\n            self._credential.close()\n\n\nasync def retrieve_secrets(\n    vault_url: str,\n    secret_names: List[str]\n) -> Dict[str, str]:\n    \"\"\"\n    Retrieve multiple secrets from Azure Key Vault in parallel.\n    \n    Args:\n        vault_url: The URL of the Azure Key Vault\n        secret_names: List of secret names to retrieve\n        \n    Returns:\n        Dictionary mapping secret names to their values\n        \n    Raises:\n        ValueError: If inputs are invalid\n        RuntimeError: If authentication fails or all retrievals fail\n    \"\"\"\n    client = AzureKeyVaultClient(vault_url)\n    \n    try:\n        secrets = await client.get_secrets_parallel(secret_names)\n        return secrets\n    finally:\n        await client.close()\n\n\n# Example usage and testing\nasync def main():\n    \"\"\"Main function demonstrating usage.\"\"\"\n    \n    # Example configuration\n    vault_url = \"https://myvault.vault.azure.net\"\n    secret_names = [\n        \"database-connection-string\",\n        \"api-key\",\n        \"storage-account-key\",\n        \"non-existent-secret\"  # This will fail but won't stop others\n    ]\n    \n    print(f\"Retrieving secrets from: {vault_url}\")\n    print(f\"Secret names: {', '.join(secret_names)}\\n\")\n    \n    try:\n        # Retrieve secrets in parallel\n        secrets = await retrieve_secrets(vault_url, secret_names)\n        \n        print(f\"\\nSuccessfully retrieved {len(secrets)} secret(s):\")\n        for name, value in secrets.items():\n            # Mask the actual value for security\n            masked_value = value[:4] + \"...\" + value[-4:] if len(value) > 8 else \"***\"\n            print(f\"  - {name}: {masked_value}\")\n            \n    except ValueError as e:\n        print(f\"Configuration error: {e}\", file=sys.stderr)\n        sys.exit(1)\n    except RuntimeError as e:\n        print(f\"Runtime error: {e}\", file=sys.stderr)\n        sys.exit(1)\n    except Exception as e:\n        print(f\"Unexpected error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n\ndef test_sync_retrieval():\n    \"\"\"Test synchronous secret retrieval.\"\"\"\n    vault_url = \"https://myvault.vault.azure.net\"\n    client = AzureKeyVaultClient(vault_url)\n    \n    try:\n        result = client.get_secret_sync(\"test-secret\")\n        if result.success:\n            print(f\"Successfully retrieved: {result.name}\")\n        else:\n            print(f\"Failed to retrieve: {result.error}\")\n    finally:\n        client._credential.close() if client._credential else None\n\n\nif __name__ == \"__main__\":\n    # Run the async main function\n    asyncio.run(main())\n    \n    # Uncomment to test synchronous retrieval\n    # test_sync_retrieval()\n```\n\n## Installation Requirements\n\n```bash\n# requirements.txt\nazure-identity>=1.19.0\nazure-keyvault-secrets>=4.9.0\n```\n\nInstall dependencies:\n```bash\npip install -r requirements.txt\n```\n\n## Environment Setup\n\n### Option 1: Service Principal with Secret\n```bash\nexport AZURE_CLIENT_ID=\"<application-client-id>\"\nexport AZURE_TENANT_ID=\"<directory-tenant-id>\"\nexport AZURE_CLIENT_SECRET=\"<client-secret-value>\"\n```\n\n### Option 2: Azure CLI (Development)\n```bash\naz login\n```\n\n### Option 3: Managed Identity (Production)\nNo environment variables needed when running on Azure resources with managed identity enabled.\n\n## Usage Examples\n\n### Basic Usage\n```python\nimport asyncio\nfrom azure_keyvault_client import retrieve_secrets\n\nasync def example():\n    vault_url = \"https://myvault.vault.azure.net\"\n    secret_names = [\"secret1\", \"secret2\", \"secret3\"]\n    \n    secrets = await retrieve_secrets(vault_url, secret_names)\n    \n    for name, value in secrets.items():\n        print(f\"{name}: {value}\")\n\nasyncio.run(example())\n```\n\n### With Custom Error Handling\n```python\nimport asyncio\nfrom azure_keyvault_client import AzureKeyVaultClient\n\nasync def example_with_error_handling():\n    client = AzureKeyVaultClient(\"https://myvault.vault.azure.net\")\n    \n    try:\n        secrets = await client.get_secrets_parallel([\n            \"database-password\",\n            \"api-key\"\n        ])\n        \n        # Use secrets\n        db_password = secrets.get(\"database-password\")\n        api_key = secrets.get(\"api-key\")\n        \n    except RuntimeError as e:\n        print(f\"Failed to retrieve secrets: {e}\")\n    finally:\n        await client.close()\n\nasyncio.run(example_with_error_handling())\n```\n\n## Key Features\n\n1. **DefaultAzureCredential**: Automatically tries multiple authentication methods\n2. **Parallel Retrieval**: Uses asyncio for concurrent secret fetching\n3. **Comprehensive Error Handling**: Catches and reports specific Azure exceptions\n4. **Type Safety**: Full type hints for better IDE support\n5. **Resource Management**: Proper cleanup with context managers\n6. **Partial Success**: Returns successfully retrieved secrets even if some fail\n\n## Error Handling\n\nThe script handles these specific exceptions:\n- `ClientAuthenticationError`: Authentication failures\n- `ResourceNotFoundError`: Secret doesn't exist\n- `HttpResponseError`: HTTP-level errors\n- `ServiceRequestError`: Network/service issues\n\n## Security Best Practices\n\n1. Never hardcode credentials\n2. Use environment variables or managed identity\n3. Mask secret values in logs\n4. Close credentials after use\n5. Use HTTPS vault URLs only",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5418,
            "output_tokens": 3286,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Python script that authenticates with Azure and retrieves secrets from Key Vault using best practices from the Azure Identity SDK.\n\n```python\n\"\"\"Azure Key Vault secret retrieval with DefaultAzureCredential.\"\"\"\nimport asyncio\nimport logging\nfrom typing import Dict, List\nfrom azure.identity.aio import DefaultAzureCredential\nfrom azure.keyvault.secrets.aio import SecretClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError,\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass KeyVaultSecretRetriever:\n    \"\"\"Retrieves secrets from Azure Key Vault using DefaultAzureCredential.\"\"\"\n\n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the secret retriever.\n\n        Args:\n            vault_url: Azure Key Vault URL (e.g., https://myvault.vault.azure.net)\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=vault_url, credential=self.credential)\n\n    async def get_secret(self, secret_name: str) -> tuple[str, str | None]:\n        \"\"\"\n        Retrieve a single secret from Key Vault.\n\n        Args:\n            secret_name: Name of the secret to retrieve\n\n        Returns:\n            Tuple of (secret_name, secret_value) or (secret_name, None) on error\n        \"\"\"\n        try:\n            secret = await self.client.get_secret(secret_name)\n            logger.info(\"Successfully retrieved secret: %s\", secret_name)\n            return (secret_name, secret.value)\n        except ResourceNotFoundError:\n            logger.warning(\"Secret not found: %s\", secret_name)\n            return (secret_name, None)\n        except ClientAuthenticationError as e:\n            logger.error(\"Authentication failed for secret %s: %s\", secret_name, e)\n            raise\n        except HttpResponseError as e:\n            logger.error(\"HTTP error retrieving secret %s: %s\", secret_name, e)\n            return (secret_name, None)\n        except Exception as e:\n            logger.error(\"Unexpected error retrieving secret %s: %s\", secret_name, e)\n            return (secret_name, None)\n\n    async def get_secrets(self, secret_names: List[str]) -> Dict[str, str | None]:\n        \"\"\"\n        Retrieve multiple secrets from Key Vault in parallel.\n\n        Args:\n            secret_names: List of secret names to retrieve\n\n        Returns:\n            Dictionary mapping secret names to their values (or None if not found)\n\n        Raises:\n            ClientAuthenticationError: If authentication fails\n        \"\"\"\n        if not secret_names:\n            logger.warning(\"No secret names provided\")\n            return {}\n\n        logger.info(\n            \"Retrieving %d secrets from vault: %s\", len(secret_names), self.vault_url\n        )\n\n        try:\n            # Retrieve all secrets in parallel\n            tasks = [self.get_secret(name) for name in secret_names]\n            results = await asyncio.gather(*tasks, return_exceptions=True)\n\n            # Process results and handle exceptions\n            secrets = {}\n            for result in results:\n                if isinstance(result, ClientAuthenticationError):\n                    # Re-raise authentication errors\n                    raise result\n                elif isinstance(result, Exception):\n                    logger.error(\"Unexpected exception in gather: %s\", result)\n                    continue\n                else:\n                    secret_name, secret_value = result\n                    secrets[secret_name] = secret_value\n\n            logger.info(\"Successfully retrieved %d/%d secrets\", len(secrets), len(secret_names))\n            return secrets\n\n        except ClientAuthenticationError as e:\n            logger.error(\"Authentication failed: %s\", e)\n            raise\n        except Exception as e:\n            logger.error(\"Unexpected error retrieving secrets: %s\", e)\n            raise\n\n    async def close(self):\n        \"\"\"Close the credential and client connections.\"\"\"\n        await self.client.close()\n        await self.credential.close()\n\n    async def __aenter__(self):\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Context manager exit.\"\"\"\n        await self.close()\n\n\nasync def retrieve_secrets(\n    vault_url: str, secret_names: List[str]\n) -> Dict[str, str | None]:\n    \"\"\"\n    Retrieve secrets from Azure Key Vault.\n\n    Args:\n        vault_url: Azure Key Vault URL (e.g., https://myvault.vault.azure.net)\n        secret_names: List of secret names to retrieve\n\n    Returns:\n        Dictionary mapping secret names to their values (or None if not found)\n\n    Raises:\n        ClientAuthenticationError: If authentication fails\n        ValueError: If vault_url is invalid\n    \"\"\"\n    if not vault_url:\n        raise ValueError(\"vault_url cannot be empty\")\n\n    if not vault_url.startswith(\"https://\"):\n        raise ValueError(\"vault_url must start with https://\")\n\n    async with KeyVaultSecretRetriever(vault_url) as retriever:\n        return await retriever.get_secrets(secret_names)\n\n\nasync def main():\n    \"\"\"Example usage of the secret retriever.\"\"\"\n    # Configure logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n\n    # Example: Retrieve secrets from Key Vault\n    vault_url = \"https://myvault.vault.azure.net\"\n    secret_names = [\"database-password\", \"api-key\", \"connection-string\"]\n\n    try:\n        secrets = await retrieve_secrets(vault_url, secret_names)\n\n        # Display results (don't log actual secret values in production!)\n        for name, value in secrets.items():\n            if value is not None:\n                logger.info(\"Secret '%s': Retrieved successfully\", name)\n            else:\n                logger.warning(\"Secret '%s': Not found or error occurred\", name)\n\n    except ClientAuthenticationError as e:\n        logger.error(\"Authentication failed: %s\", e)\n        logger.error(\n            \"Ensure you are logged in with Azure CLI (az login) or have proper credentials configured\"\n        )\n    except ValueError as e:\n        logger.error(\"Invalid configuration: %s\", e)\n    except Exception as e:\n        logger.error(\"Unexpected error: %s\", e)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\nThis script follows Azure Identity SDK best practices:\n\n**Key Features:**\n1. \u2705 Uses `DefaultAzureCredential` for automatic credential chain\n2. \u2705 Async implementation with `azure.identity.aio` and `azure.keyvault.secrets.aio`\n3. \u2705 Parallel secret retrieval using `asyncio.gather()`\n4. \u2705 Proper error handling for authentication failures\n5. \u2705 Context manager support for resource cleanup\n6. \u2705 Comprehensive logging\n7. \u2705 Type hints throughout\n\n**Error Handling:**\n- `ClientAuthenticationError`: Re-raised to caller (authentication failures)\n- `ResourceNotFoundError`: Returns `None` for missing secrets\n- `HttpResponseError`: Logged and returns `None`\n- Generic exceptions: Logged and handled gracefully\n\n**Usage:**\n```python\n# Simple usage\nsecrets = await retrieve_secrets(\n    vault_url=\"https://myvault.vault.azure.net\",\n    secret_names=[\"secret1\", \"secret2\", \"secret3\"]\n)\n\n# Or with context manager for more control\nasync with KeyVaultSecretRetriever(vault_url) as retriever:\n    secrets = await retriever.get_secrets(secret_names)\n```\n\nThe script will work with any credential in the DefaultAzureCredential chain (Azure CLI, managed identity, environment variables, etc.).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5944,
            "output_tokens": 1937,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "```python\nimport asyncio\nfrom typing import Dict, List, Optional\nfrom azure.identity.aio import DefaultAzureCredential\nfrom azure.keyvault.secrets.aio import SecretClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError,\n    ServiceRequestError\n)\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass AzureKeyVaultClient:\n    \"\"\"\n    A client for retrieving secrets from Azure Key Vault with parallel processing.\n    \"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the Azure Key Vault client.\n        \n        Args:\n            vault_url: The URL of the Azure Key Vault (e.g., https://myvault.vault.azure.net/)\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = None\n        self.client = None\n    \n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=self.vault_url, credential=self.credential)\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit with proper cleanup.\"\"\"\n        if self.client:\n            await self.client.close()\n        if self.credential:\n            await self.credential.close()\n    \n    async def get_secret(self, secret_name: str) -> Optional[Dict[str, str]]:\n        \"\"\"\n        Retrieve a single secret from Azure Key Vault.\n        \n        Args:\n            secret_name: Name of the secret to retrieve\n            \n        Returns:\n            Dictionary with secret name and value, or None if retrieval failed\n        \"\"\"\n        try:\n            logger.info(f\"Retrieving secret: {secret_name}\")\n            secret = await self.client.get_secret(secret_name)\n            logger.info(f\"Successfully retrieved secret: {secret_name}\")\n            return {\n                \"name\": secret_name,\n                \"value\": secret.value,\n                \"enabled\": secret.properties.enabled,\n                \"created_on\": secret.properties.created_on,\n                \"updated_on\": secret.properties.updated_on\n            }\n        except ResourceNotFoundError:\n            logger.error(f\"Secret not found: {secret_name}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": \"Secret not found\"\n            }\n        except ClientAuthenticationError as e:\n            logger.error(f\"Authentication failed for secret {secret_name}: {str(e)}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": f\"Authentication failed: {str(e)}\"\n            }\n        except HttpResponseError as e:\n            logger.error(f\"HTTP error retrieving secret {secret_name}: {str(e)}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": f\"HTTP error: {str(e)}\"\n            }\n        except Exception as e:\n            logger.error(f\"Unexpected error retrieving secret {secret_name}: {str(e)}\")\n            return {\n                \"name\": secret_name,\n                \"value\": None,\n                \"error\": f\"Unexpected error: {str(e)}\"\n            }\n    \n    async def get_secrets_parallel(self, secret_names: List[str]) -> Dict[str, Dict]:\n        \"\"\"\n        Retrieve multiple secrets in parallel from Azure Key Vault.\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            \n        Returns:\n            Dictionary mapping secret names to their details\n        \"\"\"\n        if not secret_names:\n            logger.warning(\"No secret names provided\")\n            return {}\n        \n        logger.info(f\"Retrieving {len(secret_names)} secrets in parallel\")\n        \n        # Create tasks for parallel execution\n        tasks = [self.get_secret(name) for name in secret_names]\n        \n        # Execute all tasks concurrently\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Process results\n        secrets_dict = {}\n        for result in results:\n            if isinstance(result, Exception):\n                logger.error(f\"Task failed with exception: {str(result)}\")\n                continue\n            if result and result.get(\"name\"):\n                secrets_dict[result[\"name\"]] = result\n        \n        logger.info(f\"Successfully retrieved {len(secrets_dict)} secrets\")\n        return secrets_dict\n    \n    async def list_all_secrets(self) -> List[str]:\n        \"\"\"\n        List all secret names in the Key Vault.\n        \n        Returns:\n            List of secret names\n        \"\"\"\n        try:\n            logger.info(\"Listing all secrets in Key Vault\")\n            secret_names = []\n            async for secret_properties in self.client.list_properties_of_secrets():\n                secret_names.append(secret_properties.name)\n            logger.info(f\"Found {len(secret_names)} secrets\")\n            return secret_names\n        except ClientAuthenticationError as e:\n            logger.error(f\"Authentication failed while listing secrets: {str(e)}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Error listing secrets: {str(e)}\")\n            raise\n\n\nasync def retrieve_secrets(\n    vault_url: str,\n    secret_names: List[str],\n    timeout: int = 30\n) -> Dict[str, Dict]:\n    \"\"\"\n    Main function to retrieve secrets from Azure Key Vault.\n    \n    Args:\n        vault_url: The URL of the Azure Key Vault\n        secret_names: List of secret names to retrieve\n        timeout: Timeout in seconds for the operation\n        \n    Returns:\n        Dictionary mapping secret names to their details\n        \n    Raises:\n        ClientAuthenticationError: If authentication fails\n        asyncio.TimeoutError: If operation times out\n    \"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            async with AzureKeyVaultClient(vault_url) as kv_client:\n                secrets = await kv_client.get_secrets_parallel(secret_names)\n                return secrets\n    except asyncio.TimeoutError:\n        logger.error(f\"Operation timed out after {timeout} seconds\")\n        raise\n    except ClientAuthenticationError as e:\n        logger.error(f\"Authentication failed: {str(e)}\")\n        logger.error(\"Please ensure you have proper Azure credentials configured:\")\n        logger.error(\"  - Azure CLI: Run 'az login'\")\n        logger.error(\"  - Managed Identity: Ensure it's properly configured\")\n        logger.error(\"  - Service Principal: Set AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET\")\n        logger.error(\"  - Visual Studio: Sign in through Visual Studio\")\n        raise\n    except ServiceRequestError as e:\n        logger.error(f\"Network error: {str(e)}\")\n        raise\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\")\n        raise\n\n\nasync def main():\n    \"\"\"\n    Example usage of the Azure Key Vault secret retrieval.\n    \"\"\"\n    # Configuration\n    VAULT_URL = \"https://your-keyvault-name.vault.azure.net/\"\n    SECRET_NAMES = [\n        \"database-password\",\n        \"api-key\",\n        \"connection-string\",\n        \"storage-account-key\"\n    ]\n    \n    try:\n        logger.info(\"Starting Azure Key Vault secret retrieval\")\n        \n        # Retrieve secrets\n        secrets = await retrieve_secrets(VAULT_URL, SECRET_NAMES)\n        \n        # Display results\n        print(\"\\n\" + \"=\"*60)\n        print(\"SECRETS RETRIEVAL RESULTS\")\n        print(\"=\"*60)\n        \n        for secret_name, secret_data in secrets.items():\n            print(f\"\\nSecret: {secret_name}\")\n            if secret_data.get(\"error\"):\n                print(f\"  Status: FAILED\")\n                print(f\"  Error: {secret_data['error']}\")\n            else:\n                print(f\"  Status: SUCCESS\")\n                print(f\"  Value: {'*' * 10} (hidden)\")\n                print(f\"  Enabled: {secret_data.get('enabled')}\")\n                print(f\"  Created: {secret_data.get('created_on')}\")\n                print(f\"  Updated: {secret_data.get('updated_on')}\")\n        \n        print(\"\\n\" + \"=\"*60)\n        \n        # Example: List all secrets in the vault\n        print(\"\\nListing all secrets in Key Vault...\")\n        async with AzureKeyVaultClient(VAULT_URL) as kv_client:\n            all_secret_names = await kv_client.list_all_secrets()\n            print(f\"Total secrets found: {len(all_secret_names)}\")\n            for name in all_secret_names[:10]:  # Show first 10\n                print(f\"  - {name}\")\n            if len(all_secret_names) > 10:\n                print(f\"  ... and {len(all_secret_names) - 10} more\")\n        \n    except ClientAuthenticationError:\n        print(\"\\n\u274c Authentication failed. Please check your Azure credentials.\")\n        return 1\n    except asyncio.TimeoutError:\n        print(\"\\n\u274c Operation timed out.\")\n        return 1\n    except Exception as e:\n        print(f\"\\n\u274c An error occurred: {str(e)}\")\n        return 1\n    \n    print(\"\\n\u2705 Secret retrieval completed successfully\")\n    return 0\n\n\n# Synchronous wrapper for easier usage\ndef get_secrets_sync(vault_url: str, secret_names: List[str]) -> Dict[str, Dict]:\n    \"\"\"\n    Synchronous wrapper for retrieving secrets.\n    \n    Args:\n        vault_url: The URL of the Azure Key Vault\n        secret_names: List of secret names to retrieve\n        \n    Returns:\n        Dictionary mapping secret names to their details\n    \"\"\"\n    return asyncio.run(retrieve_secrets(vault_url, secret_names))\n\n\nif __name__ == \"__main__\":\n    # Run the async main function\n    exit_code = asyncio.run(main())\n    exit(exit_code)\n```\n\nThis script provides a comprehensive solution for retrieving secrets from Azure Key Vault with the following features:\n\n## Key Features:\n\n1. **Async/Await Pattern**: Uses asyncio for parallel secret retrieval\n2. **DefaultAzureCredential**: Supports multiple authentication methods (Azure CLI, Managed Identity, Service Principal, etc.)\n3. **Proper Error Handling**: Catches and handles authentication, network, and resource errors\n4. **Context Managers**: Ensures proper cleanup of resources\n5. **Parallel Processing**: Retrieves multiple secrets concurrently using `asyncio.gather()`\n6. **Comprehensive Logging**: Detailed logging for debugging and monitoring\n7. **Timeout Support**: Prevents hanging operations\n8. **Flexible API**: Both async and sync interfaces available\n\n## Installation:\n\n```bash\npip install azure-identity azure-keyvault-secrets\n```\n\n## Authentication Setup:\n\nThe script supports multiple authentication methods through DefaultAzureCredential:\n- **Azure CLI**: `az login`\n- **Managed Identity**: Automatic in Azure services\n- **Service Principal**: Environment variables (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET)\n- **Visual Studio**: Sign in through VS",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 82,
            "output_tokens": 2878,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secret Retrieval with Parallel Processing\n\nI'll create a comprehensive Python script that demonstrates Azure authentication and parallel secret retrieval from Key Vault.\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Key Vault Secret Retrieval Script\nDemonstrates DefaultAzureCredential usage and parallel secret retrieval\n\"\"\"\n\nimport asyncio\nimport sys\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.identity.aio import DefaultAzureCredential as AsyncDefaultAzureCredential\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.keyvault.secrets.aio import SecretClient as AsyncSecretClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError,\n)\n\n\n@dataclass\nclass SecretResult:\n    \"\"\"Result of a secret retrieval operation\"\"\"\n    name: str\n    value: Optional[str] = None\n    error: Optional[str] = None\n    success: bool = False\n\n\nclass KeyVaultSecretRetriever:\n    \"\"\"\n    Handles authentication and secret retrieval from Azure Key Vault\n    \"\"\"\n\n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the Key Vault client with DefaultAzureCredential\n        \n        Args:\n            vault_url: The URL of the Azure Key Vault (e.g., https://myvault.vault.azure.net)\n        \"\"\"\n        if not vault_url:\n            raise ValueError(\"vault_url cannot be empty\")\n        \n        if not vault_url.startswith(\"https://\"):\n            raise ValueError(\"vault_url must start with https://\")\n        \n        self.vault_url = vault_url\n        self.credential = None\n        self.async_credential = None\n\n    async def retrieve_secrets_parallel(\n        self, \n        secret_names: List[str]\n    ) -> Dict[str, SecretResult]:\n        \"\"\"\n        Retrieve multiple secrets from Key Vault in parallel using asyncio\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            \n        Returns:\n            Dictionary mapping secret names to SecretResult objects\n            \n        Raises:\n            ClientAuthenticationError: If authentication fails\n            ValueError: If secret_names is empty\n        \"\"\"\n        if not secret_names:\n            raise ValueError(\"secret_names cannot be empty\")\n        \n        # Remove duplicates while preserving order\n        secret_names = list(dict.fromkeys(secret_names))\n        \n        print(f\"\ud83d\udd10 Authenticating with Azure using DefaultAzureCredential...\")\n        \n        try:\n            # Create async credential\n            self.async_credential = AsyncDefaultAzureCredential()\n            \n            # Create async Key Vault client\n            async with AsyncSecretClient(\n                vault_url=self.vault_url,\n                credential=self.async_credential\n            ) as client:\n                print(f\"\u2705 Successfully authenticated to Key Vault: {self.vault_url}\")\n                print(f\"\ud83d\udccb Retrieving {len(secret_names)} secrets in parallel...\")\n                \n                # Create tasks for parallel retrieval\n                tasks = [\n                    self._retrieve_single_secret(client, name)\n                    for name in secret_names\n                ]\n                \n                # Execute all tasks in parallel\n                results = await asyncio.gather(*tasks, return_exceptions=True)\n                \n                # Build results dictionary\n                results_dict = {}\n                for secret_name, result in zip(secret_names, results):\n                    if isinstance(result, Exception):\n                        results_dict[secret_name] = SecretResult(\n                            name=secret_name,\n                            error=str(result),\n                            success=False\n                        )\n                    else:\n                        results_dict[secret_name] = result\n                \n                return results_dict\n                \n        except ClientAuthenticationError as e:\n            print(f\"\u274c Authentication failed: {e.message}\")\n            raise\n        except Exception as e:\n            print(f\"\u274c Unexpected error: {str(e)}\")\n            raise\n        finally:\n            # Clean up credential\n            if self.async_credential:\n                await self.async_credential.close()\n\n    async def _retrieve_single_secret(\n        self,\n        client: AsyncSecretClient,\n        secret_name: str\n    ) -> SecretResult:\n        \"\"\"\n        Retrieve a single secret from Key Vault\n        \n        Args:\n            client: Async SecretClient instance\n            secret_name: Name of the secret to retrieve\n            \n        Returns:\n            SecretResult object with the secret value or error\n        \"\"\"\n        try:\n            print(f\"  \ud83d\udd0d Retrieving secret: {secret_name}\")\n            secret = await client.get_secret(secret_name)\n            print(f\"  \u2705 Successfully retrieved: {secret_name}\")\n            \n            return SecretResult(\n                name=secret_name,\n                value=secret.value,\n                success=True\n            )\n            \n        except ResourceNotFoundError:\n            error_msg = f\"Secret '{secret_name}' not found in Key Vault\"\n            print(f\"  \u26a0\ufe0f  {error_msg}\")\n            return SecretResult(\n                name=secret_name,\n                error=error_msg,\n                success=False\n            )\n            \n        except ClientAuthenticationError as e:\n            error_msg = f\"Authentication error for '{secret_name}': {e.message}\"\n            print(f\"  \u274c {error_msg}\")\n            return SecretResult(\n                name=secret_name,\n                error=error_msg,\n                success=False\n            )\n            \n        except HttpResponseError as e:\n            error_msg = f\"HTTP error for '{secret_name}': {e.message}\"\n            print(f\"  \u274c {error_msg}\")\n            return SecretResult(\n                name=secret_name,\n                error=error_msg,\n                success=False\n            )\n            \n        except Exception as e:\n            error_msg = f\"Unexpected error for '{secret_name}': {str(e)}\"\n            print(f\"  \u274c {error_msg}\")\n            return SecretResult(\n                name=secret_name,\n                error=error_msg,\n                success=False\n            )\n\n    def retrieve_secrets_sync(\n        self,\n        secret_names: List[str]\n    ) -> Dict[str, SecretResult]:\n        \"\"\"\n        Synchronous version of secret retrieval (for comparison)\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            \n        Returns:\n            Dictionary mapping secret names to SecretResult objects\n        \"\"\"\n        if not secret_names:\n            raise ValueError(\"secret_names cannot be empty\")\n        \n        print(f\"\ud83d\udd10 Authenticating with Azure using DefaultAzureCredential (sync)...\")\n        \n        try:\n            # Create sync credential\n            self.credential = DefaultAzureCredential()\n            \n            # Create sync Key Vault client\n            client = SecretClient(\n                vault_url=self.vault_url,\n                credential=self.credential\n            )\n            \n            print(f\"\u2705 Successfully authenticated to Key Vault: {self.vault_url}\")\n            print(f\"\ud83d\udccb Retrieving {len(secret_names)} secrets sequentially...\")\n            \n            results_dict = {}\n            for secret_name in secret_names:\n                try:\n                    print(f\"  \ud83d\udd0d Retrieving secret: {secret_name}\")\n                    secret = client.get_secret(secret_name)\n                    print(f\"  \u2705 Successfully retrieved: {secret_name}\")\n                    \n                    results_dict[secret_name] = SecretResult(\n                        name=secret_name,\n                        value=secret.value,\n                        success=True\n                    )\n                    \n                except ResourceNotFoundError:\n                    error_msg = f\"Secret '{secret_name}' not found in Key Vault\"\n                    print(f\"  \u26a0\ufe0f  {error_msg}\")\n                    results_dict[secret_name] = SecretResult(\n                        name=secret_name,\n                        error=error_msg,\n                        success=False\n                    )\n                    \n                except Exception as e:\n                    error_msg = f\"Error retrieving '{secret_name}': {str(e)}\"\n                    print(f\"  \u274c {error_msg}\")\n                    results_dict[secret_name] = SecretResult(\n                        name=secret_name,\n                        error=error_msg,\n                        success=False\n                    )\n            \n            return results_dict\n            \n        except ClientAuthenticationError as e:\n            print(f\"\u274c Authentication failed: {e.message}\")\n            raise\n        finally:\n            # Clean up credential\n            if self.credential:\n                self.credential.close()\n\n\ndef print_results(results: Dict[str, SecretResult]) -> None:\n    \"\"\"\n    Pretty print the results of secret retrieval\n    \n    Args:\n        results: Dictionary of secret results\n    \"\"\"\n    print(\"\\n\" + \"=\"*80)\n    print(\"\ud83d\udcca RETRIEVAL RESULTS\")\n    print(\"=\"*80)\n    \n    successful = sum(1 for r in results.values() if r.success)\n    failed = len(results) - successful\n    \n    print(f\"\\n\u2705 Successful: {successful}\")\n    print(f\"\u274c Failed: {failed}\")\n    print(f\"\ud83d\udcdd Total: {len(results)}\")\n    \n    print(\"\\n\" + \"-\"*80)\n    print(\"DETAILS:\")\n    print(\"-\"*80)\n    \n    for secret_name, result in results.items():\n        if result.success:\n            # Mask the secret value for security\n            masked_value = result.value[:4] + \"...\" if result.value else \"None\"\n            print(f\"\\n\u2705 {secret_name}\")\n            print(f\"   Value: {masked_value} (length: {len(result.value) if result.value else 0})\")\n        else:\n            print(f\"\\n\u274c {secret_name}\")\n            print(f\"   Error: {result.error}\")\n    \n    print(\"\\n\" + \"=\"*80)\n\n\nasync def main():\n    \"\"\"\n    Main function demonstrating the Key Vault secret retrieval\n    \"\"\"\n    # Configuration\n    VAULT_URL = \"https://myvault.vault.azure.net\"\n    SECRET_NAMES = [\n        \"database-connection-string\",\n        \"api-key\",\n        \"storage-account-key\",\n        \"non-existent-secret\",  # This will fail\n    ]\n    \n    print(\"=\"*80)\n    print(\"\ud83d\udd11 Azure Key Vault Secret Retrieval Demo\")\n    print(\"=\"*80)\n    print(f\"\\nVault URL: {VAULT_URL}\")\n    print(f\"Secrets to retrieve: {', '.join(SECRET_NAMES)}\")\n    print()\n    \n    try:\n        # Initialize retriever\n        retriever = KeyVaultSecretRetriever(vault_url=VAULT_URL)\n        \n        # Retrieve secrets in parallel\n        print(\"\\n\" + \"=\"*80)\n        print(\"\ud83d\ude80 PARALLEL RETRIEVAL (Async)\")\n        print(\"=\"*80 + \"\\n\")\n        \n        import time\n        start_time = time.time()\n        \n        results = await retriever.retrieve_secrets_parallel(SECRET_NAMES)\n        \n        elapsed_time = time.time() - start_time\n        print(f\"\\n\u23f1\ufe0f  Parallel retrieval completed in {elapsed_time:.2f} seconds\")\n        \n        # Print results\n        print_results(results)\n        \n        # Access individual secrets\n        print(\"\\n\" + \"=\"*80)\n        print(\"\ud83d\udca1 ACCESSING INDIVIDUAL SECRETS\")\n        print(\"=\"*80 + \"\\n\")\n        \n        for secret_name, result in results.items():\n            if result.success:\n                print(f\"Secret '{secret_name}' can be used in your application\")\n                # In real application: connection_string = result.value\n            else:\n                print(f\"Failed to retrieve '{secret_name}': {result.error}\")\n        \n    except ClientAuthenticationError as e:\n        print(f\"\\n\u274c AUTHENTICATION FAILED\")\n        print(f\"Error: {e.message}\")\n        print(\"\\nPossible causes:\")\n        print(\"  1. Not logged in to Azure CLI (run: az login)\")\n        print(\"  2. No managed identity assigned (if running in Azure)\")\n        print(\"  3. Missing environment variables (AZURE_CLIENT_ID, AZURE_TENANT_ID, etc.)\")\n        print(\"  4. Insufficient permissions to access Key Vault\")\n        sys.exit(1)\n        \n    except ValueError as e:\n        print(f\"\\n\u274c CONFIGURATION ERROR\")\n        print(f\"Error: {str(e)}\")\n        sys.exit(1)\n        \n    except Exception as e:\n        print(f\"\\n\u274c UNEXPECTED ERROR\")\n        print(f\"Error: {str(e)}\")\n        sys.exit(1)\n\n\ndef demo_sync_retrieval():\n    \"\"\"\n    Demonstration of synchronous retrieval (for comparison)\n    \"\"\"\n    VAULT_URL = \"https://myvault.vault.azure.net\"\n    SECRET_NAMES = [\"database-connection-string\", \"api-key\"]\n    \n    print(\"\\n\" + \"=\"*80)\n    print(\"\ud83d\udc0c SYNCHRONOUS RETRIEVAL (Sync)\")\n    print(\"=\"*80 + \"\\n\")\n    \n    import time\n    start_time = time.time()\n    \n    try:\n        retriever = KeyVaultSecretRetriever(vault_url=VAULT_URL)\n        results = retriever.retrieve_secrets_sync(SECRET_NAMES)\n        \n        elapsed_time = time.time() - start_time\n        print(f\"\\n\u23f1\ufe0f  Synchronous retrieval completed in {elapsed_time:.2f} seconds\")\n        \n        print_results(results)\n        \n    except Exception as e:\n        print(f\"Error: {str(e)}\")\n\n\nif __name__ == \"__main__\":\n    print(\"\"\"\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                                                                              \u2551\n\u2551                   Azure Key Vault Secret Retrieval Script                   \u2551\n\u2551                                                                              \u2551\n\u2551  This script demonstrates:                                                  \u2551\n\u2551  \u2022 DefaultAzureCredential for authentication                                \u2551\n\u2551  \u2022 Parallel secret retrieval using asyncio                                  \u2551\n\u2551  \u2022 Proper error handling for authentication failures                        \u2551\n\u2551  \u2022 Resource cleanup and credential management                               \u2551\n\u2551                                                                              \u2551\n\u2551  Prerequisites:                                                             \u2551\n\u2551  \u2022 pip install azure-identity azure-keyvault-secrets                        \u2551\n\u2551  \u2022 Azure authentication configured (az login, managed identity, etc.)       \u2551\n\u2551  \u2022 Access permissions to the Key Vault                                      \u2551\n\u2551                                                                              \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \"\"\")\n    \n    # Run async main\n    asyncio.run(main())\n    \n    # Optionally run sync comparison\n    # demo_sync_retrieval()\n```\n\n## Installation Requirements\n\n```bash\n# requirements.txt\nazure-identity>=1.19.0\nazure-keyvault-secrets>=4.9.0\n```\n\nInstall dependencies:\n```bash\npip install -r requirements.txt\n```\n\n## Environment Setup\n\n### Option 1: Azure CLI (Development)\n```bash\naz login\n```\n\n### Option 2: Service Principal (Production)\n```bash\nexport AZURE_CLIENT_ID=\"<client-id>\"\nexport AZURE_TENANT_ID=\"<tenant-id>\"\nexport AZURE_CLIENT_SECRET=\"<client-secret>\"\n```\n\n### Option 3: Managed Identity (Azure-hosted)\nNo configuration needed - automatically detected when running in Azure.\n\n## Usage Examples\n\n### Basic Usage\n```python\nimport asyncio\nfrom key_vault_retriever import KeyVaultSecretRetriever\n\nasync def example():\n    retriever = KeyVaultSecretRetriever(\n        vault_url=\"https://myvault.vault.azure.net\"\n    )\n    \n    results = await retriever.retrieve_secrets_parallel([\n        \"database-password\",\n        \"api-key\",\n        \"storage-connection-string\"\n    ])\n    \n    # Access successful secrets\n    for name, result in results.items():\n        if result.success:\n            print(f",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5418,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Python script that authenticates with Azure and retrieves secrets from Key Vault using best practices from the azure-identity documentation.\n\n```python\n\"\"\"Azure Key Vault secret retrieval with DefaultAzureCredential.\"\"\"\nimport asyncio\nimport logging\nfrom typing import Dict, List\nfrom azure.identity.aio import DefaultAzureCredential\nfrom azure.keyvault.secrets.aio import SecretClient\nfrom azure.core.exceptions import (\n    ClientAuthenticationError,\n    ResourceNotFoundError,\n    HttpResponseError\n)\n\nlogger = logging.getLogger(__name__)\n\n\nclass KeyVaultSecretRetriever:\n    \"\"\"Retrieves secrets from Azure Key Vault using DefaultAzureCredential.\"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the secret retriever.\n        \n        Args:\n            vault_url: Azure Key Vault URL (e.g., https://myvault.vault.azure.net)\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=vault_url, credential=self.credential)\n    \n    async def get_secret(self, secret_name: str) -> tuple[str, str | None]:\n        \"\"\"\n        Retrieve a single secret from Key Vault.\n        \n        Args:\n            secret_name: Name of the secret to retrieve\n            \n        Returns:\n            Tuple of (secret_name, secret_value) or (secret_name, None) if error\n        \"\"\"\n        try:\n            secret = await self.client.get_secret(secret_name)\n            logger.info(f\"Successfully retrieved secret: {secret_name}\")\n            return (secret_name, secret.value)\n        except ResourceNotFoundError:\n            logger.warning(f\"Secret not found: {secret_name}\")\n            return (secret_name, None)\n        except ClientAuthenticationError as e:\n            logger.error(f\"Authentication failed for secret {secret_name}: {e}\")\n            return (secret_name, None)\n        except HttpResponseError as e:\n            logger.error(f\"HTTP error retrieving secret {secret_name}: {e}\")\n            return (secret_name, None)\n        except Exception as e:\n            logger.error(f\"Unexpected error retrieving secret {secret_name}: {e}\")\n            return (secret_name, None)\n    \n    async def get_secrets(self, secret_names: List[str]) -> Dict[str, str | None]:\n        \"\"\"\n        Retrieve multiple secrets from Key Vault in parallel.\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            \n        Returns:\n            Dictionary mapping secret names to their values (or None if retrieval failed)\n        \"\"\"\n        if not secret_names:\n            logger.warning(\"No secret names provided\")\n            return {}\n        \n        logger.info(f\"Retrieving {len(secret_names)} secrets from {self.vault_url}\")\n        \n        # Retrieve all secrets in parallel\n        tasks = [self.get_secret(name) for name in secret_names]\n        results = await asyncio.gather(*tasks, return_exceptions=False)\n        \n        # Convert results to dictionary\n        secrets_dict = dict(results)\n        \n        successful = sum(1 for v in secrets_dict.values() if v is not None)\n        logger.info(f\"Successfully retrieved {successful}/{len(secret_names)} secrets\")\n        \n        return secrets_dict\n    \n    async def close(self):\n        \"\"\"Close the credential and client connections.\"\"\"\n        await self.client.close()\n        await self.credential.close()\n    \n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        await self.close()\n\n\nasync def retrieve_secrets(\n    vault_url: str,\n    secret_names: List[str]\n) -> Dict[str, str | None]:\n    \"\"\"\n    Retrieve secrets from Azure Key Vault.\n    \n    Args:\n        vault_url: Azure Key Vault URL (e.g., https://myvault.vault.azure.net)\n        secret_names: List of secret names to retrieve\n        \n    Returns:\n        Dictionary mapping secret names to their values (or None if retrieval failed)\n        \n    Raises:\n        ClientAuthenticationError: If authentication with Azure fails\n        ValueError: If vault_url is invalid\n    \"\"\"\n    if not vault_url:\n        raise ValueError(\"vault_url cannot be empty\")\n    \n    if not vault_url.startswith(\"https://\"):\n        raise ValueError(\"vault_url must start with https://\")\n    \n    try:\n        async with KeyVaultSecretRetriever(vault_url) as retriever:\n            return await retriever.get_secrets(secret_names)\n    except ClientAuthenticationError as e:\n        logger.error(f\"Authentication failed: {e}\")\n        raise\n    except Exception as e:\n        logger.error(f\"Failed to retrieve secrets: {e}\")\n        raise\n\n\nasync def main():\n    \"\"\"Example usage of the secret retriever.\"\"\"\n    # Configure logging\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n    \n    # Example configuration\n    vault_url = \"https://myvault.vault.azure.net\"\n    secret_names = [\n        \"database-connection-string\",\n        \"api-key\",\n        \"storage-account-key\",\n        \"non-existent-secret\"  # This will return None\n    ]\n    \n    try:\n        secrets = await retrieve_secrets(vault_url, secret_names)\n        \n        print(\"\\nRetrieved secrets:\")\n        for name, value in secrets.items():\n            if value is not None:\n                # Don't print actual secret values in production!\n                print(f\"  {name}: {'*' * 10} (length: {len(value)})\")\n            else:\n                print(f\"  {name}: FAILED TO RETRIEVE\")\n                \n    except ClientAuthenticationError:\n        print(\"\\nAuthentication failed. Please ensure:\")\n        print(\"  1. You're logged in with Azure CLI (az login)\")\n        print(\"  2. Or have AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET set\")\n        print(\"  3. Or running in Azure with managed identity enabled\")\n    except ValueError as e:\n        print(f\"\\nConfiguration error: {e}\")\n    except Exception as e:\n        print(f\"\\nUnexpected error: {e}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\nThis script includes:\n\n1. **DefaultAzureCredential** - Uses the recommended credential chain for dev-to-prod scenarios\n2. **Async/await** - Properly uses async Azure SDK clients\n3. **Parallel retrieval** - Uses `asyncio.gather()` to fetch multiple secrets concurrently\n4. **Error handling** - Catches `ClientAuthenticationError`, `ResourceNotFoundError`, and other exceptions\n5. **Context manager** - Properly closes credential and client connections\n6. **Logging** - Comprehensive logging for debugging\n7. **Type hints** - Full type annotations for better IDE support\n\n**Usage:**\n\n```bash\n# Install dependencies\npip install azure-identity azure-keyvault-secrets\n\n# Run with Azure CLI authentication\naz login\npython script.py\n\n# Or set environment variables for service principal\nexport AZURE_CLIENT_ID=\"<client-id>\"\nexport AZURE_TENANT_ID=\"<tenant-id>\"\nexport AZURE_CLIENT_SECRET=\"<client-secret>\"\npython script.py\n```\n\nThe script follows Azure Identity SDK best practices:\n- Reuses credential instances\n- Uses async clients for better performance\n- Handles authentication failures gracefully\n- Retrieves secrets in parallel for efficiency",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5944,
            "output_tokens": 1926,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-identity-dotnet-03",
      "task_type": "similar_syntax",
      "target_language": "java",
      "expected_patterns": [
        "import com\\.azure\\.identity",
        "import com\\.azure\\.security\\.keyvault",
        "DefaultAzureCredentialBuilder",
        "@Bean|@RestController|@GetMapping",
        "public class",
        "SecretClient|SecretClientBuilder"
      ],
      "anti_patterns": [
        "using Azure\\.Identity",
        "new DefaultAzureCredential\\(\\)",
        "DefaultAzureCredentialOptions",
        "builder\\.Services",
        "var\\s+credential\\s*=",
        "namespace\\s+"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.defaultazurecredentialbuilder",
          "description": "Azure Identity Java SDK reference - source of DefaultAzureCredentialBuilder and Java credential patterns"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclient",
          "description": "Azure Key Vault Secrets Java SDK reference - source of SecretClient and SecretClientBuilder Java patterns"
        },
        {
          "url": "https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html",
          "description": "Spring Framework request mapping annotations - source of @RestController, @GetMapping for REST endpoints as required by prompt ('expose a REST endpoint')"
        },
        {
          "url": "https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html",
          "description": "Spring Framework @Bean annotation - source of @Bean annotation for bean declarations as required by prompt ('configure a DefaultAzureCredential bean')"
        },
        {
          "url": "https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html",
          "description": "Java class definitions - source of public class keyword for defining Java classes as required for Java Spring Boot service"
        },
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/api/azure.identity.defaultazurecredential",
          "description": "Azure Identity .NET SDK reference - source of anti-pattern new DefaultAzureCredential() and DefaultAzureCredentialOptions C# syntax"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Azure Spring Boot Service with Key Vault Integration\n\nI'll create a complete Spring Boot service with Azure Identity authentication, Key Vault integration, and health checks.\n\n## Project Structure\n\n```\nsrc/main/java/com/example/azureconfig/\n\u251c\u2500\u2500 AzureConfigApplication.java\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 AzureConfig.java\n\u2502   \u2514\u2500\u2500 SecurityConfig.java\n\u251c\u2500\u2500 controller/\n\u2502   \u2514\u2500\u2500 ConfigController.java\n\u251c\u2500\u2500 service/\n\u2502   \u251c\u2500\u2500 KeyVaultService.java\n\u2502   \u2514\u2500\u2500 impl/\n\u2502       \u2514\u2500\u2500 KeyVaultServiceImpl.java\n\u251c\u2500\u2500 model/\n\u2502   \u251c\u2500\u2500 ConfigResponse.java\n\u2502   \u2514\u2500\u2500 HealthStatus.java\n\u2514\u2500\u2500 health/\n    \u2514\u2500\u2500 AzureKeyVaultHealthIndicator.java\n```\n\n## 1. pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.2.0</version>\n        <relativePath/>\n    </parent>\n    \n    <groupId>com.example</groupId>\n    <artifactId>azure-config-service</artifactId>\n    <version>1.0.0</version>\n    <name>Azure Config Service</name>\n    <description>Spring Boot service with Azure Key Vault integration</description>\n    \n    <properties>\n        <java.version>17</java.version>\n        <azure.identity.version>1.11.1</azure.identity.version>\n        <azure.security.keyvault.version>4.7.3</azure.security.keyvault.version>\n    </properties>\n    \n    <dependencies>\n        <!-- Spring Boot Starters -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-validation</artifactId>\n        </dependency>\n        \n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure.identity.version}</version>\n        </dependency>\n        \n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>${azure.security.keyvault.version}</version>\n        </dependency>\n        \n        <!-- Lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        \n        <!-- Micrometer for metrics -->\n        <dependency>\n            <groupId>io.micrometer</groupId>\n            <artifactId>micrometer-registry-prometheus</artifactId>\n        </dependency>\n        \n        <!-- Test Dependencies -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. application.yml\n\n```yaml\nspring:\n  application:\n    name: azure-config-service\n  \nserver:\n  port: 8080\n  shutdown: graceful\n\n# Azure Configuration\nazure:\n  keyvault:\n    url: ${AZURE_KEYVAULT_URL:https://your-keyvault.vault.azure.net/}\n    enabled: ${AZURE_KEYVAULT_ENABLED:true}\n    # Optional: For local development with service principal\n    tenant-id: ${AZURE_TENANT_ID:}\n    client-id: ${AZURE_CLIENT_ID:}\n    client-secret: ${AZURE_CLIENT_SECRET:}\n  \n  # Credential configuration\n  credential:\n    # Timeout for credential acquisition (in seconds)\n    timeout: 30\n    # Retry configuration\n    max-retries: 3\n    retry-delay: 2\n\n# Actuator Configuration\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,prometheus,metrics\n      base-path: /actuator\n  endpoint:\n    health:\n      show-details: always\n      probes:\n        enabled: true\n  health:\n    livenessstate:\n      enabled: true\n    readinessstate:\n      enabled: true\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n\n# Logging\nlogging:\n  level:\n    root: INFO\n    com.example.azureconfig: DEBUG\n    com.azure: INFO\n    com.azure.identity: DEBUG\n  pattern:\n    console: \"%d{yyyy-MM-dd HH:mm:ss} - %msg%n\"\n    file: \"%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\"\n```\n\n## 3. Main Application Class\n\n```java\npackage com.example.azureconfig;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationPropertiesScan;\n\n@SpringBootApplication\n@ConfigurationPropertiesScan\npublic class AzureConfigApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AzureConfigApplication.class, args);\n    }\n}\n```\n\n## 4. Azure Configuration\n\n```java\npackage com.example.azureconfig.config;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.http.policy.HttpLogDetailLevel;\nimport com.azure.core.http.policy.HttpLogOptions;\nimport com.azure.core.util.Configuration;\nimport com.azure.identity.*;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Primary;\n\nimport java.time.Duration;\n\n@org.springframework.context.annotation.Configuration\n@Slf4j\npublic class AzureConfig {\n\n    @Value(\"${azure.keyvault.url}\")\n    private String keyVaultUrl;\n\n    @Value(\"${azure.keyvault.tenant-id:}\")\n    private String tenantId;\n\n    @Value(\"${azure.keyvault.client-id:}\")\n    private String clientId;\n\n    @Value(\"${azure.keyvault.client-secret:}\")\n    private String clientSecret;\n\n    @Value(\"${azure.credential.timeout:30}\")\n    private int credentialTimeout;\n\n    @Value(\"${azure.credential.max-retries:3}\")\n    private int maxRetries;\n\n    /**\n     * Creates a DefaultAzureCredential bean with comprehensive authentication chain.\n     * This credential tries multiple authentication methods in order:\n     * 1. Environment variables\n     * 2. Managed Identity\n     * 3. Azure CLI\n     * 4. IntelliJ\n     * 5. Visual Studio Code\n     * 6. Azure PowerShell\n     */\n    @Bean\n    @Primary\n    public TokenCredential defaultAzureCredential() {\n        log.info(\"Initializing DefaultAzureCredential...\");\n        \n        try {\n            DefaultAzureCredentialBuilder builder = new DefaultAzureCredentialBuilder();\n            \n            // Configure tenant ID if provided\n            if (tenantId != null && !tenantId.isEmpty()) {\n                log.debug(\"Using tenant ID: {}\", tenantId);\n                builder.tenantId(tenantId);\n            }\n            \n            // Set timeout for credential acquisition\n            builder.credentialProcessTimeout(Duration.ofSeconds(credentialTimeout));\n            \n            // Build the credential\n            TokenCredential credential = builder.build();\n            \n            log.info(\"DefaultAzureCredential initialized successfully\");\n            return credential;\n            \n        } catch (Exception e) {\n            log.error(\"Failed to initialize DefaultAzureCredential\", e);\n            throw new RuntimeException(\"Failed to initialize Azure credentials\", e);\n        }\n    }\n\n    /**\n     * Alternative credential using Service Principal (for local development).\n     * Only activated when client credentials are provided.\n     */\n    @Bean\n    @ConditionalOnProperty(name = \"azure.keyvault.client-id\")\n    public TokenCredential clientSecretCredential() {\n        log.info(\"Initializing ClientSecretCredential for service principal authentication\");\n        \n        if (clientId == null || clientSecret == null || tenantId == null) {\n            throw new IllegalStateException(\n                \"Client ID, Client Secret, and Tenant ID must be provided for service principal authentication\"\n            );\n        }\n        \n        return new ClientSecretCredentialBuilder()\n                .clientId(clientId)\n                .clientSecret(clientSecret)\n                .tenantId(tenantId)\n                .build();\n    }\n\n    /**\n     * Creates a SecretClient bean for Azure Key Vault access.\n     */\n    @Bean\n    @ConditionalOnProperty(name = \"azure.keyvault.enabled\", havingValue = \"true\", matchIfMissing = true)\n    public SecretClient secretClient(TokenCredential credential) {\n        log.info(\"Initializing SecretClient for Key Vault: {}\", keyVaultUrl);\n        \n        if (keyVaultUrl == null || keyVaultUrl.isEmpty()) {\n            throw new IllegalStateException(\"Azure Key Vault URL must be configured\");\n        }\n        \n        try {\n            HttpLogOptions logOptions = new HttpLogOptions()\n                    .setLogLevel(HttpLogDetailLevel.BASIC);\n            \n            SecretClient client = new SecretClientBuilder()\n                    .vaultUrl(keyVaultUrl)\n                    .credential(credential)\n                    .httpLogOptions(logOptions)\n                    .buildClient();\n            \n            log.info(\"SecretClient initialized successfully\");\n            return client;\n            \n        } catch (Exception e) {\n            log.error(\"Failed to initialize SecretClient\", e);\n            throw new RuntimeException(\"Failed to initialize Key Vault client\", e);\n        }\n    }\n\n    /**\n     * Managed Identity Credential (for Azure-hosted applications).\n     */\n    @Bean\n    public TokenCredential managedIdentityCredential() {\n        log.info(\"Initializing ManagedIdentityCredential\");\n        \n        ManagedIdentityCredentialBuilder builder = new ManagedIdentityCredentialBuilder();\n        \n        // If client ID is provided, use user-assigned managed identity\n        if (clientId != null && !clientId.isEmpty()) {\n            log.debug(\"Using user-assigned managed identity with client ID: {}\", clientId);\n            builder.clientId(clientId);\n        }\n        \n        return builder.build();\n    }\n\n    /**\n     * Azure CLI Credential (for local development).\n     */\n    @Bean\n    public TokenCredential azureCliCredential() {\n        log.info(\"Initializing AzureCliCredential\");\n        \n        return new AzureCliCredentialBuilder()\n                .tenantId(tenantId != null && !tenantId.isEmpty() ? tenantId : null)\n                .build();\n    }\n}\n```\n\n## 5. Security Configuration\n\n```java\npackage com.example.azureconfig.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.web.SecurityFilterChain;\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authz -> authz\n                .requestMatchers(\"/actuator/**\").permitAll()\n                .requestMatchers(\"/api/config/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .csrf(csrf -> csrf.disable());\n        \n        return http.build();\n    }\n}\n```\n\n## 6. Model Classes\n\n```java\npackage com.example.azureconfig.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.time.LocalDateTime;\nimport java.util.Map;\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class ConfigResponse {\n    private String key;\n    private String value;\n    private LocalDateTime retrievedAt;\n    private String source;\n    private Map<String, String> metadata;\n}\n```\n\n```java\npackage com.example.azureconfig.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.time.LocalDateTime;\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class HealthStatus {\n    private String status;\n    private String message;\n    private LocalDateTime timestamp;\n    private Long responseTimeMs;\n}\n```\n\n## 7. Key Vault Service Interface\n\n```java\npackage com.example.azureconfig.service;\n\nimport com.example.azureconfig.model.ConfigResponse;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface KeyVaultService {\n    \n    /**\n     * Retrieves a secret value from Key Vault.\n     */\n    ConfigResponse getSecret(String secretName);\n    \n    /**\n     * Retrieves multiple secrets from Key Vault.\n     */\n    Map<String, ConfigResponse> getSecrets(List<String> secretNames);\n    \n    /**\n     * Lists all secret names in the Key Vault.\n     */\n    List<String> listSecretNames();\n    \n    /**\n     * Checks if Key Vault is accessible.\n     */\n    boolean isHealthy();\n    \n    /**\n     * Gets the Key Vault URL.\n     */\n    String getKeyVaultUrl();\n}\n```\n\n## 8. Key Vault Service Implementation\n\n```java\npackage com.example.azureconfig.service.impl;\n\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.example.azureconfig.model.ConfigResponse;\nimport com.example.azureconfig.service.KeyVaultService;\nimport io.micrometer.core.instrument.Counter;\nimport io.micrometer.core.instrument.MeterRegistry;\nimport io.micrometer.core.instrument.Timer;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Identity Spring Boot Service\n\nI'll create a comprehensive Spring Boot service that uses Azure Identity for authentication with Azure Key Vault.\n\n## Project Structure\n\n```\nazure-identity-service/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/main/\n\u2502   \u251c\u2500\u2500 java/com/example/azure/\n\u2502   \u2502   \u251c\u2500\u2500 AzureIdentityServiceApplication.java\n\u2502   \u2502   \u251c\u2500\u2500 config/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AzureConfiguration.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SecurityConfiguration.java\n\u2502   \u2502   \u251c\u2500\u2500 controller/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ConfigController.java\n\u2502   \u2502   \u251c\u2500\u2500 service/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 KeyVaultService.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 impl/KeyVaultServiceImpl.java\n\u2502   \u2502   \u251c\u2500\u2500 model/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ConfigResponse.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 HealthStatus.java\n\u2502   \u2502   \u251c\u2500\u2500 health/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 AzureKeyVaultHealthIndicator.java\n\u2502   \u2502   \u2514\u2500\u2500 exception/\n\u2502   \u2502       \u251c\u2500\u2500 GlobalExceptionHandler.java\n\u2502   \u2502       \u2514\u2500\u2500 KeyVaultException.java\n\u2502   \u2514\u2500\u2500 resources/\n\u2502       \u251c\u2500\u2500 application.yml\n\u2502       \u2514\u2500\u2500 application-prod.yml\n\u2514\u2500\u2500 README.md\n```\n\n## 1. pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.2.1</version>\n        <relativePath/>\n    </parent>\n    \n    <groupId>com.example</groupId>\n    <artifactId>azure-identity-service</artifactId>\n    <version>1.0.0</version>\n    <name>Azure Identity Service</name>\n    <description>Spring Boot service with Azure Identity authentication</description>\n    \n    <properties>\n        <java.version>17</java.version>\n        <azure.identity.version>1.13.2</azure.identity.version>\n        <azure.security.keyvault.version>4.8.5</azure.security.keyvault.version>\n        <azure.core.version>1.51.0</azure.core.version>\n    </properties>\n    \n    <dependencies>\n        <!-- Spring Boot Starters -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-validation</artifactId>\n        </dependency>\n        \n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure.identity.version}</version>\n        </dependency>\n        \n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>${azure.security.keyvault.version}</version>\n        </dependency>\n        \n        <!-- Azure Core -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n            <version>${azure.core.version}</version>\n        </dependency>\n        \n        <!-- Lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        \n        <!-- Micrometer for metrics -->\n        <dependency>\n            <groupId>io.micrometer</groupId>\n            <artifactId>micrometer-registry-prometheus</artifactId>\n        </dependency>\n        \n        <!-- Testing -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.mockito</groupId>\n            <artifactId>mockito-inline</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Application Configuration\n\n### application.yml\n\n```yaml\nspring:\n  application:\n    name: azure-identity-service\n  profiles:\n    active: ${SPRING_PROFILES_ACTIVE:dev}\n\nserver:\n  port: 8080\n  shutdown: graceful\n\n# Azure Configuration\nazure:\n  keyvault:\n    # Key Vault URL - can be overridden by environment variable\n    url: ${AZURE_KEYVAULT_URL:https://your-keyvault.vault.azure.net}\n    # Timeout for Key Vault operations\n    timeout-seconds: 30\n    # Retry configuration\n    retry:\n      max-retries: 3\n      delay-seconds: 1\n  identity:\n    # Credential configuration\n    credential-type: ${AZURE_CREDENTIAL_TYPE:default}\n    # For user-assigned managed identity\n    managed-identity-client-id: ${AZURE_CLIENT_ID:}\n    # Tenant ID (optional)\n    tenant-id: ${AZURE_TENANT_ID:}\n\n# Actuator Configuration\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics,prometheus\n      base-path: /actuator\n  endpoint:\n    health:\n      show-details: when-authorized\n      probes:\n        enabled: true\n  health:\n    defaults:\n      enabled: true\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n\n# Logging Configuration\nlogging:\n  level:\n    root: INFO\n    com.example.azure: DEBUG\n    com.azure: INFO\n    com.azure.identity: DEBUG\n    com.azure.security.keyvault: DEBUG\n  pattern:\n    console: \"%d{yyyy-MM-dd HH:mm:ss} - %msg%n\"\n    file: \"%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\"\n```\n\n### application-prod.yml\n\n```yaml\nspring:\n  profiles:\n    active: prod\n\nazure:\n  identity:\n    # Use managed identity in production\n    credential-type: managed\n\nlogging:\n  level:\n    root: WARN\n    com.example.azure: INFO\n    com.azure.identity: INFO\n    com.azure.security.keyvault: INFO\n\nmanagement:\n  endpoint:\n    health:\n      show-details: never\n```\n\n## 3. Main Application Class\n\n### AzureIdentityServiceApplication.java\n\n```java\npackage com.example.azure;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationPropertiesScan;\n\n/**\n * Main Spring Boot application class for Azure Identity Service.\n * \n * This service demonstrates authentication with Azure services using\n * the Azure Identity client library for Java.\n */\n@SpringBootApplication\n@ConfigurationPropertiesScan\npublic class AzureIdentityServiceApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AzureIdentityServiceApplication.class, args);\n    }\n}\n```\n\n## 4. Azure Configuration\n\n### AzureConfiguration.java\n\n```java\npackage com.example.azure.config;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.http.policy.HttpLogDetailLevel;\nimport com.azure.core.http.policy.HttpLogOptions;\nimport com.azure.core.http.policy.RetryPolicy;\nimport com.azure.core.util.Configuration;\nimport com.azure.identity.*;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Profile;\n\nimport java.time.Duration;\n\n/**\n * Azure configuration class that sets up Azure Identity credentials\n * and Azure service clients.\n */\n@org.springframework.context.annotation.Configuration\n@ConfigurationProperties(prefix = \"azure\")\n@Slf4j\npublic class AzureConfiguration {\n\n    @Value(\"${azure.keyvault.url}\")\n    private String keyVaultUrl;\n\n    @Value(\"${azure.keyvault.timeout-seconds:30}\")\n    private int timeoutSeconds;\n\n    @Value(\"${azure.keyvault.retry.max-retries:3}\")\n    private int maxRetries;\n\n    @Value(\"${azure.identity.credential-type:default}\")\n    private String credentialType;\n\n    @Value(\"${azure.identity.managed-identity-client-id:}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.identity.tenant-id:}\")\n    private String tenantId;\n\n    /**\n     * Creates a DefaultAzureCredential bean for development and testing.\n     * This credential tries multiple authentication methods in order:\n     * 1. EnvironmentCredential\n     * 2. WorkloadIdentityCredential\n     * 3. ManagedIdentityCredential\n     * 4. AzureCliCredential\n     * 5. AzurePowerShellCredential\n     * 6. IntelliJCredential\n     * \n     * @return DefaultAzureCredential instance\n     */\n    @Bean\n    @Profile(\"!prod\")\n    public TokenCredential defaultAzureCredential() {\n        log.info(\"Creating DefaultAzureCredential for development environment\");\n        \n        DefaultAzureCredentialBuilder builder = new DefaultAzureCredentialBuilder();\n        \n        if (tenantId != null && !tenantId.isEmpty()) {\n            builder.tenantId(tenantId);\n            log.debug(\"Configured tenant ID: {}\", tenantId);\n        }\n        \n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            builder.managedIdentityClientId(managedIdentityClientId);\n            log.debug(\"Configured managed identity client ID: {}\", managedIdentityClientId);\n        }\n        \n        DefaultAzureCredential credential = builder.build();\n        log.info(\"DefaultAzureCredential created successfully\");\n        \n        return credential;\n    }\n\n    /**\n     * Creates a ManagedIdentityCredential bean for production.\n     * Uses system-assigned or user-assigned managed identity.\n     * \n     * @return ManagedIdentityCredential instance\n     */\n    @Bean\n    @Profile(\"prod\")\n    public TokenCredential managedIdentityCredential() {\n        log.info(\"Creating ManagedIdentityCredential for production environment\");\n        \n        ManagedIdentityCredentialBuilder builder = new ManagedIdentityCredentialBuilder();\n        \n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            builder.clientId(managedIdentityClientId);\n            log.info(\"Using user-assigned managed identity: {}\", managedIdentityClientId);\n        } else {\n            log.info(\"Using system-assigned managed identity\");\n        }\n        \n        ManagedIdentityCredential credential = builder.build();\n        log.info(\"ManagedIdentityCredential created successfully\");\n        \n        return credential;\n    }\n\n    /**\n     * Creates a SecretClient bean for accessing Azure Key Vault.\n     * \n     * @param credential TokenCredential for authentication\n     * @return SecretClient instance\n     */\n    @Bean\n    public SecretClient secretClient(TokenCredential credential) {\n        log.info(\"Creating SecretClient for Key Vault: {}\", keyVaultUrl);\n        \n        HttpLogOptions logOptions = new HttpLogOptions()\n            .setLogLevel(HttpLogDetailLevel.BASIC)\n            .setPrettyPrintBody(true);\n        \n        SecretClient client = new SecretClientBuilder()\n            .vaultUrl(keyVaultUrl)\n            .credential(credential)\n            .httpLogOptions(logOptions)\n            .buildClient();\n        \n        log.info(\"SecretClient created successfully\");\n        return client;\n    }\n\n    /**\n     * Alternative credential configuration based on credential type.\n     * Demonstrates how to create specific credential types.\n     */\n    @Bean\n    public TokenCredential tokenCredential() {\n        log.info(\"Creating TokenCredential of type: {}\", credentialType);\n        \n        return switch (credentialType.toLowerCase()) {\n            case \"managed\" -> createManagedIdentityCredential();\n            case \"cli\" -> createAzureCliCredential();\n            case \"environment\" -> createEnvironmentCredential();\n            case \"default\" -> createDefaultAzureCredential();\n            default -> {\n                log.warn(\"Unknown credential type: {}, using DefaultAzureCredential\", \n                    credentialType);\n                yield createDefaultAzureCredential();\n            }\n        };\n    }\n\n    private TokenCredential createManagedIdentityCredential() {\n        ManagedIdentityCredentialBuilder builder = new ManagedIdentityCredentialBuilder();\n        \n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            builder.clientId(managedIdentityClientId);\n        }\n        \n        return builder.build();\n    }\n\n    private TokenCredential createAzureCliCredential() {\n        return new AzureCliCredentialBuilder().build();\n    }\n\n    private TokenCredential createEnvironmentCredential() {\n        return new EnvironmentCredentialBuilder().build();\n    }\n\n    private TokenCredential createDefaultAzureCredential() {\n        DefaultAzureCredentialBuilder builder = new DefaultAzureCredentialBuilder();\n        \n        if (tenantId != null && !tenantId.isEmpty()) {\n            builder.tenantId(tenantId);\n        }\n        \n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            builder.managedIdentityClientId(managedIdentityClientId);\n        }\n        \n        return builder.build();\n    }\n}\n```\n\n### SecurityConfiguration.java\n\n```java\npackage com.example.azure.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.web.SecurityFilterChain;\n\n/**\n * Security configuration for the application.\n */\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authz -> authz\n                .requestMatchers(\"/actuator/health/**\", \"/actuator/info\").permitAll()\n                .requestMatchers(\"/api/**\").permitAll()\n                ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5420,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive Azure Identity integration for your Spring Boot application. Let me create the necessary files:\n\n```java\n// src/main/java/com/example/app/config/AzureConfig.java\npackage com.example.app.config;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AzureConfig {\n    private static final Logger log = LoggerFactory.getLogger(AzureConfig.class);\n\n    @Value(\"${azure.keyvault.url}\")\n    private String keyVaultUrl;\n\n    @Bean\n    public DefaultAzureCredential azureCredential() {\n        log.info(\"Initializing DefaultAzureCredential\");\n        return new DefaultAzureCredentialBuilder()\n            .build();\n    }\n\n    @Bean\n    public SecretClient secretClient(DefaultAzureCredential credential) {\n        log.info(\"Creating SecretClient for Key Vault: {}\", keyVaultUrl);\n        return new SecretClientBuilder()\n            .vaultUrl(keyVaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/service/AzureKeyVaultService.java\npackage com.example.app.service;\n\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Service\npublic class AzureKeyVaultService {\n    private static final Logger log = LoggerFactory.getLogger(AzureKeyVaultService.class);\n    private final SecretClient secretClient;\n\n    public AzureKeyVaultService(SecretClient secretClient) {\n        this.secretClient = secretClient;\n    }\n\n    @Cacheable(value = \"secrets\", key = \"#secretName\")\n    public String getSecret(String secretName) {\n        try {\n            log.debug(\"Retrieving secret: {}\", secretName);\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            log.info(\"Successfully retrieved secret: {}\", secretName);\n            return secret.getValue();\n        } catch (ResourceNotFoundException e) {\n            log.error(\"Secret not found: {}\", secretName);\n            throw new IllegalArgumentException(\"Secret not found: \" + secretName, e);\n        } catch (Exception e) {\n            log.error(\"Error retrieving secret: {}\", secretName, e);\n            throw new RuntimeException(\"Failed to retrieve secret: \" + secretName, e);\n        }\n    }\n\n    public Map<String, String> getSecrets(String... secretNames) {\n        Map<String, String> secrets = new HashMap<>();\n        for (String secretName : secretNames) {\n            try {\n                secrets.put(secretName, getSecret(secretName));\n            } catch (Exception e) {\n                log.warn(\"Failed to retrieve secret: {}\", secretName);\n                secrets.put(secretName, null);\n            }\n        }\n        return secrets;\n    }\n\n    public boolean isHealthy() {\n        try {\n            // Try to list secrets to verify connectivity\n            secretClient.listPropertiesOfSecrets().stream().findFirst();\n            log.debug(\"Key Vault health check passed\");\n            return true;\n        } catch (Exception e) {\n            log.error(\"Key Vault health check failed\", e);\n            return false;\n        }\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/controller/ConfigController.java\npackage com.example.app.controller;\n\nimport com.example.app.service.AzureKeyVaultService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/api/config\")\npublic class ConfigController {\n    private static final Logger log = LoggerFactory.getLogger(ConfigController.class);\n    private final AzureKeyVaultService keyVaultService;\n\n    @Value(\"${app.config.secrets:database-connection-string,api-key,smtp-password}\")\n    private String[] configSecrets;\n\n    public ConfigController(AzureKeyVaultService keyVaultService) {\n        this.keyVaultService = keyVaultService;\n    }\n\n    @GetMapping\n    public ResponseEntity<Map<String, Object>> getConfiguration() {\n        log.info(\"Retrieving application configuration from Key Vault\");\n        try {\n            Map<String, String> secrets = keyVaultService.getSecrets(configSecrets);\n            \n            Map<String, Object> response = new HashMap<>();\n            response.put(\"status\", \"success\");\n            response.put(\"configuration\", secrets);\n            response.put(\"timestamp\", System.currentTimeMillis());\n            \n            log.info(\"Successfully retrieved {} configuration values\", secrets.size());\n            return ResponseEntity.ok(response);\n        } catch (Exception e) {\n            log.error(\"Failed to retrieve configuration\", e);\n            Map<String, Object> errorResponse = new HashMap<>();\n            errorResponse.put(\"status\", \"error\");\n            errorResponse.put(\"message\", \"Failed to retrieve configuration: \" + e.getMessage());\n            errorResponse.put(\"timestamp\", System.currentTimeMillis());\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);\n        }\n    }\n\n    @GetMapping(\"/{secretName}\")\n    public ResponseEntity<Map<String, Object>> getSecret(@PathVariable String secretName) {\n        log.info(\"Retrieving secret: {}\", secretName);\n        try {\n            String secretValue = keyVaultService.getSecret(secretName);\n            \n            Map<String, Object> response = new HashMap<>();\n            response.put(\"status\", \"success\");\n            response.put(\"secretName\", secretName);\n            response.put(\"value\", secretValue);\n            response.put(\"timestamp\", System.currentTimeMillis());\n            \n            return ResponseEntity.ok(response);\n        } catch (IllegalArgumentException e) {\n            log.warn(\"Secret not found: {}\", secretName);\n            Map<String, Object> errorResponse = new HashMap<>();\n            errorResponse.put(\"status\", \"error\");\n            errorResponse.put(\"message\", \"Secret not found: \" + secretName);\n            errorResponse.put(\"timestamp\", System.currentTimeMillis());\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);\n        } catch (Exception e) {\n            log.error(\"Failed to retrieve secret: {}\", secretName, e);\n            Map<String, Object> errorResponse = new HashMap<>();\n            errorResponse.put(\"status\", \"error\");\n            errorResponse.put(\"message\", \"Failed to retrieve secret: \" + e.getMessage());\n            errorResponse.put(\"timestamp\", System.currentTimeMillis());\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);\n        }\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/health/AzureHealthIndicator.java\npackage com.example.app.health;\n\nimport com.example.app.service.AzureKeyVaultService;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.HealthIndicator;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class AzureHealthIndicator implements HealthIndicator {\n    private final AzureKeyVaultService keyVaultService;\n\n    public AzureHealthIndicator(AzureKeyVaultService keyVaultService) {\n        this.keyVaultService = keyVaultService;\n    }\n\n    @Override\n    public Health health() {\n        try {\n            boolean isHealthy = keyVaultService.isHealthy();\n            if (isHealthy) {\n                return Health.up()\n                    .withDetail(\"keyVault\", \"Connected\")\n                    .withDetail(\"status\", \"Healthy\")\n                    .build();\n            } else {\n                return Health.down()\n                    .withDetail(\"keyVault\", \"Connection failed\")\n                    .withDetail(\"status\", \"Unhealthy\")\n                    .build();\n            }\n        } catch (Exception e) {\n            return Health.down()\n                .withDetail(\"keyVault\", \"Error\")\n                .withDetail(\"error\", e.getMessage())\n                .withException(e)\n                .build();\n        }\n    }\n}\n```\n\n```properties\n# src/main/resources/application.properties\n# Azure Key Vault Configuration\nazure.keyvault.url=https://your-keyvault-name.vault.azure.net\n\n# Application configuration secrets to retrieve\napp.config.secrets=database-connection-string,api-key,smtp-password\n\n# Cache configuration for secrets\nspring.cache.cache-names=secrets\nspring.cache.caffeine.spec=maximumSize=100,expireAfterWrite=3600s\n\n# Health check configuration\nmanagement.endpoints.web.exposure.include=health,info\nmanagement.endpoint.health.show-details=always\nmanagement.health.defaults.enabled=true\n\n# Logging\nlogging.level.com.example.app=INFO\nlogging.level.com.azure=WARN\n```\n\n```xml\n<!-- pom.xml - Add these dependencies -->\n<dependencies>\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.13.2</version>\n    </dependency>\n\n    <!-- Azure Key Vault Secrets -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-secrets</artifactId>\n        <version>4.8.5</version>\n    </dependency>\n\n    <!-- Spring Boot Actuator for health checks -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n\n    <!-- Caffeine cache for secret caching -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-cache</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.github.ben-manes.caffeine</groupId>\n        <artifactId>caffeine</artifactId>\n    </dependency>\n</dependencies>\n```\n\n```java\n// src/main/java/com/example/app/config/CacheConfig.java\npackage com.example.app.config;\n\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n    // Cache configuration is handled in application.properties\n}\n```\n\n```java\n// src/test/java/com/example/app/service/AzureKeyVaultServiceTest.java\npackage com.example.app.service;\n\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass AzureKeyVaultServiceTest {\n\n    @Mock\n    private SecretClient secretClient;\n\n    private AzureKeyVaultService service;\n\n    @BeforeEach\n    void setUp() {\n        service = new AzureKeyVaultService(secretClient);\n    }\n\n    @Test\n    void getSecret_Success() {\n        // Arrange\n        String secretName = \"test-secret\";\n        String secretValue = \"test-value\";\n        KeyVaultSecret secret = new KeyVaultSecret(secretName, secretValue);\n        when(secretClient.getSecret(secretName)).thenReturn(secret);\n\n        // Act\n        String result = service.getSecret(secretName);\n\n        // Assert\n        assertEquals(secretValue, result);\n        verify(secretClient).getSecret(secretName);\n    }\n\n    @Test\n    void getSecret_NotFound() {\n        // Arrange\n        String secretName = \"missing-secret\";\n        when(secretClient.getSecret(secretName))\n            .thenThrow(new ResourceNotFoundException(\"Secret not found\", null));\n\n        // Act & Assert\n        assertThrows(IllegalArgumentException.class, () -> service.getSecret(secretName));\n        verify(secretClient).getSecret(secretName);\n    }\n\n    @Test\n    void getSecrets_MultipleSecrets() {\n        // Arrange\n        KeyVaultSecret secret1 = new KeyVaultSecret(\"secret1\", \"value1\");\n        KeyVaultSecret secret2 = new KeyVaultSecret(\"secret2\", \"value2\");\n        when(secretClient.getSecret(\"secret1\")).thenReturn(secret1);\n        when(secretClient.getSecret(\"secret2\")).thenReturn(secret2);\n\n        // Act\n        Map<String, String> results = service.getSecrets(\"secret1\", \"secret2\");\n\n        // Assert\n        assertEquals(2, results.size());\n        assertEquals(\"value1\", results.get(\"secret1\"));\n        assertEquals(\"value2\", results.get(\"secret2\"));\n    }\n\n    @Test\n    void getSecrets_PartialFailure() {\n        // Arrange\n        KeyVaultSecret secret1 = new KeyVaultSecret(\"secret1\", \"value1\");\n        when(secretClient.getSecret(\"secret1\")).thenReturn(secret1);\n        when(secretClient.getSecret(\"secret2\"))\n            .thenThrow(new ResourceNotFoundException(\"Not found\", null));\n\n        // Act\n        Map<String, String> results = service.getSecrets(\"secret1\", \"secret2\");\n\n        // Assert\n        assertEquals(2, results.size());\n        assertEquals(\"value1\", results.get(\"secret1\"));\n        assertNull(results.get(\"secret2\"));\n    }\n}\n```\n\n```java\n// src/test/java/com/example/app/controller/ConfigControllerTest.java\npackage com.example.app.controller;\n\nimport com.example.app.service.AzureKeyVaultService;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.boot.test.mock.mockito.MockBean;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.when;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;\n\n@WebMvcTest(ConfigController.class)\nclass ConfigControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private AzureKeyVaultService keyVaultService;\n\n    @Test\n    void getConfiguration_Success() throws Exception {\n        // Arrange\n        Map<String, String> secrets = new HashMap<>();\n        secrets.put(\"database-connection-string\", \"jdbc:postgresql://localhost:5432/db\");\n        secrets.put(\"api-key\", \"",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5945,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Azure Spring Boot Service with Key Vault Integration\n\nI'll create a complete Spring Boot service with Azure Identity authentication, Key Vault integration, and health checks.\n\n## Project Structure\n\n```\nsrc/main/java/com/example/azureservice/\n\u251c\u2500\u2500 AzureServiceApplication.java\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 AzureConfig.java\n\u2502   \u2514\u2500\u2500 SecurityConfig.java\n\u251c\u2500\u2500 controller/\n\u2502   \u2514\u2500\u2500 ConfigController.java\n\u251c\u2500\u2500 service/\n\u2502   \u251c\u2500\u2500 KeyVaultService.java\n\u2502   \u2514\u2500\u2500 impl/\n\u2502       \u2514\u2500\u2500 KeyVaultServiceImpl.java\n\u251c\u2500\u2500 model/\n\u2502   \u251c\u2500\u2500 ConfigResponse.java\n\u2502   \u2514\u2500\u2500 HealthStatus.java\n\u2514\u2500\u2500 health/\n    \u2514\u2500\u2500 AzureKeyVaultHealthIndicator.java\n```\n\n## 1. Maven Dependencies (pom.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.2.0</version>\n        <relativePath/>\n    </parent>\n    \n    <groupId>com.example</groupId>\n    <artifactId>azure-service</artifactId>\n    <version>1.0.0</version>\n    <name>Azure Service</name>\n    <description>Spring Boot service with Azure Key Vault integration</description>\n    \n    <properties>\n        <java.version>17</java.version>\n        <azure.identity.version>1.11.1</azure.identity.version>\n        <azure.security.keyvault.version>4.7.3</azure.security.keyvault.version>\n    </properties>\n    \n    <dependencies>\n        <!-- Spring Boot Starters -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-validation</artifactId>\n        </dependency>\n        \n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure.identity.version}</version>\n        </dependency>\n        \n        <!-- Azure Key Vault -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>${azure.security.keyvault.version}</version>\n        </dependency>\n        \n        <!-- Lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        \n        <!-- Testing -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Application Properties\n\n```yaml\n# src/main/resources/application.yml\nspring:\n  application:\n    name: azure-service\n  \nserver:\n  port: 8080\n\n# Azure Configuration\nazure:\n  keyvault:\n    url: ${AZURE_KEYVAULT_URL:https://your-keyvault.vault.azure.net/}\n    enabled: ${AZURE_KEYVAULT_ENABLED:true}\n  \n  # Optional: Specific credential configuration\n  identity:\n    client-id: ${AZURE_CLIENT_ID:}\n    tenant-id: ${AZURE_TENANT_ID:}\n    client-secret: ${AZURE_CLIENT_SECRET:}\n\n# Actuator Configuration\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics\n      base-path: /actuator\n  endpoint:\n    health:\n      show-details: always\n      probes:\n        enabled: true\n  health:\n    defaults:\n      enabled: true\n\n# Logging\nlogging:\n  level:\n    root: INFO\n    com.example.azureservice: DEBUG\n    com.azure: INFO\n```\n\n## 3. Main Application Class\n\n```java\npackage com.example.azureservice;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class AzureServiceApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AzureServiceApplication.class, args);\n    }\n}\n```\n\n## 4. Azure Configuration\n\n```java\npackage com.example.azureservice.config;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Azure configuration class for setting up authentication and Key Vault access.\n */\n@Configuration\n@Slf4j\n@ConditionalOnProperty(name = \"azure.keyvault.enabled\", havingValue = \"true\", matchIfMissing = true)\npublic class AzureConfig {\n\n    @Value(\"${azure.keyvault.url}\")\n    private String keyVaultUrl;\n\n    @Value(\"${azure.identity.client-id:}\")\n    private String clientId;\n\n    @Value(\"${azure.identity.tenant-id:}\")\n    private String tenantId;\n\n    /**\n     * Creates a DefaultAzureCredential bean for authentication.\n     * This credential type tries multiple authentication methods in order:\n     * 1. Environment variables\n     * 2. Managed Identity\n     * 3. Azure CLI\n     * 4. IntelliJ/VS Code\n     * 5. Azure PowerShell\n     */\n    @Bean\n    public DefaultAzureCredential defaultAzureCredential() {\n        log.info(\"Initializing DefaultAzureCredential\");\n        \n        DefaultAzureCredentialBuilder builder = new DefaultAzureCredentialBuilder();\n        \n        // Optionally configure specific tenant/client if provided\n        if (tenantId != null && !tenantId.isEmpty()) {\n            log.debug(\"Configuring credential with tenant ID: {}\", tenantId);\n            builder.tenantId(tenantId);\n        }\n        \n        if (clientId != null && !clientId.isEmpty()) {\n            log.debug(\"Configuring credential with managed identity client ID: {}\", clientId);\n            builder.managedIdentityClientId(clientId);\n        }\n        \n        DefaultAzureCredential credential = builder.build();\n        log.info(\"DefaultAzureCredential initialized successfully\");\n        \n        return credential;\n    }\n\n    /**\n     * Creates a SecretClient bean for Key Vault access.\n     */\n    @Bean\n    public SecretClient secretClient(TokenCredential credential) {\n        log.info(\"Initializing SecretClient for Key Vault: {}\", keyVaultUrl);\n        \n        SecretClient secretClient = new SecretClientBuilder()\n                .vaultUrl(keyVaultUrl)\n                .credential(credential)\n                .buildClient();\n        \n        log.info(\"SecretClient initialized successfully\");\n        \n        return secretClient;\n    }\n}\n```\n\n## 5. Model Classes\n\n```java\npackage com.example.azureservice.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.time.Instant;\nimport java.util.Map;\n\n/**\n * Response model for configuration data.\n */\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class ConfigResponse {\n    private String key;\n    private String value;\n    private Instant retrievedAt;\n    private Map<String, String> metadata;\n    \n    public static ConfigResponse of(String key, String value) {\n        return ConfigResponse.builder()\n                .key(key)\n                .value(value)\n                .retrievedAt(Instant.now())\n                .build();\n    }\n}\n```\n\n```java\npackage com.example.azureservice.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * Health status model for Azure connectivity.\n */\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class HealthStatus {\n    private String status;\n    private String message;\n    private Long responseTimeMs;\n    private String keyVaultUrl;\n}\n```\n\n## 6. Key Vault Service Interface\n\n```java\npackage com.example.azureservice.service;\n\nimport com.example.azureservice.model.ConfigResponse;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * Service interface for Key Vault operations.\n */\npublic interface KeyVaultService {\n    \n    /**\n     * Retrieves a secret value from Key Vault.\n     *\n     * @param secretName the name of the secret\n     * @return Optional containing the secret value if found\n     */\n    Optional<String> getSecret(String secretName);\n    \n    /**\n     * Retrieves a configuration value as ConfigResponse.\n     *\n     * @param key the configuration key\n     * @return ConfigResponse with the value and metadata\n     */\n    ConfigResponse getConfig(String key);\n    \n    /**\n     * Retrieves multiple configuration values.\n     *\n     * @param keys list of configuration keys\n     * @return map of key-value pairs\n     */\n    Map<String, String> getConfigs(List<String> keys);\n    \n    /**\n     * Lists all secret names in the Key Vault.\n     *\n     * @return list of secret names\n     */\n    List<String> listSecretNames();\n    \n    /**\n     * Tests connectivity to Key Vault.\n     *\n     * @return true if connection is successful\n     */\n    boolean testConnection();\n}\n```\n\n## 7. Key Vault Service Implementation\n\n```java\npackage com.example.azureservice.service.impl;\n\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.example.azureservice.model.ConfigResponse;\nimport com.example.azureservice.service.KeyVaultService;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * Implementation of KeyVaultService for accessing Azure Key Vault.\n */\n@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class KeyVaultServiceImpl implements KeyVaultService {\n\n    private final SecretClient secretClient;\n\n    @Override\n    @Cacheable(value = \"secrets\", key = \"#secretName\")\n    public Optional<String> getSecret(String secretName) {\n        try {\n            log.debug(\"Retrieving secret: {}\", secretName);\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            log.info(\"Successfully retrieved secret: {}\", secretName);\n            return Optional.ofNullable(secret.getValue());\n        } catch (ResourceNotFoundException e) {\n            log.warn(\"Secret not found: {}\", secretName);\n            return Optional.empty();\n        } catch (Exception e) {\n            log.error(\"Error retrieving secret: {}\", secretName, e);\n            throw new RuntimeException(\"Failed to retrieve secret: \" + secretName, e);\n        }\n    }\n\n    @Override\n    public ConfigResponse getConfig(String key) {\n        log.debug(\"Retrieving configuration for key: {}\", key);\n        \n        try {\n            KeyVaultSecret secret = secretClient.getSecret(key);\n            \n            Map<String, String> metadata = new HashMap<>();\n            if (secret.getProperties() != null) {\n                SecretProperties props = secret.getProperties();\n                metadata.put(\"version\", props.getVersion());\n                metadata.put(\"enabled\", String.valueOf(props.isEnabled()));\n                if (props.getCreatedOn() != null) {\n                    metadata.put(\"createdOn\", props.getCreatedOn().toString());\n                }\n                if (props.getUpdatedOn() != null) {\n                    metadata.put(\"updatedOn\", props.getUpdatedOn().toString());\n                }\n            }\n            \n            return ConfigResponse.builder()\n                    .key(key)\n                    .value(secret.getValue())\n                    .retrievedAt(java.time.Instant.now())\n                    .metadata(metadata)\n                    .build();\n                    \n        } catch (ResourceNotFoundException e) {\n            log.warn(\"Configuration key not found: {}\", key);\n            return ConfigResponse.builder()\n                    .key(key)\n                    .value(null)\n                    .retrievedAt(java.time.Instant.now())\n                    .build();\n        } catch (Exception e) {\n            log.error(\"Error retrieving configuration for key: {}\", key, e);\n            throw new RuntimeException(\"Failed to retrieve configuration: \" + key, e);\n        }\n    }\n\n    @Override\n    public Map<String, String> getConfigs(List<String> keys) {\n        log.debug(\"Retrieving multiple configurations: {}\", keys);\n        \n        return keys.stream()\n                .collect(Collectors.toMap(\n                        key -> key,\n                        key -> getSecret(key).orElse(null)\n                ));\n    }\n\n    @Override\n    public List<String> listSecretNames() {\n        log.debug(\"Listing all secret names\");\n        \n        try {\n            return secretClient.listPropertiesOfSecrets()\n                    .stream()\n                    .map(SecretProperties::getName)\n                    .collect(Collectors.toList());\n        } catch (Exception e) {\n            log.error(\"Error listing secret names\", e);\n            throw new RuntimeException(\"Failed to list secrets\", e);\n        }\n    }\n\n    @Override\n    public boolean testConnection() {\n        try {\n            log.debug(\"Testing Key Vault connection\");\n            // Try to list secrets as a connection test\n            secretClient.listPropertiesOfSecrets().stream().findFirst();\n            log.info(\"Key Vault connection test successful\");\n            return true;\n        } catch (Exception e) {\n            log.error(\"Key Vault connection test failed\", e);\n            return false;\n        }\n    }\n}\n```\n\n## 8. REST Controller\n\n```java\npackage com.example.azureservice.controller;\n\nimport com.example.azureservice.model.ConfigResponse;",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Identity Spring Boot Service\n\nI'll create a comprehensive Spring Boot service that uses Azure Identity for authentication with Azure Key Vault.\n\n## Project Structure\n\n```\nazure-identity-service/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/main/\n\u2502   \u251c\u2500\u2500 java/com/example/azureidentity/\n\u2502   \u2502   \u251c\u2500\u2500 AzureIdentityServiceApplication.java\n\u2502   \u2502   \u251c\u2500\u2500 config/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AzureConfig.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SecurityConfig.java\n\u2502   \u2502   \u251c\u2500\u2500 controller/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ConfigController.java\n\u2502   \u2502   \u251c\u2500\u2500 service/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 KeyVaultService.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 impl/KeyVaultServiceImpl.java\n\u2502   \u2502   \u251c\u2500\u2500 model/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ConfigResponse.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 HealthStatus.java\n\u2502   \u2502   \u251c\u2500\u2500 health/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 AzureKeyVaultHealthIndicator.java\n\u2502   \u2502   \u2514\u2500\u2500 exception/\n\u2502   \u2502       \u251c\u2500\u2500 AzureServiceException.java\n\u2502   \u2502       \u2514\u2500\u2500 GlobalExceptionHandler.java\n\u2502   \u2514\u2500\u2500 resources/\n\u2502       \u251c\u2500\u2500 application.yml\n\u2502       \u2514\u2500\u2500 application-prod.yml\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.2.1</version>\n        <relativePath/>\n    </parent>\n    \n    <groupId>com.example</groupId>\n    <artifactId>azure-identity-service</artifactId>\n    <version>1.0.0</version>\n    <name>Azure Identity Service</name>\n    <description>Spring Boot service with Azure Identity authentication</description>\n    \n    <properties>\n        <java.version>17</java.version>\n        <azure-identity.version>1.11.2</azure-identity.version>\n        <azure-security-keyvault-secrets.version>4.8.0</azure-security-keyvault-secrets.version>\n        <azure-core.version>1.46.0</azure-core.version>\n    </properties>\n    \n    <dependencies>\n        <!-- Spring Boot Starters -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-validation</artifactId>\n        </dependency>\n        \n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure-identity.version}</version>\n        </dependency>\n        \n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>${azure-security-keyvault-secrets.version}</version>\n        </dependency>\n        \n        <!-- Azure Core -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n            <version>${azure-core.version}</version>\n        </dependency>\n        \n        <!-- Lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        \n        <!-- Micrometer for metrics -->\n        <dependency>\n            <groupId>io.micrometer</groupId>\n            <artifactId>micrometer-registry-prometheus</artifactId>\n        </dependency>\n        \n        <!-- Testing -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.mockito</groupId>\n            <artifactId>mockito-inline</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## Application Configuration\n\n### application.yml\n\n```yaml\nspring:\n  application:\n    name: azure-identity-service\n  profiles:\n    active: ${SPRING_PROFILES_ACTIVE:dev}\n\nserver:\n  port: 8080\n  shutdown: graceful\n\n# Azure Configuration\nazure:\n  keyvault:\n    url: ${AZURE_KEYVAULT_URL:https://your-keyvault.vault.azure.net}\n    enabled: true\n  identity:\n    # DefaultAzureCredential configuration\n    exclude-environment-credential: false\n    exclude-managed-identity-credential: false\n    exclude-shared-token-cache-credential: true\n    exclude-azure-cli-credential: false\n    exclude-azure-powershell-credential: true\n    exclude-intellij-credential: false\n    exclude-visual-studio-code-credential: false\n    exclude-interactive-browser-credential: true\n    # Optional: Specify tenant ID for multi-tenant scenarios\n    tenant-id: ${AZURE_TENANT_ID:}\n    # Optional: Specify client ID for user-assigned managed identity\n    managed-identity-client-id: ${AZURE_CLIENT_ID:}\n    # Retry configuration\n    retry:\n      max-retries: 3\n      delay-seconds: 1\n      max-delay-seconds: 60\n\n# Management endpoints\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics,prometheus\n      base-path: /actuator\n  endpoint:\n    health:\n      show-details: always\n      probes:\n        enabled: true\n  health:\n    livenessstate:\n      enabled: true\n    readinessstate:\n      enabled: true\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n\n# Logging\nlogging:\n  level:\n    root: INFO\n    com.example.azureidentity: DEBUG\n    com.azure: INFO\n    com.azure.identity: DEBUG\n    com.azure.security.keyvault: DEBUG\n  pattern:\n    console: \"%d{yyyy-MM-dd HH:mm:ss} - %logger{36} - %msg%n\"\n```\n\n### application-prod.yml\n\n```yaml\nazure:\n  identity:\n    # Production: Use only Managed Identity and Environment credentials\n    exclude-environment-credential: false\n    exclude-managed-identity-credential: false\n    exclude-shared-token-cache-credential: true\n    exclude-azure-cli-credential: true\n    exclude-azure-powershell-credential: true\n    exclude-intellij-credential: true\n    exclude-visual-studio-code-credential: true\n    exclude-interactive-browser-credential: true\n\nlogging:\n  level:\n    root: WARN\n    com.example.azureidentity: INFO\n    com.azure: WARN\n    com.azure.identity: INFO\n```\n\n## Main Application\n\n### AzureIdentityServiceApplication.java\n\n```java\npackage com.example.azureidentity;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationPropertiesScan;\n\n/**\n * Azure Identity Service Application\n * \n * Demonstrates authentication with Azure services using DefaultAzureCredential\n * and integration with Azure Key Vault for configuration management.\n */\n@SpringBootApplication\n@ConfigurationPropertiesScan\npublic class AzureIdentityServiceApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AzureIdentityServiceApplication.class, args);\n    }\n}\n```\n\n## Configuration Classes\n\n### AzureConfig.java\n\n```java\npackage com.example.azureidentity.config;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.http.policy.HttpLogDetailLevel;\nimport com.azure.core.http.policy.HttpLogOptions;\nimport com.azure.core.http.policy.RetryPolicy;\nimport com.azure.core.util.Configuration;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Primary;\n\nimport java.time.Duration;\n\n/**\n * Azure configuration for credential and Key Vault client setup\n */\n@org.springframework.context.annotation.Configuration\n@Slf4j\npublic class AzureConfig {\n\n    @Value(\"${azure.keyvault.url}\")\n    private String keyVaultUrl;\n\n    @Value(\"${azure.identity.exclude-environment-credential:false}\")\n    private boolean excludeEnvironmentCredential;\n\n    @Value(\"${azure.identity.exclude-managed-identity-credential:false}\")\n    private boolean excludeManagedIdentityCredential;\n\n    @Value(\"${azure.identity.exclude-shared-token-cache-credential:true}\")\n    private boolean excludeSharedTokenCacheCredential;\n\n    @Value(\"${azure.identity.exclude-azure-cli-credential:false}\")\n    private boolean excludeAzureCliCredential;\n\n    @Value(\"${azure.identity.exclude-azure-powershell-credential:true}\")\n    private boolean excludeAzurePowerShellCredential;\n\n    @Value(\"${azure.identity.exclude-intellij-credential:false}\")\n    private boolean excludeIntelliJCredential;\n\n    @Value(\"${azure.identity.exclude-visual-studio-code-credential:false}\")\n    private boolean excludeVisualStudioCodeCredential;\n\n    @Value(\"${azure.identity.exclude-interactive-browser-credential:true}\")\n    private boolean excludeInteractiveBrowserCredential;\n\n    @Value(\"${azure.identity.tenant-id:}\")\n    private String tenantId;\n\n    @Value(\"${azure.identity.managed-identity-client-id:}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.identity.retry.max-retries:3}\")\n    private int maxRetries;\n\n    @Value(\"${azure.identity.retry.delay-seconds:1}\")\n    private int retryDelaySeconds;\n\n    @Value(\"${azure.identity.retry.max-delay-seconds:60}\")\n    private int maxRetryDelaySeconds;\n\n    /**\n     * Creates a DefaultAzureCredential bean with customized configuration.\n     * \n     * DefaultAzureCredential tries credentials in this order:\n     * 1. EnvironmentCredential\n     * 2. WorkloadIdentityCredential\n     * 3. ManagedIdentityCredential\n     * 4. SharedTokenCacheCredential\n     * 5. IntelliJCredential\n     * 6. AzureCliCredential\n     * 7. AzurePowerShellCredential\n     * 8. AzureDeveloperCliCredential\n     * \n     * @return Configured DefaultAzureCredential instance\n     */\n    @Bean\n    @Primary\n    public DefaultAzureCredential defaultAzureCredential() {\n        log.info(\"Initializing DefaultAzureCredential with custom configuration\");\n        \n        DefaultAzureCredentialBuilder builder = new DefaultAzureCredentialBuilder()\n            .excludeEnvironmentCredential(excludeEnvironmentCredential)\n            .excludeManagedIdentityCredential(excludeManagedIdentityCredential)\n            .excludeSharedTokenCacheCredential(excludeSharedTokenCacheCredential)\n            .excludeAzureCliCredential(excludeAzureCliCredential)\n            .excludeAzurePowerShellCredential(excludeAzurePowerShellCredential)\n            .excludeIntelliJCredential(excludeIntelliJCredential)\n            .excludeVisualStudioCodeCredential(excludeVisualStudioCodeCredential)\n            .excludeInteractiveBrowserCredential(excludeInteractiveBrowserCredential);\n\n        // Configure tenant ID if provided\n        if (tenantId != null && !tenantId.isEmpty()) {\n            log.info(\"Configuring DefaultAzureCredential with tenant ID: {}\", tenantId);\n            builder.tenantId(tenantId);\n        }\n\n        // Configure managed identity client ID if provided\n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            log.info(\"Configuring DefaultAzureCredential with managed identity client ID: {}\", \n                     managedIdentityClientId);\n            builder.managedIdentityClientId(managedIdentityClientId);\n        }\n\n        DefaultAzureCredential credential = builder.build();\n        \n        log.info(\"DefaultAzureCredential initialized successfully\");\n        logCredentialChainConfiguration();\n        \n        return credential;\n    }\n\n    /**\n     * Creates a SecretClient bean for Azure Key Vault access.\n     * \n     * @param credential The TokenCredential to use for authentication\n     * @return Configured SecretClient instance\n     */\n    @Bean\n    @ConditionalOnProperty(name = \"azure.keyvault.enabled\", havingValue = \"true\", matchIfMissing = true)\n    public SecretClient secretClient(TokenCredential credential) {\n        log.info(\"Initializing SecretClient for Key Vault: {}\", keyVaultUrl);\n        \n        HttpLogOptions logOptions = new HttpLogOptions()\n            .setLogLevel(HttpLogDetailLevel.BASIC)\n            .setPrettyPrintBody(true);\n\n        SecretClient client = new SecretClientBuilder()\n            .vaultUrl(keyVaultUrl)\n            .credential(credential)\n            .httpLogOptions(logOptions)\n            .retryPolicy(new RetryPolicy(\n                maxRetries,\n                Duration.ofSeconds(retryDelaySeconds),\n                Duration.ofSeconds(maxRetryDelaySeconds)\n            ))\n            .buildClient();\n        \n        log.info(\"SecretClient initialized successfully\");\n        return client;\n    }\n\n    /**\n     * Logs the current credential chain configuration for debugging\n     */\n    private void logCredentialChainConfiguration() {\n        log.debug(\"DefaultAzureCredential Chain Configuration:\");\n        log.debug(\"  - EnvironmentCredential: {}\", !excludeEnvironmentCredential ? \"ENABLED\" : \"DISABLED\");\n        log.debug(\"  - ManagedIdentityCredential: {}\", !excludeManagedIdentityCredential ? \"ENABLED\" : \"DISABLED\");\n        log.debug(\"  - SharedTokenCacheCredential: {}\", !excludeSharedTokenCacheCredential ? \"ENABLED\" : \"DISABLED\");\n        log.debug(\"  - AzureCliCredential: {}\", !excludeAzureCliCredential ? \"ENABLED\" : \"DISABLED",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5420,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive Azure Identity integration for your Spring Boot application with Key Vault access and health checks.\n\n```java\n// src/main/java/com/example/app/config/AzureConfig.java\npackage com.example.app.config;\n\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AzureConfig {\n\n    @Value(\"${azure.keyvault.uri}\")\n    private String keyVaultUri;\n\n    @Bean\n    public DefaultAzureCredential defaultAzureCredential() {\n        return new DefaultAzureCredentialBuilder()\n            .build();\n    }\n\n    @Bean\n    public SecretClient secretClient(DefaultAzureCredential credential) {\n        return new SecretClientBuilder()\n            .vaultUrl(keyVaultUri)\n            .credential(credential)\n            .buildClient();\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/service/AzureKeyVaultService.java\npackage com.example.app.service;\n\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\n\n@Service\npublic class AzureKeyVaultService {\n    private static final Logger log = LoggerFactory.getLogger(AzureKeyVaultService.class);\n    private final SecretClient secretClient;\n\n    public AzureKeyVaultService(SecretClient secretClient) {\n        this.secretClient = secretClient;\n    }\n\n    @Cacheable(value = \"keyVaultSecrets\", key = \"#secretName\")\n    public Optional<String> getSecret(String secretName) {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            log.info(\"Successfully retrieved secret: {}\", secretName);\n            return Optional.of(secret.getValue());\n        } catch (ResourceNotFoundException e) {\n            log.warn(\"Secret not found: {}\", secretName);\n            return Optional.empty();\n        } catch (Exception e) {\n            log.error(\"Error retrieving secret: {}\", secretName, e);\n            throw new AzureKeyVaultException(\"Failed to retrieve secret: \" + secretName, e);\n        }\n    }\n\n    public Map<String, String> getApplicationConfig() {\n        Map<String, String> config = new HashMap<>();\n        \n        // Define the configuration keys to retrieve\n        String[] configKeys = {\n            \"database-connection-string\",\n            \"api-key\",\n            \"external-service-url\",\n            \"feature-flags\"\n        };\n\n        for (String key : configKeys) {\n            getSecret(key).ifPresent(value -> config.put(key, value));\n        }\n\n        log.info(\"Retrieved {} configuration values from Key Vault\", config.size());\n        return config;\n    }\n\n    public boolean testConnection() {\n        try {\n            // Attempt to list secrets to verify connectivity\n            secretClient.listPropertiesOfSecrets().stream().findFirst();\n            log.info(\"Key Vault connection test successful\");\n            return true;\n        } catch (Exception e) {\n            log.error(\"Key Vault connection test failed\", e);\n            return false;\n        }\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/service/AzureKeyVaultException.java\npackage com.example.app.service;\n\npublic class AzureKeyVaultException extends RuntimeException {\n    public AzureKeyVaultException(String message) {\n        super(message);\n    }\n\n    public AzureKeyVaultException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/controller/ConfigController.java\npackage com.example.app.controller;\n\nimport com.example.app.service.AzureKeyVaultService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/api/config\")\npublic class ConfigController {\n    private static final Logger log = LoggerFactory.getLogger(ConfigController.class);\n    private final AzureKeyVaultService keyVaultService;\n\n    public ConfigController(AzureKeyVaultService keyVaultService) {\n        this.keyVaultService = keyVaultService;\n    }\n\n    @GetMapping\n    public ResponseEntity<Map<String, String>> getConfiguration() {\n        log.info(\"Retrieving application configuration from Key Vault\");\n        Map<String, String> config = keyVaultService.getApplicationConfig();\n        return ResponseEntity.ok(config);\n    }\n\n    @GetMapping(\"/{secretName}\")\n    public ResponseEntity<Map<String, String>> getSecret(@PathVariable String secretName) {\n        log.info(\"Retrieving secret: {}\", secretName);\n        return keyVaultService.getSecret(secretName)\n            .map(value -> ResponseEntity.ok(Map.of(\"name\", secretName, \"value\", value)))\n            .orElse(ResponseEntity.notFound().build());\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/health/AzureKeyVaultHealthIndicator.java\npackage com.example.app.health;\n\nimport com.example.app.service.AzureKeyVaultService;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.HealthIndicator;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class AzureKeyVaultHealthIndicator implements HealthIndicator {\n    private final AzureKeyVaultService keyVaultService;\n\n    public AzureKeyVaultHealthIndicator(AzureKeyVaultService keyVaultService) {\n        this.keyVaultService = keyVaultService;\n    }\n\n    @Override\n    public Health health() {\n        try {\n            boolean isHealthy = keyVaultService.testConnection();\n            if (isHealthy) {\n                return Health.up()\n                    .withDetail(\"service\", \"Azure Key Vault\")\n                    .withDetail(\"status\", \"Connected\")\n                    .build();\n            } else {\n                return Health.down()\n                    .withDetail(\"service\", \"Azure Key Vault\")\n                    .withDetail(\"status\", \"Connection failed\")\n                    .build();\n            }\n        } catch (Exception e) {\n            return Health.down()\n                .withDetail(\"service\", \"Azure Key Vault\")\n                .withDetail(\"error\", e.getMessage())\n                .build();\n        }\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/controller/GlobalExceptionHandler.java\npackage com.example.app.controller;\n\nimport com.example.app.service.AzureKeyVaultException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\nimport java.time.LocalDateTime;\nimport java.util.Map;\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);\n\n    @ExceptionHandler(AzureKeyVaultException.class)\n    public ResponseEntity<Map<String, Object>> handleAzureKeyVaultException(AzureKeyVaultException e) {\n        log.error(\"Azure Key Vault error\", e);\n        Map<String, Object> errorResponse = Map.of(\n            \"timestamp\", LocalDateTime.now(),\n            \"status\", HttpStatus.SERVICE_UNAVAILABLE.value(),\n            \"error\", \"Azure Key Vault Error\",\n            \"message\", e.getMessage()\n        );\n        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(errorResponse);\n    }\n}\n```\n\n```properties\n# src/main/resources/application.properties\n# Azure Key Vault Configuration\nazure.keyvault.uri=https://your-keyvault-name.vault.azure.net/\n\n# Azure Identity will use these environment variables if set:\n# AZURE_CLIENT_ID=<your-client-id>\n# AZURE_TENANT_ID=<your-tenant-id>\n# AZURE_CLIENT_SECRET=<your-client-secret>\n\n# For Managed Identity (production), no additional config needed\n# For local development, use Azure CLI: az login\n\n# Cache configuration for Key Vault secrets\nspring.cache.cache-names=keyVaultSecrets\nspring.cache.caffeine.spec=maximumSize=100,expireAfterWrite=3600s\n\n# Actuator endpoints for health checks\nmanagement.endpoints.web.exposure.include=health,info\nmanagement.endpoint.health.show-details=always\nmanagement.health.defaults.enabled=true\n```\n\n```xml\n<!-- Add to pom.xml -->\n<dependencies>\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.13.2</version>\n    </dependency>\n\n    <!-- Azure Key Vault Secrets -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-secrets</artifactId>\n        <version>4.8.5</version>\n    </dependency>\n\n    <!-- Spring Boot Actuator for health checks -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n\n    <!-- Caffeine cache -->\n    <dependency>\n        <groupId>com.github.ben-manes.caffeine</groupId>\n        <artifactId>caffeine</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-cache</artifactId>\n    </dependency>\n</dependencies>\n```\n\n```java\n// src/main/java/com/example/app/Application.java - Add cache enabling\npackage com.example.app;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cache.annotation.EnableCaching;\n\n@SpringBootApplication\n@EnableCaching\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n## Usage\n\n**Environment Variables (for Service Principal authentication):**\n```bash\nexport AZURE_CLIENT_ID=<your-client-id>\nexport AZURE_TENANT_ID=<your-tenant-id>\nexport AZURE_CLIENT_SECRET=<your-client-secret>\n```\n\n**For Managed Identity (production):** No environment variables needed.\n\n**For local development:** Run `az login` to authenticate with Azure CLI.\n\n**API Endpoints:**\n- `GET /api/config` - Get all application configuration\n- `GET /api/config/{secretName}` - Get specific secret\n- `GET /actuator/health` - Health check including Azure Key Vault connectivity\n\n**Key Features:**\n- \u2705 DefaultAzureCredential for flexible authentication (dev \u2192 production)\n- \u2705 SecretClient bean for Key Vault access\n- \u2705 REST endpoint for configuration retrieval\n- \u2705 Health indicator for Azure connectivity monitoring\n- \u2705 Caching to reduce Key Vault API calls\n- \u2705 Comprehensive error handling\n- \u2705 Logging for observability",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5945,
            "output_tokens": 3053,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Azure Spring Boot Service with Key Vault Integration\n\nI'll create a complete Spring Boot service that authenticates with Azure services and retrieves configuration from Key Vault.\n\n## Project Structure\n\n```\nazure-keyvault-service/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/main/\n\u2502   \u251c\u2500\u2500 java/com/example/azure/\n\u2502   \u2502   \u251c\u2500\u2500 AzureKeyVaultServiceApplication.java\n\u2502   \u2502   \u251c\u2500\u2500 config/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AzureConfiguration.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 AzureProperties.java\n\u2502   \u2502   \u251c\u2500\u2500 controller/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ConfigController.java\n\u2502   \u2502   \u251c\u2500\u2500 service/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 KeyVaultService.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 KeyVaultServiceImpl.java\n\u2502   \u2502   \u251c\u2500\u2500 model/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ConfigResponse.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ErrorResponse.java\n\u2502   \u2502   \u251c\u2500\u2500 exception/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 KeyVaultException.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 GlobalExceptionHandler.java\n\u2502   \u2502   \u2514\u2500\u2500 health/\n\u2502   \u2502       \u2514\u2500\u2500 AzureKeyVaultHealthIndicator.java\n\u2502   \u2514\u2500\u2500 resources/\n\u2502       \u251c\u2500\u2500 application.yml\n\u2502       \u2514\u2500\u2500 application-dev.yml\n```\n\n## 1. pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.2.0</version>\n        <relativePath/>\n    </parent>\n    \n    <groupId>com.example</groupId>\n    <artifactId>azure-keyvault-service</artifactId>\n    <version>1.0.0</version>\n    <name>Azure KeyVault Service</name>\n    <description>Spring Boot service with Azure Key Vault integration</description>\n    \n    <properties>\n        <java.version>17</java.version>\n        <azure.identity.version>1.11.1</azure.identity.version>\n        <azure.security.keyvault.version>4.7.3</azure.security.keyvault.version>\n    </properties>\n    \n    <dependencies>\n        <!-- Spring Boot Starters -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-validation</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n        \n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure.identity.version}</version>\n        </dependency>\n        \n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>${azure.security.keyvault.version}</version>\n        </dependency>\n        \n        <!-- Lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        \n        <!-- Micrometer for metrics -->\n        <dependency>\n            <groupId>io.micrometer</groupId>\n            <artifactId>micrometer-registry-prometheus</artifactId>\n        </dependency>\n        \n        <!-- Testing -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.mockito</groupId>\n            <artifactId>mockito-inline</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Application Main Class\n\n```java\npackage com.example.azure;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\n\n@SpringBootApplication\n@EnableConfigurationProperties\npublic class AzureKeyVaultServiceApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AzureKeyVaultServiceApplication.class, args);\n    }\n}\n```\n\n## 3. Azure Configuration\n\n```java\npackage com.example.azure.config;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Azure configuration class that sets up authentication and Key Vault client\n */\n@Slf4j\n@Configuration\n@RequiredArgsConstructor\npublic class AzureConfiguration {\n\n    private final AzureProperties azureProperties;\n\n    /**\n     * Creates a DefaultAzureCredential bean for authentication.\n     * This credential type tries multiple authentication methods in order:\n     * 1. Environment variables\n     * 2. Managed Identity\n     * 3. Azure CLI\n     * 4. IntelliJ\n     * 5. Visual Studio Code\n     * 6. Azure PowerShell\n     */\n    @Bean\n    public DefaultAzureCredential defaultAzureCredential() {\n        log.info(\"Initializing DefaultAzureCredential\");\n        \n        DefaultAzureCredentialBuilder builder = new DefaultAzureCredentialBuilder();\n        \n        // Configure tenant ID if provided\n        if (azureProperties.getTenantId() != null && !azureProperties.getTenantId().isEmpty()) {\n            log.info(\"Using tenant ID: {}\", azureProperties.getTenantId());\n            builder.tenantId(azureProperties.getTenantId());\n        }\n        \n        // Configure managed identity client ID if provided\n        if (azureProperties.getManagedIdentityClientId() != null && \n            !azureProperties.getManagedIdentityClientId().isEmpty()) {\n            log.info(\"Using managed identity client ID: {}\", \n                     azureProperties.getManagedIdentityClientId());\n            builder.managedIdentityClientId(azureProperties.getManagedIdentityClientId());\n        }\n        \n        DefaultAzureCredential credential = builder.build();\n        log.info(\"DefaultAzureCredential initialized successfully\");\n        \n        return credential;\n    }\n\n    /**\n     * Creates a SecretClient bean for accessing Azure Key Vault\n     */\n    @Bean\n    public SecretClient secretClient(TokenCredential credential) {\n        log.info(\"Initializing SecretClient for Key Vault: {}\", \n                 azureProperties.getKeyVault().getVaultUrl());\n        \n        if (azureProperties.getKeyVault().getVaultUrl() == null || \n            azureProperties.getKeyVault().getVaultUrl().isEmpty()) {\n            throw new IllegalStateException(\"Key Vault URL is not configured\");\n        }\n        \n        SecretClient secretClient = new SecretClientBuilder()\n                .vaultUrl(azureProperties.getKeyVault().getVaultUrl())\n                .credential(credential)\n                .buildClient();\n        \n        log.info(\"SecretClient initialized successfully\");\n        \n        return secretClient;\n    }\n}\n```\n\n## 4. Azure Properties\n\n```java\npackage com.example.azure.config;\n\nimport jakarta.validation.constraints.NotBlank;\nimport lombok.Data;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\nimport org.springframework.validation.annotation.Validated;\n\n/**\n * Configuration properties for Azure services\n */\n@Data\n@Component\n@Validated\n@ConfigurationProperties(prefix = \"azure\")\npublic class AzureProperties {\n\n    /**\n     * Azure tenant ID (optional)\n     */\n    private String tenantId;\n\n    /**\n     * Managed Identity client ID (optional)\n     */\n    private String managedIdentityClientId;\n\n    /**\n     * Key Vault configuration\n     */\n    private KeyVault keyVault = new KeyVault();\n\n    @Data\n    public static class KeyVault {\n        /**\n         * Key Vault URL (required)\n         */\n        @NotBlank(message = \"Key Vault URL must be configured\")\n        private String vaultUrl;\n\n        /**\n         * Connection timeout in seconds\n         */\n        private int connectionTimeout = 30;\n\n        /**\n         * Read timeout in seconds\n         */\n        private int readTimeout = 30;\n\n        /**\n         * Enable caching of secrets\n         */\n        private boolean cacheEnabled = true;\n\n        /**\n         * Cache TTL in seconds\n         */\n        private int cacheTtl = 300;\n    }\n}\n```\n\n## 5. Key Vault Service Interface\n\n```java\npackage com.example.azure.service;\n\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * Service interface for Key Vault operations\n */\npublic interface KeyVaultService {\n\n    /**\n     * Retrieves a secret value from Key Vault\n     *\n     * @param secretName the name of the secret\n     * @return Optional containing the secret value if found\n     */\n    Optional<String> getSecret(String secretName);\n\n    /**\n     * Retrieves multiple secrets from Key Vault\n     *\n     * @param secretNames array of secret names\n     * @return Map of secret names to values\n     */\n    Map<String, String> getSecrets(String... secretNames);\n\n    /**\n     * Retrieves all secrets from Key Vault\n     *\n     * @return Map of all secret names to values\n     */\n    Map<String, String> getAllSecrets();\n\n    /**\n     * Checks if Key Vault is accessible\n     *\n     * @return true if Key Vault is accessible\n     */\n    boolean isHealthy();\n\n    /**\n     * Gets the Key Vault URL\n     *\n     * @return the vault URL\n     */\n    String getVaultUrl();\n}\n```\n\n## 6. Key Vault Service Implementation\n\n```java\npackage com.example.azure.service;\n\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.example.azure.config.AzureProperties;\nimport com.example.azure.exception.KeyVaultException;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Implementation of KeyVaultService\n */\n@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class KeyVaultServiceImpl implements KeyVaultService {\n\n    private final SecretClient secretClient;\n    private final AzureProperties azureProperties;\n    private final Map<String, CachedSecret> secretCache = new ConcurrentHashMap<>();\n\n    @Override\n    @Cacheable(value = \"secrets\", key = \"#secretName\", unless = \"#result == null\")\n    public Optional<String> getSecret(String secretName) {\n        log.debug(\"Retrieving secret: {}\", secretName);\n        \n        try {\n            // Check cache first if enabled\n            if (azureProperties.getKeyVault().isCacheEnabled()) {\n                CachedSecret cached = secretCache.get(secretName);\n                if (cached != null && !cached.isExpired()) {\n                    log.debug(\"Returning cached secret: {}\", secretName);\n                    return Optional.of(cached.getValue());\n                }\n            }\n            \n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            String value = secret.getValue();\n            \n            // Cache the secret if enabled\n            if (azureProperties.getKeyVault().isCacheEnabled()) {\n                secretCache.put(secretName, new CachedSecret(\n                    value, \n                    azureProperties.getKeyVault().getCacheTtl()\n                ));\n            }\n            \n            log.info(\"Successfully retrieved secret: {}\", secretName);\n            return Optional.of(value);\n            \n        } catch (ResourceNotFoundException e) {\n            log.warn(\"Secret not found: {}\", secretName);\n            return Optional.empty();\n        } catch (Exception e) {\n            log.error(\"Error retrieving secret: {}\", secretName, e);\n            throw new KeyVaultException(\"Failed to retrieve secret: \" + secretName, e);\n        }\n    }\n\n    @Override\n    public Map<String, String> getSecrets(String... secretNames) {\n        log.debug(\"Retrieving {} secrets\", secretNames.length);\n        \n        Map<String, String> secrets = new HashMap<>();\n        \n        for (String secretName : secretNames) {\n            getSecret(secretName).ifPresent(value -> secrets.put(secretName, value));\n        }\n        \n        log.info(\"Successfully retrieved {} out of {} secrets\", \n                 secrets.size(), secretNames.length);\n        \n        return secrets;\n    }\n\n    @Override\n    public Map<String, String> getAllSecrets() {\n        log.debug(\"Retrieving all secrets from Key Vault\");\n        \n        Map<String, String> secrets = new HashMap<>();\n        \n        try {\n            for (SecretProperties properties : secretClient.listPropertiesOfSecrets()) {\n                if (properties.isEnabled()) {\n                    String secretName = properties.getName();\n                    getSecret(secretName).ifPresent(value -> \n                        secrets.put(secretName, value)\n                    );\n                }\n            }\n            \n            log.info(\"Successfully retrieved {} secrets\", secrets.size());\n            return secrets;\n            \n        } catch (Exception e) {\n            log.error(\"Error retrieving all secrets\", e);\n            throw new KeyVaultException(\"Failed to retrieve all secrets\", e);\n        }\n    }\n\n    @Override\n    public boolean isHealthy() {\n        try {\n            // Try to list secrets as a health check\n            secretClient.listPropertiesOfSecrets().stream().findFirst();\n            log.debug(\"Key Vault health check passed\");\n            return true;\n        } catch (Exception e) {\n            log.error(\"Key Vault health check failed\", e",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Identity Spring Boot Service\n\nI'll create a comprehensive Spring Boot service that uses Azure Identity for authentication with Azure Key Vault.\n\n## Project Structure\n\n```\nazure-identity-service/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/main/\n\u2502   \u251c\u2500\u2500 java/com/example/azureidentity/\n\u2502   \u2502   \u251c\u2500\u2500 AzureIdentityApplication.java\n\u2502   \u2502   \u251c\u2500\u2500 config/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AzureConfig.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 SecurityConfig.java\n\u2502   \u2502   \u251c\u2500\u2500 controller/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ConfigController.java\n\u2502   \u2502   \u251c\u2500\u2500 service/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 KeyVaultService.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 impl/KeyVaultServiceImpl.java\n\u2502   \u2502   \u251c\u2500\u2500 model/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ConfigResponse.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 HealthStatus.java\n\u2502   \u2502   \u251c\u2500\u2500 exception/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 GlobalExceptionHandler.java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 KeyVaultException.java\n\u2502   \u2502   \u2514\u2500\u2500 health/\n\u2502   \u2502       \u2514\u2500\u2500 AzureKeyVaultHealthIndicator.java\n\u2502   \u2514\u2500\u2500 resources/\n\u2502       \u251c\u2500\u2500 application.yml\n\u2502       \u2514\u2500\u2500 application-prod.yml\n\u2514\u2500\u2500 src/test/\n    \u2514\u2500\u2500 java/com/example/azureidentity/\n        \u251c\u2500\u2500 controller/\n        \u2502   \u2514\u2500\u2500 ConfigControllerTest.java\n        \u2514\u2500\u2500 service/\n            \u2514\u2500\u2500 KeyVaultServiceTest.java\n```\n\n## 1. pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>3.2.1</version>\n        <relativePath/>\n    </parent>\n    \n    <groupId>com.example</groupId>\n    <artifactId>azure-identity-service</artifactId>\n    <version>1.0.0</version>\n    <name>Azure Identity Service</name>\n    <description>Spring Boot service with Azure Identity authentication</description>\n    \n    <properties>\n        <java.version>17</java.version>\n        <azure-identity.version>1.11.2</azure-identity.version>\n        <azure-security-keyvault-secrets.version>4.8.0</azure-security-keyvault-secrets.version>\n        <azure-core.version>1.46.0</azure-core.version>\n    </properties>\n    \n    <dependencies>\n        <!-- Spring Boot Starters -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-validation</artifactId>\n        </dependency>\n        \n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure-identity.version}</version>\n        </dependency>\n        \n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>${azure-security-keyvault-secrets.version}</version>\n        </dependency>\n        \n        <!-- Azure Core -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-core</artifactId>\n            <version>${azure-core.version}</version>\n        </dependency>\n        \n        <!-- Lombok -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n        \n        <!-- Micrometer for metrics -->\n        <dependency>\n            <groupId>io.micrometer</groupId>\n            <artifactId>micrometer-registry-prometheus</artifactId>\n        </dependency>\n        \n        <!-- Test Dependencies -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        \n        <dependency>\n            <groupId>org.mockito</groupId>\n            <artifactId>mockito-inline</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                    <excludes>\n                        <exclude>\n                            <groupId>org.projectlombok</groupId>\n                            <artifactId>lombok</artifactId>\n                        </exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Application Configuration\n\n### application.yml\n\n```yaml\nspring:\n  application:\n    name: azure-identity-service\n  profiles:\n    active: ${SPRING_PROFILES_ACTIVE:dev}\n\nserver:\n  port: 8080\n  shutdown: graceful\n\n# Azure Configuration\nazure:\n  keyvault:\n    uri: ${AZURE_KEYVAULT_URI:https://your-keyvault.vault.azure.net}\n    # For user-assigned managed identity (optional)\n    managed-identity-client-id: ${AZURE_CLIENT_ID:}\n  \n  # Credential configuration\n  credential:\n    # Customize DefaultAzureCredential behavior\n    exclude-environment-credential: false\n    exclude-managed-identity-credential: false\n    exclude-azure-cli-credential: false\n    exclude-azure-powershell-credential: true\n    exclude-intellij-credential: false\n    exclude-visual-studio-code-credential: false\n    exclude-interactive-browser-credential: true\n    \n    # Tenant ID (optional, for multi-tenant scenarios)\n    tenant-id: ${AZURE_TENANT_ID:}\n    \n    # Retry configuration\n    retry:\n      max-retries: 3\n      delay-seconds: 2\n      max-delay-seconds: 60\n\n# Actuator Configuration\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics,prometheus\n      base-path: /actuator\n  endpoint:\n    health:\n      show-details: always\n      probes:\n        enabled: true\n  health:\n    livenessstate:\n      enabled: true\n    readinessstate:\n      enabled: true\n  metrics:\n    export:\n      prometheus:\n        enabled: true\n\n# Logging\nlogging:\n  level:\n    root: INFO\n    com.example.azureidentity: DEBUG\n    com.azure: INFO\n    com.azure.identity: DEBUG\n    com.azure.security.keyvault: DEBUG\n  pattern:\n    console: \"%d{yyyy-MM-dd HH:mm:ss} - %msg%n\"\n    file: \"%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\"\n```\n\n### application-prod.yml\n\n```yaml\n# Production-specific configuration\nazure:\n  credential:\n    # In production, use only managed identity\n    exclude-environment-credential: true\n    exclude-azure-cli-credential: true\n    exclude-intellij-credential: true\n    exclude-visual-studio-code-credential: true\n    exclude-interactive-browser-credential: true\n\nlogging:\n  level:\n    root: WARN\n    com.example.azureidentity: INFO\n    com.azure.identity: INFO\n    com.azure.security.keyvault: INFO\n\nmanagement:\n  endpoint:\n    health:\n      show-details: when-authorized\n```\n\n## 3. Main Application\n\n### AzureIdentityApplication.java\n\n```java\npackage com.example.azureidentity;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationPropertiesScan;\n\n/**\n * Main Spring Boot application for Azure Identity service.\n * \n * This application demonstrates:\n * - Azure Identity authentication using DefaultAzureCredential\n * - Azure Key Vault integration\n * - Health checks for Azure connectivity\n * - REST API for configuration management\n */\n@SpringBootApplication\n@ConfigurationPropertiesScan\npublic class AzureIdentityApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AzureIdentityApplication.class, args);\n    }\n}\n```\n\n## 4. Configuration Classes\n\n### AzureConfig.java\n\n```java\npackage com.example.azureidentity.config;\n\nimport com.azure.core.credential.TokenCredential;\nimport com.azure.core.http.policy.HttpLogDetailLevel;\nimport com.azure.core.http.policy.HttpLogOptions;\nimport com.azure.core.http.policy.RetryPolicy;\nimport com.azure.core.http.policy.RetryOptions;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Profile;\n\nimport java.time.Duration;\n\n/**\n * Azure configuration for credentials and Key Vault client.\n */\n@Slf4j\n@Configuration\npublic class AzureConfig {\n\n    @Value(\"${azure.keyvault.uri}\")\n    private String keyVaultUri;\n\n    @Value(\"${azure.keyvault.managed-identity-client-id:}\")\n    private String managedIdentityClientId;\n\n    @Value(\"${azure.credential.tenant-id:}\")\n    private String tenantId;\n\n    @Value(\"${azure.credential.exclude-environment-credential:false}\")\n    private boolean excludeEnvironmentCredential;\n\n    @Value(\"${azure.credential.exclude-managed-identity-credential:false}\")\n    private boolean excludeManagedIdentityCredential;\n\n    @Value(\"${azure.credential.exclude-azure-cli-credential:false}\")\n    private boolean excludeAzureCliCredential;\n\n    @Value(\"${azure.credential.exclude-azure-powershell-credential:true}\")\n    private boolean excludeAzurePowerShellCredential;\n\n    @Value(\"${azure.credential.exclude-intellij-credential:false}\")\n    private boolean excludeIntellijCredential;\n\n    @Value(\"${azure.credential.exclude-visual-studio-code-credential:false}\")\n    private boolean excludeVisualStudioCodeCredential;\n\n    @Value(\"${azure.credential.exclude-interactive-browser-credential:true}\")\n    private boolean excludeInteractiveBrowserCredential;\n\n    @Value(\"${azure.credential.retry.max-retries:3}\")\n    private int maxRetries;\n\n    @Value(\"${azure.credential.retry.delay-seconds:2}\")\n    private int retryDelaySeconds;\n\n    @Value(\"${azure.credential.retry.max-delay-seconds:60}\")\n    private int maxRetryDelaySeconds;\n\n    /**\n     * Creates a DefaultAzureCredential bean.\n     * \n     * DefaultAzureCredential tries credentials in this order:\n     * 1. EnvironmentCredential\n     * 2. WorkloadIdentityCredential\n     * 3. ManagedIdentityCredential\n     * 4. IntelliJCredential\n     * 5. AzureCliCredential\n     * 6. AzurePowerShellCredential\n     * 7. AzureDeveloperCliCredential\n     * \n     * @return configured DefaultAzureCredential\n     */\n    @Bean\n    public DefaultAzureCredential defaultAzureCredential() {\n        log.info(\"Initializing DefaultAzureCredential\");\n        log.debug(\"Key Vault URI: {}\", keyVaultUri);\n        log.debug(\"Managed Identity Client ID: {}\", \n            managedIdentityClientId != null && !managedIdentityClientId.isEmpty() \n                ? managedIdentityClientId : \"Not configured (using system-assigned)\");\n\n        DefaultAzureCredentialBuilder builder = new DefaultAzureCredentialBuilder()\n            .excludeEnvironmentCredential(excludeEnvironmentCredential)\n            .excludeManagedIdentityCredential(excludeManagedIdentityCredential)\n            .excludeAzureCliCredential(excludeAzureCliCredential)\n            .excludeAzurePowerShellCredential(excludeAzurePowerShellCredential)\n            .excludeIntelliJCredential(excludeIntellijCredential)\n            .excludeVisualStudioCodeCredential(excludeVisualStudioCodeCredential)\n            .excludeInteractiveBrowserCredential(excludeInteractiveBrowserCredential);\n\n        // Configure tenant ID if provided\n        if (tenantId != null && !tenantId.isEmpty()) {\n            log.debug(\"Using tenant ID: {}\", tenantId);\n            builder.tenantId(tenantId);\n        }\n\n        // Configure user-assigned managed identity if provided\n        if (managedIdentityClientId != null && !managedIdentityClientId.isEmpty()) {\n            log.debug(\"Using user-assigned managed identity: {}\", managedIdentityClientId);\n            builder.managedIdentityClientId(managedIdentityClientId);\n        }\n\n        DefaultAzureCredential credential = builder.build();\n        log.info(\"DefaultAzureCredential initialized successfully\");\n        \n        return credential;\n    }\n\n    /**\n     * Creates a SecretClient bean for Azure Key Vault access.\n     * \n     * @param credential the TokenCredential to use for authentication\n     * @return configured SecretClient\n     */\n    @Bean\n    public SecretClient secretClient(TokenCredential credential) {\n        log.info(\"Initializing SecretClient for Key Vault: {}\", keyVaultUri);\n\n        // Configure retry policy\n        RetryOptions retryOptions = new RetryOptions()\n            .setMaxRetries(maxRetries)\n            .setTryTimeout(Duration.ofSeconds(retryDelaySeconds))\n            .setMaxRetryDelay(Duration.ofSeconds(maxRetryDelaySeconds));\n\n        // Configure HTTP logging (adjust for production)\n        HttpLogOptions logOptions = new HttpLogOptions()\n            .setLogLevel(HttpLogDetailLevel.BASIC);\n\n        SecretClient client = new SecretClientBuilder()\n            .vaultUrl(keyVaultUri)\n            .credential(credential)\n            .retryOptions(retryOptions)\n            .httpLogOptions(logOptions)\n            .buildClient();\n\n        log.info(\"SecretClient initialized successfully\");\n        return client;\n    }\n\n    /**\n     * Development-specific credential configuration.\n     * Uses all available credential types for local development.\n     */\n    @Bean\n    @Profile(\"dev\")\n    public DefaultAzureCredential devCredential() {\n        log.info(\"Using development credential configuration\");\n        return new DefaultAzureCredentialBuilder()\n            .excludeInteractiveBrowserCredential(false) // Enable for dev\n            .build();\n    }\n\n    /**\n     * Production-specific credential configuration.\n     * Uses only managed identity for production environments.\n     ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5420,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive Azure Identity integration for your Spring Boot application. Let me create the necessary files:\n\n```java\n// src/main/java/com/example/app/config/AzureConfig.java\npackage com.example.app.config;\n\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AzureConfig {\n\n    @Value(\"${azure.keyvault.uri}\")\n    private String keyVaultUri;\n\n    @Bean\n    public DefaultAzureCredential defaultAzureCredential() {\n        return new DefaultAzureCredentialBuilder()\n            .build();\n    }\n\n    @Bean\n    public SecretClient secretClient(DefaultAzureCredential credential) {\n        return new SecretClientBuilder()\n            .vaultUrl(keyVaultUri)\n            .credential(credential)\n            .buildClient();\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/service/AzureKeyVaultService.java\npackage com.example.app.service;\n\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Service\npublic class AzureKeyVaultService {\n    private static final Logger log = LoggerFactory.getLogger(AzureKeyVaultService.class);\n    private final SecretClient secretClient;\n\n    public AzureKeyVaultService(SecretClient secretClient) {\n        this.secretClient = secretClient;\n    }\n\n    @Cacheable(value = \"keyVaultSecrets\", key = \"#secretName\")\n    public String getSecret(String secretName) {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            log.info(\"Successfully retrieved secret: {}\", secretName);\n            return secret.getValue();\n        } catch (ResourceNotFoundException e) {\n            log.error(\"Secret not found: {}\", secretName);\n            throw new IllegalArgumentException(\"Secret not found: \" + secretName, e);\n        } catch (Exception e) {\n            log.error(\"Error retrieving secret: {}\", secretName, e);\n            throw new RuntimeException(\"Failed to retrieve secret: \" + secretName, e);\n        }\n    }\n\n    public Map<String, String> getMultipleSecrets(String... secretNames) {\n        Map<String, String> secrets = new HashMap<>();\n        for (String secretName : secretNames) {\n            try {\n                secrets.put(secretName, getSecret(secretName));\n            } catch (Exception e) {\n                log.warn(\"Failed to retrieve secret: {}\", secretName);\n                secrets.put(secretName, null);\n            }\n        }\n        return secrets;\n    }\n\n    public boolean isHealthy() {\n        try {\n            // Try to list secrets to verify connectivity\n            secretClient.listPropertiesOfSecrets().stream().findFirst();\n            return true;\n        } catch (Exception e) {\n            log.error(\"Key Vault health check failed\", e);\n            return false;\n        }\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/controller/ConfigController.java\npackage com.example.app.controller;\n\nimport com.example.app.service.AzureKeyVaultService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/api/config\")\npublic class ConfigController {\n    private static final Logger log = LoggerFactory.getLogger(ConfigController.class);\n    private final AzureKeyVaultService keyVaultService;\n\n    public ConfigController(AzureKeyVaultService keyVaultService) {\n        this.keyVaultService = keyVaultService;\n    }\n\n    @GetMapping(\"/{secretName}\")\n    public ResponseEntity<Map<String, String>> getConfig(@PathVariable String secretName) {\n        try {\n            String secretValue = keyVaultService.getSecret(secretName);\n            Map<String, String> response = new HashMap<>();\n            response.put(\"key\", secretName);\n            response.put(\"value\", secretValue);\n            return ResponseEntity.ok(response);\n        } catch (IllegalArgumentException e) {\n            log.warn(\"Secret not found: {}\", secretName);\n            return ResponseEntity.status(HttpStatus.NOT_FOUND)\n                .body(Map.of(\"error\", \"Secret not found: \" + secretName));\n        } catch (Exception e) {\n            log.error(\"Error retrieving secret: {}\", secretName, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(Map.of(\"error\", \"Failed to retrieve secret\"));\n        }\n    }\n\n    @PostMapping(\"/batch\")\n    public ResponseEntity<Map<String, String>> getMultipleConfigs(\n            @RequestBody Map<String, String[]> request) {\n        try {\n            String[] secretNames = request.get(\"secrets\");\n            if (secretNames == null || secretNames.length == 0) {\n                return ResponseEntity.badRequest()\n                    .body(Map.of(\"error\", \"No secrets specified\"));\n            }\n            \n            Map<String, String> secrets = keyVaultService.getMultipleSecrets(secretNames);\n            return ResponseEntity.ok(secrets);\n        } catch (Exception e) {\n            log.error(\"Error retrieving multiple secrets\", e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(Map.of(\"error\", \"Failed to retrieve secrets\"));\n        }\n    }\n\n    @GetMapping(\"/health\")\n    public ResponseEntity<Map<String, Object>> healthCheck() {\n        boolean healthy = keyVaultService.isHealthy();\n        Map<String, Object> response = new HashMap<>();\n        response.put(\"status\", healthy ? \"UP\" : \"DOWN\");\n        response.put(\"service\", \"Azure Key Vault\");\n        \n        return ResponseEntity\n            .status(healthy ? HttpStatus.OK : HttpStatus.SERVICE_UNAVAILABLE)\n            .body(response);\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/health/AzureKeyVaultHealthIndicator.java\npackage com.example.app.health;\n\nimport com.example.app.service.AzureKeyVaultService;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.boot.actuate.health.HealthIndicator;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class AzureKeyVaultHealthIndicator implements HealthIndicator {\n    private final AzureKeyVaultService keyVaultService;\n\n    public AzureKeyVaultHealthIndicator(AzureKeyVaultService keyVaultService) {\n        this.keyVaultService = keyVaultService;\n    }\n\n    @Override\n    public Health health() {\n        try {\n            boolean healthy = keyVaultService.isHealthy();\n            if (healthy) {\n                return Health.up()\n                    .withDetail(\"service\", \"Azure Key Vault\")\n                    .withDetail(\"status\", \"Connected\")\n                    .build();\n            } else {\n                return Health.down()\n                    .withDetail(\"service\", \"Azure Key Vault\")\n                    .withDetail(\"status\", \"Connection failed\")\n                    .build();\n            }\n        } catch (Exception e) {\n            return Health.down()\n                .withDetail(\"service\", \"Azure Key Vault\")\n                .withDetail(\"error\", e.getMessage())\n                .build();\n        }\n    }\n}\n```\n\n```properties\n# src/main/resources/application.properties\n# Azure Key Vault Configuration\nazure.keyvault.uri=https://your-keyvault-name.vault.azure.net/\n\n# Spring Cache Configuration\nspring.cache.cache-names=keyVaultSecrets\nspring.cache.caffeine.spec=maximumSize=100,expireAfterWrite=300s\n\n# Actuator Configuration\nmanagement.endpoints.web.exposure.include=health,info\nmanagement.endpoint.health.show-details=always\nmanagement.health.defaults.enabled=true\n```\n\n```xml\n<!-- Add to pom.xml -->\n<dependencies>\n    <!-- Azure Identity -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.13.2</version>\n    </dependency>\n    \n    <!-- Azure Key Vault Secrets -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-secrets</artifactId>\n        <version>4.8.5</version>\n    </dependency>\n    \n    <!-- Spring Boot Actuator for health checks -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    \n    <!-- Spring Cache -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-cache</artifactId>\n    </dependency>\n    \n    <!-- Caffeine Cache -->\n    <dependency>\n        <groupId>com.github.ben-manes.caffeine</groupId>\n        <artifactId>caffeine</artifactId>\n    </dependency>\n</dependencies>\n```\n\n```java\n// src/test/java/com/example/app/service/AzureKeyVaultServiceTest.java\npackage com.example.app.service;\n\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass AzureKeyVaultServiceTest {\n\n    @Mock\n    private SecretClient secretClient;\n\n    private AzureKeyVaultService service;\n\n    @BeforeEach\n    void setUp() {\n        service = new AzureKeyVaultService(secretClient);\n    }\n\n    @Test\n    void getSecret_Success() {\n        // Arrange\n        String secretName = \"test-secret\";\n        String secretValue = \"test-value\";\n        KeyVaultSecret secret = new KeyVaultSecret(secretName, secretValue);\n        when(secretClient.getSecret(secretName)).thenReturn(secret);\n\n        // Act\n        String result = service.getSecret(secretName);\n\n        // Assert\n        assertEquals(secretValue, result);\n        verify(secretClient).getSecret(secretName);\n    }\n\n    @Test\n    void getSecret_NotFound() {\n        // Arrange\n        String secretName = \"missing-secret\";\n        when(secretClient.getSecret(secretName))\n            .thenThrow(new ResourceNotFoundException(\"Not found\", null));\n\n        // Act & Assert\n        assertThrows(IllegalArgumentException.class, () -> service.getSecret(secretName));\n        verify(secretClient).getSecret(secretName);\n    }\n\n    @Test\n    void getMultipleSecrets_Success() {\n        // Arrange\n        KeyVaultSecret secret1 = new KeyVaultSecret(\"secret1\", \"value1\");\n        KeyVaultSecret secret2 = new KeyVaultSecret(\"secret2\", \"value2\");\n        when(secretClient.getSecret(\"secret1\")).thenReturn(secret1);\n        when(secretClient.getSecret(\"secret2\")).thenReturn(secret2);\n\n        // Act\n        Map<String, String> result = service.getMultipleSecrets(\"secret1\", \"secret2\");\n\n        // Assert\n        assertEquals(2, result.size());\n        assertEquals(\"value1\", result.get(\"secret1\"));\n        assertEquals(\"value2\", result.get(\"secret2\"));\n    }\n\n    @Test\n    void getMultipleSecrets_PartialFailure() {\n        // Arrange\n        KeyVaultSecret secret1 = new KeyVaultSecret(\"secret1\", \"value1\");\n        when(secretClient.getSecret(\"secret1\")).thenReturn(secret1);\n        when(secretClient.getSecret(\"secret2\"))\n            .thenThrow(new ResourceNotFoundException(\"Not found\", null));\n\n        // Act\n        Map<String, String> result = service.getMultipleSecrets(\"secret1\", \"secret2\");\n\n        // Assert\n        assertEquals(2, result.size());\n        assertEquals(\"value1\", result.get(\"secret1\"));\n        assertNull(result.get(\"secret2\"));\n    }\n\n    @Test\n    void isHealthy_Success() {\n        // Arrange\n        when(secretClient.listPropertiesOfSecrets()).thenReturn(mock());\n\n        // Act\n        boolean result = service.isHealthy();\n\n        // Assert\n        assertTrue(result);\n    }\n\n    @Test\n    void isHealthy_Failure() {\n        // Arrange\n        when(secretClient.listPropertiesOfSecrets())\n            .thenThrow(new RuntimeException(\"Connection failed\"));\n\n        // Act\n        boolean result = service.isHealthy();\n\n        // Assert\n        assertFalse(result);\n    }\n}\n```\n\n```java\n// src/main/java/com/example/app/Application.java - Add cache enabling\npackage com.example.app;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cache.annotation.EnableCaching;\n\n@SpringBootApplication\n@EnableCaching\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n## Key Features:\n\n1. **DefaultAzureCredential Bean**: Configured in `AzureConfig` - tries multiple authentication methods (environment variables, managed identity, Azure CLI, etc.)\n\n2. **SecretClient Bean**: Configured with the credential for Key Vault access\n\n3. **REST Endpoints**:\n   - `GET /api/config/{secretName}` - Retrieve single secret\n   - `POST /api/config/batch` - Retrieve multiple secrets\n   - `GET /api/config/health` - Azure connectivity health check\n\n4. **Spring Boot Actuator Integration**: Custom health indicator at `/actuator/health`\n\n5. **Caching**: Secrets are cached for 5 minutes to reduce Key Vault calls\n\n6. **Error Handling**: Proper exception handling with appropriate HTTP status codes\n\n7. **Comprehensive Tests**: Unit tests with Mockito\n\n## Environment Setup:\n\nFor local development, set these environment variables:\n```bash\nexport AZURE_CLIENT_ID=<your-client-id>\nexport AZURE_TENANT_ID=<your-tenant-id>\nexport AZURE_CLIENT_SECRET=<your-client-secret>\n```\n\nOr use Azure CLI authentication:\n```bash\naz login\n```\n\nFor production (Azure-hosted), use Managed Identity - no credentials needed!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5945,
            "output_tokens": 3940,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-identity-dotnet-04",
      "task_type": "grounded",
      "target_language": "csharp",
      "expected_patterns": [
        "ManagedIdentityCredential|ChainedTokenCredential",
        "private.*readonly|static",
        "IConfiguration|Environment",
        "try|catch.*AuthenticationFailedException",
        "catch.*CredentialUnavailableException",
        "IsProduction|IsDevelopment|ASPNETCORE_ENVIRONMENT"
      ],
      "anti_patterns": [
        "from azure",
        "import azure",
        "def\\s+",
        "pip install",
        "async def",
        "python"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/api/azure.identity.managedidentitycredential",
          "description": "Azure ManagedIdentityCredential .NET docs - source of ManagedIdentityCredential and ChainedTokenCredential patterns for production"
        },
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/api/azure.identity.defaultazurecredential",
          "description": "Azure Identity .NET SDK reference - source of credential reuse and AuthenticationFailedException handling patterns"
        },
        {
          "url": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/environments",
          "description": "ASP.NET Core environments docs - source of IsDevelopment/IsProduction and ASPNETCORE_ENVIRONMENT patterns"
        },
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/fields",
          "description": "C# field modifiers - source of private, readonly, and static keywords for reusable credential fields as required by fix ('credential is created on every call instead of being reused')"
        },
        {
          "url": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration",
          "description": "ASP.NET Core configuration - source of IConfiguration interface for accessing vault URL from config as required by fix ('vault URL is hardcoded')"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Fixed Authentication Code\n\nHere's the corrected implementation addressing all the issues:\n\n```csharp\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\n\npublic class SecretService : IDisposable\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n    private readonly TokenCredential _credential;\n\n    public SecretService(\n        IConfiguration configuration,\n        ILogger<SecretService> logger)\n    {\n        _logger = logger;\n\n        // Get vault URL from configuration instead of hardcoding\n        var vaultUrl = configuration[\"KeyVault:VaultUrl\"] \n            ?? throw new InvalidOperationException(\"KeyVault:VaultUrl configuration is missing\");\n\n        // Environment-based credential selection\n        _credential = CreateCredential(configuration);\n        \n        _client = new SecretClient(new Uri(vaultUrl), _credential);\n        \n        _logger.LogInformation(\"SecretService initialized with vault: {VaultUrl}\", vaultUrl);\n    }\n\n    private TokenCredential CreateCredential(IConfiguration configuration)\n    {\n        var environment = configuration[\"Environment\"] ?? \"Development\";\n        \n        _logger.LogInformation(\"Creating credential for environment: {Environment}\", environment);\n\n        return environment.ToLowerInvariant() switch\n        {\n            \"production\" => CreateProductionCredential(configuration),\n            \"staging\" => CreateProductionCredential(configuration),\n            \"development\" => CreateDevelopmentCredential(),\n            _ => throw new InvalidOperationException($\"Unknown environment: {environment}\")\n        };\n    }\n\n    private TokenCredential CreateProductionCredential(IConfiguration configuration)\n    {\n        // Use Managed Identity in production/staging\n        var clientId = configuration[\"KeyVault:ManagedIdentityClientId\"];\n        \n        if (!string.IsNullOrEmpty(clientId))\n        {\n            _logger.LogInformation(\"Using User-Assigned Managed Identity with ClientId: {ClientId}\", clientId);\n            return new ManagedIdentityCredential(clientId);\n        }\n        \n        _logger.LogInformation(\"Using System-Assigned Managed Identity\");\n        return new ManagedIdentityCredential();\n    }\n\n    private TokenCredential CreateDevelopmentCredential()\n    {\n        // Use DefaultAzureCredential for local development\n        // This tries multiple credential types in order:\n        // 1. EnvironmentCredential\n        // 2. WorkloadIdentityCredential\n        // 3. ManagedIdentityCredential\n        // 4. SharedTokenCacheCredential\n        // 5. VisualStudioCredential\n        // 6. VisualStudioCodeCredential\n        // 7. AzureCliCredential\n        // 8. AzurePowerShellCredential\n        // 9. InteractiveBrowserCredential (disabled by default)\n        \n        var options = new DefaultAzureCredentialOptions\n        {\n            ExcludeInteractiveBrowserCredential = true, // Avoid browser popups\n            Diagnostics =\n            {\n                IsLoggingEnabled = true,\n                LoggedHeaderNames = { \"x-ms-request-id\" },\n                LoggedQueryParameters = { \"api-version\" }\n            }\n        };\n        \n        _logger.LogInformation(\"Using DefaultAzureCredential for development\");\n        return new DefaultAzureCredential(options);\n    }\n\n    public async Task<string> GetSecret(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            throw new ArgumentException(\"Secret name cannot be null or empty\", nameof(name));\n        }\n\n        try\n        {\n            _logger.LogDebug(\"Retrieving secret: {SecretName}\", name);\n            \n            var secret = await _client.GetSecretAsync(name);\n            \n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n            return secret.Value.Value;\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogError(ex, \"Secret not found: {SecretName}\", name);\n            throw new SecretNotFoundException($\"Secret '{name}' was not found in the key vault\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 401 || ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Authentication/Authorization failed for secret: {SecretName}\", name);\n            throw new SecretAccessDeniedException(\n                $\"Access denied to secret '{name}'. Ensure the managed identity has proper permissions.\", ex);\n        }\n        catch (Azure.RequestFailedException ex)\n        {\n            _logger.LogError(ex, \"Azure request failed while retrieving secret: {SecretName}. Status: {Status}\", \n                name, ex.Status);\n            throw new SecretRetrievalException(\n                $\"Failed to retrieve secret '{name}' from key vault. Status: {ex.Status}\", ex);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error while retrieving secret: {SecretName}\", name);\n            throw new SecretRetrievalException($\"Unexpected error retrieving secret '{name}'\", ex);\n        }\n    }\n\n    public void Dispose()\n    {\n        // Dispose credential if it implements IDisposable\n        if (_credential is IDisposable disposableCredential)\n        {\n            disposableCredential.Dispose();\n        }\n    }\n}\n\n// Custom exceptions for better error handling\npublic class SecretNotFoundException : Exception\n{\n    public SecretNotFoundException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n\npublic class SecretAccessDeniedException : Exception\n{\n    public SecretAccessDeniedException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n\npublic class SecretRetrievalException : Exception\n{\n    public SecretRetrievalException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n```\n\n## Dependency Injection Setup\n\n```csharp\n// Program.cs or Startup.cs\nusing Microsoft.Extensions.DependencyInjection;\n\npublic static class ServiceCollectionExtensions\n{\n    public static IServiceCollection AddSecretService(this IServiceCollection services)\n    {\n        // Register as singleton to reuse credential and client\n        services.AddSingleton<SecretService>();\n        return services;\n    }\n}\n```\n\n## Configuration (appsettings.json)\n\n```json\n{\n  \"Environment\": \"Production\",\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://myvault.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"\"  // Optional: for user-assigned managed identity\n  }\n}\n```\n\n## Configuration (appsettings.Development.json)\n\n```json\n{\n  \"Environment\": \"Development\",\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://myvault-dev.vault.azure.net\"\n  }\n}\n```\n\n## Key Improvements:\n\n1. **\u2705 Credential Reuse**: Credential and SecretClient are created once in the constructor and reused\n2. **\u2705 Production-Specific Credential**: Uses `ManagedIdentityCredential` in production/staging\n3. **\u2705 Comprehensive Error Handling**: Catches specific Azure exceptions with proper logging\n4. **\u2705 Configuration-Based**: Vault URL comes from configuration, not hardcoded\n5. **\u2705 Environment-Based Selection**: Automatically selects appropriate credential based on environment\n6. **\u2705 Logging**: Proper logging for debugging and monitoring\n7. **\u2705 Custom Exceptions**: Better error categorization for consumers\n8. **\u2705 Dependency Injection**: Follows DI best practices\n9. **\u2705 Resource Cleanup**: Implements IDisposable for proper cleanup",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 219,
            "output_tokens": 1960,
            "cached": false
          },
          "with_skill": {
            "output": "# Fixed Code with Production-Ready Authentication\n\nHere's the corrected implementation addressing all issues:\n\n```csharp\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Azure.Core;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\npublic class SecretService\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n\n    // Constructor with dependency injection - credential and client are reused\n    public SecretService(\n        IConfiguration configuration,\n        ILogger<SecretService> logger,\n        IHostEnvironment environment)\n    {\n        _logger = logger;\n\n        // Issue #4 Fixed: Vault URL from configuration instead of hardcoded\n        var vaultUri = new Uri(configuration[\"KeyVault:VaultUri\"] \n            ?? throw new InvalidOperationException(\"KeyVault:VaultUri configuration is missing\"));\n\n        // Issue #2 Fixed: Environment-based credential selection\n        TokenCredential credential = environment.IsProduction()\n            ? CreateProductionCredential(configuration)\n            : CreateDevelopmentCredential();\n\n        // Issue #1 Fixed: Client created once and reused\n        _client = new SecretClient(vaultUri, credential);\n    }\n\n    private TokenCredential CreateProductionCredential(IConfiguration configuration)\n    {\n        // Use specific ManagedIdentityCredential in production for deterministic behavior\n        var clientId = configuration[\"KeyVault:ManagedIdentityClientId\"];\n        \n        if (!string.IsNullOrEmpty(clientId))\n        {\n            _logger.LogInformation(\"Using user-assigned managed identity: {ClientId}\", clientId);\n            return new ManagedIdentityCredential(\n                ManagedIdentityId.FromUserAssignedClientId(clientId));\n        }\n\n        _logger.LogInformation(\"Using system-assigned managed identity\");\n        return new ManagedIdentityCredential(ManagedIdentityId.SystemAssigned);\n    }\n\n    private TokenCredential CreateDevelopmentCredential()\n    {\n        // Use DefaultAzureCredential in development for flexibility\n        _logger.LogInformation(\"Using DefaultAzureCredential for development\");\n        return new DefaultAzureCredential(new DefaultAzureCredentialOptions\n        {\n            ExcludeInteractiveBrowserCredential = false, // Allow interactive in dev\n            Diagnostics = { IsLoggingEnabled = true }\n        });\n    }\n\n    // Issue #3 Fixed: Proper error handling with specific exceptions\n    public async Task<string> GetSecret(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            throw new ArgumentException(\"Secret name cannot be null or empty\", nameof(name));\n        }\n\n        try\n        {\n            _logger.LogInformation(\"Retrieving secret: {SecretName}\", name);\n            \n            KeyVaultSecret secret = await _client.GetSecretAsync(name);\n            \n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n            return secret.Value.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed when accessing Key Vault for secret: {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Failed to authenticate to Key Vault. Ensure managed identity has proper permissions.\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \"Credential unavailable for Key Vault access: {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"No valid credential available. Check managed identity configuration.\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", name);\n            throw new KeyNotFoundException($\"Secret '{name}' not found in Key Vault\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to secret: {SecretName}\", name);\n            throw new UnauthorizedAccessException(\n                $\"Access denied to secret '{name}'. Check Key Vault access policies.\", ex);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n            throw;\n        }\n    }\n}\n```\n\n## Dependency Injection Registration\n\n```csharp\n// Program.cs or Startup.cs\nusing Microsoft.Extensions.DependencyInjection;\n\nbuilder.Services.AddSingleton<SecretService>();\n\n// Or with more explicit configuration:\nbuilder.Services.AddSingleton<SecretService>(sp =>\n{\n    var configuration = sp.GetRequiredService<IConfiguration>();\n    var logger = sp.GetRequiredService<ILogger<SecretService>>();\n    var environment = sp.GetRequiredService<IHostEnvironment>();\n    \n    return new SecretService(configuration, logger, environment);\n});\n```\n\n## Configuration (appsettings.json)\n\n```json\n{\n  \"KeyVault\": {\n    \"VaultUri\": \"https://myvault.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"\"  // Optional: for user-assigned MI\n  }\n}\n```\n\n## Environment-Specific Configuration\n\n### appsettings.Production.json\n```json\n{\n  \"KeyVault\": {\n    \"VaultUri\": \"https://prod-vault.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"12345678-1234-1234-1234-123456789abc\"\n  }\n}\n```\n\n### appsettings.Development.json\n```json\n{\n  \"KeyVault\": {\n    \"VaultUri\": \"https://dev-vault.vault.azure.net\"\n  }\n}\n```\n\n## Alternative: Using Microsoft.Extensions.Azure\n\nFor even better integration with ASP.NET Core:\n\n```csharp\nusing Microsoft.Extensions.Azure;\nusing Azure.Identity;\n\n// Program.cs\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    // Add Key Vault client\n    clientBuilder.AddSecretClient(\n        new Uri(builder.Configuration[\"KeyVault:VaultUri\"]!));\n\n    // Configure credential based on environment\n    if (builder.Environment.IsProduction())\n    {\n        var clientId = builder.Configuration[\"KeyVault:ManagedIdentityClientId\"];\n        clientBuilder.UseCredential(\n            new ManagedIdentityCredential(\n                ManagedIdentityId.FromUserAssignedClientId(clientId)));\n    }\n    else\n    {\n        clientBuilder.UseCredential(new DefaultAzureCredential());\n    }\n});\n\n// Simplified service using injected client\npublic class SecretService\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n\n    public SecretService(SecretClient client, ILogger<SecretService> logger)\n    {\n        _client = client;\n        _logger = logger;\n    }\n\n    public async Task<string> GetSecret(string name)\n    {\n        // Same error handling as above\n        try\n        {\n            var secret = await _client.GetSecretAsync(name);\n            return secret.Value.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed\");\n            throw new InvalidOperationException(\"Failed to authenticate\", ex);\n        }\n        // ... other catch blocks\n    }\n}\n```\n\n## Key Improvements Summary\n\n| Issue | Original Problem | Solution |\n|-------|-----------------|----------|\n| **#1: Credential Reuse** | New credential created per call | Credential created once in constructor, reused via DI |\n| **#2: Production Credential** | Always uses DefaultAzureCredential | Environment-based: ManagedIdentityCredential in prod, DefaultAzureCredential in dev |\n| **#3: Error Handling** | No error handling | Comprehensive exception handling with logging |\n| **#4: Hardcoded URL** | Vault URL hardcoded | Configuration-based with validation |\n\n## Additional Best Practices Implemented\n\n1. **Dependency Injection**: Service registered as singleton for credential reuse\n2. **Logging**: Structured logging for debugging and monitoring\n3. **Configuration Validation**: Throws early if required config is missing\n4. **Specific Exception Types**: Catches and wraps Azure-specific exceptions\n5. **Environment Awareness**: Different credentials for dev vs production\n6. **Thread Safety**: SecretClient is thread-safe and can be shared\n\n## Testing the Solution\n\n```csharp\n// Unit test example\npublic class SecretServiceTests\n{\n    [Fact]\n    public async Task GetSecret_WithValidName_ReturnsSecretValue()\n    {\n        // Arrange\n        var configuration = new ConfigurationBuilder()\n            .AddInMemoryCollection(new Dictionary<string, string>\n            {\n                [\"KeyVault:VaultUri\"] = \"https://test-vault.vault.azure.net\"\n            })\n            .Build();\n\n        var logger = Mock.Of<ILogger<SecretService>>();\n        var environment = Mock.Of<IHostEnvironment>(e => e.EnvironmentName == \"Development\");\n\n        var service = new SecretService(configuration, logger, environment);\n\n        // Act & Assert\n        // ... test implementation\n    }\n}\n```\n\nThis solution is production-ready, follows Azure SDK best practices, and addresses all identified issues.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5555,
            "output_tokens": 2331,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll fix all the issues in this code. Let me create an improved version:\n\n```csharp\nusing Azure.Core;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Microsoft.Extensions.Logging;\n\nnamespace App.Services;\n\npublic class SecretService\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n\n    public SecretService(\n        IConfiguration configuration,\n        IHostEnvironment environment,\n        ILogger<SecretService> logger)\n    {\n        _logger = logger;\n\n        // Issue #2 Fixed: Environment-based credential selection\n        // Production uses deterministic ManagedIdentityCredential\n        // Development uses DefaultAzureCredential for local dev\n        TokenCredential credential = environment.IsProduction()\n            ? CreateProductionCredential(configuration)\n            : CreateDevelopmentCredential();\n\n        // Issue #4 Fixed: Vault URL from configuration instead of hardcoded\n        var vaultUri = configuration[\"Azure:KeyVault:VaultUri\"]\n            ?? throw new InvalidOperationException(\"KeyVault VaultUri not configured\");\n\n        // Issue #1 Fixed: Client (and credential) created once and reused\n        _client = new SecretClient(new Uri(vaultUri), credential);\n\n        _logger.LogInformation(\n            \"SecretService initialized with {CredentialType} for environment {Environment}\",\n            credential.GetType().Name,\n            environment.EnvironmentName);\n    }\n\n    private static TokenCredential CreateProductionCredential(IConfiguration configuration)\n    {\n        // Use user-assigned managed identity if configured, otherwise system-assigned\n        var managedIdentityClientId = configuration[\"Azure:ManagedIdentity:ClientId\"];\n\n        return string.IsNullOrEmpty(managedIdentityClientId)\n            ? new ManagedIdentityCredential(ManagedIdentityId.SystemAssigned)\n            : new ManagedIdentityCredential(\n                ManagedIdentityId.FromUserAssignedClientId(managedIdentityClientId));\n    }\n\n    private static TokenCredential CreateDevelopmentCredential()\n    {\n        // DefaultAzureCredential for local development\n        // Tries: Environment -> Managed Identity -> Visual Studio -> Azure CLI -> etc.\n        return new DefaultAzureCredential(\n            new DefaultAzureCredentialOptions\n            {\n                ExcludeInteractiveBrowserCredential = true // Avoid browser prompts in dev\n            });\n    }\n\n    // Issue #3 Fixed: Proper error handling with specific exception types\n    public async Task<string> GetSecretAsync(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            throw new ArgumentException(\"Secret name cannot be null or empty\", nameof(name));\n        }\n\n        try\n        {\n            _logger.LogDebug(\"Retrieving secret {SecretName}\", name);\n            \n            KeyVaultSecret secret = await _client.GetSecretAsync(name);\n            \n            _logger.LogInformation(\"Successfully retrieved secret {SecretName}\", name);\n            return secret.Value.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \n                \"Authentication failed while retrieving secret {SecretName}. \" +\n                \"Check credential configuration and permissions.\", name);\n            throw;\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex,\n                \"Credential unavailable while retrieving secret {SecretName}. \" +\n                \"Ensure the application is running in a supported environment.\", name);\n            throw;\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret {SecretName} not found in Key Vault\", name);\n            throw new KeyNotFoundException($\"Secret '{name}' not found in Key Vault\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex,\n                \"Access denied to secret {SecretName}. \" +\n                \"Check Key Vault access policies or RBAC permissions.\", name);\n            throw new UnauthorizedAccessException(\n                $\"Access denied to secret '{name}'. Check permissions.\", ex);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret {SecretName}\", name);\n            throw;\n        }\n    }\n}\n```\n\nNow let's add the configuration file (`appsettings.json`):\n\n```json\n{\n  \"Azure\": {\n    \"KeyVault\": {\n      \"VaultUri\": \"https://myvault.vault.azure.net\"\n    },\n    \"ManagedIdentity\": {\n      \"ClientId\": \"\"\n    }\n  }\n}\n```\n\nAnd the production configuration override (`appsettings.Production.json`):\n\n```json\n{\n  \"Azure\": {\n    \"KeyVault\": {\n      \"VaultUri\": \"https://prod-vault.vault.azure.net\"\n    },\n    \"ManagedIdentity\": {\n      \"ClientId\": \"your-user-assigned-mi-client-id\"\n    }\n  }\n}\n```\n\nFinally, register the service in `Program.cs`:\n\n```csharp\n// In Program.cs\nbuilder.Services.AddSingleton<SecretService>();\n```\n\n## Summary of Fixes\n\n1. **\u2705 Credential Reuse**: Credential and `SecretClient` are now created once in the constructor and reused for all calls\n2. **\u2705 Production Credential**: Uses `ManagedIdentityCredential` in production, `DefaultAzureCredential` in development\n3. **\u2705 Error Handling**: Comprehensive exception handling for authentication, authorization, and not-found scenarios\n4. **\u2705 Configuration**: Vault URL comes from configuration, not hardcoded\n\n## Key Improvements\n\n- **Thread-safe**: Single `SecretClient` instance is thread-safe and can be shared\n- **Performance**: No credential recreation overhead on each call\n- **Observability**: Structured logging for debugging authentication issues\n- **Flexibility**: Supports both system-assigned and user-assigned managed identities\n- **Type-safe exceptions**: Converts Azure exceptions to standard .NET exceptions where appropriate",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6061,
            "output_tokens": 1534,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Fixed Authentication Code\n\nHere's the corrected implementation with all issues addressed:\n\n```csharp\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\n\npublic class SecretService : IDisposable\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n    private readonly TokenCredential _credential;\n\n    public SecretService(\n        IConfiguration configuration,\n        ILogger<SecretService> logger)\n    {\n        _logger = logger;\n        \n        // Get vault URL from configuration instead of hardcoding\n        var vaultUrl = configuration[\"KeyVault:VaultUrl\"] \n            ?? throw new InvalidOperationException(\"KeyVault:VaultUrl configuration is missing\");\n\n        // Environment-based credential selection\n        _credential = CreateCredential(configuration);\n        \n        _client = new SecretClient(new Uri(vaultUrl), _credential);\n        \n        _logger.LogInformation(\"SecretService initialized with vault: {VaultUrl}\", vaultUrl);\n    }\n\n    private TokenCredential CreateCredential(IConfiguration configuration)\n    {\n        var environment = configuration[\"ASPNETCORE_ENVIRONMENT\"] \n            ?? Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\") \n            ?? \"Production\";\n\n        _logger.LogInformation(\"Creating credential for environment: {Environment}\", environment);\n\n        if (environment.Equals(\"Development\", StringComparison.OrdinalIgnoreCase))\n        {\n            // Development: Use DefaultAzureCredential for flexibility\n            // This tries multiple credential types in order:\n            // 1. EnvironmentCredential\n            // 2. WorkloadIdentityCredential\n            // 3. ManagedIdentityCredential\n            // 4. SharedTokenCacheCredential\n            // 5. VisualStudioCredential\n            // 6. VisualStudioCodeCredential\n            // 7. AzureCliCredential\n            // 8. AzurePowerShellCredential\n            // 9. InteractiveBrowserCredential (if enabled)\n            \n            var options = new DefaultAzureCredentialOptions\n            {\n                ExcludeInteractiveBrowserCredential = false, // Allow interactive login in dev\n                Diagnostics = { IsLoggingEnabled = true }\n            };\n            \n            return new DefaultAzureCredential(options);\n        }\n        else\n        {\n            // Production: Use ManagedIdentityCredential for better performance and security\n            var clientId = configuration[\"KeyVault:ManagedIdentityClientId\"];\n            \n            if (!string.IsNullOrEmpty(clientId))\n            {\n                // User-assigned managed identity\n                _logger.LogInformation(\"Using user-assigned managed identity: {ClientId}\", clientId);\n                return new ManagedIdentityCredential(clientId);\n            }\n            else\n            {\n                // System-assigned managed identity\n                _logger.LogInformation(\"Using system-assigned managed identity\");\n                return new ManagedIdentityCredential();\n            }\n        }\n    }\n\n    public async Task<string> GetSecretAsync(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            throw new ArgumentException(\"Secret name cannot be null or empty\", nameof(name));\n        }\n\n        try\n        {\n            _logger.LogDebug(\"Retrieving secret: {SecretName}\", name);\n            \n            var secret = await _client.GetSecretAsync(name);\n            \n            _logger.LogDebug(\"Successfully retrieved secret: {SecretName}\", name);\n            \n            return secret.Value.Value;\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogError(ex, \"Secret not found: {SecretName}\", name);\n            throw new SecretNotFoundException($\"Secret '{name}' was not found in the vault\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to secret: {SecretName}\", name);\n            throw new SecretAccessDeniedException($\"Access denied to secret '{name}'. Check managed identity permissions.\", ex);\n        }\n        catch (Azure.Identity.AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while accessing secret: {SecretName}\", name);\n            throw new SecretAuthenticationException(\"Failed to authenticate with Azure Key Vault\", ex);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n            throw new SecretRetrievalException($\"Failed to retrieve secret '{name}'\", ex);\n        }\n    }\n\n    public void Dispose()\n    {\n        // Dispose credential if it implements IDisposable\n        if (_credential is IDisposable disposableCredential)\n        {\n            disposableCredential.Dispose();\n        }\n    }\n}\n\n// Custom exceptions for better error handling\npublic class SecretNotFoundException : Exception\n{\n    public SecretNotFoundException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n\npublic class SecretAccessDeniedException : Exception\n{\n    public SecretAccessDeniedException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n\npublic class SecretAuthenticationException : Exception\n{\n    public SecretAuthenticationException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n\npublic class SecretRetrievalException : Exception\n{\n    public SecretRetrievalException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n```\n\n## Dependency Injection Registration\n\n```csharp\n// Program.cs or Startup.cs\npublic static class ServiceCollectionExtensions\n{\n    public static IServiceCollection AddSecretService(this IServiceCollection services)\n    {\n        services.AddSingleton<SecretService>();\n        return services;\n    }\n}\n\n// Usage in Program.cs\nbuilder.Services.AddSecretService();\n```\n\n## Configuration Files\n\n**appsettings.json:**\n```json\n{\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://myvault.vault.azure.net\"\n  }\n}\n```\n\n**appsettings.Development.json:**\n```json\n{\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://mydevvault.vault.azure.net\"\n  }\n}\n```\n\n**appsettings.Production.json:**\n```json\n{\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://myprodvault.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"optional-client-id-for-user-assigned-identity\"\n  }\n}\n```\n\n## Key Improvements\n\n1. **\u2705 Credential Reuse**: Credential is created once in constructor and reused\n2. **\u2705 Production-Specific Credential**: Uses `ManagedIdentityCredential` in production\n3. **\u2705 Comprehensive Error Handling**: Catches specific Azure exceptions with proper logging\n4. **\u2705 Configuration-Based URLs**: Vault URL comes from configuration\n5. **\u2705 Environment-Based Selection**: Automatically selects appropriate credential based on environment\n6. **\u2705 Logging**: Proper logging for debugging and monitoring\n7. **\u2705 Dependency Injection**: Follows DI best practices\n8. **\u2705 Resource Cleanup**: Implements IDisposable for proper cleanup\n\n## Testing\n\n```csharp\n// Unit test example\npublic class SecretServiceTests\n{\n    [Fact]\n    public async Task GetSecretAsync_ValidName_ReturnsSecret()\n    {\n        // Arrange\n        var configuration = new ConfigurationBuilder()\n            .AddInMemoryCollection(new Dictionary<string, string>\n            {\n                [\"KeyVault:VaultUrl\"] = \"https://test.vault.azure.net\",\n                [\"ASPNETCORE_ENVIRONMENT\"] = \"Development\"\n            })\n            .Build();\n\n        var logger = new Mock<ILogger<SecretService>>();\n        var service = new SecretService(configuration, logger.Object);\n\n        // Act & Assert\n        // Add your test logic here\n    }\n}\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 219,
            "output_tokens": 2055,
            "cached": false
          },
          "with_skill": {
            "output": "# Fixed Authentication Implementation\n\nHere's the corrected code with all issues resolved:\n\n```csharp\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Azure.Core;\nusing Microsoft.Extensions.Options;\n\npublic class SecretServiceOptions\n{\n    public string KeyVaultUri { get; set; } = string.Empty;\n    public string? ManagedIdentityClientId { get; set; }\n    public bool IsProduction { get; set; }\n}\n\npublic class SecretService\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n\n    public SecretService(\n        IOptions<SecretServiceOptions> options,\n        ILogger<SecretService> logger)\n    {\n        _logger = logger;\n        \n        // \u2705 FIXED: Reuse credential instance (created once in constructor)\n        // \u2705 FIXED: Environment-based credential selection\n        TokenCredential credential = CreateCredential(options.Value);\n        \n        // \u2705 FIXED: Vault URL from configuration instead of hardcoded\n        _client = new SecretClient(\n            new Uri(options.Value.KeyVaultUri),\n            credential);\n    }\n\n    private TokenCredential CreateCredential(SecretServiceOptions options)\n    {\n        if (options.IsProduction)\n        {\n            // \u2705 FIXED: Use deterministic ManagedIdentityCredential in production\n            _logger.LogInformation(\"Using ManagedIdentityCredential for production\");\n            \n            if (!string.IsNullOrEmpty(options.ManagedIdentityClientId))\n            {\n                // User-assigned managed identity\n                return new ManagedIdentityCredential(\n                    ManagedIdentityId.FromUserAssignedClientId(\n                        options.ManagedIdentityClientId));\n            }\n            \n            // System-assigned managed identity\n            return new ManagedIdentityCredential(ManagedIdentityId.SystemAssigned);\n        }\n        \n        // Development: Use DefaultAzureCredential for flexibility\n        _logger.LogInformation(\"Using DefaultAzureCredential for development\");\n        return new DefaultAzureCredential(\n            new DefaultAzureCredentialOptions\n            {\n                // Exclude interactive browser in non-interactive environments\n                ExcludeInteractiveBrowserCredential = true\n            });\n    }\n\n    public async Task<string> GetSecret(string name)\n    {\n        try\n        {\n            // \u2705 FIXED: Proper error handling with specific exceptions\n            var secret = await _client.GetSecretAsync(name);\n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n            return secret.Value.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            // \u2705 FIXED: Handle authentication failures\n            _logger.LogError(ex, \n                \"Authentication failed when retrieving secret: {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Failed to authenticate to Key Vault for secret '{name}'\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            // \u2705 FIXED: Handle credential unavailability\n            _logger.LogError(ex, \n                \"Credential unavailable when retrieving secret: {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"No valid credential available to access secret '{name}'\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            // \u2705 FIXED: Handle secret not found\n            _logger.LogWarning(\"Secret not found: {SecretName}\", name);\n            throw new KeyNotFoundException($\"Secret '{name}' not found in Key Vault\", ex);\n        }\n        catch (Azure.RequestFailedException ex)\n        {\n            // \u2705 FIXED: Handle other Azure-specific errors\n            _logger.LogError(ex, \n                \"Azure request failed when retrieving secret: {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Failed to retrieve secret '{name}' from Key Vault\", ex);\n        }\n    }\n}\n```\n\n## Configuration Setup\n\n### appsettings.json (Development)\n```json\n{\n  \"SecretService\": {\n    \"KeyVaultUri\": \"https://myvault.vault.azure.net\",\n    \"IsProduction\": false\n  }\n}\n```\n\n### appsettings.Production.json\n```json\n{\n  \"SecretService\": {\n    \"KeyVaultUri\": \"https://myvault.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"<user-assigned-mi-client-id>\",\n    \"IsProduction\": true\n  }\n}\n```\n\n## Dependency Injection Registration\n\n```csharp\nusing Microsoft.Extensions.DependencyInjection;\n\npublic static class ServiceCollectionExtensions\n{\n    public static IServiceCollection AddSecretService(\n        this IServiceCollection services,\n        IConfiguration configuration)\n    {\n        // Register options\n        services.Configure<SecretServiceOptions>(\n            configuration.GetSection(\"SecretService\"));\n        \n        // Register service as singleton (credential is reused)\n        services.AddSingleton<SecretService>();\n        \n        return services;\n    }\n}\n```\n\n### Program.cs\n```csharp\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// \u2705 Register SecretService with configuration\nbuilder.Services.AddSecretService(builder.Configuration);\n\nvar app = builder.Build();\napp.Run();\n```\n\n## Alternative: Using Microsoft.Extensions.Azure\n\nFor better integration with Azure SDK clients:\n\n```csharp\nusing Azure.Identity;\nusing Microsoft.Extensions.Azure;\nusing Microsoft.Extensions.DependencyInjection;\n\npublic static class ServiceCollectionExtensions\n{\n    public static IServiceCollection AddAzureServices(\n        this IServiceCollection services,\n        IConfiguration configuration,\n        IWebHostEnvironment environment)\n    {\n        services.AddAzureClients(clientBuilder =>\n        {\n            // Add Key Vault client\n            clientBuilder.AddSecretClient(\n                new Uri(configuration[\"SecretService:KeyVaultUri\"]!));\n            \n            // \u2705 Environment-based credential selection\n            if (environment.IsProduction())\n            {\n                var clientId = configuration[\"SecretService:ManagedIdentityClientId\"];\n                clientBuilder.UseCredential(\n                    !string.IsNullOrEmpty(clientId)\n                        ? new ManagedIdentityCredential(\n                            ManagedIdentityId.FromUserAssignedClientId(clientId))\n                        : new ManagedIdentityCredential(ManagedIdentityId.SystemAssigned));\n            }\n            else\n            {\n                clientBuilder.UseCredential(new DefaultAzureCredential());\n            }\n        });\n        \n        return services;\n    }\n}\n\npublic class SecretService\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n\n    // \u2705 Inject SecretClient directly (credential already configured)\n    public SecretService(SecretClient client, ILogger<SecretService> logger)\n    {\n        _client = client;\n        _logger = logger;\n    }\n\n    public async Task<string> GetSecret(string name)\n    {\n        try\n        {\n            var secret = await _client.GetSecretAsync(name);\n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n            return secret.Value.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \n                \"Authentication failed when retrieving secret: {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Failed to authenticate to Key Vault for secret '{name}'\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \n                \"Credential unavailable when retrieving secret: {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"No valid credential available to access secret '{name}'\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret not found: {SecretName}\", name);\n            throw new KeyNotFoundException($\"Secret '{name}' not found in Key Vault\", ex);\n        }\n        catch (Azure.RequestFailedException ex)\n        {\n            _logger.LogError(ex, \n                \"Azure request failed when retrieving secret: {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Failed to retrieve secret '{name}' from Key Vault\", ex);\n        }\n    }\n}\n```\n\n## Summary of Fixes\n\n| Issue | Original Problem | Solution |\n|-------|-----------------|----------|\n| **1. Credential Reuse** | Created new credential on every call | Credential created once in constructor, reused for all calls |\n| **2. Production Credential** | Always used DefaultAzureCredential | Environment-based selection: ManagedIdentityCredential in production, DefaultAzureCredential in development |\n| **3. Error Handling** | No error handling | Comprehensive exception handling for authentication, credential unavailability, and Azure-specific errors |\n| **4. Hardcoded URL** | Vault URL hardcoded in code | Configuration-based URL from appsettings.json |\n\n## Key Benefits\n\n\u2705 **Performance**: Credential instance reused across all calls (no redundant token acquisition)  \n\u2705 **Security**: No hardcoded secrets or URLs  \n\u2705 **Reliability**: Deterministic ManagedIdentityCredential in production  \n\u2705 **Observability**: Comprehensive logging for debugging  \n\u2705 **Maintainability**: Configuration-driven, environment-aware  \n\u2705 **Error Handling**: Specific exception handling with meaningful error messages",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5555,
            "output_tokens": 2448,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll fix all the issues in this code. Let me create an improved version:\n\n```csharp\nusing Azure.Core;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace App.Services;\n\npublic class SecretService\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n\n    public SecretService(\n        IConfiguration configuration,\n        ILogger<SecretService> logger,\n        IHostEnvironment environment)\n    {\n        _logger = logger;\n\n        // Get vault URL from configuration instead of hardcoding\n        var vaultUrl = configuration[\"KeyVault:VaultUrl\"] \n            ?? throw new InvalidOperationException(\"KeyVault:VaultUrl configuration is missing\");\n\n        // Environment-based credential selection\n        TokenCredential credential = environment.IsProduction()\n            ? CreateProductionCredential(configuration)\n            : new DefaultAzureCredential();\n\n        // Reuse single client instance\n        _client = new SecretClient(new Uri(vaultUrl), credential);\n        \n        _logger.LogInformation(\n            \"SecretService initialized with vault {VaultUrl} in {Environment} environment\",\n            vaultUrl,\n            environment.EnvironmentName);\n    }\n\n    private static TokenCredential CreateProductionCredential(IConfiguration configuration)\n    {\n        // Use user-assigned managed identity in production for deterministic behavior\n        var managedIdentityClientId = configuration[\"KeyVault:ManagedIdentityClientId\"];\n        \n        return string.IsNullOrEmpty(managedIdentityClientId)\n            ? new ManagedIdentityCredential(ManagedIdentityId.SystemAssigned)\n            : new ManagedIdentityCredential(\n                ManagedIdentityId.FromUserAssignedClientId(managedIdentityClientId));\n    }\n\n    public async Task<string> GetSecretAsync(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            throw new ArgumentException(\"Secret name cannot be null or empty\", nameof(name));\n        }\n\n        try\n        {\n            _logger.LogDebug(\"Retrieving secret {SecretName}\", name);\n            \n            KeyVaultSecret secret = await _client.GetSecretAsync(name);\n            \n            _logger.LogInformation(\"Successfully retrieved secret {SecretName}\", name);\n            return secret.Value.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \n                \"Authentication failed while retrieving secret {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Failed to authenticate with Key Vault for secret '{name}'\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \n                \"Credential unavailable while retrieving secret {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"No valid credential available to access Key Vault for secret '{name}'\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret {SecretName} not found in Key Vault\", name);\n            throw new KeyNotFoundException($\"Secret '{name}' not found in Key Vault\", ex);\n        }\n        catch (Azure.RequestFailedException ex)\n        {\n            _logger.LogError(ex, \n                \"Key Vault request failed while retrieving secret {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Failed to retrieve secret '{name}' from Key Vault\", ex);\n        }\n    }\n}\n```\n\nNow add the configuration to `appsettings.json`:\n\n```json\n{\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://myvault.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"\"\n  }\n}\n```\n\nAnd for production in `appsettings.Production.json`:\n\n```json\n{\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://prod-vault.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"<your-user-assigned-mi-client-id>\"\n  }\n}\n```\n\nRegister the service in `Program.cs`:\n\n```csharp\nbuilder.Services.AddSingleton<SecretService>();\n```\n\n## Key Fixes Applied:\n\n1. **\u2705 Credential Reuse**: Credential and `SecretClient` created once in constructor, not on every call\n2. **\u2705 Production-Specific Credential**: Uses `ManagedIdentityCredential` in production, `DefaultAzureCredential` in development\n3. **\u2705 Comprehensive Error Handling**: Catches `AuthenticationFailedException`, `CredentialUnavailableException`, and `RequestFailedException`\n4. **\u2705 Configuration-Based URL**: Vault URL from `appsettings.json` instead of hardcoded\n5. **\u2705 Proper Logging**: Structured logging for debugging and monitoring\n6. **\u2705 Singleton Registration**: Service registered as singleton to ensure single credential instance\n\nThe service now follows Azure Identity SDK best practices with deterministic production credentials and proper error handling.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6061,
            "output_tokens": 1280,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Fixed Authentication Code with Best Practices\n\nHere's the corrected implementation addressing all the issues:\n\n```csharp\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\n\npublic class SecretService : IDisposable\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n    private bool _disposed = false;\n\n    public SecretService(\n        IConfiguration configuration,\n        ILogger<SecretService> logger)\n    {\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        \n        // Get vault URL from configuration\n        var vaultUrl = configuration[\"KeyVault:VaultUrl\"] \n            ?? throw new InvalidOperationException(\"KeyVault:VaultUrl configuration is missing\");\n\n        // Create credential based on environment\n        var credential = CreateCredential(configuration);\n        \n        // Create client once and reuse\n        _client = new SecretClient(new Uri(vaultUrl), credential);\n        \n        _logger.LogInformation(\"SecretService initialized with vault: {VaultUrl}\", vaultUrl);\n    }\n\n    private Azure.Core.TokenCredential CreateCredential(IConfiguration configuration)\n    {\n        var environment = configuration[\"Environment\"] ?? \"Development\";\n        \n        _logger.LogInformation(\"Creating credential for environment: {Environment}\", environment);\n\n        return environment.ToLowerInvariant() switch\n        {\n            \"production\" or \"prod\" => CreateProductionCredential(configuration),\n            \"staging\" or \"stage\" => CreateProductionCredential(configuration),\n            \"development\" or \"dev\" => CreateDevelopmentCredential(),\n            _ => throw new InvalidOperationException($\"Unknown environment: {environment}\")\n        };\n    }\n\n    private Azure.Core.TokenCredential CreateProductionCredential(IConfiguration configuration)\n    {\n        // Use Managed Identity in production\n        var clientId = configuration[\"KeyVault:ManagedIdentityClientId\"];\n        \n        if (!string.IsNullOrEmpty(clientId))\n        {\n            _logger.LogInformation(\"Using User-Assigned Managed Identity with ClientId: {ClientId}\", clientId);\n            return new ManagedIdentityCredential(clientId);\n        }\n        \n        _logger.LogInformation(\"Using System-Assigned Managed Identity\");\n        return new ManagedIdentityCredential();\n    }\n\n    private Azure.Core.TokenCredential CreateDevelopmentCredential()\n    {\n        // Use DefaultAzureCredential for local development\n        // This tries: Environment variables -> Managed Identity -> Visual Studio -> Azure CLI -> etc.\n        _logger.LogInformation(\"Using DefaultAzureCredential for development\");\n        \n        var options = new DefaultAzureCredentialOptions\n        {\n            ExcludeInteractiveBrowserCredential = false,\n            ExcludeVisualStudioCredential = false,\n            ExcludeAzureCliCredential = false,\n            ExcludeAzurePowerShellCredential = true,\n            ExcludeSharedTokenCacheCredential = true\n        };\n        \n        return new DefaultAzureCredential(options);\n    }\n\n    public async Task<string> GetSecretAsync(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            throw new ArgumentException(\"Secret name cannot be null or empty\", nameof(name));\n        }\n\n        try\n        {\n            _logger.LogDebug(\"Retrieving secret: {SecretName}\", name);\n            \n            var secret = await _client.GetSecretAsync(name);\n            \n            _logger.LogInformation(\"Successfully retrieved secret: {SecretName}\", name);\n            return secret.Value.Value;\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogError(ex, \"Secret not found: {SecretName}\", name);\n            throw new SecretNotFoundException($\"Secret '{name}' was not found in the vault\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 403)\n        {\n            _logger.LogError(ex, \"Access denied to secret: {SecretName}\", name);\n            throw new SecretAccessDeniedException($\"Access denied to secret '{name}'. Check managed identity permissions.\", ex);\n        }\n        catch (Azure.Identity.AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \"Authentication failed while accessing secret: {SecretName}\", name);\n            throw new SecretAuthenticationException(\"Failed to authenticate with Azure Key Vault\", ex);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving secret: {SecretName}\", name);\n            throw new SecretRetrievalException($\"Failed to retrieve secret '{name}'\", ex);\n        }\n    }\n\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!_disposed)\n        {\n            if (disposing)\n            {\n                // SecretClient doesn't implement IDisposable, but we mark as disposed\n                _logger.LogInformation(\"SecretService disposed\");\n            }\n            _disposed = true;\n        }\n    }\n}\n\n// Custom exceptions for better error handling\npublic class SecretNotFoundException : Exception\n{\n    public SecretNotFoundException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n\npublic class SecretAccessDeniedException : Exception\n{\n    public SecretAccessDeniedException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n\npublic class SecretAuthenticationException : Exception\n{\n    public SecretAuthenticationException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n\npublic class SecretRetrievalException : Exception\n{\n    public SecretRetrievalException(string message, Exception innerException) \n        : base(message, innerException) { }\n}\n```\n\n## Configuration Files\n\n### appsettings.json (Development)\n```json\n{\n  \"Environment\": \"Development\",\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://myvault-dev.vault.azure.net\"\n  },\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"SecretService\": \"Debug\"\n    }\n  }\n}\n```\n\n### appsettings.Production.json\n```json\n{\n  \"Environment\": \"Production\",\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://myvault-prod.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"\"  // Optional: specify for user-assigned identity\n  },\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Warning\",\n      \"SecretService\": \"Information\"\n    }\n  }\n}\n```\n\n## Dependency Injection Setup\n\n```csharp\nusing Microsoft.Extensions.DependencyInjection;\n\npublic static class ServiceCollectionExtensions\n{\n    public static IServiceCollection AddSecretService(this IServiceCollection services)\n    {\n        // Register as singleton to reuse the credential and client\n        services.AddSingleton<SecretService>();\n        \n        return services;\n    }\n}\n\n// In Program.cs or Startup.cs\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var builder = WebApplication.CreateBuilder(args);\n        \n        // Add services\n        builder.Services.AddSecretService();\n        \n        var app = builder.Build();\n        app.Run();\n    }\n}\n```\n\n## Usage Example\n\n```csharp\npublic class MyController : ControllerBase\n{\n    private readonly SecretService _secretService;\n    \n    public MyController(SecretService secretService)\n    {\n        _secretService = secretService;\n    }\n    \n    [HttpGet(\"config\")]\n    public async Task<IActionResult> GetConfiguration()\n    {\n        try\n        {\n            var connectionString = await _secretService.GetSecretAsync(\"DatabaseConnectionString\");\n            // Use the secret...\n            return Ok(\"Configuration loaded\");\n        }\n        catch (SecretNotFoundException)\n        {\n            return NotFound(\"Secret not configured\");\n        }\n        catch (SecretAccessDeniedException)\n        {\n            return StatusCode(403, \"Access denied to secret\");\n        }\n        catch (Exception ex)\n        {\n            return StatusCode(500, \"Failed to retrieve configuration\");\n        }\n    }\n}\n```\n\n## Key Improvements\n\n1. **\u2705 Credential Reuse**: Credential and `SecretClient` created once in constructor\n2. **\u2705 Production-Specific Credential**: Uses `ManagedIdentityCredential` in production\n3. **\u2705 Comprehensive Error Handling**: Specific exceptions for different failure scenarios\n4. **\u2705 Configuration-Based**: Vault URL from configuration, not hardcoded\n5. **\u2705 Environment-Based Selection**: Different credentials for dev/staging/prod\n6. **\u2705 Logging**: Proper logging for debugging and monitoring\n7. **\u2705 Dependency Injection**: Registered as singleton for optimal performance\n8. **\u2705 Custom Exceptions**: Better error handling and diagnostics\n\nThis implementation follows Azure best practices and is production-ready!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 219,
            "output_tokens": 2311,
            "cached": false
          },
          "with_skill": {
            "output": "# Fixed Authentication Code\n\nHere's the corrected implementation addressing all issues:\n\n```csharp\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Azure.Core;\nusing Microsoft.Extensions.Options;\n\npublic class SecretServiceOptions\n{\n    public string KeyVaultUri { get; set; } = string.Empty;\n    public string? ManagedIdentityClientId { get; set; }\n    public bool IsProduction { get; set; }\n}\n\npublic class SecretService\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n\n    public SecretService(\n        IOptions<SecretServiceOptions> options,\n        ILogger<SecretService> logger)\n    {\n        _logger = logger;\n        \n        // Issue #2 Fixed: Environment-based credential selection\n        TokenCredential credential = options.Value.IsProduction\n            ? CreateProductionCredential(options.Value.ManagedIdentityClientId)\n            : new DefaultAzureCredential();\n\n        // Issue #1 Fixed: Credential and client created once and reused\n        // Issue #4 Fixed: Vault URL from configuration\n        _client = new SecretClient(\n            new Uri(options.Value.KeyVaultUri),\n            credential);\n    }\n\n    private static TokenCredential CreateProductionCredential(string? clientId)\n    {\n        // Use deterministic credential in production\n        return string.IsNullOrEmpty(clientId)\n            ? new ManagedIdentityCredential(ManagedIdentityId.SystemAssigned)\n            : new ManagedIdentityCredential(\n                ManagedIdentityId.FromUserAssignedClientId(clientId));\n    }\n\n    // Issue #3 Fixed: Proper error handling\n    public async Task<string> GetSecret(string name)\n    {\n        try\n        {\n            KeyVaultSecret secret = await _client.GetSecretAsync(name);\n            return secret.Value.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \n                \"Authentication failed when retrieving secret '{SecretName}'. \" +\n                \"Verify managed identity has 'Key Vault Secrets User' role.\", \n                name);\n            throw;\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex,\n                \"Credential unavailable when retrieving secret '{SecretName}'. \" +\n                \"Ensure managed identity is properly configured.\",\n                name);\n            throw;\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(ex,\n                \"Secret '{SecretName}' not found in Key Vault.\",\n                name);\n            throw new KeyNotFoundException(\n                $\"Secret '{name}' not found in Key Vault.\", ex);\n        }\n        catch (Azure.RequestFailedException ex)\n        {\n            _logger.LogError(ex,\n                \"Failed to retrieve secret '{SecretName}' from Key Vault. Status: {Status}\",\n                name, ex.Status);\n            throw;\n        }\n    }\n}\n```\n\n## Dependency Injection Registration\n\n```csharp\n// Program.cs or Startup.cs\nusing Azure.Identity;\nusing Microsoft.Extensions.Azure;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure options from appsettings.json\nbuilder.Services.Configure<SecretServiceOptions>(\n    builder.Configuration.GetSection(\"KeyVault\"));\n\n// Register the service\nbuilder.Services.AddSingleton<SecretService>();\n\n// Alternative: Using Microsoft.Extensions.Azure for better DI integration\nbuilder.Services.AddAzureClients(clientBuilder =>\n{\n    var keyVaultUri = builder.Configuration[\"KeyVault:KeyVaultUri\"];\n    var isProduction = builder.Environment.IsProduction();\n    var managedIdentityClientId = builder.Configuration[\"KeyVault:ManagedIdentityClientId\"];\n\n    clientBuilder.AddSecretClient(new Uri(keyVaultUri!));\n    \n    // Environment-based credential\n    clientBuilder.UseCredential(isProduction\n        ? string.IsNullOrEmpty(managedIdentityClientId)\n            ? new ManagedIdentityCredential(ManagedIdentityId.SystemAssigned)\n            : new ManagedIdentityCredential(\n                ManagedIdentityId.FromUserAssignedClientId(managedIdentityClientId))\n        : new DefaultAzureCredential());\n});\n```\n\n## Configuration (appsettings.json)\n\n```json\n{\n  \"KeyVault\": {\n    \"KeyVaultUri\": \"https://myvault.vault.azure.net\",\n    \"ManagedIdentityClientId\": null,\n    \"IsProduction\": false\n  }\n}\n```\n\n## Configuration (appsettings.Production.json)\n\n```json\n{\n  \"KeyVault\": {\n    \"KeyVaultUri\": \"https://prod-vault.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"<user-assigned-mi-client-id>\",\n    \"IsProduction\": true\n  }\n}\n```\n\n## Summary of Fixes\n\n| Issue | Problem | Solution |\n|-------|---------|----------|\n| **#1** | Credential created on every call | Credential and client created once in constructor and reused |\n| **#2** | No production-specific credential | Environment-based selection: `ManagedIdentityCredential` in production, `DefaultAzureCredential` in development |\n| **#3** | No error handling | Comprehensive exception handling with logging for `AuthenticationFailedException`, `CredentialUnavailableException`, and `RequestFailedException` |\n| **#4** | Hardcoded vault URL | Configuration-based URI from `appsettings.json` |\n\n## Key Improvements\n\n1. **Thread-Safe Singleton**: `SecretClient` is created once and safely shared across requests\n2. **Deterministic Production Auth**: Uses `ManagedIdentityCredential` in production for predictable behavior\n3. **Flexible Development Auth**: Uses `DefaultAzureCredential` in development for multiple auth methods\n4. **Proper Exception Handling**: Catches and logs specific authentication and Key Vault errors\n5. **Configuration-Based**: All environment-specific values externalized to configuration\n6. **Logging**: Structured logging for troubleshooting authentication issues\n\n## Testing the Fix\n\n```csharp\n// Unit test with mocked credential\npublic class SecretServiceTests\n{\n    [Fact]\n    public async Task GetSecret_WithValidCredential_ReturnsSecretValue()\n    {\n        // Arrange\n        var options = Options.Create(new SecretServiceOptions\n        {\n            KeyVaultUri = \"https://test-vault.vault.azure.net\",\n            IsProduction = false\n        });\n        var logger = new Mock<ILogger<SecretService>>();\n        var service = new SecretService(options, logger.Object);\n\n        // Act & Assert\n        // Requires actual Key Vault or mock SecretClient\n    }\n}\n```\n\nThis implementation follows Azure SDK best practices and ensures reliable authentication in both development and production environments.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5555,
            "output_tokens": 1740,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll fix all the issues in this code. Let me create an improved version:\n\n```csharp\nusing Azure.Core;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\nnamespace App.Services;\n\npublic class SecretService\n{\n    private readonly SecretClient _client;\n    private readonly ILogger<SecretService> _logger;\n\n    public SecretService(\n        IConfiguration configuration,\n        ILogger<SecretService> logger,\n        IHostEnvironment environment)\n    {\n        _logger = logger;\n\n        // Get vault URL from configuration instead of hardcoding\n        var vaultUrl = configuration[\"KeyVault:VaultUrl\"] \n            ?? throw new InvalidOperationException(\"KeyVault:VaultUrl configuration is missing\");\n\n        // Environment-based credential selection\n        TokenCredential credential = environment.IsProduction()\n            ? CreateProductionCredential(configuration)\n            : new DefaultAzureCredential();\n\n        // Reuse client instance (which reuses the credential)\n        _client = new SecretClient(new Uri(vaultUrl), credential);\n        \n        _logger.LogInformation(\n            \"SecretService initialized with {CredentialType} for environment {Environment}\",\n            credential.GetType().Name,\n            environment.EnvironmentName);\n    }\n\n    private static TokenCredential CreateProductionCredential(IConfiguration configuration)\n    {\n        // Use deterministic ManagedIdentityCredential in production\n        var clientId = configuration[\"KeyVault:ManagedIdentityClientId\"];\n        \n        return string.IsNullOrEmpty(clientId)\n            ? new ManagedIdentityCredential(ManagedIdentityId.SystemAssigned)\n            : new ManagedIdentityCredential(\n                ManagedIdentityId.FromUserAssignedClientId(clientId));\n    }\n\n    public async Task<string> GetSecretAsync(string name)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            throw new ArgumentException(\"Secret name cannot be null or empty\", nameof(name));\n        }\n\n        try\n        {\n            _logger.LogDebug(\"Retrieving secret {SecretName}\", name);\n            \n            var secret = await _client.GetSecretAsync(name);\n            \n            _logger.LogInformation(\"Successfully retrieved secret {SecretName}\", name);\n            return secret.Value.Value;\n        }\n        catch (AuthenticationFailedException ex)\n        {\n            _logger.LogError(ex, \n                \"Authentication failed while retrieving secret {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Failed to authenticate with Key Vault for secret '{name}'\", ex);\n        }\n        catch (CredentialUnavailableException ex)\n        {\n            _logger.LogError(ex, \n                \"Credential unavailable while retrieving secret {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Credential is not available for secret '{name}'\", ex);\n        }\n        catch (Azure.RequestFailedException ex) when (ex.Status == 404)\n        {\n            _logger.LogWarning(\"Secret {SecretName} not found in Key Vault\", name);\n            throw new KeyNotFoundException($\"Secret '{name}' not found in Key Vault\", ex);\n        }\n        catch (Azure.RequestFailedException ex)\n        {\n            _logger.LogError(ex, \n                \"Key Vault request failed while retrieving secret {SecretName}\", name);\n            throw new InvalidOperationException(\n                $\"Failed to retrieve secret '{name}' from Key Vault\", ex);\n        }\n    }\n}\n```\n\nNow let's add the configuration file structure. Create or update `appsettings.json`:\n\n```json\n{\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://myvault.vault.azure.net\"\n  },\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"App.Services.SecretService\": \"Debug\"\n    }\n  }\n}\n```\n\nAnd `appsettings.Production.json`:\n\n```json\n{\n  \"KeyVault\": {\n    \"VaultUrl\": \"https://prod-vault.vault.azure.net\",\n    \"ManagedIdentityClientId\": \"\"\n  }\n}\n```\n\nFinally, register the service in your DI container (in `Program.cs` or `Startup.cs`):\n\n```csharp\n// In Program.cs\nbuilder.Services.AddSingleton<SecretService>();\n```\n\n## Summary of Fixes\n\n1. **\u2705 Credential Reuse**: Credential is now created once in the constructor and reused via the `_client` instance\n2. **\u2705 Production-Specific Credential**: Uses `ManagedIdentityCredential` in production (deterministic), `DefaultAzureCredential` in development\n3. **\u2705 Error Handling**: Comprehensive exception handling for:\n   - `AuthenticationFailedException`\n   - `CredentialUnavailableException`\n   - `RequestFailedException` (404 and other errors)\n4. **\u2705 Configuration-Based URL**: Vault URL comes from configuration, not hardcoded\n5. **\u2705 Logging**: Added structured logging for debugging and monitoring\n6. **\u2705 Async Naming**: Renamed method to `GetSecretAsync` following .NET conventions\n7. **\u2705 Input Validation**: Added null/empty check for secret name\n\nThe service is now production-ready with proper credential management, error handling, and configuration!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6061,
            "output_tokens": 1351,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-identity-dotnet-05",
      "task_type": "adjacent_domain",
      "target_language": "csharp",
      "expected_patterns": [
        "AddAuthentication|AddJwtBearer",
        "JwtBearerDefaults",
        "TokenValidationParameters",
        "\\[Authorize.*\\]",
        "ClaimsTransformation|IClaimsTransformation",
        "builder\\.Services|app\\.UseAuthentication"
      ],
      "anti_patterns": [
        "DefaultAzureCredential",
        "ManagedIdentityCredential",
        "ClientSecretCredential",
        "Azure\\.Identity",
        "SecretClient",
        "BlobServiceClient"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/aspnet/core/security/authentication/jwt-authn",
          "description": "ASP.NET Core JWT authentication docs - source of AddAuthentication, AddJwtBearer, and TokenValidationParameters patterns"
        },
        {
          "url": "https://learn.microsoft.com/en-us/aspnet/core/security/authorization/claims",
          "description": "ASP.NET Core claims-based authorization docs - source of IClaimsTransformation and [Authorize] attribute patterns"
        },
        {
          "url": "https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.jwtbearer.jwtbearerdefaults",
          "description": "JwtBearerDefaults class - source of JwtBearerDefaults.AuthenticationScheme constant for JWT Bearer authentication scheme"
        },
        {
          "url": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis",
          "description": "ASP.NET Core Minimal APIs - source of builder.Services for DI registration and app.UseAuthentication middleware registration as required for JWT middleware setup"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# JWT Bearer Token Authentication Middleware with Claims Transformation\n\nI'll create a comprehensive JWT authentication solution with JWKS validation, claims checking, and role mapping.\n\n## 1. Project Setup\n\n```xml\n<!-- Add to your .csproj file -->\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.AspNetCore.Authentication.JwtBearer\" Version=\"8.0.0\" />\n    <PackageReference Include=\"System.IdentityModel.Tokens.Jwt\" Version=\"7.0.0\" />\n    <PackageReference Include=\"Microsoft.IdentityModel.Protocols.OpenIdConnect\" Version=\"7.0.0\" />\n  </ItemGroup>\n</Project>\n```\n\n## 2. Configuration Models\n\n```csharp\n// Models/JwtSettings.cs\nnamespace JwtAuthMiddleware.Models\n{\n    public class JwtSettings\n    {\n        public string Authority { get; set; } = string.Empty;\n        public string Audience { get; set; } = string.Empty;\n        public string Issuer { get; set; } = string.Empty;\n        public string JwksEndpoint { get; set; } = string.Empty;\n        public bool RequireHttpsMetadata { get; set; } = true;\n        public bool ValidateIssuer { get; set; } = true;\n        public bool ValidateAudience { get; set; } = true;\n        public bool ValidateLifetime { get; set; } = true;\n        public int ClockSkew { get; set; } = 300; // 5 minutes in seconds\n        public Dictionary<string, string> RoleMappings { get; set; } = new();\n    }\n\n    public class RequiredClaims\n    {\n        public bool RequireSubject { get; set; } = true;\n        public bool RequireEmail { get; set; } = true;\n        public bool RequireRoles { get; set; } = false;\n        public List<string> AdditionalRequiredClaims { get; set; } = new();\n    }\n}\n```\n\n## 3. Claims Transformation Service\n\n```csharp\n// Services/ClaimsTransformationService.cs\nusing Microsoft.AspNetCore.Authentication;\nusing System.Security.Claims;\n\nnamespace JwtAuthMiddleware.Services\n{\n    public class ClaimsTransformationService : IClaimsTransformation\n    {\n        private readonly ILogger<ClaimsTransformationService> _logger;\n        private readonly Dictionary<string, string> _roleMappings;\n\n        public ClaimsTransformationService(\n            ILogger<ClaimsTransformationService> logger,\n            IConfiguration configuration)\n        {\n            _logger = logger;\n            \n            // Load role mappings from configuration\n            var jwtSettings = configuration.GetSection(\"JwtSettings\").Get<JwtSettings>();\n            _roleMappings = jwtSettings?.RoleMappings ?? new Dictionary<string, string>();\n        }\n\n        public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)\n        {\n            if (principal.Identity?.IsAuthenticated != true)\n            {\n                return Task.FromResult(principal);\n            }\n\n            var claimsIdentity = (ClaimsIdentity)principal.Identity;\n            \n            // Transform external roles to application roles\n            var externalRoles = principal.FindAll(ClaimTypes.Role).ToList();\n            var externalRolesFromClaim = principal.FindAll(\"roles\").ToList();\n            \n            // Combine both role claim types\n            var allRoles = externalRoles.Concat(externalRolesFromClaim)\n                .Select(c => c.Value)\n                .Distinct()\n                .ToList();\n\n            _logger.LogDebug(\"Found {Count} external roles for user {UserId}\", \n                allRoles.Count, \n                principal.FindFirst(ClaimTypes.NameIdentifier)?.Value);\n\n            // Add mapped roles\n            foreach (var externalRole in allRoles)\n            {\n                if (_roleMappings.TryGetValue(externalRole, out var mappedRole))\n                {\n                    _logger.LogDebug(\"Mapping external role '{ExternalRole}' to '{MappedRole}'\", \n                        externalRole, mappedRole);\n                    \n                    claimsIdentity.AddClaim(new Claim(ClaimTypes.Role, mappedRole));\n                    claimsIdentity.AddClaim(new Claim(\"app_role\", mappedRole));\n                }\n                else\n                {\n                    // Keep original role if no mapping exists\n                    if (!claimsIdentity.HasClaim(ClaimTypes.Role, externalRole))\n                    {\n                        claimsIdentity.AddClaim(new Claim(ClaimTypes.Role, externalRole));\n                    }\n                }\n            }\n\n            // Add custom claims\n            AddCustomClaims(claimsIdentity, principal);\n\n            return Task.FromResult(principal);\n        }\n\n        private void AddCustomClaims(ClaimsIdentity identity, ClaimsPrincipal principal)\n        {\n            // Add email as a standard claim if it exists\n            var email = principal.FindFirst(\"email\")?.Value \n                ?? principal.FindFirst(ClaimTypes.Email)?.Value;\n            \n            if (!string.IsNullOrEmpty(email) && !identity.HasClaim(ClaimTypes.Email, email))\n            {\n                identity.AddClaim(new Claim(ClaimTypes.Email, email));\n            }\n\n            // Add name claims\n            var name = principal.FindFirst(\"name\")?.Value \n                ?? principal.FindFirst(ClaimTypes.Name)?.Value;\n            \n            if (!string.IsNullOrEmpty(name) && !identity.HasClaim(ClaimTypes.Name, name))\n            {\n                identity.AddClaim(new Claim(ClaimTypes.Name, name));\n            }\n\n            // Add subject as NameIdentifier\n            var sub = principal.FindFirst(\"sub\")?.Value \n                ?? principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n            \n            if (!string.IsNullOrEmpty(sub) && !identity.HasClaim(ClaimTypes.NameIdentifier, sub))\n            {\n                identity.AddClaim(new Claim(ClaimTypes.NameIdentifier, sub));\n            }\n        }\n    }\n}\n```\n\n## 4. JWT Validation Middleware\n\n```csharp\n// Middleware/JwtValidationMiddleware.cs\nusing System.Security.Claims;\nusing Microsoft.AspNetCore.Authentication;\n\nnamespace JwtAuthMiddleware.Middleware\n{\n    public class JwtValidationMiddleware\n    {\n        private readonly RequestDelegate _next;\n        private readonly ILogger<JwtValidationMiddleware> _logger;\n        private readonly RequiredClaims _requiredClaims;\n\n        public JwtValidationMiddleware(\n            RequestDelegate next,\n            ILogger<JwtValidationMiddleware> logger,\n            IConfiguration configuration)\n        {\n            _next = next;\n            _logger = logger;\n            _requiredClaims = configuration.GetSection(\"RequiredClaims\")\n                .Get<RequiredClaims>() ?? new RequiredClaims();\n        }\n\n        public async Task InvokeAsync(HttpContext context)\n        {\n            // Skip validation for anonymous endpoints\n            var endpoint = context.GetEndpoint();\n            var allowAnonymous = endpoint?.Metadata\n                .GetMetadata<Microsoft.AspNetCore.Authorization.IAllowAnonymous>() != null;\n\n            if (allowAnonymous)\n            {\n                await _next(context);\n                return;\n            }\n\n            // Check if user is authenticated\n            if (context.User.Identity?.IsAuthenticated == true)\n            {\n                var validationResult = ValidateRequiredClaims(context.User);\n                \n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\n                        \"JWT validation failed for user {UserId}: {Reason}\",\n                        context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? \"unknown\",\n                        validationResult.ErrorMessage);\n\n                    context.Response.StatusCode = StatusCodes.Status403Forbidden;\n                    await context.Response.WriteAsJsonAsync(new\n                    {\n                        error = \"invalid_token\",\n                        error_description = validationResult.ErrorMessage\n                    });\n                    return;\n                }\n\n                _logger.LogDebug(\n                    \"JWT validation successful for user {UserId}\",\n                    context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value);\n            }\n\n            await _next(context);\n        }\n\n        private ValidationResult ValidateRequiredClaims(ClaimsPrincipal principal)\n        {\n            // Check for subject claim\n            if (_requiredClaims.RequireSubject)\n            {\n                var sub = principal.FindFirst(\"sub\")?.Value \n                    ?? principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n                \n                if (string.IsNullOrEmpty(sub))\n                {\n                    return ValidationResult.Failure(\"Missing required 'sub' claim\");\n                }\n            }\n\n            // Check for email claim\n            if (_requiredClaims.RequireEmail)\n            {\n                var email = principal.FindFirst(\"email\")?.Value \n                    ?? principal.FindFirst(ClaimTypes.Email)?.Value;\n                \n                if (string.IsNullOrEmpty(email))\n                {\n                    return ValidationResult.Failure(\"Missing required 'email' claim\");\n                }\n            }\n\n            // Check for roles claim\n            if (_requiredClaims.RequireRoles)\n            {\n                var roles = principal.FindAll(ClaimTypes.Role)\n                    .Concat(principal.FindAll(\"roles\"))\n                    .ToList();\n                \n                if (!roles.Any())\n                {\n                    return ValidationResult.Failure(\"Missing required 'roles' claim\");\n                }\n            }\n\n            // Check for additional required claims\n            foreach (var claimType in _requiredClaims.AdditionalRequiredClaims)\n            {\n                if (!principal.HasClaim(c => c.Type == claimType))\n                {\n                    return ValidationResult.Failure($\"Missing required '{claimType}' claim\");\n                }\n            }\n\n            return ValidationResult.Success();\n        }\n\n        private class ValidationResult\n        {\n            public bool IsValid { get; set; }\n            public string ErrorMessage { get; set; } = string.Empty;\n\n            public static ValidationResult Success() => new() { IsValid = true };\n            public static ValidationResult Failure(string message) => \n                new() { IsValid = false, ErrorMessage = message };\n        }\n    }\n}\n```\n\n## 5. Custom Authorization Handler\n\n```csharp\n// Authorization/RoleAuthorizationHandler.cs\nusing Microsoft.AspNetCore.Authorization;\nusing System.Security.Claims;\n\nnamespace JwtAuthMiddleware.Authorization\n{\n    public class RoleRequirement : IAuthorizationRequirement\n    {\n        public string[] Roles { get; }\n\n        public RoleRequirement(params string[] roles)\n        {\n            Roles = roles;\n        }\n    }\n\n    public class RoleAuthorizationHandler : AuthorizationHandler<RoleRequirement>\n    {\n        private readonly ILogger<RoleAuthorizationHandler> _logger;\n\n        public RoleAuthorizationHandler(ILogger<RoleAuthorizationHandler> logger)\n        {\n            _logger = logger;\n        }\n\n        protected override Task HandleRequirementAsync(\n            AuthorizationHandlerContext context,\n            RoleRequirement requirement)\n        {\n            var user = context.User;\n            var userId = user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? \"unknown\";\n\n            if (!user.Identity?.IsAuthenticated ?? true)\n            {\n                _logger.LogWarning(\"Authorization failed: User {UserId} is not authenticated\", userId);\n                return Task.CompletedTask;\n            }\n\n            var userRoles = user.FindAll(ClaimTypes.Role)\n                .Select(c => c.Value)\n                .ToList();\n\n            _logger.LogDebug(\n                \"Checking authorization for user {UserId} with roles: {Roles}\",\n                userId,\n                string.Join(\", \", userRoles));\n\n            foreach (var requiredRole in requirement.Roles)\n            {\n                if (userRoles.Contains(requiredRole, StringComparer.OrdinalIgnoreCase))\n                {\n                    _logger.LogDebug(\n                        \"User {UserId} authorized with role {Role}\",\n                        userId,\n                        requiredRole);\n                    \n                    context.Succeed(requirement);\n                    return Task.CompletedTask;\n                }\n            }\n\n            _logger.LogWarning(\n                \"Authorization failed: User {UserId} does not have any of the required roles: {RequiredRoles}\",\n                userId,\n                string.Join(\", \", requirement.Roles));\n\n            return Task.CompletedTask;\n        }\n    }\n}\n```\n\n## 6. Custom Authorization Attributes\n\n```csharp\n// Authorization/CustomAuthorizeAttribute.cs\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace JwtAuthMiddleware.Authorization\n{\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]\n    public class RequireRoleAttribute : AuthorizeAttribute\n    {\n        public RequireRoleAttribute(params string[] roles)\n        {\n            Roles = string.Join(\",\", roles);\n            Policy = $\"RequireRole_{string.Join(\"_\", roles)}\";\n        }\n    }\n\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]\n    public class RequireClaimAttribute : AuthorizeAttribute\n    {\n        public RequireClaimAttribute(string claimType, string claimValue)\n        {\n            Policy = $\"RequireClaim_{claimType}_{claimValue}\";\n        }\n    }\n}\n```\n\n## 7. JWT Events Handler\n\n```csharp\n// Services/JwtBearerEventsHandler.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\n\nnamespace JwtAuthMiddleware.Services\n{\n    public class JwtBearerEventsHandler : JwtBearerEvents\n    {\n        private readonly ILogger<JwtBearerEventsHandler> _logger;\n\n        public JwtBearerEventsHandler(ILogger<JwtBearerEventsHandler> logger)\n        {\n            _logger = logger;\n        }\n\n        public override Task AuthenticationFailed(AuthenticationFailedContext context)\n        {\n            _logger.LogError(\n                context.Exception,\n                \"JWT authentication failed: {Message}\",\n                context.Exception.Message);\n\n            context.Response.StatusCode = StatusCodes.Status401Unauthorized;\n            context.Response.ContentType = \"application/json\";\n\n            var result = System.Text.Json.JsonSerializer.Serialize(new\n            {\n                error = \"invalid_token\",\n                error_description = \"The access token is invalid or expired\"\n            });\n\n            return context.Response.WriteAsync(result);\n        }\n\n        public override Task TokenValidated(TokenValidatedContext context)\n        {\n            var userId = context.Principal?.FindFirst(\"sub\")?.Value ?? \"unknown\";\n            _logger.LogInformation(\"Token validated successfully for user {UserId}\", userId);\n            \n            return Task.CompletedTask;\n        }\n\n        public override Task Challenge(JwtBearerChallengeContext context)\n        {\n            _logger.LogWarning(\n                \"JWT authentication challenge: {Error} - {ErrorDescription}\",\n                context.Error,\n                context.ErrorDescription);\n\n            return base.Challenge(context);\n        }\n\n        public override Task MessageReceived(MessageReceivedContext context)\n        {\n            // Support token from query string (useful for SignalR, etc.)\n            var token = context.Request.Query[\"access_token\"].FirstOrDefault();\n            \n            if (!string.IsNullOrEmpty(token))\n            {\n                context.Token = token;\n                _logger.LogDebug(\"Token received from query string\");\n            }\n\n            return Task.CompletedTask;\n        }\n    }\n}\n```\n\n## 8. Program.cs Configuration\n\n```csharp\n// Program.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.IdentityModel",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 91,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# JWT Bearer Authentication Middleware with Claims Transformation\n\nI'll create a comprehensive JWT authentication solution with JWKS validation, claims checking, and role mapping.\n\n## Project Structure\n\n```\nJwtAuthDemo/\n\u251c\u2500\u2500 Program.cs\n\u251c\u2500\u2500 appsettings.json\n\u251c\u2500\u2500 Authentication/\n\u2502   \u251c\u2500\u2500 JwtBearerConfiguration.cs\n\u2502   \u251c\u2500\u2500 ClaimsTransformation.cs\n\u2502   \u2514\u2500\u2500 RequiredClaimsAuthorizationHandler.cs\n\u251c\u2500\u2500 Authorization/\n\u2502   \u251c\u2500\u2500 RoleMapping.cs\n\u2502   \u2514\u2500\u2500 Policies.cs\n\u251c\u2500\u2500 Middleware/\n\u2502   \u2514\u2500\u2500 JwtValidationMiddleware.cs\n\u251c\u2500\u2500 Controllers/\n\u2502   \u2514\u2500\u2500 SecureController.cs\n\u2514\u2500\u2500 Models/\n    \u2514\u2500\u2500 UserClaims.cs\n```\n\n## Installation\n\n```bash\ndotnet new webapi -n JwtAuthDemo\ncd JwtAuthDemo\n\ndotnet add package Microsoft.AspNetCore.Authentication.JwtBearer\ndotnet add package System.IdentityModel.Tokens.Jwt\ndotnet add package Microsoft.Identity.Web\n```\n\n## 1. Configuration (appsettings.json)\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"JwtBearer\": {\n    \"Authority\": \"https://your-identity-provider.com\",\n    \"Audience\": \"your-api-audience\",\n    \"MetadataAddress\": \"https://your-identity-provider.com/.well-known/openid-configuration\",\n    \"RequireHttpsMetadata\": true,\n    \"ValidateIssuer\": true,\n    \"ValidateAudience\": true,\n    \"ValidateLifetime\": true,\n    \"ValidateIssuerSigningKey\": true,\n    \"ClockSkew\": \"00:05:00\",\n    \"RequiredClaims\": [\"sub\", \"email\", \"roles\"]\n  },\n  \"RoleMapping\": {\n    \"ExternalToInternal\": {\n      \"external-admin\": \"Admin\",\n      \"external-user\": \"User\",\n      \"external-moderator\": \"Moderator\",\n      \"external-viewer\": \"Viewer\"\n    }\n  }\n}\n```\n\n## 2. JWT Configuration Model\n\n**Authentication/JwtBearerConfiguration.cs**\n\n```csharp\nusing System.ComponentModel.DataAnnotations;\n\nnamespace JwtAuthDemo.Authentication;\n\npublic class JwtBearerConfiguration\n{\n    public const string SectionName = \"JwtBearer\";\n\n    [Required]\n    public string Authority { get; set; } = string.Empty;\n\n    [Required]\n    public string Audience { get; set; } = string.Empty;\n\n    public string? MetadataAddress { get; set; }\n\n    public bool RequireHttpsMetadata { get; set; } = true;\n\n    public bool ValidateIssuer { get; set; } = true;\n\n    public bool ValidateAudience { get; set; } = true;\n\n    public bool ValidateLifetime { get; set; } = true;\n\n    public bool ValidateIssuerSigningKey { get; set; } = true;\n\n    public TimeSpan ClockSkew { get; set; } = TimeSpan.FromMinutes(5);\n\n    public List<string> RequiredClaims { get; set; } = new();\n}\n```\n\n## 3. Role Mapping Configuration\n\n**Authorization/RoleMapping.cs**\n\n```csharp\nnamespace JwtAuthDemo.Authorization;\n\npublic class RoleMappingConfiguration\n{\n    public const string SectionName = \"RoleMapping\";\n\n    public Dictionary<string, string> ExternalToInternal { get; set; } = new();\n}\n\npublic static class ApplicationRoles\n{\n    public const string Admin = \"Admin\";\n    public const string User = \"User\";\n    public const string Moderator = \"Moderator\";\n    public const string Viewer = \"Viewer\";\n}\n```\n\n## 4. Authorization Policies\n\n**Authorization/Policies.cs**\n\n```csharp\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace JwtAuthDemo.Authorization;\n\npublic static class AuthorizationPolicies\n{\n    public const string RequireAdminRole = \"RequireAdminRole\";\n    public const string RequireModeratorRole = \"RequireModeratorRole\";\n    public const string RequireUserRole = \"RequireUserRole\";\n    public const string RequireEmailVerified = \"RequireEmailVerified\";\n    public const string RequireAllClaims = \"RequireAllClaims\";\n\n    public static void AddPolicies(AuthorizationOptions options)\n    {\n        // Role-based policies\n        options.AddPolicy(RequireAdminRole, policy =>\n            policy.RequireRole(ApplicationRoles.Admin));\n\n        options.AddPolicy(RequireModeratorRole, policy =>\n            policy.RequireRole(ApplicationRoles.Moderator, ApplicationRoles.Admin));\n\n        options.AddPolicy(RequireUserRole, policy =>\n            policy.RequireRole(ApplicationRoles.User, ApplicationRoles.Moderator, ApplicationRoles.Admin));\n\n        // Claims-based policies\n        options.AddPolicy(RequireEmailVerified, policy =>\n            policy.RequireClaim(\"email_verified\", \"true\"));\n\n        // Custom requirement\n        options.AddPolicy(RequireAllClaims, policy =>\n            policy.Requirements.Add(new RequiredClaimsRequirement()));\n    }\n}\n```\n\n## 5. Required Claims Authorization Handler\n\n**Authentication/RequiredClaimsAuthorizationHandler.cs**\n\n```csharp\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Options;\n\nnamespace JwtAuthDemo.Authentication;\n\npublic class RequiredClaimsRequirement : IAuthorizationRequirement\n{\n}\n\npublic class RequiredClaimsAuthorizationHandler : AuthorizationHandler<RequiredClaimsRequirement>\n{\n    private readonly JwtBearerConfiguration _jwtConfig;\n    private readonly ILogger<RequiredClaimsAuthorizationHandler> _logger;\n\n    public RequiredClaimsAuthorizationHandler(\n        IOptions<JwtBearerConfiguration> jwtConfig,\n        ILogger<RequiredClaimsAuthorizationHandler> logger)\n    {\n        _jwtConfig = jwtConfig.Value;\n        _logger = logger;\n    }\n\n    protected override Task HandleRequirementAsync(\n        AuthorizationHandlerContext context,\n        RequiredClaimsRequirement requirement)\n    {\n        var user = context.User;\n\n        if (user?.Identity?.IsAuthenticated != true)\n        {\n            _logger.LogWarning(\"User is not authenticated\");\n            context.Fail();\n            return Task.CompletedTask;\n        }\n\n        var missingClaims = new List<string>();\n\n        foreach (var requiredClaim in _jwtConfig.RequiredClaims)\n        {\n            if (!user.HasClaim(c => c.Type == requiredClaim))\n            {\n                missingClaims.Add(requiredClaim);\n            }\n        }\n\n        if (missingClaims.Any())\n        {\n            _logger.LogWarning(\n                \"User {UserId} is missing required claims: {MissingClaims}\",\n                user.FindFirst(\"sub\")?.Value ?? \"unknown\",\n                string.Join(\", \", missingClaims));\n            \n            context.Fail();\n            return Task.CompletedTask;\n        }\n\n        _logger.LogInformation(\n            \"User {UserId} has all required claims\",\n            user.FindFirst(\"sub\")?.Value);\n\n        context.Succeed(requirement);\n        return Task.CompletedTask;\n    }\n}\n```\n\n## 6. Claims Transformation\n\n**Authentication/ClaimsTransformation.cs**\n\n```csharp\nusing Microsoft.AspNetCore.Authentication;\nusing Microsoft.Extensions.Options;\nusing System.Security.Claims;\nusing JwtAuthDemo.Authorization;\n\nnamespace JwtAuthDemo.Authentication;\n\npublic class RoleClaimsTransformation : IClaimsTransformation\n{\n    private readonly RoleMappingConfiguration _roleMapping;\n    private readonly ILogger<RoleClaimsTransformation> _logger;\n\n    public RoleClaimsTransformation(\n        IOptions<RoleMappingConfiguration> roleMapping,\n        ILogger<RoleClaimsTransformation> logger)\n    {\n        _roleMapping = roleMapping.Value;\n        _logger = logger;\n    }\n\n    public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)\n    {\n        if (principal.Identity?.IsAuthenticated != true)\n        {\n            return Task.FromResult(principal);\n        }\n\n        var claimsIdentity = (ClaimsIdentity)principal.Identity;\n        var userId = principal.FindFirst(\"sub\")?.Value ?? \"unknown\";\n\n        // Get external roles from token\n        var externalRoles = principal.FindAll(\"roles\")\n            .Select(c => c.Value)\n            .ToList();\n\n        if (!externalRoles.Any())\n        {\n            // Also check for 'role' claim (singular)\n            externalRoles = principal.FindAll(\"role\")\n                .Select(c => c.Value)\n                .ToList();\n        }\n\n        _logger.LogInformation(\n            \"Transforming claims for user {UserId}. External roles: {ExternalRoles}\",\n            userId,\n            string.Join(\", \", externalRoles));\n\n        // Map external roles to internal roles\n        var mappedRoles = new HashSet<string>();\n        foreach (var externalRole in externalRoles)\n        {\n            if (_roleMapping.ExternalToInternal.TryGetValue(externalRole, out var internalRole))\n            {\n                mappedRoles.Add(internalRole);\n                _logger.LogDebug(\n                    \"Mapped external role '{ExternalRole}' to internal role '{InternalRole}' for user {UserId}\",\n                    externalRole, internalRole, userId);\n            }\n            else\n            {\n                _logger.LogWarning(\n                    \"No mapping found for external role '{ExternalRole}' for user {UserId}\",\n                    externalRole, userId);\n            }\n        }\n\n        // Add mapped roles as ClaimTypes.Role claims\n        foreach (var role in mappedRoles)\n        {\n            claimsIdentity.AddClaim(new Claim(ClaimTypes.Role, role));\n        }\n\n        // Add custom claims for easier access\n        var email = principal.FindFirst(\"email\")?.Value;\n        if (!string.IsNullOrEmpty(email))\n        {\n            claimsIdentity.AddClaim(new Claim(ClaimTypes.Email, email));\n        }\n\n        var name = principal.FindFirst(\"name\")?.Value;\n        if (!string.IsNullOrEmpty(name))\n        {\n            claimsIdentity.AddClaim(new Claim(ClaimTypes.Name, name));\n        }\n\n        _logger.LogInformation(\n            \"Claims transformation complete for user {UserId}. Internal roles: {InternalRoles}\",\n            userId,\n            string.Join(\", \", mappedRoles));\n\n        return Task.FromResult(principal);\n    }\n}\n```\n\n## 7. JWT Validation Middleware\n\n**Middleware/JwtValidationMiddleware.cs**\n\n```csharp\nusing System.IdentityModel.Tokens.Jwt;\nusing Microsoft.Extensions.Options;\nusing JwtAuthDemo.Authentication;\n\nnamespace JwtAuthDemo.Middleware;\n\npublic class JwtValidationMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogger<JwtValidationMiddleware> _logger;\n    private readonly JwtBearerConfiguration _jwtConfig;\n\n    public JwtValidationMiddleware(\n        RequestDelegate next,\n        ILogger<JwtValidationMiddleware> logger,\n        IOptions<JwtBearerConfiguration> jwtConfig)\n    {\n        _next = next;\n        _logger = logger;\n        _jwtConfig = jwtConfig.Value;\n    }\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        var token = ExtractToken(context);\n\n        if (!string.IsNullOrEmpty(token))\n        {\n            try\n            {\n                var handler = new JwtSecurityTokenHandler();\n                var jwtToken = handler.ReadJwtToken(token);\n\n                // Log token information\n                _logger.LogDebug(\n                    \"JWT Token - Issuer: {Issuer}, Audience: {Audience}, Expires: {Expires}\",\n                    jwtToken.Issuer,\n                    string.Join(\", \", jwtToken.Audiences),\n                    jwtToken.ValidTo);\n\n                // Check for required claims\n                var missingClaims = _jwtConfig.RequiredClaims\n                    .Where(claim => !jwtToken.Claims.Any(c => c.Type == claim))\n                    .ToList();\n\n                if (missingClaims.Any())\n                {\n                    _logger.LogWarning(\n                        \"Token is missing required claims: {MissingClaims}\",\n                        string.Join(\", \", missingClaims));\n                }\n\n                // Add token info to context for downstream use\n                context.Items[\"JwtToken\"] = jwtToken;\n                context.Items[\"TokenExpiry\"] = jwtToken.ValidTo;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to parse JWT token\");\n            }\n        }\n\n        await _next(context);\n    }\n\n    private static string? ExtractToken(HttpContext context)\n    {\n        var authHeader = context.Request.Headers.Authorization.FirstOrDefault();\n        \n        if (string.IsNullOrEmpty(authHeader))\n        {\n            return null;\n        }\n\n        if (authHeader.StartsWith(\"Bearer \", StringComparison.OrdinalIgnoreCase))\n        {\n            return authHeader[\"Bearer \".Length..].Trim();\n        }\n\n        return null;\n    }\n}\n\npublic static class JwtValidationMiddlewareExtensions\n{\n    public static IApplicationBuilder UseJwtValidation(this IApplicationBuilder builder)\n    {\n        return builder.UseMiddleware<JwtValidationMiddleware>();\n    }\n}\n```\n\n## 8. User Claims Model\n\n**Models/UserClaims.cs**\n\n```csharp\nusing System.Security.Claims;\n\nnamespace JwtAuthDemo.Models;\n\npublic class UserClaimsModel\n{\n    public string UserId { get; set; } = string.Empty;\n    public string Email { get; set; } = string.Empty;\n    public string Name { get; set; } = string.Empty;\n    public List<string> Roles { get; set; } = new();\n    public Dictionary<string, string> AllClaims { get; set; } = new();\n\n    public static UserClaimsModel FromClaimsPrincipal(ClaimsPrincipal principal)\n    {\n        return new UserClaimsModel\n        {\n            UserId = principal.FindFirst(\"sub\")?.Value ?? string.Empty,\n            Email = principal.FindFirst(ClaimTypes.Email)?.Value \n                   ?? principal.FindFirst(\"email\")?.Value \n                   ?? string.Empty,\n            Name = principal.FindFirst(ClaimTypes.Name)?.Value \n                  ?? principal.FindFirst(\"name\")?.Value \n                  ?? string.Empty,\n            Roles = principal.FindAll(ClaimTypes.Role)\n                .Select(c => c.Value)\n                .ToList(),\n            AllClaims = principal.Claims\n                .GroupBy(c => c.Type)\n                .ToDictionary(\n                    g => g.Key,\n                    g => string.Join(\", \", g.Select(c => c.Value)))\n        };\n    }\n}\n```\n\n## 9. Secure Controller\n\n**Controllers/SecureController.cs**\n\n```csharp\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing JwtAuthDemo.Authorization;\nusing JwtAuthDemo.Models;\n\nnamespace JwtAuthDemo.Controllers;\n\n[ApiController]\n[Route(\"api/[controller]\")]\n[Authorize] // Requires authentication for all endpoints\npublic class SecureController : ControllerBase\n{\n    private readonly ILogger<SecureController> _logger;\n\n    public SecureController(ILogger<SecureController> logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Public endpoint - no authentication required\n    /// </summary>\n    [AllowAnonymous]\n    [HttpGet(\"public\")]\n    public IActionResult GetPublic()\n    {",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5427,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive JWT authentication middleware solution with claims transformation and role-based authorization.\n\n```csharp\n// Middleware/JwtAuthenticationMiddleware.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Security.Claims;\n\nnamespace App.Middleware;\n\npublic static class JwtAuthenticationMiddleware\n{\n    public static IServiceCollection AddJwtAuthentication(\n        this IServiceCollection services,\n        IConfiguration configuration)\n    {\n        var jwtSettings = configuration.GetSection(\"JwtSettings\");\n        var authority = jwtSettings[\"Authority\"];\n        var audience = jwtSettings[\"Audience\"];\n        var requireHttpsMetadata = jwtSettings.GetValue<bool>(\"RequireHttpsMetadata\", true);\n\n        services.AddAuthentication(options =>\n        {\n            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n        })\n        .AddJwtBearer(options =>\n        {\n            options.Authority = authority;\n            options.Audience = audience;\n            options.RequireHttpsMetadata = requireHttpsMetadata;\n            \n            options.TokenValidationParameters = new TokenValidationParameters\n            {\n                ValidateIssuer = true,\n                ValidateAudience = true,\n                ValidateLifetime = true,\n                ValidateIssuerSigningKey = true,\n                ValidAudience = audience,\n                ValidIssuer = authority,\n                ClockSkew = TimeSpan.FromMinutes(5),\n                RoleClaimType = ClaimTypes.Role,\n                NameClaimType = \"sub\"\n            };\n\n            options.Events = new JwtBearerEvents\n            {\n                OnAuthenticationFailed = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    \n                    logger.LogWarning(\n                        \"JWT authentication failed: {Message}\",\n                        context.Exception.Message);\n                    \n                    return Task.CompletedTask;\n                },\n                OnTokenValidated = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    \n                    var claimsIdentity = context.Principal?.Identity as ClaimsIdentity;\n                    var sub = claimsIdentity?.FindFirst(\"sub\")?.Value;\n                    var email = claimsIdentity?.FindFirst(\"email\")?.Value;\n                    \n                    if (string.IsNullOrEmpty(sub))\n                    {\n                        logger.LogWarning(\"Token missing required 'sub' claim\");\n                        context.Fail(\"Token missing required 'sub' claim\");\n                        return Task.CompletedTask;\n                    }\n                    \n                    if (string.IsNullOrEmpty(email))\n                    {\n                        logger.LogWarning(\"Token missing required 'email' claim for user {Sub}\", sub);\n                        context.Fail(\"Token missing required 'email' claim\");\n                        return Task.CompletedTask;\n                    }\n                    \n                    logger.LogInformation(\n                        \"JWT token validated for user {Sub} ({Email})\",\n                        sub,\n                        email);\n                    \n                    return Task.CompletedTask;\n                },\n                OnChallenge = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    \n                    logger.LogWarning(\n                        \"JWT authentication challenge: {Error} - {ErrorDescription}\",\n                        context.Error,\n                        context.ErrorDescription);\n                    \n                    return Task.CompletedTask;\n                }\n            };\n        });\n\n        services.AddAuthorization(options =>\n        {\n            options.AddPolicy(\"RequireAdminRole\", policy =>\n                policy.RequireRole(\"Admin\"));\n            \n            options.AddPolicy(\"RequireManagerRole\", policy =>\n                policy.RequireRole(\"Manager\", \"Admin\"));\n            \n            options.AddPolicy(\"RequireUserRole\", policy =>\n                policy.RequireRole(\"User\", \"Manager\", \"Admin\"));\n            \n            options.AddPolicy(\"RequireEmailVerified\", policy =>\n                policy.RequireClaim(\"email_verified\", \"true\"));\n        });\n\n        services.AddScoped<IClaimsTransformation, RoleClaimsTransformation>();\n\n        return services;\n    }\n}\n```\n\n```csharp\n// Services/RoleClaimsTransformation.cs\nusing Microsoft.AspNetCore.Authentication;\nusing System.Security.Claims;\n\nnamespace App.Services;\n\npublic class RoleClaimsTransformation : IClaimsTransformation\n{\n    private readonly ILogger<RoleClaimsTransformation> _logger;\n    private readonly IConfiguration _configuration;\n\n    public RoleClaimsTransformation(\n        ILogger<RoleClaimsTransformation> logger,\n        IConfiguration configuration)\n    {\n        _logger = logger;\n        _configuration = configuration;\n    }\n\n    public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)\n    {\n        var claimsIdentity = principal.Identity as ClaimsIdentity;\n        if (claimsIdentity == null || !claimsIdentity.IsAuthenticated)\n        {\n            return Task.FromResult(principal);\n        }\n\n        var sub = claimsIdentity.FindFirst(\"sub\")?.Value;\n        _logger.LogDebug(\"Transforming claims for user {Sub}\", sub);\n\n        // Get external roles from token\n        var externalRoles = claimsIdentity.FindAll(\"roles\")\n            .Select(c => c.Value)\n            .ToList();\n\n        // Also check for role claim (some IdPs use singular)\n        var singleRole = claimsIdentity.FindFirst(\"role\")?.Value;\n        if (!string.IsNullOrEmpty(singleRole))\n        {\n            externalRoles.Add(singleRole);\n        }\n\n        // Map external roles to application roles\n        var roleMappings = GetRoleMappings();\n        var mappedRoles = new HashSet<string>();\n\n        foreach (var externalRole in externalRoles)\n        {\n            if (roleMappings.TryGetValue(externalRole, out var appRole))\n            {\n                mappedRoles.Add(appRole);\n                _logger.LogDebug(\n                    \"Mapped external role '{ExternalRole}' to '{AppRole}' for user {Sub}\",\n                    externalRole,\n                    appRole,\n                    sub);\n            }\n            else\n            {\n                // If no mapping exists, use the external role as-is\n                mappedRoles.Add(externalRole);\n                _logger.LogDebug(\n                    \"No mapping for external role '{ExternalRole}', using as-is for user {Sub}\",\n                    externalRole,\n                    sub);\n            }\n        }\n\n        // Add mapped roles as claims\n        foreach (var role in mappedRoles)\n        {\n            if (!claimsIdentity.HasClaim(ClaimTypes.Role, role))\n            {\n                claimsIdentity.AddClaim(new Claim(ClaimTypes.Role, role));\n            }\n        }\n\n        // Add custom application claims\n        AddCustomClaims(claimsIdentity);\n\n        _logger.LogInformation(\n            \"Claims transformation complete for user {Sub}. Roles: {Roles}\",\n            sub,\n            string.Join(\", \", mappedRoles));\n\n        return Task.FromResult(principal);\n    }\n\n    private Dictionary<string, string> GetRoleMappings()\n    {\n        var mappings = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n        // Load from configuration\n        var configMappings = _configuration.GetSection(\"RoleMappings\")\n            .GetChildren()\n            .ToDictionary(x => x.Key, x => x.Value ?? string.Empty);\n\n        foreach (var mapping in configMappings)\n        {\n            mappings[mapping.Key] = mapping.Value;\n        }\n\n        // Default mappings if not in config\n        if (mappings.Count == 0)\n        {\n            mappings[\"external-admin\"] = \"Admin\";\n            mappings[\"external-manager\"] = \"Manager\";\n            mappings[\"external-user\"] = \"User\";\n            mappings[\"administrator\"] = \"Admin\";\n            mappings[\"power-user\"] = \"Manager\";\n            mappings[\"standard-user\"] = \"User\";\n        }\n\n        return mappings;\n    }\n\n    private void AddCustomClaims(ClaimsIdentity claimsIdentity)\n    {\n        var email = claimsIdentity.FindFirst(\"email\")?.Value;\n        var sub = claimsIdentity.FindFirst(\"sub\")?.Value;\n\n        // Add custom claim for email domain\n        if (!string.IsNullOrEmpty(email))\n        {\n            var domain = email.Split('@').LastOrDefault();\n            if (!string.IsNullOrEmpty(domain))\n            {\n                claimsIdentity.AddClaim(new Claim(\"email_domain\", domain));\n            }\n        }\n\n        // Add custom claim for user type based on roles\n        var roles = claimsIdentity.FindAll(ClaimTypes.Role).Select(c => c.Value).ToList();\n        string userType = roles.Contains(\"Admin\") ? \"Administrator\" :\n                         roles.Contains(\"Manager\") ? \"Manager\" :\n                         \"Standard\";\n        \n        claimsIdentity.AddClaim(new Claim(\"user_type\", userType));\n\n        _logger.LogDebug(\n            \"Added custom claims for user {Sub}: email_domain, user_type={UserType}\",\n            sub,\n            userType);\n    }\n}\n```\n\n```csharp\n// Controllers/SecureController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Security.Claims;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"api/[controller]\")]\n[Authorize]\npublic class SecureController : ControllerBase\n{\n    private readonly ILogger<SecureController> _logger;\n\n    public SecureController(ILogger<SecureController> logger)\n    {\n        _logger = logger;\n    }\n\n    [HttpGet(\"profile\")]\n    public IActionResult GetProfile()\n    {\n        var sub = User.FindFirst(\"sub\")?.Value;\n        var email = User.FindFirst(\"email\")?.Value;\n        var roles = User.FindAll(ClaimTypes.Role).Select(c => c.Value).ToList();\n        var userType = User.FindFirst(\"user_type\")?.Value;\n        var emailDomain = User.FindFirst(\"email_domain\")?.Value;\n\n        _logger.LogInformation(\"Profile accessed by user {Sub}\", sub);\n\n        return Ok(new\n        {\n            sub,\n            email,\n            roles,\n            userType,\n            emailDomain,\n            claims = User.Claims.Select(c => new { c.Type, c.Value })\n        });\n    }\n\n    [HttpGet(\"admin\")]\n    [Authorize(Roles = \"Admin\")]\n    public IActionResult AdminOnly()\n    {\n        var sub = User.FindFirst(\"sub\")?.Value;\n        _logger.LogInformation(\"Admin endpoint accessed by user {Sub}\", sub);\n        \n        return Ok(new { message = \"Admin access granted\", user = sub });\n    }\n\n    [HttpGet(\"manager\")]\n    [Authorize(Policy = \"RequireManagerRole\")]\n    public IActionResult ManagerOrAdmin()\n    {\n        var sub = User.FindFirst(\"sub\")?.Value;\n        _logger.LogInformation(\"Manager endpoint accessed by user {Sub}\", sub);\n        \n        return Ok(new { message = \"Manager or Admin access granted\", user = sub });\n    }\n\n    [HttpGet(\"user\")]\n    [Authorize(Policy = \"RequireUserRole\")]\n    public IActionResult UserAccess()\n    {\n        var sub = User.FindFirst(\"sub\")?.Value;\n        _logger.LogInformation(\"User endpoint accessed by user {Sub}\", sub);\n        \n        return Ok(new { message = \"User access granted\", user = sub });\n    }\n\n    [HttpGet(\"verified\")]\n    [Authorize(Policy = \"RequireEmailVerified\")]\n    public IActionResult VerifiedEmailOnly()\n    {\n        var sub = User.FindFirst(\"sub\")?.Value;\n        var email = User.FindFirst(\"email\")?.Value;\n        _logger.LogInformation(\"Verified email endpoint accessed by user {Sub}\", sub);\n        \n        return Ok(new { message = \"Email verified access granted\", user = sub, email });\n    }\n}\n```\n\n```csharp\n// Controllers/AuthTestController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class AuthTestController : ControllerBase\n{\n    private readonly ILogger<AuthTestController> _logger;\n\n    public AuthTestController(ILogger<AuthTestController> logger)\n    {\n        _logger = logger;\n    }\n\n    [HttpGet(\"public\")]\n    [AllowAnonymous]\n    public IActionResult Public()\n    {\n        _logger.LogInformation(\"Public endpoint accessed\");\n        return Ok(new { message = \"Public endpoint - no authentication required\" });\n    }\n\n    [HttpGet(\"authenticated\")]\n    [Authorize]\n    public IActionResult Authenticated()\n    {\n        var sub = User.FindFirst(\"sub\")?.Value;\n        _logger.LogInformation(\"Authenticated endpoint accessed by user {Sub}\", sub);\n        \n        return Ok(new \n        { \n            message = \"Authenticated endpoint\",\n            user = sub,\n            isAuthenticated = User.Identity?.IsAuthenticated ?? false\n        });\n    }\n\n    [HttpGet(\"check-role/{role}\")]\n    [Authorize]\n    public IActionResult CheckRole(string role)\n    {\n        var sub = User.FindFirst(\"sub\")?.Value;\n        var hasRole = User.IsInRole(role);\n        \n        _logger.LogInformation(\n            \"Role check for '{Role}' by user {Sub}: {HasRole}\",\n            role,\n            sub,\n            hasRole);\n        \n        return Ok(new \n        { \n            role,\n            hasRole,\n            user = sub,\n            allRoles = User.Claims\n                .Where(c => c.Type == System.Security.Claims.ClaimTypes.Role)\n                .Select(c => c.Value)\n                .ToList()\n        });\n    }\n}\n```\n\n```json\n// appsettings.json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"App.Services.RoleClaimsTransformation\": \"Debug\"\n    }\n  },\n  \"JwtSettings\": {\n    \"Authority\": \"https://your-identity-provider.com\",\n    \"Audience\": \"your-api-audience\",\n    \"RequireHttpsMetadata\": true\n  },\n  \"RoleMappings\": {\n    \"external-admin\": \"Admin\",\n    \"external-manager\": \"Manager\",\n    \"external-user\": \"User\",\n    \"administrator\": \"Admin\",\n    \"power-user\": \"Manager\",\n    \"standard-user\": \"User\",\n    \"org-admin\": \"Admin\",\n    \"org-member\": \"User\"\n  }\n}\n```\n\n```json\n// appsettings.Development.json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Microsoft.AspNetCore\": \"Information\",\n      \"App.Services.RoleClaimsTransformation\": \"Debug\"\n    }\n  },\n  \"JwtSettings\": {\n    \"Authority\": \"https://dev-identity-provider.com\",\n    \"Audience\": \"dev-api-audience\",\n    \"RequireHttpsMetadata\": false\n  }\n}\n```\n\n```csharp\n// Program.cs\nusing App.Middleware;\nusing App.Services;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen(options =>\n{\n    options.AddSecurityDefinition(\"Bearer\", new Microsoft.OpenApi.Models.OpenApiSecurityScheme\n    {\n        Name = \"Authorization\",\n        Type = Microsoft.OpenApi.Models.Security",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5933,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# JWT Bearer Token Authentication Middleware with Claims Transformation\n\nI'll create a comprehensive JWT authentication system with JWKS validation, claims checking, and role mapping.\n\n## 1. Project Setup\n\n```xml\n<!-- Add to your .csproj file -->\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.AspNetCore.Authentication.JwtBearer\" Version=\"8.0.0\" />\n    <PackageReference Include=\"System.IdentityModel.Tokens.Jwt\" Version=\"7.0.0\" />\n    <PackageReference Include=\"Microsoft.IdentityModel.Protocols.OpenIdConnect\" Version=\"7.0.0\" />\n  </ItemGroup>\n</Project>\n```\n\n## 2. Configuration Models\n\n```csharp\n// Models/JwtSettings.cs\nnamespace JwtAuthMiddleware.Models\n{\n    public class JwtSettings\n    {\n        public string Authority { get; set; } = string.Empty;\n        public string Audience { get; set; } = string.Empty;\n        public string Issuer { get; set; } = string.Empty;\n        public string JwksEndpoint { get; set; } = string.Empty;\n        public bool ValidateIssuer { get; set; } = true;\n        public bool ValidateAudience { get; set; } = true;\n        public bool ValidateLifetime { get; set; } = true;\n        public bool ValidateIssuerSigningKey { get; set; } = true;\n        public int ClockSkewMinutes { get; set; } = 5;\n        public Dictionary<string, string> RoleMappings { get; set; } = new();\n    }\n\n    public class RequiredClaims\n    {\n        public bool RequireSubject { get; set; } = true;\n        public bool RequireEmail { get; set; } = true;\n        public bool RequireRoles { get; set; } = false;\n        public List<string> CustomRequiredClaims { get; set; } = new();\n    }\n}\n```\n\n## 3. Claims Transformation Service\n\n```csharp\n// Services/ClaimsTransformationService.cs\nusing Microsoft.AspNetCore.Authentication;\nusing System.Security.Claims;\n\nnamespace JwtAuthMiddleware.Services\n{\n    public class ClaimsTransformationService : IClaimsTransformation\n    {\n        private readonly ILogger<ClaimsTransformationService> _logger;\n        private readonly Dictionary<string, string> _roleMappings;\n\n        public ClaimsTransformationService(\n            ILogger<ClaimsTransformationService> logger,\n            IConfiguration configuration)\n        {\n            _logger = logger;\n            \n            // Load role mappings from configuration\n            _roleMappings = configuration\n                .GetSection(\"JwtSettings:RoleMappings\")\n                .Get<Dictionary<string, string>>() ?? new Dictionary<string, string>();\n        }\n\n        public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)\n        {\n            if (principal.Identity?.IsAuthenticated != true)\n            {\n                return Task.FromResult(principal);\n            }\n\n            var claimsIdentity = (ClaimsIdentity)principal.Identity;\n            \n            // Transform external roles to application roles\n            var externalRoles = principal.FindAll(ClaimTypes.Role).ToList();\n            var externalRolesFromClaim = principal.FindAll(\"roles\").ToList();\n            \n            var allExternalRoles = externalRoles.Concat(externalRolesFromClaim).ToList();\n\n            foreach (var roleClaim in allExternalRoles)\n            {\n                var externalRole = roleClaim.Value;\n                \n                if (_roleMappings.TryGetValue(externalRole, out var mappedRole))\n                {\n                    _logger.LogDebug(\n                        \"Mapping external role '{ExternalRole}' to application role '{MappedRole}'\",\n                        externalRole, mappedRole);\n                    \n                    // Add the mapped role as a new claim\n                    claimsIdentity.AddClaim(new Claim(\n                        \"app_role\", \n                        mappedRole, \n                        ClaimValueTypes.String, \n                        \"ApplicationRoleMapper\"));\n                    \n                    // Also add as standard role claim for [Authorize(Roles = \"...\")] to work\n                    claimsIdentity.AddClaim(new Claim(\n                        ClaimTypes.Role, \n                        mappedRole, \n                        ClaimValueTypes.String, \n                        \"ApplicationRoleMapper\"));\n                }\n                else\n                {\n                    _logger.LogDebug(\n                        \"No mapping found for external role '{ExternalRole}', keeping original\",\n                        externalRole);\n                }\n            }\n\n            // Add custom claims transformations\n            AddCustomClaims(claimsIdentity, principal);\n\n            return Task.FromResult(principal);\n        }\n\n        private void AddCustomClaims(ClaimsIdentity identity, ClaimsPrincipal principal)\n        {\n            // Example: Add a normalized email claim\n            var emailClaim = principal.FindFirst(ClaimTypes.Email) \n                ?? principal.FindFirst(\"email\");\n            \n            if (emailClaim != null && !string.IsNullOrEmpty(emailClaim.Value))\n            {\n                identity.AddClaim(new Claim(\n                    \"normalized_email\", \n                    emailClaim.Value.ToLowerInvariant()));\n            }\n\n            // Example: Add user display name\n            var nameClaim = principal.FindFirst(ClaimTypes.Name) \n                ?? principal.FindFirst(\"name\");\n            \n            if (nameClaim != null)\n            {\n                identity.AddClaim(new Claim(\n                    \"display_name\", \n                    nameClaim.Value));\n            }\n\n            // Example: Add tenant information if available\n            var tenantClaim = principal.FindFirst(\"tenant_id\");\n            if (tenantClaim != null)\n            {\n                identity.AddClaim(new Claim(\n                    \"app_tenant\", \n                    tenantClaim.Value));\n            }\n        }\n    }\n}\n```\n\n## 4. Claims Validation Middleware\n\n```csharp\n// Middleware/ClaimsValidationMiddleware.cs\nusing System.Security.Claims;\nusing JwtAuthMiddleware.Models;\n\nnamespace JwtAuthMiddleware.Middleware\n{\n    public class ClaimsValidationMiddleware\n    {\n        private readonly RequestDelegate _next;\n        private readonly ILogger<ClaimsValidationMiddleware> _logger;\n        private readonly RequiredClaims _requiredClaims;\n\n        public ClaimsValidationMiddleware(\n            RequestDelegate next,\n            ILogger<ClaimsValidationMiddleware> logger,\n            IConfiguration configuration)\n        {\n            _next = next;\n            _logger = logger;\n            _requiredClaims = configuration\n                .GetSection(\"RequiredClaims\")\n                .Get<RequiredClaims>() ?? new RequiredClaims();\n        }\n\n        public async Task InvokeAsync(HttpContext context)\n        {\n            // Only validate if user is authenticated\n            if (context.User.Identity?.IsAuthenticated == true)\n            {\n                var validationResult = ValidateRequiredClaims(context.User);\n                \n                if (!validationResult.IsValid)\n                {\n                    _logger.LogWarning(\n                        \"User {UserId} failed claims validation: {Reason}\",\n                        context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? \"Unknown\",\n                        validationResult.ErrorMessage);\n\n                    context.Response.StatusCode = StatusCodes.Status403Forbidden;\n                    await context.Response.WriteAsJsonAsync(new\n                    {\n                        error = \"insufficient_claims\",\n                        message = validationResult.ErrorMessage\n                    });\n                    return;\n                }\n            }\n\n            await _next(context);\n        }\n\n        private ClaimsValidationResult ValidateRequiredClaims(ClaimsPrincipal user)\n        {\n            // Check for 'sub' claim\n            if (_requiredClaims.RequireSubject)\n            {\n                var subClaim = user.FindFirst(ClaimTypes.NameIdentifier) \n                    ?? user.FindFirst(\"sub\");\n                \n                if (subClaim == null || string.IsNullOrWhiteSpace(subClaim.Value))\n                {\n                    return ClaimsValidationResult.Failure(\n                        \"Missing required 'sub' (subject) claim\");\n                }\n            }\n\n            // Check for 'email' claim\n            if (_requiredClaims.RequireEmail)\n            {\n                var emailClaim = user.FindFirst(ClaimTypes.Email) \n                    ?? user.FindFirst(\"email\");\n                \n                if (emailClaim == null || string.IsNullOrWhiteSpace(emailClaim.Value))\n                {\n                    return ClaimsValidationResult.Failure(\n                        \"Missing required 'email' claim\");\n                }\n            }\n\n            // Check for 'roles' claim\n            if (_requiredClaims.RequireRoles)\n            {\n                var roleClaims = user.FindAll(ClaimTypes.Role)\n                    .Concat(user.FindAll(\"roles\"))\n                    .ToList();\n                \n                if (!roleClaims.Any())\n                {\n                    return ClaimsValidationResult.Failure(\n                        \"Missing required 'roles' claim\");\n                }\n            }\n\n            // Check for custom required claims\n            foreach (var claimType in _requiredClaims.CustomRequiredClaims)\n            {\n                var claim = user.FindFirst(claimType);\n                if (claim == null || string.IsNullOrWhiteSpace(claim.Value))\n                {\n                    return ClaimsValidationResult.Failure(\n                        $\"Missing required '{claimType}' claim\");\n                }\n            }\n\n            return ClaimsValidationResult.Success();\n        }\n\n        private class ClaimsValidationResult\n        {\n            public bool IsValid { get; set; }\n            public string ErrorMessage { get; set; } = string.Empty;\n\n            public static ClaimsValidationResult Success() => \n                new() { IsValid = true };\n\n            public static ClaimsValidationResult Failure(string message) => \n                new() { IsValid = false, ErrorMessage = message };\n        }\n    }\n}\n```\n\n## 5. JWT Events Handler\n\n```csharp\n// Services/JwtBearerEventsHandler.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\n\nnamespace JwtAuthMiddleware.Services\n{\n    public class JwtBearerEventsHandler : JwtBearerEvents\n    {\n        private readonly ILogger<JwtBearerEventsHandler> _logger;\n\n        public JwtBearerEventsHandler(ILogger<JwtBearerEventsHandler> logger)\n        {\n            _logger = logger;\n        }\n\n        public override Task AuthenticationFailed(AuthenticationFailedContext context)\n        {\n            _logger.LogWarning(\n                \"JWT authentication failed: {Exception}\", \n                context.Exception.Message);\n\n            if (context.Exception is SecurityTokenExpiredException)\n            {\n                context.Response.Headers.Add(\"Token-Expired\", \"true\");\n                _logger.LogInformation(\"Token expired for request to {Path}\", \n                    context.Request.Path);\n            }\n\n            return Task.CompletedTask;\n        }\n\n        public override Task TokenValidated(TokenValidatedContext context)\n        {\n            var userId = context.Principal?.FindFirst(\"sub\")?.Value \n                ?? context.Principal?.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n            \n            _logger.LogInformation(\n                \"Token validated successfully for user {UserId}\", \n                userId ?? \"Unknown\");\n\n            return Task.CompletedTask;\n        }\n\n        public override Task Challenge(JwtBearerChallengeContext context)\n        {\n            _logger.LogWarning(\n                \"JWT authentication challenge for {Path}: {Error}\", \n                context.Request.Path,\n                context.Error ?? \"No error specified\");\n\n            return Task.CompletedTask;\n        }\n\n        public override Task MessageReceived(MessageReceivedContext context)\n        {\n            // Support token from query string for SignalR/WebSocket scenarios\n            var accessToken = context.Request.Query[\"access_token\"];\n\n            if (!string.IsNullOrEmpty(accessToken) && \n                context.Request.Path.StartsWithSegments(\"/hubs\"))\n            {\n                context.Token = accessToken;\n                _logger.LogDebug(\"Token received from query string for SignalR hub\");\n            }\n\n            return Task.CompletedTask;\n        }\n\n        public override Task Forbidden(ForbiddenContext context)\n        {\n            _logger.LogWarning(\n                \"Access forbidden for user {UserId} to {Path}\",\n                context.Principal?.FindFirst(\"sub\")?.Value ?? \"Unknown\",\n                context.Request.Path);\n\n            return Task.CompletedTask;\n        }\n    }\n}\n```\n\n## 6. Authorization Policy Provider\n\n```csharp\n// Authorization/RoleAuthorizationPolicyProvider.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.Extensions.Options;\n\nnamespace JwtAuthMiddleware.Authorization\n{\n    public class RoleAuthorizationPolicyProvider : DefaultAuthorizationPolicyProvider\n    {\n        private readonly ILogger<RoleAuthorizationPolicyProvider> _logger;\n\n        public RoleAuthorizationPolicyProvider(\n            IOptions<AuthorizationOptions> options,\n            ILogger<RoleAuthorizationPolicyProvider> logger) \n            : base(options)\n        {\n            _logger = logger;\n        }\n\n        public override async Task<AuthorizationPolicy?> GetPolicyAsync(string policyName)\n        {\n            // Try to get the policy from the default provider first\n            var policy = await base.GetPolicyAsync(policyName);\n\n            if (policy != null)\n            {\n                return policy;\n            }\n\n            // Create dynamic policies for role-based authorization\n            if (policyName.StartsWith(\"Role:\"))\n            {\n                var role = policyName.Substring(\"Role:\".Length);\n                _logger.LogDebug(\"Creating dynamic policy for role: {Role}\", role);\n\n                return new AuthorizationPolicyBuilder()\n                    .RequireAuthenticatedUser()\n                    .RequireRole(role)\n                    .Build();\n            }\n\n            // Create dynamic policies for claim-based authorization\n            if (policyName.StartsWith(\"Claim:\"))\n            {\n                var parts = policyName.Substring(\"Claim:\".Length).Split('=');\n                if (parts.Length == 2)\n                {\n                    _logger.LogDebug(\n                        \"Creating dynamic policy for claim: {ClaimType}={ClaimValue}\", \n                        parts[0], parts[1]);\n\n                    return new AuthorizationPolicyBuilder()\n                        .RequireAuthenticatedUser()\n                        .RequireClaim(parts[0], parts[1])\n                        .Build();\n                }\n            }\n\n            return null;\n        }\n    }\n}\n```\n\n## 7. Custom Authorization Attributes\n\n```csharp\n// Authorization/RequireRoleAttribute.cs\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace JwtAuthMiddleware.Authorization\n{\n    /// <summary>\n    /// Requires user to have one or more application roles\n    /// </summary>\n    public class RequireRoleAttribute : AuthorizeAttribute\n    {\n        public RequireRoleAttribute(params string[] roles)\n        {\n            Roles = string.Join(\",\", roles);\n        }\n    }\n\n    /// <summary>\n    /// Requires user to have all specified roles\n    /// </summary>\n    public class RequireAllRolesAttribute : AuthorizeAttribute\n    {\n        public RequireAllRolesAttribute(params string[] roles)\n        {\n            Policy = $\"RequireAllRoles:{string.Join(\",\", roles)}\";\n        }\n    }\n\n    /// <summary>\n    /// Requires user to have a specific claim\n    /// </summary>\n    public class RequireClaimAttribute : AuthorizeAttribute\n    {\n        public RequireClaimAttribute(string claimType, string claimValue)\n        {\n            Policy = $\"Claim:{claimType}={claimValue}\";\n        }\n    }",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 91,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# JWT Bearer Authentication Middleware with Claims Transformation\n\nI'll create a comprehensive JWT authentication solution with JWKS validation, claims checking, and role mapping.\n\n## Project Structure\n\n```\nJwtAuthMiddleware/\n\u251c\u2500\u2500 Program.cs\n\u251c\u2500\u2500 Authentication/\n\u2502   \u251c\u2500\u2500 JwtBearerConfiguration.cs\n\u2502   \u251c\u2500\u2500 ClaimsTransformation.cs\n\u2502   \u2514\u2500\u2500 JwtValidationService.cs\n\u251c\u2500\u2500 Authorization/\n\u2502   \u251c\u2500\u2500 Requirements/\n\u2502   \u2502   \u251c\u2500\u2500 RequiredClaimsRequirement.cs\n\u2502   \u2502   \u2514\u2500\u2500 RequiredClaimsHandler.cs\n\u2502   \u2514\u2500\u2500 Policies/\n\u2502       \u2514\u2500\u2500 AuthorizationPolicies.cs\n\u251c\u2500\u2500 Controllers/\n\u2502   \u251c\u2500\u2500 AuthTestController.cs\n\u2502   \u2514\u2500\u2500 AdminController.cs\n\u251c\u2500\u2500 Models/\n\u2502   \u251c\u2500\u2500 JwtSettings.cs\n\u2502   \u2514\u2500\u2500 UserClaims.cs\n\u2514\u2500\u2500 Middleware/\n    \u2514\u2500\u2500 JwtLoggingMiddleware.cs\n```\n\n## Installation\n\n```bash\ndotnet add package Microsoft.AspNetCore.Authentication.JwtBearer\ndotnet add package System.IdentityModel.Tokens.Jwt\ndotnet add package Microsoft.IdentityModel.Protocols.OpenIdConnect\n```\n\n## 1. Configuration Models\n\n### Models/JwtSettings.cs\n```csharp\nnamespace JwtAuthMiddleware.Models;\n\npublic class JwtSettings\n{\n    public const string SectionName = \"JwtSettings\";\n    \n    public string Authority { get; set; } = string.Empty;\n    public string Audience { get; set; } = string.Empty;\n    public string Issuer { get; set; } = string.Empty;\n    public string MetadataAddress { get; set; } = string.Empty;\n    public bool RequireHttpsMetadata { get; set; } = true;\n    public bool ValidateIssuer { get; set; } = true;\n    public bool ValidateAudience { get; set; } = true;\n    public bool ValidateLifetime { get; set; } = true;\n    public bool ValidateIssuerSigningKey { get; set; } = true;\n    public int ClockSkewSeconds { get; set; } = 300;\n    public List<string> RequiredClaims { get; set; } = new();\n    public Dictionary<string, string> RoleMappings { get; set; } = new();\n}\n```\n\n### Models/UserClaims.cs\n```csharp\nnamespace JwtAuthMiddleware.Models;\n\npublic class UserClaims\n{\n    public string Sub { get; set; } = string.Empty;\n    public string Email { get; set; } = string.Empty;\n    public List<string> Roles { get; set; } = new();\n    public string Name { get; set; } = string.Empty;\n    public Dictionary<string, string> AdditionalClaims { get; set; } = new();\n}\n```\n\n## 2. JWT Configuration\n\n### Authentication/JwtBearerConfiguration.cs\n```csharp\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing JwtAuthMiddleware.Models;\nusing System.Security.Claims;\n\nnamespace JwtAuthMiddleware.Authentication;\n\npublic static class JwtBearerConfiguration\n{\n    public static IServiceCollection AddJwtBearerAuthentication(\n        this IServiceCollection services,\n        IConfiguration configuration)\n    {\n        var jwtSettings = configuration\n            .GetSection(JwtSettings.SectionName)\n            .Get<JwtSettings>() \n            ?? throw new InvalidOperationException(\"JWT settings not configured\");\n\n        services.AddSingleton(jwtSettings);\n\n        services.AddAuthentication(options =>\n        {\n            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n            options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;\n        })\n        .AddJwtBearer(options =>\n        {\n            // JWKS endpoint configuration\n            options.Authority = jwtSettings.Authority;\n            options.Audience = jwtSettings.Audience;\n            options.MetadataAddress = jwtSettings.MetadataAddress;\n            options.RequireHttpsMetadata = jwtSettings.RequireHttpsMetadata;\n\n            // Token validation parameters\n            options.TokenValidationParameters = new TokenValidationParameters\n            {\n                ValidateIssuer = jwtSettings.ValidateIssuer,\n                ValidIssuer = jwtSettings.Issuer,\n                \n                ValidateAudience = jwtSettings.ValidateAudience,\n                ValidAudience = jwtSettings.Audience,\n                \n                ValidateLifetime = jwtSettings.ValidateLifetime,\n                ValidateIssuerSigningKey = jwtSettings.ValidateIssuerSigningKey,\n                \n                // Clock skew for token expiration\n                ClockSkew = TimeSpan.FromSeconds(jwtSettings.ClockSkewSeconds),\n                \n                // Require specific claims\n                RequireExpirationTime = true,\n                RequireSignedTokens = true,\n                \n                // Name and role claim types\n                NameClaimType = ClaimTypes.NameIdentifier,\n                RoleClaimType = ClaimTypes.Role\n            };\n\n            // Events for custom validation and logging\n            options.Events = new JwtBearerEvents\n            {\n                OnAuthenticationFailed = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    \n                    logger.LogError(context.Exception, \n                        \"JWT authentication failed: {Message}\", \n                        context.Exception.Message);\n                    \n                    return Task.CompletedTask;\n                },\n                \n                OnTokenValidated = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    \n                    var claimsIdentity = context.Principal?.Identity as ClaimsIdentity;\n                    var sub = claimsIdentity?.FindFirst(\"sub\")?.Value;\n                    \n                    logger.LogInformation(\n                        \"JWT token validated for user: {Sub}\", \n                        sub ?? \"Unknown\");\n                    \n                    // Validate required claims\n                    var validationService = context.HttpContext.RequestServices\n                        .GetRequiredService<JwtValidationService>();\n                    \n                    if (!validationService.ValidateRequiredClaims(context.Principal!))\n                    {\n                        context.Fail(\"Required claims are missing\");\n                    }\n                    \n                    return Task.CompletedTask;\n                },\n                \n                OnChallenge = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    \n                    logger.LogWarning(\n                        \"JWT authentication challenge: {Error} - {ErrorDescription}\",\n                        context.Error,\n                        context.ErrorDescription);\n                    \n                    return Task.CompletedTask;\n                },\n                \n                OnMessageReceived = context =>\n                {\n                    // Support token from query string (for SignalR, etc.)\n                    var accessToken = context.Request.Query[\"access_token\"];\n                    var path = context.HttpContext.Request.Path;\n                    \n                    if (!string.IsNullOrEmpty(accessToken) && \n                        path.StartsWithSegments(\"/hubs\"))\n                    {\n                        context.Token = accessToken;\n                    }\n                    \n                    return Task.CompletedTask;\n                }\n            };\n\n            // Configure backchannel for JWKS retrieval\n            options.BackchannelTimeout = TimeSpan.FromSeconds(30);\n            options.RefreshOnIssuerKeyNotFound = true;\n            options.SaveToken = true;\n        });\n\n        return services;\n    }\n}\n```\n\n### Authentication/JwtValidationService.cs\n```csharp\nusing System.Security.Claims;\nusing JwtAuthMiddleware.Models;\n\nnamespace JwtAuthMiddleware.Authentication;\n\npublic class JwtValidationService\n{\n    private readonly JwtSettings _jwtSettings;\n    private readonly ILogger<JwtValidationService> _logger;\n\n    public JwtValidationService(\n        JwtSettings jwtSettings,\n        ILogger<JwtValidationService> logger)\n    {\n        _jwtSettings = jwtSettings;\n        _logger = logger;\n    }\n\n    public bool ValidateRequiredClaims(ClaimsPrincipal principal)\n    {\n        var claimsIdentity = principal.Identity as ClaimsIdentity;\n        if (claimsIdentity == null)\n        {\n            _logger.LogWarning(\"ClaimsIdentity is null\");\n            return false;\n        }\n\n        var missingClaims = new List<string>();\n\n        foreach (var requiredClaim in _jwtSettings.RequiredClaims)\n        {\n            if (!claimsIdentity.HasClaim(c => c.Type == requiredClaim))\n            {\n                missingClaims.Add(requiredClaim);\n            }\n        }\n\n        if (missingClaims.Any())\n        {\n            _logger.LogWarning(\n                \"Missing required claims: {MissingClaims}\", \n                string.Join(\", \", missingClaims));\n            return false;\n        }\n\n        // Validate specific required claims\n        var sub = claimsIdentity.FindFirst(\"sub\")?.Value;\n        var email = claimsIdentity.FindFirst(\"email\")?.Value;\n\n        if (string.IsNullOrEmpty(sub))\n        {\n            _logger.LogWarning(\"Subject (sub) claim is missing or empty\");\n            return false;\n        }\n\n        if (string.IsNullOrEmpty(email))\n        {\n            _logger.LogWarning(\"Email claim is missing or empty\");\n            return false;\n        }\n\n        return true;\n    }\n\n    public UserClaims ExtractUserClaims(ClaimsPrincipal principal)\n    {\n        var claimsIdentity = principal.Identity as ClaimsIdentity;\n        if (claimsIdentity == null)\n        {\n            throw new InvalidOperationException(\"ClaimsIdentity is null\");\n        }\n\n        var userClaims = new UserClaims\n        {\n            Sub = claimsIdentity.FindFirst(\"sub\")?.Value ?? string.Empty,\n            Email = claimsIdentity.FindFirst(\"email\")?.Value ?? string.Empty,\n            Name = claimsIdentity.FindFirst(\"name\")?.Value ?? string.Empty,\n            Roles = claimsIdentity.FindAll(ClaimTypes.Role)\n                .Select(c => c.Value)\n                .ToList()\n        };\n\n        // Extract additional claims\n        foreach (var claim in claimsIdentity.Claims)\n        {\n            if (!IsStandardClaim(claim.Type))\n            {\n                userClaims.AdditionalClaims[claim.Type] = claim.Value;\n            }\n        }\n\n        return userClaims;\n    }\n\n    private static bool IsStandardClaim(string claimType)\n    {\n        var standardClaims = new[]\n        {\n            \"sub\", \"email\", \"name\", ClaimTypes.Role,\n            \"iss\", \"aud\", \"exp\", \"nbf\", \"iat\", \"jti\"\n        };\n\n        return standardClaims.Contains(claimType);\n    }\n}\n```\n\n## 3. Claims Transformation\n\n### Authentication/ClaimsTransformation.cs\n```csharp\nusing Microsoft.AspNetCore.Authentication;\nusing System.Security.Claims;\nusing JwtAuthMiddleware.Models;\n\nnamespace JwtAuthMiddleware.Authentication;\n\npublic class CustomClaimsTransformation : IClaimsTransformation\n{\n    private readonly JwtSettings _jwtSettings;\n    private readonly ILogger<CustomClaimsTransformation> _logger;\n\n    public CustomClaimsTransformation(\n        JwtSettings jwtSettings,\n        ILogger<CustomClaimsTransformation> logger)\n    {\n        _jwtSettings = jwtSettings;\n        _logger = logger;\n    }\n\n    public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)\n    {\n        var claimsIdentity = principal.Identity as ClaimsIdentity;\n        if (claimsIdentity == null || !claimsIdentity.IsAuthenticated)\n        {\n            return Task.FromResult(principal);\n        }\n\n        // Create a new claims identity with transformed claims\n        var transformedIdentity = new ClaimsIdentity(\n            claimsIdentity.Claims,\n            claimsIdentity.AuthenticationType,\n            claimsIdentity.NameClaimType,\n            claimsIdentity.RoleClaimType);\n\n        // Map external roles to application roles\n        var externalRoles = claimsIdentity\n            .FindAll(\"roles\") // External role claim type\n            .Select(c => c.Value)\n            .ToList();\n\n        foreach (var externalRole in externalRoles)\n        {\n            if (_jwtSettings.RoleMappings.TryGetValue(externalRole, out var appRole))\n            {\n                _logger.LogDebug(\n                    \"Mapping external role {ExternalRole} to {AppRole}\",\n                    externalRole,\n                    appRole);\n\n                transformedIdentity.AddClaim(\n                    new Claim(ClaimTypes.Role, appRole));\n            }\n            else\n            {\n                // Keep unmapped roles as-is\n                transformedIdentity.AddClaim(\n                    new Claim(ClaimTypes.Role, externalRole));\n            }\n        }\n\n        // Add custom application claims\n        var email = claimsIdentity.FindFirst(\"email\")?.Value;\n        if (!string.IsNullOrEmpty(email))\n        {\n            // Add email domain as a claim\n            var domain = email.Split('@').LastOrDefault();\n            if (!string.IsNullOrEmpty(domain))\n            {\n                transformedIdentity.AddClaim(\n                    new Claim(\"email_domain\", domain));\n            }\n        }\n\n        // Add user type based on email domain\n        if (email?.EndsWith(\"@admin.com\") == true)\n        {\n            transformedIdentity.AddClaim(\n                new Claim(\"user_type\", \"internal\"));\n        }\n        else\n        {\n            transformedIdentity.AddClaim(\n                new Claim(\"user_type\", \"external\"));\n        }\n\n        // Add timestamp of transformation\n        transformedIdentity.AddClaim(\n            new Claim(\"claims_transformed_at\", \n                DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString()));\n\n        var transformedPrincipal = new ClaimsPrincipal(transformedIdentity);\n\n        _logger.LogInformation(\n            \"Claims transformed for user {Sub}. Roles: {Roles}\",\n            claimsIdentity.FindFirst(\"sub\")?.Value,\n            string.Join(\", \", transformedIdentity.FindAll(ClaimTypes.Role)\n                .Select(c => c.Value)));\n\n        return Task.FromResult(transformedPrincipal);\n    }\n}\n```\n\n## 4. Authorization Policies\n\n### Authorization/Requirements/RequiredClaimsRequirement.cs\n```csharp\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace JwtAuthMiddleware.Authorization.Requirements;\n\npublic class RequiredClaimsRequirement : IAuthorizationRequirement\n{\n    public string ClaimType { get; }\n    public string? ClaimValue { get; }\n\n    public RequiredClaimsRequirement(string claimType, string? claimValue = null)\n    {\n        ClaimType = claimType;\n        ClaimValue = claimValue;\n    }\n}\n```\n\n### Authorization/Requirements/RequiredClaimsHandler.cs\n```csharp\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace JwtAuthMiddleware.Authorization.Requirements;\n\npublic class RequiredClaimsHandler : AuthorizationHandler<RequiredClaimsRequirement>\n{\n    private readonly ILogger<RequiredClaimsHandler> _logger;\n\n    public RequiredClaimsHandler(ILogger<RequiredClaimsHandler> logger)\n    {\n        _logger = logger;\n    }\n\n    protected override Task HandleRequirementAsync(\n        AuthorizationHandlerContext context,\n        RequiredClaimsRequirement requirement)\n    {\n        var hasClaim = requirement.ClaimValue == null\n            ? context.User.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5427,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive JWT authentication middleware with claims transformation and role-based authorization.\n\nFirst, let me check the existing project structure:\n\n<read_file>\n<path>App.csproj\n</path>\n</read_file>\n\nNow I'll create the JWT authentication implementation:\n\n<write_file>\n<path>Middleware/JwtAuthenticationMiddleware.cs</path>\n<content>using System.Security.Claims;\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\n\nnamespace App.Middleware;\n\n/// <summary>\n/// Configures JWT Bearer authentication with JWKS validation and claims transformation\n/// </summary>\npublic static class JwtAuthenticationMiddleware\n{\n    public static IServiceCollection AddJwtAuthentication(\n        this IServiceCollection services,\n        IConfiguration configuration)\n    {\n        var jwtSettings = configuration.GetSection(\"JwtSettings\");\n        var authority = jwtSettings[\"Authority\"] \n            ?? throw new InvalidOperationException(\"JwtSettings:Authority is required\");\n        var audience = jwtSettings[\"Audience\"] \n            ?? throw new InvalidOperationException(\"JwtSettings:Audience is required\");\n\n        services.AddAuthentication(options =>\n        {\n            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n        })\n        .AddJwtBearer(options =>\n        {\n            // Configure JWKS endpoint validation\n            options.Authority = authority;\n            options.Audience = audience;\n            options.RequireHttpsMetadata = true;\n\n            options.TokenValidationParameters = new TokenValidationParameters\n            {\n                ValidateIssuer = true,\n                ValidateAudience = true,\n                ValidateLifetime = true,\n                ValidateIssuerSigningKey = true,\n                ValidIssuer = authority,\n                ValidAudience = audience,\n                ClockSkew = TimeSpan.FromMinutes(5),\n                \n                // Require specific claims\n                RequireExpirationTime = true,\n                RequireSignedTokens = true\n            };\n\n            // Custom event handlers\n            options.Events = new JwtBearerEvents\n            {\n                OnAuthenticationFailed = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    \n                    logger.LogWarning(\n                        \"JWT authentication failed: {Error}\", \n                        context.Exception.Message);\n                    \n                    return Task.CompletedTask;\n                },\n                \n                OnTokenValidated = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    \n                    var claimsPrincipal = context.Principal;\n                    var userId = claimsPrincipal?.FindFirst(ClaimTypes.NameIdentifier)?.Value \n                        ?? claimsPrincipal?.FindFirst(\"sub\")?.Value;\n                    \n                    logger.LogInformation(\n                        \"JWT token validated for user: {UserId}\", \n                        userId);\n                    \n                    // Validate required claims\n                    if (!ValidateRequiredClaims(claimsPrincipal, logger))\n                    {\n                        context.Fail(\"Required claims are missing\");\n                    }\n                    \n                    return Task.CompletedTask;\n                },\n                \n                OnChallenge = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    \n                    logger.LogWarning(\n                        \"JWT authentication challenge: {Error}\", \n                        context.Error ?? \"Unauthorized\");\n                    \n                    return Task.CompletedTask;\n                }\n            };\n        });\n\n        // Add claims transformation\n        services.AddScoped<IClaimsTransformation, RoleClaimsTransformation>();\n\n        // Add authorization with policies\n        services.AddAuthorization(options =>\n        {\n            // Default policy requires authentication\n            options.FallbackPolicy = options.DefaultPolicy;\n            \n            // Role-based policies\n            options.AddPolicy(\"AdminOnly\", policy => \n                policy.RequireRole(\"Admin\"));\n            \n            options.AddPolicy(\"UserOrAdmin\", policy => \n                policy.RequireRole(\"User\", \"Admin\"));\n            \n            options.AddPolicy(\"ManagerOnly\", policy => \n                policy.RequireRole(\"Manager\"));\n            \n            // Claim-based policies\n            options.AddPolicy(\"RequireEmail\", policy => \n                policy.RequireClaim(ClaimTypes.Email));\n            \n            options.AddPolicy(\"RequireEmailVerified\", policy =>\n                policy.RequireClaim(\"email_verified\", \"true\"));\n        });\n\n        return services;\n    }\n\n    private static bool ValidateRequiredClaims(ClaimsPrincipal? principal, ILogger logger)\n    {\n        if (principal == null)\n        {\n            logger.LogWarning(\"ClaimsPrincipal is null\");\n            return false;\n        }\n\n        // Check for 'sub' claim (subject/user identifier)\n        var subClaim = principal.FindFirst(ClaimTypes.NameIdentifier) \n            ?? principal.FindFirst(\"sub\");\n        if (subClaim == null)\n        {\n            logger.LogWarning(\"Required claim 'sub' is missing\");\n            return false;\n        }\n\n        // Check for 'email' claim\n        var emailClaim = principal.FindFirst(ClaimTypes.Email) \n            ?? principal.FindFirst(\"email\");\n        if (emailClaim == null)\n        {\n            logger.LogWarning(\"Required claim 'email' is missing\");\n            return false;\n        }\n\n        // Check for 'roles' claim (can be array or single value)\n        var rolesClaim = principal.FindFirst(ClaimTypes.Role) \n            ?? principal.FindFirst(\"roles\") \n            ?? principal.FindFirst(\"role\");\n        if (rolesClaim == null)\n        {\n            logger.LogWarning(\"Required claim 'roles' is missing\");\n            return false;\n        }\n\n        return true;\n    }\n}\n</content>\n</write_file>\n\n<write_file>\n<path>Middleware/RoleClaimsTransformation.cs</path>\n<content>using System.Security.Claims;\nusing Microsoft.AspNetCore.Authentication;\n\nnamespace App.Middleware;\n\n/// <summary>\n/// Transforms external identity provider roles to application-specific roles\n/// </summary>\npublic class RoleClaimsTransformation : IClaimsTransformation\n{\n    private readonly ILogger<RoleClaimsTransformation> _logger;\n    private readonly IConfiguration _configuration;\n\n    // Role mapping: external role -> internal role(s)\n    private readonly Dictionary<string, string[]> _roleMapping = new()\n    {\n        // External roles from IdP\n        { \"external-admin\", new[] { \"Admin\", \"User\" } },\n        { \"external-manager\", new[] { \"Manager\", \"User\" } },\n        { \"external-user\", new[] { \"User\" } },\n        { \"external-readonly\", new[] { \"ReadOnly\" } },\n        \n        // Direct mappings\n        { \"admin\", new[] { \"Admin\", \"User\" } },\n        { \"manager\", new[] { \"Manager\", \"User\" } },\n        { \"user\", new[] { \"User\" } }\n    };\n\n    public RoleClaimsTransformation(\n        ILogger<RoleClaimsTransformation> logger,\n        IConfiguration configuration)\n    {\n        _logger = logger;\n        _configuration = configuration;\n        \n        // Load custom role mappings from configuration if available\n        LoadCustomRoleMappings();\n    }\n\n    public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)\n    {\n        var claimsIdentity = principal.Identity as ClaimsIdentity;\n        if (claimsIdentity == null || !claimsIdentity.IsAuthenticated)\n        {\n            return Task.FromResult(principal);\n        }\n\n        // Get existing role claims from various possible claim types\n        var existingRoles = principal.Claims\n            .Where(c => c.Type == ClaimTypes.Role || \n                       c.Type == \"roles\" || \n                       c.Type == \"role\")\n            .Select(c => c.Value)\n            .ToList();\n\n        if (!existingRoles.Any())\n        {\n            _logger.LogWarning(\n                \"No roles found for user {UserId}\", \n                principal.FindFirst(\"sub\")?.Value);\n            return Task.FromResult(principal);\n        }\n\n        // Create new identity with transformed claims\n        var transformedIdentity = new ClaimsIdentity(\n            claimsIdentity.Claims,\n            claimsIdentity.AuthenticationType,\n            claimsIdentity.NameClaimType,\n            ClaimTypes.Role);\n\n        // Remove old role claims\n        var oldRoleClaims = transformedIdentity.Claims\n            .Where(c => c.Type == ClaimTypes.Role || \n                       c.Type == \"roles\" || \n                       c.Type == \"role\")\n            .ToList();\n        \n        foreach (var claim in oldRoleClaims)\n        {\n            transformedIdentity.RemoveClaim(claim);\n        }\n\n        // Map external roles to internal roles\n        var mappedRoles = new HashSet<string>();\n        foreach (var externalRole in existingRoles)\n        {\n            if (_roleMapping.TryGetValue(externalRole.ToLowerInvariant(), out var internalRoles))\n            {\n                foreach (var internalRole in internalRoles)\n                {\n                    mappedRoles.Add(internalRole);\n                }\n                \n                _logger.LogDebug(\n                    \"Mapped external role '{ExternalRole}' to internal roles: {InternalRoles}\",\n                    externalRole,\n                    string.Join(\", \", internalRoles));\n            }\n            else\n            {\n                // Keep unmapped roles as-is\n                mappedRoles.Add(externalRole);\n                \n                _logger.LogDebug(\n                    \"No mapping found for role '{Role}', keeping as-is\",\n                    externalRole);\n            }\n        }\n\n        // Add transformed role claims\n        foreach (var role in mappedRoles)\n        {\n            transformedIdentity.AddClaim(new Claim(ClaimTypes.Role, role));\n        }\n\n        // Add custom application claims\n        AddCustomClaims(transformedIdentity, principal);\n\n        var transformedPrincipal = new ClaimsPrincipal(transformedIdentity);\n        \n        _logger.LogInformation(\n            \"Claims transformed for user {UserId}. Roles: {Roles}\",\n            principal.FindFirst(\"sub\")?.Value,\n            string.Join(\", \", mappedRoles));\n\n        return Task.FromResult(transformedPrincipal);\n    }\n\n    private void AddCustomClaims(ClaimsIdentity identity, ClaimsPrincipal principal)\n    {\n        // Add tenant ID if available\n        var tenantId = principal.FindFirst(\"tenant_id\")?.Value \n            ?? principal.FindFirst(\"tid\")?.Value;\n        if (!string.IsNullOrEmpty(tenantId))\n        {\n            identity.AddClaim(new Claim(\"app_tenant_id\", tenantId));\n        }\n\n        // Add user display name\n        var name = principal.FindFirst(ClaimTypes.Name)?.Value \n            ?? principal.FindFirst(\"name\")?.Value;\n        if (!string.IsNullOrEmpty(name))\n        {\n            identity.AddClaim(new Claim(\"app_display_name\", name));\n        }\n\n        // Add email verification status\n        var emailVerified = principal.FindFirst(\"email_verified\")?.Value;\n        if (!string.IsNullOrEmpty(emailVerified))\n        {\n            identity.AddClaim(new Claim(\"app_email_verified\", emailVerified));\n        }\n    }\n\n    private void LoadCustomRoleMappings()\n    {\n        var customMappings = _configuration\n            .GetSection(\"JwtSettings:RoleMappings\")\n            .Get<Dictionary<string, string[]>>();\n\n        if (customMappings != null)\n        {\n            foreach (var mapping in customMappings)\n            {\n                _roleMapping[mapping.Key.ToLowerInvariant()] = mapping.Value;\n            }\n            \n            _logger.LogInformation(\n                \"Loaded {Count} custom role mappings from configuration\",\n                customMappings.Count);\n        }\n    }\n}\n</content>\n</write_file>\n\n<write_file>\n<path>Controllers/AuthTestController.cs</path>\n<content>using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Security.Claims;\n\nnamespace App.Controllers;\n\n/// <summary>\n/// Test controller demonstrating JWT authentication and role-based authorization\n/// </summary>\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class AuthTestController : ControllerBase\n{\n    private readonly ILogger<AuthTestController> _logger;\n\n    public AuthTestController(ILogger<AuthTestController> logger)\n    {\n        _logger = logger;\n    }\n\n    /// <summary>\n    /// Public endpoint - no authentication required\n    /// </summary>\n    [HttpGet(\"public\")]\n    [AllowAnonymous]\n    public IActionResult GetPublic()\n    {\n        return Ok(new { message = \"This is a public endpoint\" });\n    }\n\n    /// <summary>\n    /// Protected endpoint - requires valid JWT token\n    /// </summary>\n    [HttpGet(\"protected\")]\n    [Authorize]\n    public IActionResult GetProtected()\n    {\n        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value \n            ?? User.FindFirst(\"sub\")?.Value;\n        var email = User.FindFirst(ClaimTypes.Email)?.Value \n            ?? User.FindFirst(\"email\")?.Value;\n\n        return Ok(new\n        {\n            message = \"This is a protected endpoint\",\n            userId,\n            email,\n            isAuthenticated = User.Identity?.IsAuthenticated ?? false\n        });\n    }\n\n    /// <summary>\n    /// Admin-only endpoint\n    /// </summary>\n    [HttpGet(\"admin\")]\n    [Authorize(Roles = \"Admin\")]\n    public IActionResult GetAdmin()\n    {\n        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value \n            ?? User.FindFirst(\"sub\")?.Value;\n\n        return Ok(new\n        {\n            message = \"This is an admin-only endpoint\",\n            userId,\n            roles = User.Claims\n                .Where(c => c.Type == ClaimTypes.Role)\n                .Select(c => c.Value)\n                .ToList()\n        });\n    }\n\n    /// <summary>\n    /// Manager or Admin endpoint\n    /// </summary>\n    [HttpGet(\"manager\")]\n    [Authorize(Roles = \"Manager,Admin\")]\n    public IActionResult GetManager()\n    {\n        return Ok(new\n        {\n            message = \"This endpoint requires Manager or Admin role\",\n            roles = User.Claims\n                .Where(c => c.Type == ClaimTypes.Role)\n                .Select(c => c.Value)\n                .ToList()\n        });\n    }\n\n    /// <summary>\n    /// Policy-based authorization\n    /// </summary>\n    [HttpGet(\"user-or-admin\")]\n    [Authorize(Policy = \"UserOrAdmin\")]\n    public IActionResult GetUserOrAdmin()\n    {\n        return Ok(new\n        {\n            message = \"This endpoint uses policy-based authorization\",\n            policy = \"UserOrAdmin\"\n        });\n    }\n\n    /// <summary>\n    /// Requires email claim\n    /// </summary>\n    [HttpGet(\"require-email\")]\n    [Authorize(Policy = \"RequireEmail\")]\n    public IActionResult GetRequireEmail()\n    {\n        var email = User.FindFirst(ClaimTypes.Email)?.Value \n            ?? User.FindFirst(\"email\")?.Value;\n\n        return Ok(new\n        {\n            message = \"This endpoint requires email claim\",\n            email\n        });\n    }\n\n    /// <summary>\n    /// Get all claims for the current user\n    /// </summary>\n    [HttpGet(\"claims\")]\n    [Authorize]\n    public IActionResult GetClaims()\n    {\n        var claims = User.Claims.Select(c => new\n        {\n            type = c.Type,\n            value = c.Value\n        ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5933,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# JWT Bearer Token Authentication Middleware with Claims Transformation\n\nI'll create a comprehensive JWT authentication solution with JWKS validation, claims checking, and role mapping.\n\n## 1. Core Models and Configuration\n\n```csharp\n// Models/JwtSettings.cs\nnamespace JwtAuthMiddleware.Models\n{\n    public class JwtSettings\n    {\n        public string Authority { get; set; }\n        public string Audience { get; set; }\n        public string MetadataAddress { get; set; }\n        public bool RequireHttpsMetadata { get; set; } = true;\n        public bool ValidateIssuer { get; set; } = true;\n        public bool ValidateAudience { get; set; } = true;\n        public bool ValidateLifetime { get; set; } = true;\n        public int ClockSkew { get; set; } = 300; // seconds\n        public List<string> RequiredClaims { get; set; } = new();\n        public Dictionary<string, string> RoleMappings { get; set; } = new();\n    }\n\n    public class ClaimRequirement\n    {\n        public string ClaimType { get; set; }\n        public string ClaimValue { get; set; }\n        public bool IsRequired { get; set; }\n    }\n}\n```\n\n## 2. Claims Transformation Service\n\n```csharp\n// Services/ClaimsTransformationService.cs\nusing Microsoft.AspNetCore.Authentication;\nusing System.Security.Claims;\n\nnamespace JwtAuthMiddleware.Services\n{\n    public class ClaimsTransformationService : IClaimsTransformation\n    {\n        private readonly ILogger<ClaimsTransformationService> _logger;\n        private readonly JwtSettings _jwtSettings;\n\n        public ClaimsTransformationService(\n            ILogger<ClaimsTransformationService> logger,\n            IOptions<JwtSettings> jwtSettings)\n        {\n            _logger = logger;\n            _jwtSettings = jwtSettings.Value;\n        }\n\n        public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)\n        {\n            if (principal.Identity?.IsAuthenticated != true)\n            {\n                return Task.FromResult(principal);\n            }\n\n            var claimsIdentity = (ClaimsIdentity)principal.Identity;\n            \n            // Transform external roles to application roles\n            TransformRoles(claimsIdentity);\n            \n            // Add custom claims\n            AddCustomClaims(claimsIdentity);\n            \n            // Normalize claim types\n            NormalizeClaims(claimsIdentity);\n\n            _logger.LogInformation(\n                \"Claims transformed for user {UserId}. Total claims: {ClaimCount}\",\n                claimsIdentity.FindFirst(ClaimTypes.NameIdentifier)?.Value,\n                claimsIdentity.Claims.Count());\n\n            return Task.FromResult(principal);\n        }\n\n        private void TransformRoles(ClaimsIdentity identity)\n        {\n            var externalRoles = identity.FindAll(ClaimTypes.Role)\n                .Select(c => c.Value)\n                .ToList();\n\n            var externalRolesAlt = identity.FindAll(\"roles\")\n                .Select(c => c.Value)\n                .ToList();\n\n            var allExternalRoles = externalRoles.Concat(externalRolesAlt).Distinct();\n\n            foreach (var externalRole in allExternalRoles)\n            {\n                if (_jwtSettings.RoleMappings.TryGetValue(externalRole, out var appRole))\n                {\n                    _logger.LogDebug(\n                        \"Mapping external role {ExternalRole} to {AppRole}\",\n                        externalRole, appRole);\n                    \n                    identity.AddClaim(new Claim(ClaimTypes.Role, appRole));\n                    identity.AddClaim(new Claim(\"app_role\", appRole));\n                }\n                else\n                {\n                    // Keep unmapped roles as-is\n                    if (!identity.HasClaim(ClaimTypes.Role, externalRole))\n                    {\n                        identity.AddClaim(new Claim(ClaimTypes.Role, externalRole));\n                    }\n                }\n            }\n        }\n\n        private void AddCustomClaims(ClaimsIdentity identity)\n        {\n            // Add tenant claim if available\n            var tenantClaim = identity.FindFirst(\"tenant_id\") \n                ?? identity.FindFirst(\"tid\");\n            \n            if (tenantClaim != null && !identity.HasClaim(\"tenant\", tenantClaim.Value))\n            {\n                identity.AddClaim(new Claim(\"tenant\", tenantClaim.Value));\n            }\n\n            // Add display name\n            var nameClaim = identity.FindFirst(ClaimTypes.Name) \n                ?? identity.FindFirst(\"name\")\n                ?? identity.FindFirst(\"preferred_username\");\n            \n            if (nameClaim != null && !identity.HasClaim(\"display_name\", nameClaim.Value))\n            {\n                identity.AddClaim(new Claim(\"display_name\", nameClaim.Value));\n            }\n\n            // Add permissions claim if roles exist\n            var roles = identity.FindAll(ClaimTypes.Role).Select(c => c.Value);\n            if (roles.Any())\n            {\n                var permissions = string.Join(\",\", roles);\n                identity.AddClaim(new Claim(\"permissions\", permissions));\n            }\n        }\n\n        private void NormalizeClaims(ClaimsIdentity identity)\n        {\n            // Normalize 'sub' to NameIdentifier\n            var subClaim = identity.FindFirst(\"sub\");\n            if (subClaim != null && !identity.HasClaim(ClaimTypes.NameIdentifier, subClaim.Value))\n            {\n                identity.AddClaim(new Claim(ClaimTypes.NameIdentifier, subClaim.Value));\n            }\n\n            // Normalize email\n            var emailClaim = identity.FindFirst(\"email\");\n            if (emailClaim != null && !identity.HasClaim(ClaimTypes.Email, emailClaim.Value))\n            {\n                identity.AddClaim(new Claim(ClaimTypes.Email, emailClaim.Value));\n            }\n        }\n    }\n}\n```\n\n## 3. Custom Authorization Requirements\n\n```csharp\n// Authorization/RequiredClaimsRequirement.cs\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace JwtAuthMiddleware.Authorization\n{\n    public class RequiredClaimsRequirement : IAuthorizationRequirement\n    {\n        public List<string> RequiredClaims { get; }\n\n        public RequiredClaimsRequirement(params string[] claims)\n        {\n            RequiredClaims = claims.ToList();\n        }\n    }\n\n    public class RequiredClaimsHandler : AuthorizationHandler<RequiredClaimsRequirement>\n    {\n        private readonly ILogger<RequiredClaimsHandler> _logger;\n\n        public RequiredClaimsHandler(ILogger<RequiredClaimsHandler> logger)\n        {\n            _logger = logger;\n        }\n\n        protected override Task HandleRequirementAsync(\n            AuthorizationHandlerContext context,\n            RequiredClaimsRequirement requirement)\n        {\n            var missingClaims = new List<string>();\n\n            foreach (var claimType in requirement.RequiredClaims)\n            {\n                if (!context.User.HasClaim(c => c.Type == claimType))\n                {\n                    missingClaims.Add(claimType);\n                }\n            }\n\n            if (missingClaims.Any())\n            {\n                _logger.LogWarning(\n                    \"User {UserId} is missing required claims: {MissingClaims}\",\n                    context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value,\n                    string.Join(\", \", missingClaims));\n                \n                context.Fail();\n                return Task.CompletedTask;\n            }\n\n            context.Succeed(requirement);\n            return Task.CompletedTask;\n        }\n    }\n\n    public class RoleRequirement : IAuthorizationRequirement\n    {\n        public string[] AllowedRoles { get; }\n\n        public RoleRequirement(params string[] roles)\n        {\n            AllowedRoles = roles;\n        }\n    }\n\n    public class RoleRequirementHandler : AuthorizationHandler<RoleRequirement>\n    {\n        private readonly ILogger<RoleRequirementHandler> _logger;\n\n        public RoleRequirementHandler(ILogger<RoleRequirementHandler> logger)\n        {\n            _logger = logger;\n        }\n\n        protected override Task HandleRequirementAsync(\n            AuthorizationHandlerContext context,\n            RoleRequirement requirement)\n        {\n            var userRoles = context.User.FindAll(ClaimTypes.Role)\n                .Select(c => c.Value)\n                .ToList();\n\n            var hasRequiredRole = requirement.AllowedRoles\n                .Any(role => userRoles.Contains(role, StringComparer.OrdinalIgnoreCase));\n\n            if (hasRequiredRole)\n            {\n                _logger.LogDebug(\n                    \"User {UserId} has required role. User roles: {UserRoles}, Required: {RequiredRoles}\",\n                    context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value,\n                    string.Join(\", \", userRoles),\n                    string.Join(\", \", requirement.AllowedRoles));\n                \n                context.Succeed(requirement);\n            }\n            else\n            {\n                _logger.LogWarning(\n                    \"User {UserId} does not have required role. User roles: {UserRoles}, Required: {RequiredRoles}\",\n                    context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value,\n                    string.Join(\", \", userRoles),\n                    string.Join(\", \", requirement.AllowedRoles));\n                \n                context.Fail();\n            }\n\n            return Task.CompletedTask;\n        }\n    }\n}\n```\n\n## 4. JWT Validation Middleware\n\n```csharp\n// Middleware/JwtValidationMiddleware.cs\nusing Microsoft.AspNetCore.Http;\nusing System.IdentityModel.Tokens.Jwt;\n\nnamespace JwtAuthMiddleware.Middleware\n{\n    public class JwtValidationMiddleware\n    {\n        private readonly RequestDelegate _next;\n        private readonly ILogger<JwtValidationMiddleware> _logger;\n        private readonly JwtSettings _jwtSettings;\n\n        public JwtValidationMiddleware(\n            RequestDelegate next,\n            ILogger<JwtValidationMiddleware> logger,\n            IOptions<JwtSettings> jwtSettings)\n        {\n            _next = next;\n            _logger = logger;\n            _jwtSettings = jwtSettings.Value;\n        }\n\n        public async Task InvokeAsync(HttpContext context)\n        {\n            var token = ExtractToken(context);\n\n            if (!string.IsNullOrEmpty(token))\n            {\n                try\n                {\n                    ValidateRequiredClaims(context);\n                    LogTokenInfo(context, token);\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"Token validation failed\");\n                    context.Response.StatusCode = StatusCodes.Status401Unauthorized;\n                    await context.Response.WriteAsJsonAsync(new\n                    {\n                        error = \"invalid_token\",\n                        error_description = \"Token validation failed\"\n                    });\n                    return;\n                }\n            }\n\n            await _next(context);\n        }\n\n        private string ExtractToken(HttpContext context)\n        {\n            var authHeader = context.Request.Headers[\"Authorization\"].FirstOrDefault();\n            \n            if (string.IsNullOrEmpty(authHeader))\n                return null;\n\n            if (authHeader.StartsWith(\"Bearer \", StringComparison.OrdinalIgnoreCase))\n            {\n                return authHeader.Substring(\"Bearer \".Length).Trim();\n            }\n\n            return null;\n        }\n\n        private void ValidateRequiredClaims(HttpContext context)\n        {\n            if (!_jwtSettings.RequiredClaims.Any())\n                return;\n\n            var user = context.User;\n            var missingClaims = new List<string>();\n\n            foreach (var requiredClaim in _jwtSettings.RequiredClaims)\n            {\n                if (!user.HasClaim(c => c.Type == requiredClaim))\n                {\n                    missingClaims.Add(requiredClaim);\n                }\n            }\n\n            if (missingClaims.Any())\n            {\n                throw new UnauthorizedAccessException(\n                    $\"Missing required claims: {string.Join(\", \", missingClaims)}\");\n            }\n        }\n\n        private void LogTokenInfo(HttpContext context, string token)\n        {\n            try\n            {\n                var handler = new JwtSecurityTokenHandler();\n                var jwtToken = handler.ReadJwtToken(token);\n\n                _logger.LogInformation(\n                    \"JWT Token - Issuer: {Issuer}, Subject: {Subject}, Expires: {Expires}\",\n                    jwtToken.Issuer,\n                    jwtToken.Subject,\n                    jwtToken.ValidTo);\n\n                // Log claims for debugging (be careful in production)\n                if (_logger.IsEnabled(LogLevel.Debug))\n                {\n                    foreach (var claim in jwtToken.Claims)\n                    {\n                        _logger.LogDebug(\"Claim: {Type} = {Value}\", claim.Type, claim.Value);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"Failed to parse JWT token for logging\");\n            }\n        }\n    }\n}\n```\n\n## 5. Service Configuration Extensions\n\n```csharp\n// Extensions/JwtAuthenticationExtensions.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\n\nnamespace JwtAuthMiddleware.Extensions\n{\n    public static class JwtAuthenticationExtensions\n    {\n        public static IServiceCollection AddJwtAuthentication(\n            this IServiceCollection services,\n            IConfiguration configuration)\n        {\n            var jwtSettings = configuration.GetSection(\"JwtSettings\").Get<JwtSettings>();\n            services.Configure<JwtSettings>(configuration.GetSection(\"JwtSettings\"));\n\n            services.AddAuthentication(options =>\n            {\n                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n            })\n            .AddJwtBearer(options =>\n            {\n                options.Authority = jwtSettings.Authority;\n                options.Audience = jwtSettings.Audience;\n                options.RequireHttpsMetadata = jwtSettings.RequireHttpsMetadata;\n\n                if (!string.IsNullOrEmpty(jwtSettings.MetadataAddress))\n                {\n                    options.MetadataAddress = jwtSettings.MetadataAddress;\n                }\n\n                options.TokenValidationParameters = new TokenValidationParameters\n                {\n                    ValidateIssuer = jwtSettings.ValidateIssuer,\n                    ValidateAudience = jwtSettings.ValidateAudience,\n                    ValidateLifetime = jwtSettings.ValidateLifetime,\n                    ValidateIssuerSigningKey = true,\n                    ClockSkew = TimeSpan.FromSeconds(jwtSettings.ClockSkew),\n                    \n                    // Additional validation\n                    RequireExpirationTime = true,\n                    RequireSignedTokens = true,\n                    \n                    // Role claim type mapping\n                    RoleClaimType = ClaimTypes.Role,\n                    NameClaimType = ClaimTypes.NameIdentifier\n                };\n\n                options.Events = new JwtBearerEvents\n                {\n                    OnAuthenticationFailed = context =>\n                    {\n                        var logger = context.HttpContext.RequestServices\n                            .GetRequiredService<ILogger<Program>>();\n                        \n                        logger.LogError(context.Exception, \n                            \"Authentication failed: {Error}\", \n                            context.Exception.Message);\n\n                        if (context.Exception is SecurityTokenExpiredException)\n                        {\n                            context.Response.Headers.Add(\"Token-Expired\", \"true\");\n                        }\n\n                        return Task.CompletedTask;\n                    },\n                    OnTokenValidated = context =>\n                    {\n                        var logger = context.HttpContext.RequestServices",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 91,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# JWT Bearer Authentication Middleware with Claims Transformation\n\nI'll create a comprehensive JWT authentication solution with JWKS validation, claims checking, and role mapping.\n\n## Project Structure\n\n```\nJwtAuthMiddleware/\n\u251c\u2500\u2500 Program.cs\n\u251c\u2500\u2500 Authentication/\n\u2502   \u251c\u2500\u2500 JwtBearerConfiguration.cs\n\u2502   \u251c\u2500\u2500 ClaimsTransformation.cs\n\u2502   \u2514\u2500\u2500 JwtBearerEvents.cs\n\u251c\u2500\u2500 Authorization/\n\u2502   \u251c\u2500\u2500 RoleRequirement.cs\n\u2502   \u2514\u2500\u2500 RoleAuthorizationHandler.cs\n\u251c\u2500\u2500 Controllers/\n\u2502   \u2514\u2500\u2500 SecureController.cs\n\u251c\u2500\u2500 Models/\n\u2502   \u2514\u2500\u2500 JwtSettings.cs\n\u2514\u2500\u2500 appsettings.json\n```\n\n## Installation\n\n```bash\ndotnet new webapi -n JwtAuthMiddleware\ncd JwtAuthMiddleware\n\ndotnet add package Microsoft.AspNetCore.Authentication.JwtBearer\ndotnet add package System.IdentityModel.Tokens.Jwt\ndotnet add package Microsoft.IdentityModel.Protocols.OpenIdConnect\n```\n\n## 1. Configuration Model\n\n**Models/JwtSettings.cs**\n```csharp\nnamespace JwtAuthMiddleware.Models;\n\n/// <summary>\n/// JWT authentication configuration settings\n/// </summary>\npublic class JwtSettings\n{\n    public const string SectionName = \"JwtSettings\";\n\n    /// <summary>\n    /// Identity provider's authority URL (e.g., https://login.microsoftonline.com/{tenant-id}/v2.0)\n    /// </summary>\n    public string Authority { get; set; } = string.Empty;\n\n    /// <summary>\n    /// Expected audience (client ID) for the JWT token\n    /// </summary>\n    public string Audience { get; set; } = string.Empty;\n\n    /// <summary>\n    /// JWKS endpoint URL for token validation (optional, auto-discovered from Authority)\n    /// </summary>\n    public string? MetadataAddress { get; set; }\n\n    /// <summary>\n    /// Whether to require HTTPS for metadata endpoint\n    /// </summary>\n    public bool RequireHttpsMetadata { get; set; } = true;\n\n    /// <summary>\n    /// Token validation parameters\n    /// </summary>\n    public TokenValidationSettings Validation { get; set; } = new();\n\n    /// <summary>\n    /// Role mapping configuration\n    /// </summary>\n    public RoleMappingSettings RoleMapping { get; set; } = new();\n}\n\npublic class TokenValidationSettings\n{\n    /// <summary>\n    /// Validate token lifetime\n    /// </summary>\n    public bool ValidateLifetime { get; set; } = true;\n\n    /// <summary>\n    /// Validate token issuer\n    /// </summary>\n    public bool ValidateIssuer { get; set; } = true;\n\n    /// <summary>\n    /// Validate token audience\n    /// </summary>\n    public bool ValidateAudience { get; set; } = true;\n\n    /// <summary>\n    /// Validate issuer signing key\n    /// </summary>\n    public bool ValidateIssuerSigningKey { get; set; } = true;\n\n    /// <summary>\n    /// Clock skew for token expiration validation\n    /// </summary>\n    public TimeSpan ClockSkew { get; set; } = TimeSpan.FromMinutes(5);\n\n    /// <summary>\n    /// Required claims that must be present in the token\n    /// </summary>\n    public List<string> RequiredClaims { get; set; } = new() { \"sub\", \"email\" };\n}\n\npublic class RoleMappingSettings\n{\n    /// <summary>\n    /// External role claim type (e.g., \"roles\", \"groups\")\n    /// </summary>\n    public string ExternalRoleClaimType { get; set; } = \"roles\";\n\n    /// <summary>\n    /// Internal role claim type\n    /// </summary>\n    public string InternalRoleClaimType { get; set; } = \"http://schemas.microsoft.com/ws/2008/06/identity/claims/role\";\n\n    /// <summary>\n    /// Role mappings: external role -> internal role(s)\n    /// </summary>\n    public Dictionary<string, List<string>> Mappings { get; set; } = new();\n\n    /// <summary>\n    /// Default roles to assign if no mappings match\n    /// </summary>\n    public List<string> DefaultRoles { get; set; } = new() { \"User\" };\n}\n```\n\n## 2. JWT Bearer Configuration\n\n**Authentication/JwtBearerConfiguration.cs**\n```csharp\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing JwtAuthMiddleware.Models;\nusing System.Security.Claims;\n\nnamespace JwtAuthMiddleware.Authentication;\n\n/// <summary>\n/// Configures JWT Bearer authentication with JWKS validation\n/// </summary>\npublic static class JwtBearerConfiguration\n{\n    public static IServiceCollection AddJwtBearerAuthentication(\n        this IServiceCollection services,\n        IConfiguration configuration)\n    {\n        var jwtSettings = configuration\n            .GetSection(JwtSettings.SectionName)\n            .Get<JwtSettings>() \n            ?? throw new InvalidOperationException(\"JWT settings not configured\");\n\n        services.AddSingleton(jwtSettings);\n\n        services.AddAuthentication(options =>\n        {\n            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n        })\n        .AddJwtBearer(options =>\n        {\n            ConfigureJwtBearerOptions(options, jwtSettings);\n        });\n\n        return services;\n    }\n\n    private static void ConfigureJwtBearerOptions(\n        JwtBearerOptions options,\n        JwtSettings settings)\n    {\n        // Configure token validation parameters\n        options.TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidateIssuer = settings.Validation.ValidateIssuer,\n            ValidateAudience = settings.Validation.ValidateAudience,\n            ValidateLifetime = settings.Validation.ValidateLifetime,\n            ValidateIssuerSigningKey = settings.Validation.ValidateIssuerSigningKey,\n            \n            ValidIssuer = settings.Authority,\n            ValidAudience = settings.Audience,\n            \n            ClockSkew = settings.Validation.ClockSkew,\n            \n            // Map name claim types\n            NameClaimType = ClaimTypes.Name,\n            RoleClaimType = settings.RoleMapping.InternalRoleClaimType\n        };\n\n        // Configure OIDC metadata endpoint\n        options.Authority = settings.Authority;\n        options.RequireHttpsMetadata = settings.RequireHttpsMetadata;\n        \n        if (!string.IsNullOrEmpty(settings.MetadataAddress))\n        {\n            options.MetadataAddress = settings.MetadataAddress;\n        }\n\n        // Save token for later use\n        options.SaveToken = true;\n\n        // Configure events for custom validation\n        options.Events = new CustomJwtBearerEvents(settings);\n    }\n}\n\n/// <summary>\n/// Custom JWT Bearer events for additional validation\n/// </summary>\npublic class CustomJwtBearerEvents : JwtBearerEvents\n{\n    private readonly JwtSettings _settings;\n\n    public CustomJwtBearerEvents(JwtSettings settings)\n    {\n        _settings = settings;\n    }\n\n    public override Task TokenValidated(TokenValidatedContext context)\n    {\n        var claimsIdentity = context.Principal?.Identity as ClaimsIdentity;\n        \n        if (claimsIdentity == null)\n        {\n            context.Fail(\"Invalid token: No claims identity\");\n            return Task.CompletedTask;\n        }\n\n        // Validate required claims\n        var missingClaims = _settings.Validation.RequiredClaims\n            .Where(claim => !claimsIdentity.HasClaim(c => c.Type == claim))\n            .ToList();\n\n        if (missingClaims.Any())\n        {\n            context.Fail($\"Missing required claims: {string.Join(\", \", missingClaims)}\");\n            return Task.CompletedTask;\n        }\n\n        // Log successful authentication\n        var userId = claimsIdentity.FindFirst(\"sub\")?.Value ?? \"unknown\";\n        var logger = context.HttpContext.RequestServices\n            .GetRequiredService<ILogger<CustomJwtBearerEvents>>();\n        \n        logger.LogInformation(\n            \"Token validated successfully for user {UserId}\",\n            userId);\n\n        return Task.CompletedTask;\n    }\n\n    public override Task AuthenticationFailed(AuthenticationFailedContext context)\n    {\n        var logger = context.HttpContext.RequestServices\n            .GetRequiredService<ILogger<CustomJwtBearerEvents>>();\n\n        logger.LogWarning(\n            context.Exception,\n            \"JWT authentication failed: {Message}\",\n            context.Exception.Message);\n\n        // Provide user-friendly error messages\n        if (context.Exception is SecurityTokenExpiredException)\n        {\n            context.Response.Headers.Append(\"Token-Expired\", \"true\");\n        }\n\n        return Task.CompletedTask;\n    }\n\n    public override Task Challenge(JwtBearerChallengeContext context)\n    {\n        var logger = context.HttpContext.RequestServices\n            .GetRequiredService<ILogger<CustomJwtBearerEvents>>();\n\n        logger.LogWarning(\n            \"JWT authentication challenge issued: {Error} - {ErrorDescription}\",\n            context.Error,\n            context.ErrorDescription);\n\n        return Task.CompletedTask;\n    }\n}\n```\n\n## 3. Claims Transformation\n\n**Authentication/ClaimsTransformation.cs**\n```csharp\nusing Microsoft.AspNetCore.Authentication;\nusing System.Security.Claims;\nusing JwtAuthMiddleware.Models;\n\nnamespace JwtAuthMiddleware.Authentication;\n\n/// <summary>\n/// Transforms external identity provider claims to application-specific claims\n/// </summary>\npublic class RoleClaimsTransformation : IClaimsTransformation\n{\n    private readonly JwtSettings _settings;\n    private readonly ILogger<RoleClaimsTransformation> _logger;\n\n    public RoleClaimsTransformation(\n        JwtSettings settings,\n        ILogger<RoleClaimsTransformation> logger)\n    {\n        _settings = settings;\n        _logger = logger;\n    }\n\n    public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)\n    {\n        var claimsIdentity = principal.Identity as ClaimsIdentity;\n        \n        if (claimsIdentity == null || !claimsIdentity.IsAuthenticated)\n        {\n            return Task.FromResult(principal);\n        }\n\n        // Get external roles from token\n        var externalRoles = claimsIdentity\n            .FindAll(_settings.RoleMapping.ExternalRoleClaimType)\n            .Select(c => c.Value)\n            .ToList();\n\n        if (!externalRoles.Any())\n        {\n            _logger.LogDebug(\n                \"No external roles found for user {UserId}\",\n                claimsIdentity.FindFirst(\"sub\")?.Value);\n        }\n\n        // Map external roles to internal roles\n        var mappedRoles = MapRolesToInternal(externalRoles);\n\n        // Add mapped roles as claims\n        foreach (var role in mappedRoles)\n        {\n            if (!claimsIdentity.HasClaim(\n                _settings.RoleMapping.InternalRoleClaimType, \n                role))\n            {\n                claimsIdentity.AddClaim(new Claim(\n                    _settings.RoleMapping.InternalRoleClaimType,\n                    role));\n                \n                _logger.LogDebug(\n                    \"Added role claim: {Role} for user {UserId}\",\n                    role,\n                    claimsIdentity.FindFirst(\"sub\")?.Value);\n            }\n        }\n\n        // Add custom claims\n        AddCustomClaims(claimsIdentity);\n\n        return Task.FromResult(principal);\n    }\n\n    private List<string> MapRolesToInternal(List<string> externalRoles)\n    {\n        var mappedRoles = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n        foreach (var externalRole in externalRoles)\n        {\n            if (_settings.RoleMapping.Mappings.TryGetValue(\n                externalRole, \n                out var internalRoles))\n            {\n                foreach (var internalRole in internalRoles)\n                {\n                    mappedRoles.Add(internalRole);\n                }\n                \n                _logger.LogDebug(\n                    \"Mapped external role {ExternalRole} to internal roles: {InternalRoles}\",\n                    externalRole,\n                    string.Join(\", \", internalRoles));\n            }\n        }\n\n        // Add default roles if no mappings found\n        if (!mappedRoles.Any() && _settings.RoleMapping.DefaultRoles.Any())\n        {\n            foreach (var defaultRole in _settings.RoleMapping.DefaultRoles)\n            {\n                mappedRoles.Add(defaultRole);\n            }\n            \n            _logger.LogDebug(\n                \"No role mappings found, assigned default roles: {DefaultRoles}\",\n                string.Join(\", \", _settings.RoleMapping.DefaultRoles));\n        }\n\n        return mappedRoles.ToList();\n    }\n\n    private void AddCustomClaims(ClaimsIdentity identity)\n    {\n        // Add email_verified claim if email exists\n        var emailClaim = identity.FindFirst(\"email\");\n        if (emailClaim != null && !identity.HasClaim(\"email_verified\", \"true\"))\n        {\n            identity.AddClaim(new Claim(\"email_verified\", \"true\"));\n        }\n\n        // Add tenant information if available\n        var tenantId = identity.FindFirst(\"tid\")?.Value;\n        if (!string.IsNullOrEmpty(tenantId) && \n            !identity.HasClaim(\"tenant_id\", tenantId))\n        {\n            identity.AddClaim(new Claim(\"tenant_id\", tenantId));\n        }\n\n        // Add user display name\n        var name = identity.FindFirst(\"name\")?.Value \n            ?? identity.FindFirst(\"preferred_username\")?.Value \n            ?? identity.FindFirst(\"email\")?.Value;\n        \n        if (!string.IsNullOrEmpty(name) && \n            !identity.HasClaim(ClaimTypes.Name, name))\n        {\n            identity.AddClaim(new Claim(ClaimTypes.Name, name));\n        }\n    }\n}\n\npublic static class ClaimsTransformationExtensions\n{\n    public static IServiceCollection AddRoleClaimsTransformation(\n        this IServiceCollection services)\n    {\n        services.AddScoped<IClaimsTransformation, RoleClaimsTransformation>();\n        return services;\n    }\n}\n```\n\n## 4. Authorization Handlers\n\n**Authorization/RoleRequirement.cs**\n```csharp\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace JwtAuthMiddleware.Authorization;\n\n/// <summary>\n/// Custom authorization requirement for role-based access\n/// </summary>\npublic class RoleRequirement : IAuthorizationRequirement\n{\n    public string[] AllowedRoles { get; }\n    public bool RequireAllRoles { get; }\n\n    public RoleRequirement(string[] allowedRoles, bool requireAllRoles = false)\n    {\n        AllowedRoles = allowedRoles ?? throw new ArgumentNullException(nameof(allowedRoles));\n        RequireAllRoles = requireAllRoles;\n    }\n}\n\n/// <summary>\n/// Authorization handler for role requirements\n/// </summary>\npublic class RoleAuthorizationHandler : AuthorizationHandler<RoleRequirement>\n{\n    private readonly ILogger<RoleAuthorizationHandler> _logger;\n\n    public RoleAuthorizationHandler(ILogger<RoleAuthorizationHandler> logger)\n    {\n        _logger = logger;\n    }\n\n    protected override Task HandleRequirementAsync(\n        AuthorizationHandlerContext context,\n        RoleRequirement requirement)\n    {\n        var user = context.User;\n        var userId = user.FindFirst(\"sub\")?.Value ?? \"unknown\";\n\n        if (!user.Identity?.IsAuthenticated ?? true)\n        {\n            _logger.LogWarning(\n                \"Authorization failed: User {UserId} is not authenticated\",\n                userId);\n            return Task.CompletedTask;\n        }\n\n        var userR",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5427,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive JWT authentication middleware with claims transformation and role-based authorization.\n\n```csharp\n// Middleware/JwtAuthenticationMiddleware.cs\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing System.Security.Claims;\n\nnamespace App.Middleware;\n\npublic static class JwtAuthenticationMiddleware\n{\n    public static IServiceCollection AddJwtAuthentication(\n        this IServiceCollection services,\n        IConfiguration configuration)\n    {\n        var jwtSettings = configuration.GetSection(\"JwtSettings\");\n        var authority = jwtSettings[\"Authority\"];\n        var audience = jwtSettings[\"Audience\"];\n        var requireHttpsMetadata = jwtSettings.GetValue<bool>(\"RequireHttpsMetadata\", true);\n\n        services.AddAuthentication(options =>\n        {\n            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n        })\n        .AddJwtBearer(options =>\n        {\n            options.Authority = authority;\n            options.Audience = audience;\n            options.RequireHttpsMetadata = requireHttpsMetadata;\n            \n            options.TokenValidationParameters = new TokenValidationParameters\n            {\n                ValidateIssuer = true,\n                ValidateAudience = true,\n                ValidateLifetime = true,\n                ValidateIssuerSigningKey = true,\n                ValidIssuer = authority,\n                ValidAudience = audience,\n                ClockSkew = TimeSpan.FromMinutes(5)\n            };\n\n            options.Events = new JwtBearerEvents\n            {\n                OnAuthenticationFailed = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    logger.LogError(context.Exception, \"JWT authentication failed\");\n                    return Task.CompletedTask;\n                },\n                OnTokenValidated = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    var claimsIdentity = context.Principal?.Identity as ClaimsIdentity;\n                    \n                    // Validate required claims\n                    var sub = claimsIdentity?.FindFirst(ClaimTypes.NameIdentifier)?.Value \n                        ?? claimsIdentity?.FindFirst(\"sub\")?.Value;\n                    var email = claimsIdentity?.FindFirst(ClaimTypes.Email)?.Value \n                        ?? claimsIdentity?.FindFirst(\"email\")?.Value;\n                    \n                    if (string.IsNullOrEmpty(sub))\n                    {\n                        context.Fail(\"Missing required claim: sub\");\n                        return Task.CompletedTask;\n                    }\n                    \n                    if (string.IsNullOrEmpty(email))\n                    {\n                        context.Fail(\"Missing required claim: email\");\n                        return Task.CompletedTask;\n                    }\n                    \n                    logger.LogInformation(\"Token validated for user {Sub} ({Email})\", sub, email);\n                    return Task.CompletedTask;\n                },\n                OnChallenge = context =>\n                {\n                    var logger = context.HttpContext.RequestServices\n                        .GetRequiredService<ILogger<Program>>();\n                    logger.LogWarning(\"JWT challenge triggered: {Error}\", context.Error);\n                    return Task.CompletedTask;\n                }\n            };\n        });\n\n        services.AddAuthorization(options =>\n        {\n            options.AddPolicy(\"AdminOnly\", policy => \n                policy.RequireRole(\"Admin\"));\n            options.AddPolicy(\"UserOrAdmin\", policy => \n                policy.RequireRole(\"User\", \"Admin\"));\n            options.AddPolicy(\"RequireEmail\", policy => \n                policy.RequireClaim(ClaimTypes.Email));\n        });\n\n        services.AddScoped<IClaimsTransformation, RoleClaimsTransformation>();\n\n        return services;\n    }\n}\n```\n\n```csharp\n// Services/RoleClaimsTransformation.cs\nusing Microsoft.AspNetCore.Authentication;\nusing System.Security.Claims;\n\nnamespace App.Services;\n\npublic class RoleClaimsTransformation : IClaimsTransformation\n{\n    private readonly ILogger<RoleClaimsTransformation> _logger;\n    private readonly IConfiguration _configuration;\n\n    public RoleClaimsTransformation(\n        ILogger<RoleClaimsTransformation> logger,\n        IConfiguration configuration)\n    {\n        _logger = logger;\n        _configuration = configuration;\n    }\n\n    public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)\n    {\n        var claimsIdentity = principal.Identity as ClaimsIdentity;\n        if (claimsIdentity == null || !claimsIdentity.IsAuthenticated)\n        {\n            return Task.FromResult(principal);\n        }\n\n        // Get external roles from token\n        var externalRoles = principal.FindAll(\"roles\")\n            .Select(c => c.Value)\n            .ToList();\n\n        if (!externalRoles.Any())\n        {\n            externalRoles = principal.FindAll(ClaimTypes.Role)\n                .Select(c => c.Value)\n                .ToList();\n        }\n\n        // Map external roles to application roles\n        var roleMappings = _configuration.GetSection(\"RoleMappings\")\n            .Get<Dictionary<string, string>>() ?? new Dictionary<string, string>();\n\n        var mappedRoles = new HashSet<string>();\n        foreach (var externalRole in externalRoles)\n        {\n            if (roleMappings.TryGetValue(externalRole, out var appRole))\n            {\n                mappedRoles.Add(appRole);\n                _logger.LogDebug(\"Mapped external role {ExternalRole} to {AppRole}\", \n                    externalRole, appRole);\n            }\n            else\n            {\n                // If no mapping exists, use the external role as-is\n                mappedRoles.Add(externalRole);\n            }\n        }\n\n        // Add mapped roles as claims\n        var newIdentity = new ClaimsIdentity(claimsIdentity);\n        foreach (var role in mappedRoles)\n        {\n            if (!newIdentity.HasClaim(ClaimTypes.Role, role))\n            {\n                newIdentity.AddClaim(new Claim(ClaimTypes.Role, role));\n            }\n        }\n\n        // Add custom claims\n        var userId = principal.FindFirst(\"sub\")?.Value \n            ?? principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n        if (!string.IsNullOrEmpty(userId) && !newIdentity.HasClaim(\"UserId\", userId))\n        {\n            newIdentity.AddClaim(new Claim(\"UserId\", userId));\n        }\n\n        var email = principal.FindFirst(\"email\")?.Value \n            ?? principal.FindFirst(ClaimTypes.Email)?.Value;\n        if (!string.IsNullOrEmpty(email) && !newIdentity.HasClaim(ClaimTypes.Email, email))\n        {\n            newIdentity.AddClaim(new Claim(ClaimTypes.Email, email));\n        }\n\n        _logger.LogInformation(\"Claims transformation completed for user {UserId}. Roles: {Roles}\", \n            userId, string.Join(\", \", mappedRoles));\n\n        return Task.FromResult(new ClaimsPrincipal(newIdentity));\n    }\n}\n```\n\n```csharp\n// Controllers/SecureController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Security.Claims;\n\nnamespace App.Controllers;\n\n[ApiController]\n[Route(\"api/[controller]\")]\n[Authorize]\npublic class SecureController : ControllerBase\n{\n    private readonly ILogger<SecureController> _logger;\n\n    public SecureController(ILogger<SecureController> logger)\n    {\n        _logger = logger;\n    }\n\n    [HttpGet(\"profile\")]\n    public IActionResult GetProfile()\n    {\n        var userId = User.FindFirst(\"UserId\")?.Value \n            ?? User.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n        var email = User.FindFirst(ClaimTypes.Email)?.Value;\n        var roles = User.FindAll(ClaimTypes.Role).Select(c => c.Value).ToList();\n\n        return Ok(new\n        {\n            UserId = userId,\n            Email = email,\n            Roles = roles,\n            Claims = User.Claims.Select(c => new { c.Type, c.Value })\n        });\n    }\n\n    [HttpGet(\"admin\")]\n    [Authorize(Roles = \"Admin\")]\n    public IActionResult AdminOnly()\n    {\n        return Ok(new { Message = \"Admin access granted\" });\n    }\n\n    [HttpGet(\"user\")]\n    [Authorize(Policy = \"UserOrAdmin\")]\n    public IActionResult UserAccess()\n    {\n        return Ok(new { Message = \"User or Admin access granted\" });\n    }\n\n    [HttpGet(\"public\")]\n    [AllowAnonymous]\n    public IActionResult Public()\n    {\n        return Ok(new { Message = \"Public endpoint - no authentication required\" });\n    }\n}\n```\n\n```json\n// appsettings.json\n{\n  \"JwtSettings\": {\n    \"Authority\": \"https://your-identity-provider.com\",\n    \"Audience\": \"your-api-audience\",\n    \"RequireHttpsMetadata\": true\n  },\n  \"RoleMappings\": {\n    \"external-admin\": \"Admin\",\n    \"external-user\": \"User\",\n    \"external-moderator\": \"Moderator\",\n    \"external-viewer\": \"User\"\n  },\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore.Authentication\": \"Debug\"\n    }\n  }\n}\n```\n\n```json\n// appsettings.Development.json\n{\n  \"JwtSettings\": {\n    \"Authority\": \"https://dev-identity-provider.com\",\n    \"Audience\": \"dev-api-audience\",\n    \"RequireHttpsMetadata\": false\n  },\n  \"RoleMappings\": {\n    \"dev-admin\": \"Admin\",\n    \"dev-user\": \"User\"\n  }\n}\n```\n\n```csharp\n// Program.cs\nusing App.Middleware;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen(options =>\n{\n    options.AddSecurityDefinition(\"Bearer\", new Microsoft.OpenApi.Models.OpenApiSecurityScheme\n    {\n        Name = \"Authorization\",\n        Type = Microsoft.OpenApi.Models.SecuritySchemeType.Http,\n        Scheme = \"Bearer\",\n        BearerFormat = \"JWT\",\n        In = Microsoft.OpenApi.Models.ParameterLocation.Header,\n        Description = \"JWT Authorization header using the Bearer scheme.\"\n    });\n    options.AddSecurityRequirement(new Microsoft.OpenApi.Models.OpenApiSecurityRequirement\n    {\n        {\n            new Microsoft.OpenApi.Models.OpenApiSecurityScheme\n            {\n                Reference = new Microsoft.OpenApi.Models.OpenApiReference\n                {\n                    Type = Microsoft.OpenApi.Models.ReferenceType.SecurityScheme,\n                    Id = \"Bearer\"\n                }\n            },\n            Array.Empty<string>()\n        }\n    });\n});\n\n// Add JWT authentication\nbuilder.Services.AddJwtAuthentication(builder.Configuration);\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n```xml\n<!-- Add to your .csproj file -->\n<ItemGroup>\n  <PackageReference Include=\"Microsoft.AspNetCore.Authentication.JwtBearer\" Version=\"8.0.0\" />\n</ItemGroup>\n```\n\n```csharp\n// Services/IUserService.cs (Example service using authentication)\nusing System.Security.Claims;\n\nnamespace App.Services;\n\npublic interface IUserService\n{\n    Task<UserDto?> GetCurrentUserAsync();\n    bool IsInRole(string role);\n}\n\npublic class UserService : IUserService\n{\n    private readonly IHttpContextAccessor _httpContextAccessor;\n    private readonly ILogger<UserService> _logger;\n\n    public UserService(\n        IHttpContextAccessor httpContextAccessor,\n        ILogger<UserService> logger)\n    {\n        _httpContextAccessor = httpContextAccessor;\n        _logger = logger;\n    }\n\n    public async Task<UserDto?> GetCurrentUserAsync()\n    {\n        var user = _httpContextAccessor.HttpContext?.User;\n        if (user?.Identity?.IsAuthenticated != true)\n        {\n            return null;\n        }\n\n        var userId = user.FindFirst(\"UserId\")?.Value \n            ?? user.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n        var email = user.FindFirst(ClaimTypes.Email)?.Value;\n        var roles = user.FindAll(ClaimTypes.Role).Select(c => c.Value).ToList();\n\n        return await Task.FromResult(new UserDto\n        {\n            Id = userId ?? string.Empty,\n            Email = email ?? string.Empty,\n            Roles = roles\n        });\n    }\n\n    public bool IsInRole(string role)\n    {\n        var user = _httpContextAccessor.HttpContext?.User;\n        return user?.IsInRole(role) ?? false;\n    }\n}\n\npublic class UserDto\n{\n    public string Id { get; set; } = string.Empty;\n    public string Email { get; set; } = string.Empty;\n    public List<string> Roles { get; set; } = new();\n}\n```\n\nThis implementation provides:\n\n1. **JWT Authentication Middleware** - Validates tokens against JWKS endpoint\n2. **Required Claims Validation** - Checks for sub, email, and roles\n3. **Custom Claims Transformation** - Maps external roles to application roles\n4. **Role-Based Authorization** - Using [Authorize] attributes and policies\n5. **Comprehensive Logging** - For debugging authentication issues\n6. **Swagger Integration** - For testing with JWT tokens\n7. **Example Controllers** - Demonstrating different authorization levels\n\nThe role mapping configuration allows you to map identity provider roles to your application's role structure without code changes.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5933,
            "output_tokens": 3633,
            "cached": false
          }
        }
      ]
    }
  ]
}