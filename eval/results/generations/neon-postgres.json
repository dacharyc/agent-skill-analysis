{
  "skill_name": "neon-postgres",
  "generated_at": "2026-02-16T10:37:50.888510+00:00",
  "model": "claude-sonnet-4-5-20250929",
  "temperature": 0.3,
  "runs_per_condition": 3,
  "contamination_score": 0.0,
  "risk_level": "medium",
  "test_category": "hidden_contamination",
  "tasks": [
    {
      "task_id": "neon-postgres-01",
      "task_type": "direct_target",
      "target_language": "typescript",
      "expected_patterns": [
        "import.*@neondatabase/serverless|neon.*serverless",
        "neon\\(",
        "process\\.env\\.DATABASE_URL|DATABASE_URL",
        "interface\\s+User|type\\s+User",
        "async\\s+function|async\\s+\\(",
        "export"
      ],
      "anti_patterns": [
        "import psycopg|import asyncpg",
        "neon_api|NeonAPI",
        "from neon_api",
        "pip install",
        "def\\s+\\w+\\(",
        "class\\s+.*Model"
      ],
      "pattern_sources": [
        {
          "url": "https://neon.com/docs/serverless/serverless-driver.md",
          "description": "Neon serverless driver: import { neon } from '@neondatabase/serverless', neon(process.env.DATABASE_URL) function, template literal queries with sql``, TypeScript usage with async/await"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html",
          "description": "TypeScript object types - source of interface and type declarations for User interface definition"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html",
          "description": "TypeScript functions - source of async function syntax for database queries"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/modules.html",
          "description": "TypeScript modules - source of export keyword for exporting functions from modules"
        },
        {
          "url": "https://neon.com/docs/guides/python.md",
          "description": "Anti-patterns: Python database drivers (psycopg, asyncpg imports) that should not appear in TypeScript"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "```typescript\n// pages/api/users/by-domain.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { neon, NeonQueryFunction } from '@neondatabase/serverless';\n\n/**\n * User interface representing the structure of user data\n */\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\n/**\n * API Response type\n */\ninterface ApiResponse {\n  success: boolean;\n  data?: User[];\n  error?: string;\n  message?: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres database\n * @param domain - The email domain to filter users (e.g., \"example.com\")\n * @returns Promise resolving to an array of User objects\n * @throws Error if database connection or query fails\n */\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  // Validate input\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  let sql: NeonQueryFunction<false, false>;\n\n  try {\n    // Create connection to Neon Postgres\n    sql = neon(process.env.DATABASE_URL);\n\n    // Run parameterized SELECT query\n    // Using parameterized queries to prevent SQL injection\n    const query = `\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC\n    `;\n\n    // Execute query with parameterized domain\n    const result = await sql(query, [`%@${domain}`]);\n\n    // Map results to User type\n    const users: User[] = result.map((row: any) => ({\n      id: row.id,\n      email: row.email,\n      name: row.name,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n\n    return users;\n  } catch (error) {\n    // Handle connection and query errors\n    if (error instanceof Error) {\n      throw new Error(`Database error: ${error.message}`);\n    }\n    throw new Error('An unknown database error occurred');\n  }\n}\n\n/**\n * Next.js API route handler\n */\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({\n      success: false,\n      error: 'Method not allowed',\n      message: 'Only GET requests are supported',\n    });\n  }\n\n  try {\n    // Extract domain from query parameters\n    const { domain } = req.query;\n\n    // Validate domain parameter\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({\n        success: false,\n        error: 'Bad request',\n        message: 'Domain query parameter is required',\n      });\n    }\n\n    // Fetch users by domain\n    const users = await getUsersByEmailDomain(domain);\n\n    // Return successful response\n    return res.status(200).json({\n      success: true,\n      data: users,\n      message: `Found ${users.length} user(s) with email domain @${domain}`,\n    });\n  } catch (error) {\n    // Log error for debugging (in production, use proper logging service)\n    console.error('API Error:', error);\n\n    // Return error response\n    return res.status(500).json({\n      success: false,\n      error: 'Internal server error',\n      message: error instanceof Error ? error.message : 'An unexpected error occurred',\n    });\n  }\n}\n```\n\n```typescript\n// Alternative: App Router version (app/api/users/by-domain/route.ts)\nimport { NextRequest, NextResponse } from 'next/server';\nimport { neon } from '@neondatabase/serverless';\n\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  try {\n    const sql = neon(process.env.DATABASE_URL);\n\n    const query = `\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC\n    `;\n\n    const result = await sql(query, [`%@${domain}`]);\n\n    const users: User[] = result.map((row: any) => ({\n      id: row.id,\n      email: row.email,\n      name: row.name,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n\n    return users;\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Database error: ${error.message}`);\n    }\n    throw new Error('An unknown database error occurred');\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get('domain');\n\n    if (!domain) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Bad request',\n          message: 'Domain query parameter is required',\n        },\n        { status: 400 }\n      );\n    }\n\n    const users = await getUsersByEmailDomain(domain);\n\n    return NextResponse.json(\n      {\n        success: true,\n        data: users,\n        message: `Found ${users.length} user(s) with email domain @${domain}`,\n      },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('API Error:', error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Internal server error',\n        message: error instanceof Error ? error.message : 'An unexpected error occurred',\n      },\n      { status: 500 }\n    );\n  }\n}\n```\n\n```typescript\n// Example usage in a component or another API route\nimport { getUsersByEmailDomain, User } from '@/pages/api/users/by-domain';\n\nasync function exampleUsage() {\n  try {\n    const users: User[] = await getUsersByEmailDomain('gmail.com');\n    console.log(`Found ${users.length} Gmail users:`, users);\n  } catch (error) {\n    console.error('Failed to fetch users:', error);\n  }\n}\n```\n\n**Key Features:**\n\n1. **Proper TypeScript typing** with `User` interface\n2. **Parameterized queries** to prevent SQL injection\n3. **Environment variable validation**\n4. **Comprehensive error handling** for connection and query errors\n5. **Input validation** for domain parameter\n6. **Structured API responses** with success/error states\n7. **Support for both Pages Router and App Router**\n8. **Reusable function** that can be imported elsewhere\n9. **HTTP method validation**\n10. **Proper status codes** for different scenarios\n\n**Usage:**\n```\nGET /api/users/by-domain?domain=gmail.com\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 98,
            "output_tokens": 1920,
            "cached": true
          },
          "with_skill": {
            "output": "```typescript\n// app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextResponse } from \"next/server\";\n\n// User interface matching your database schema\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., \"example.com\")\n * @returns Array of User objects\n */\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  // Create Neon HTTP connection\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Parameterized query using tagged template literals\n    // The % wildcards are safely included in the parameter\n    const users = await sql<User[]>`\n      SELECT id, email, name, created_at\n      FROM users\n      WHERE email LIKE ${\"%\" + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users for domain: ${domain}. ${error instanceof Error ? error.message : \"Unknown error\"}`\n    );\n  }\n}\n\n// Next.js API route handler\nexport async function GET(request: Request) {\n  try {\n    // Extract domain from query parameters\n    const { searchParams } = new URL(request.url);\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Domain parameter is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate domain format (basic check)\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json(\n        { error: \"Invalid domain format\" },\n        { status: 400 }\n      );\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return NextResponse.json({\n      success: true,\n      count: users.length,\n      data: users,\n    });\n  } catch (error) {\n    console.error(\"API route error:\", error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error:\n          error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n```\n\n**Alternative version with `sql.query()` for manual parameterization:**\n\n```typescript\n// If you prefer the .query() method instead of tagged templates\nexport async function getUsersByDomainAlt(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    const users = await sql.query<User>(\n      `\n      SELECT id, email, name, created_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC\n    `,\n      [\"%\" + domain]\n    );\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users for domain: ${domain}. ${error instanceof Error ? error.message : \"Unknown error\"}`\n    );\n  }\n}\n```\n\n**Environment setup (.env.local):**\n\n```bash\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-1.aws.neon.tech/neondb\n```\n\n**Usage example:**\n\n```bash\n# Fetch all users with @example.com emails\ncurl http://localhost:3000/api/users/by-domain?domain=example.com\n```\n\n**Response format:**\n\n```json\n{\n  \"success\": true,\n  \"count\": 3,\n  \"data\": [\n    {\n      \"id\": 1,\n      \"email\": \"john@example.com\",\n      \"name\": \"John Doe\",\n      \"created_at\": \"2024-01-15T10:30:00.000Z\"\n    },\n    {\n      \"id\": 2,\n      \"email\": \"jane@example.com\",\n      \"name\": \"Jane Smith\",\n      \"created_at\": \"2024-01-14T09:15:00.000Z\"\n    }\n  ]\n}\n```\n\n**Key features:**\n\n1. \u2705 Uses `neon()` HTTP driver for fast serverless queries\n2. \u2705 Parameterized queries prevent SQL injection\n3. \u2705 Proper TypeScript typing with `User` interface\n4. \u2705 Comprehensive error handling\n5. \u2705 Environment variable validation\n6. \u2705 Input validation for domain parameter\n7. \u2705 Structured JSON responses",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24688,
            "output_tokens": 1248,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Next.js API Route with Neon Serverless Driver\n\nHere's a complete TypeScript module for a Next.js API route that connects to Neon Postgres using the `@neondatabase/serverless` driver:\n\n```typescript\n// app/api/users/route.ts (App Router)\n// or pages/api/users.ts (Pages Router)\n\nimport { neon } from '@neondatabase/serverless';\nimport { NextRequest, NextResponse } from 'next/server';\n\n// User interface matching your database schema\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n// Response type for better type safety\ninterface UsersResponse {\n  users: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  error: string;\n  details?: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., 'example.com')\n * @returns Array of users matching the domain\n */\nexport async function getUsersByDomain(\n  domain: string\n): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  // Create Neon serverless connection\n  const sql = neon<User[]>(process.env.DATABASE_URL);\n\n  try {\n    // Run parameterized query to prevent SQL injection\n    // The % wildcards are safely included in the parameter\n    const users = await sql(\n      `SELECT id, email, name, created_at \n       FROM users \n       WHERE email LIKE $1 \n       ORDER BY created_at DESC`,\n      [`%@${domain}`]\n    );\n\n    return users;\n  } catch (error) {\n    // Re-throw with context for better error handling\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('Unknown database error occurred');\n  }\n}\n\n// App Router (Next.js 13+) API Route Handler\nexport async function GET(request: NextRequest) {\n  try {\n    // Extract domain from query parameters\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get('domain');\n\n    // Validate required parameter\n    if (!domain) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Missing required parameter: domain' },\n        { status: 400 }\n      );\n    }\n\n    // Basic domain validation\n    if (!/^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Invalid domain format' },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return NextResponse.json<UsersResponse>(\n      {\n        users,\n        count: users.length,\n      },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('API route error:', error);\n\n    // Handle specific error types\n    if (error instanceof Error) {\n      if (error.message.includes('DATABASE_URL')) {\n        return NextResponse.json<ErrorResponse>(\n          { error: 'Database configuration error' },\n          { status: 500 }\n        );\n      }\n\n      if (error.message.includes('Database query failed')) {\n        return NextResponse.json<ErrorResponse>(\n          {\n            error: 'Database query failed',\n            details: error.message,\n          },\n          { status: 500 }\n        );\n      }\n    }\n\n    // Generic error response\n    return NextResponse.json<ErrorResponse>(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n// Pages Router (Next.js 12 and earlier) API Route Handler\n// Uncomment if using Pages Router instead of App Router\n/*\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<UsersResponse | ErrorResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { domain } = req.query;\n\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({ error: 'Missing required parameter: domain' });\n    }\n\n    if (!/^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return res.status(400).json({ error: 'Invalid domain format' });\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return res.status(200).json({\n      users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error('API route error:', error);\n\n    if (error instanceof Error) {\n      if (error.message.includes('DATABASE_URL')) {\n        return res.status(500).json({ error: 'Database configuration error' });\n      }\n\n      if (error.message.includes('Database query failed')) {\n        return res.status(500).json({\n          error: 'Database query failed',\n          details: error.message,\n        });\n      }\n    }\n\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}\n*/\n```\n\n## Installation\n\n```bash\nnpm install @neondatabase/serverless\n```\n\n## Environment Setup\n\nAdd to your `.env.local`:\n\n```bash\nDATABASE_URL=\"postgresql://user:password@ep-xxx.region.aws.neon.tech/dbname?sslmode=require\"\n```\n\n## Usage Examples\n\n### Client-side fetch (App Router)\n\n```typescript\n// app/components/UserList.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\nexport default function UserList() {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const fetchUsers = async (domain: string) => {\n    setLoading(true);\n    try {\n      const response = await fetch(`/api/users?domain=${encodeURIComponent(domain)}`);\n      const data = await response.json();\n      \n      if (response.ok) {\n        setUsers(data.users);\n      } else {\n        console.error('Error:', data.error);\n      }\n    } catch (error) {\n      console.error('Fetch error:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div>\n      <button onClick={() => fetchUsers('gmail.com')}>\n        Load Gmail Users\n      </button>\n      {loading && <p>Loading...</p>}\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>{user.name} - {user.email}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n### Server-side usage (Server Component)\n\n```typescript\n// app/users/page.tsx\nimport { getUsersByDomain } from '@/app/api/users/route';\n\nexport default async function UsersPage() {\n  const users = await getUsersByDomain('example.com');\n\n  return (\n    <div>\n      <h1>Users from example.com</h1>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>{user.name} - {user.email}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## Key Features\n\n1. **Parameterized Queries**: Uses `$1` placeholder to prevent SQL injection\n2. **Type Safety**: Full TypeScript types for User interface and responses\n3. **Error Handling**: Comprehensive error catching and meaningful error messages\n4. **Environment Validation**: Checks for DATABASE_URL before attempting connection\n5. **Input Validation**: Validates domain format before querying\n6. **HTTP over WebSockets**: Uses Neon's HTTP protocol (default for `neon()` function)\n\n## Connection Details\n\nThe `@neondatabase/serverless` driver uses **HTTP by default** when you use the `neon()` function, which is ideal for:\n- Serverless/edge functions\n- Short-lived connections\n- Environments where WebSocket connections aren't supported\n\nFor WebSocket connections (better for long-running processes), use `neonConfig.webSocketConstructor` as documented in the Neon serverless driver guide.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2240,
            "output_tokens": 2237,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a TypeScript module for a Next.js API route that connects to Neon Postgres using the serverless driver.\n\n```typescript\n// src/app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\ninterface GetUsersByDomainParams {\n  domain: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., \"example.com\")\n * @returns Array of users matching the domain\n */\nexport async function getUsersByDomain(\n  domain: string,\n): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Use parameterized query with LIKE pattern for domain matching\n    // The % wildcard matches any characters before @domain\n    const users = await sql<User[]>`\n      SELECT id, name, email, created_at, updated_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users by domain: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    );\n  }\n}\n\n/**\n * GET /api/users/by-domain?domain=example.com\n * Returns users filtered by email domain\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Domain parameter is required\" },\n        { status: 400 },\n      );\n    }\n\n    // Validate domain format (basic validation)\n    const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\\.[a-zA-Z]{2,}$/;\n    if (!domainRegex.test(domain)) {\n      return NextResponse.json(\n        { error: \"Invalid domain format\" },\n        { status: 400 },\n      );\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return NextResponse.json({\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error(\"API route error:\", error);\n    return NextResponse.json(\n      {\n        error: error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 },\n    );\n  }\n}\n```\n\nNow let me create a reusable database client module:\n\n```typescript\n// src/lib/db/client.ts\nimport { neon } from \"@neondatabase/serverless\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL environment variable is not set\");\n}\n\n/**\n * Neon serverless SQL client\n * Uses HTTP fetch for fast, single queries in serverless environments\n */\nexport const sql = neon(process.env.DATABASE_URL);\n\n/**\n * Type-safe query wrapper with error handling\n */\nexport async function query<T>(\n  queryFn: () => Promise<T>,\n): Promise<{ data: T | null; error: string | null }> {\n  try {\n    const data = await queryFn();\n    return { data, error: null };\n  } catch (error) {\n    console.error(\"Database query error:\", error);\n    return {\n      data: null,\n      error: error instanceof Error ? error.message : \"Unknown database error\",\n    };\n  }\n}\n```\n\nAnd here's an example of using the reusable client:\n\n```typescript\n// src/lib/db/users.ts\nimport { sql, query } from \"./client\";\n\nexport interface User {\n  id: number;\n  name: string;\n  email: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\n/**\n * Fetches users by email domain\n */\nexport async function getUsersByDomain(domain: string) {\n  return query(async () => {\n    const users = await sql<User[]>`\n      SELECT id, name, email, created_at, updated_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n    return users;\n  });\n}\n\n/**\n * Fetches a single user by email\n */\nexport async function getUserByEmail(email: string) {\n  return query(async () => {\n    const [user] = await sql<User[]>`\n      SELECT id, name, email, created_at, updated_at\n      FROM users\n      WHERE email = ${email}\n      LIMIT 1\n    `;\n    return user || null;\n  });\n}\n\n/**\n * Fetches all users with pagination\n */\nexport async function getUsers(limit = 10, offset = 0) {\n  return query(async () => {\n    const users = await sql<User[]>`\n      SELECT id, name, email, created_at, updated_at\n      FROM users\n      ORDER BY created_at DESC\n      LIMIT ${limit}\n      OFFSET ${offset}\n    `;\n    return users;\n  });\n}\n```\n\nKey features:\n\n1. **Parameterized queries** - Uses tagged template literals for safe SQL injection prevention\n2. **TypeScript types** - Strongly typed User interface and query results\n3. **Error handling** - Catches and logs database errors, returns meaningful error messages\n4. **Environment validation** - Checks for DATABASE_URL before attempting connection\n5. **Reusable client** - Separates DB client from business logic for better organization\n6. **Next.js API route** - Complete GET handler with validation and proper HTTP responses\n\nTo use this, you'll need to:\n\n```bash\nnpm install @neondatabase/serverless\n```\n\nAnd add to your `.env.local`:\n```\nDATABASE_URL=postgresql://user:password@host.neon.tech/database\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25183,
            "output_tokens": 1582,
            "cached": true
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "```typescript\n// pages/api/users/by-domain.ts\nimport { neon, NeonQueryFunction } from '@neondatabase/serverless';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\n// User interface definition\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\n// API response types\ntype SuccessResponse = {\n  success: true;\n  data: User[];\n  count: number;\n};\n\ntype ErrorResponse = {\n  success: false;\n  error: string;\n  details?: string;\n};\n\ntype ApiResponse = SuccessResponse | ErrorResponse;\n\n/**\n * Fetches users by email domain from the database\n * @param domain - The email domain to search for (e.g., \"example.com\")\n * @returns Array of User objects matching the domain\n * @throws Error if DATABASE_URL is not configured or query fails\n */\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not configured');\n  }\n\n  // Validate input\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  let sql: NeonQueryFunction<false, false>;\n\n  try {\n    // Create connection using neon()\n    sql = neon(process.env.DATABASE_URL);\n\n    // Run parameterized SELECT query\n    // Using LIKE with parameterized query to search for email domain\n    const emailPattern = `%@${domain}`;\n    \n    const result = await sql<User[]>(\n      `SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC`,\n      [emailPattern]\n    );\n\n    // Return typed results\n    return result as User[];\n  } catch (error) {\n    // Handle connection and query errors\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('An unknown database error occurred');\n  }\n}\n\n/**\n * Next.js API route handler\n */\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({\n      success: false,\n      error: 'Method not allowed',\n    });\n  }\n\n  try {\n    // Extract domain from query parameters\n    const { domain } = req.query;\n\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing or invalid domain parameter',\n        details: 'Please provide a domain query parameter (e.g., ?domain=example.com)',\n      });\n    }\n\n    // Fetch users by domain\n    const users = await getUsersByEmailDomain(domain);\n\n    // Return successful response\n    return res.status(200).json({\n      success: true,\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error('API Error:', error);\n\n    // Return error response\n    return res.status(500).json({\n      success: false,\n      error: 'Internal server error',\n      details: error instanceof Error ? error.message : 'Unknown error occurred',\n    });\n  }\n}\n```\n\n```typescript\n// Alternative version using App Router (app/api/users/by-domain/route.ts)\nimport { neon } from '@neondatabase/serverless';\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not configured');\n  }\n\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  try {\n    const sql = neon(process.env.DATABASE_URL);\n    const emailPattern = `%@${domain}`;\n    \n    const result = await sql<User[]>(\n      `SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC`,\n      [emailPattern]\n    );\n\n    return result as User[];\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('An unknown database error occurred');\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get('domain');\n\n    if (!domain) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Missing domain parameter',\n        },\n        { status: 400 }\n      );\n    }\n\n    const users = await getUsersByEmailDomain(domain);\n\n    return NextResponse.json({\n      success: true,\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error('API Error:', error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Internal server error',\n        details: error instanceof Error ? error.message : 'Unknown error occurred',\n      },\n      { status: 500 }\n    );\n  }\n}\n```\n\n```typescript\n// Example .env.local file\n// DATABASE_URL=postgresql://user:password@ep-xxx-xxx.us-east-2.aws.neon.tech/dbname?sslmode=require\n```\n\n```typescript\n// Example usage in a component or another API route\nimport { getUsersByEmailDomain, User } from '@/pages/api/users/by-domain';\n\nasync function example() {\n  try {\n    const users: User[] = await getUsersByEmailDomain('gmail.com');\n    console.log(`Found ${users.length} users with @gmail.com emails`);\n    users.forEach(user => {\n      console.log(`${user.name} - ${user.email}`);\n    });\n  } catch (error) {\n    console.error('Error fetching users:', error);\n  }\n}\n```\n\nThis module includes:\n\n1. **Proper TypeScript types** for User interface and API responses\n2. **Connection using neon()** with DATABASE_URL environment variable\n3. **Parameterized SELECT query** to prevent SQL injection\n4. **Typed return values** for type safety\n5. **Comprehensive error handling** for connection and query errors\n6. **Input validation** for domain parameter\n7. **Both Pages Router and App Router** implementations\n8. **Proper HTTP status codes** and response formatting\n9. **Reusable function** that can be imported elsewhere\n10. **Documentation** with JSDoc comments",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 98,
            "output_tokens": 1792,
            "cached": true
          },
          "with_skill": {
            "output": "```typescript\n// app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextResponse } from \"next/server\";\n\n// User interface matching the database schema\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., \"example.com\")\n * @returns Array of User objects\n */\nexport async function getUsersByDomain(\n  domain: string\n): Promise<User[]> {\n  // Validate input\n  if (!domain || typeof domain !== \"string\") {\n    throw new Error(\"Invalid domain parameter\");\n  }\n\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  // Create connection using neon() function\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Run parameterized query using tagged template literal\n    // This prevents SQL injection by safely interpolating the domain parameter\n    const users = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    // Handle database errors\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users by domain: ${error instanceof Error ? error.message : \"Unknown error\"}`\n    );\n  }\n}\n\n// Next.js API Route Handler\nexport async function GET(request: Request) {\n  try {\n    // Extract domain from query parameters\n    const { searchParams } = new URL(request.url);\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Domain parameter is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users by domain\n    const users = await getUsersByDomain(domain);\n\n    return NextResponse.json({\n      success: true,\n      count: users.length,\n      users,\n    });\n  } catch (error) {\n    console.error(\"API route error:\", error);\n    \n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n```\n\n**Usage example:**\n\n```typescript\n// Call the API route\nconst response = await fetch('/api/users/by-domain?domain=example.com');\nconst data = await response.json();\n\n// Or use the function directly in a Server Component\nimport { getUsersByDomain } from '@/app/api/users/by-domain/route';\n\nexport default async function UsersPage() {\n  const users = await getUsersByDomain('example.com');\n  \n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name} - {user.email}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n**Environment setup (.env.local):**\n\n```bash\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-1.aws.neon.tech/neondb\n```\n\n**Key features:**\n\n1. \u2705 Uses `neon()` function for HTTP-based queries (optimal for serverless)\n2. \u2705 Parameterized query with tagged template literal (prevents SQL injection)\n3. \u2705 Proper TypeScript typing with `User` interface\n4. \u2705 Comprehensive error handling with try/catch\n5. \u2705 Environment variable validation\n6. \u2705 Input validation for the domain parameter\n7. \u2705 Next.js App Router API route handler\n8. \u2705 Returns typed results as JSON\n\n**Alternative: Using `.query()` method:**\n\n```typescript\n// If you prefer the .query() method over tagged templates:\nconst users = await sql.query<User>(\n  `SELECT id, email, name, created_at \n   FROM users \n   WHERE email LIKE $1 \n   ORDER BY created_at DESC`,\n  [`%@${domain}`]\n);\n```\n\nBoth approaches are safe and prevent SQL injection. The tagged template literal is more concise, while `.query()` is more explicit about parameter binding.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24688,
            "output_tokens": 1108,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Next.js API Route with Neon Serverless Driver\n\nHere's a complete TypeScript module for a Next.js API route that connects to Neon Postgres using the `@neondatabase/serverless` driver:\n\n```typescript\n// app/api/users/route.ts (App Router)\n// or pages/api/users.ts (Pages Router)\n\nimport { neon } from '@neondatabase/serverless';\nimport { NextRequest, NextResponse } from 'next/server';\n\n// User interface matching your database schema\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n// Response type for better type safety\ninterface UsersResponse {\n  users: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  error: string;\n  details?: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., 'example.com')\n * @returns Array of users matching the domain\n */\nasync function getUsersByDomain(domain: string): Promise<User[]> {\n  // Validate DATABASE_URL exists\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  // Create Neon serverless connection\n  const sql = neon<User[]>(process.env.DATABASE_URL);\n\n  try {\n    // Run parameterized query to prevent SQL injection\n    // The LIKE pattern matches emails ending with @domain\n    const users = await sql`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    // Re-throw with more context\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('Unknown database error occurred');\n  }\n}\n\n// App Router (Next.js 13+) - GET handler\nexport async function GET(request: NextRequest) {\n  try {\n    // Extract domain from query parameters\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get('domain');\n\n    // Validate domain parameter\n    if (!domain) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Missing required parameter: domain' },\n        { status: 400 }\n      );\n    }\n\n    // Basic domain validation\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Invalid domain format' },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users from database\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return NextResponse.json<UsersResponse>(\n      {\n        users,\n        count: users.length,\n      },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('API route error:', error);\n\n    // Handle different error types\n    if (error instanceof Error) {\n      return NextResponse.json<ErrorResponse>(\n        {\n          error: 'Internal server error',\n          details: process.env.NODE_ENV === 'development' ? error.message : undefined,\n        },\n        { status: 500 }\n      );\n    }\n\n    return NextResponse.json<ErrorResponse>(\n      { error: 'An unexpected error occurred' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n## Alternative: Pages Router Version\n\nIf you're using the Pages Router, here's the equivalent:\n\n```typescript\n// pages/api/users.ts\n\nimport { neon } from '@neondatabase/serverless';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface UsersResponse {\n  users: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  error: string;\n  details?: string;\n}\n\nasync function getUsersByDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  const sql = neon<User[]>(process.env.DATABASE_URL);\n\n  try {\n    const users = await sql`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('Unknown database error occurred');\n  }\n}\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<UsersResponse | ErrorResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { domain } = req.query;\n\n    // Validate domain parameter\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({ error: 'Missing required parameter: domain' });\n    }\n\n    // Basic domain validation\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return res.status(400).json({ error: 'Invalid domain format' });\n    }\n\n    // Fetch users from database\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return res.status(200).json({\n      users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error('API route error:', error);\n\n    if (error instanceof Error) {\n      return res.status(500).json({\n        error: 'Internal server error',\n        details: process.env.NODE_ENV === 'development' ? error.message : undefined,\n      });\n    }\n\n    return res.status(500).json({ error: 'An unexpected error occurred' });\n  }\n}\n```\n\n## Environment Setup\n\nAdd to your `.env.local`:\n\n```bash\nDATABASE_URL=\"postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require\"\n```\n\n## Installation\n\n```bash\nnpm install @neondatabase/serverless\n# or\npnpm add @neondatabase/serverless\n# or\nyarn add @neondatabase/serverless\n```\n\n## Usage Example\n\n```typescript\n// Client-side fetch\nconst response = await fetch('/api/users?domain=example.com');\nconst data = await response.json();\n\nif (response.ok) {\n  console.log(`Found ${data.count} users`);\n  data.users.forEach(user => {\n    console.log(`${user.name} - ${user.email}`);\n  });\n}\n```\n\n## Key Features\n\n1. **Parameterized Queries**: Uses template literals to prevent SQL injection\n2. **Type Safety**: Full TypeScript types for User interface and responses\n3. **Error Handling**: Comprehensive error handling with appropriate HTTP status codes\n4. **Environment Validation**: Checks for DATABASE_URL before attempting connection\n5. **Input Validation**: Validates domain parameter format\n6. **HTTP-based**: Uses Neon's serverless driver over HTTP (perfect for edge/serverless)\n\n## Notes\n\n- The `@neondatabase/serverless` driver uses HTTP/WebSocket, making it ideal for serverless and edge environments\n- No connection pooling needed - each query is a stateless HTTP request\n- For traditional Node.js environments with connection pooling, consider using `pg` or `postgres` with Neon's pooled connection string",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2240,
            "output_tokens": 1984,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a TypeScript module for a Next.js API route that connects to Neon Postgres using the serverless driver.\n\n```typescript\n// src/app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextResponse } from \"next/server\";\n\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., \"example.com\")\n * @returns Array of User objects\n */\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Use parameterized query with tagged template literal for safety\n    const users = await sql<User[]>`\n      SELECT id, email, name, created_at \n      FROM users \n      WHERE email LIKE ${\"%\" + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users by domain: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    );\n  }\n}\n\n/**\n * GET handler for the API route\n * Query parameter: domain (required)\n */\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Domain parameter is required\" },\n        { status: 400 },\n      );\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return NextResponse.json({\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error(\"API route error:\", error);\n    return NextResponse.json(\n      {\n        error:\n          error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 },\n    );\n  }\n}\n```\n\nNow let me create the environment variable configuration:\n\n```typescript\n// .env.local (create this file if it doesn't exist)\nDATABASE_URL=postgresql://user:password@ep-xxx-xxx.us-east-1.aws.neon.tech/neondb\n```\n\nAnd here's a usage example in a client component:\n\n```typescript\n// src/components/UsersByDomain.tsx\n\"use client\";\n\nimport { useState } from \"react\";\nimport type { User } from \"@/app/api/users/by-domain/route\";\n\nexport function UsersByDomain() {\n  const [domain, setDomain] = useState(\"\");\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchUsers = async () => {\n    if (!domain) return;\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(\n        `/api/users/by-domain?domain=${encodeURIComponent(domain)}`,\n      );\n      const result = await response.json();\n\n      if (!response.ok) {\n        throw new Error(result.error || \"Failed to fetch users\");\n      }\n\n      setUsers(result.data);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : \"An error occurred\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"p-4\">\n      <div className=\"mb-4\">\n        <input\n          type=\"text\"\n          value={domain}\n          onChange={(e) => setDomain(e.target.value)}\n          placeholder=\"Enter email domain (e.g., example.com)\"\n          className=\"border p-2 rounded mr-2\"\n        />\n        <button\n          onClick={fetchUsers}\n          disabled={loading || !domain}\n          className=\"bg-blue-500 text-white px-4 py-2 rounded disabled:opacity-50\"\n        >\n          {loading ? \"Loading...\" : \"Search\"}\n        </button>\n      </div>\n\n      {error && <div className=\"text-red-500 mb-4\">{error}</div>}\n\n      {users.length > 0 && (\n        <div>\n          <h3 className=\"font-bold mb-2\">Found {users.length} users</h3>\n          <ul className=\"space-y-2\">\n            {users.map((user) => (\n              <li key={user.id} className=\"border p-2 rounded\">\n                <div className=\"font-semibold\">{user.name}</div>\n                <div className=\"text-sm text-gray-600\">{user.email}</div>\n                <div className=\"text-xs text-gray-400\">\n                  {new Date(user.created_at).toLocaleDateString()}\n                </div>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**Key features:**\n\n1. \u2705 Uses `neon()` function from `@neondatabase/serverless` for HTTP-based queries\n2. \u2705 Parameterized query using tagged template literals (prevents SQL injection)\n3. \u2705 Proper TypeScript types with `User` interface\n4. \u2705 Environment variable validation\n5. \u2705 Comprehensive error handling with try-catch\n6. \u2705 Next.js App Router API route pattern\n7. \u2705 Returns typed objects with proper JSON response\n\n**To install the dependency:**\n```bash\npnpm add @neondatabase/serverless\n```\n\nThe module is production-ready and follows Neon's best practices for serverless environments!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25183,
            "output_tokens": 1497,
            "cached": true
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "```typescript\n// pages/api/users/by-domain.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { neon, NeonQueryFunction } from '@neondatabase/serverless';\n\n/**\n * User interface representing the structure of user data\n */\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\n/**\n * API Response type for success cases\n */\ninterface SuccessResponse {\n  success: true;\n  data: User[];\n  count: number;\n}\n\n/**\n * API Response type for error cases\n */\ninterface ErrorResponse {\n  success: false;\n  error: string;\n  message: string;\n}\n\ntype ApiResponse = SuccessResponse | ErrorResponse;\n\n/**\n * Fetches users from the database by email domain\n * @param domain - The email domain to filter by (e.g., 'example.com')\n * @returns Promise resolving to an array of User objects\n * @throws Error if database connection or query fails\n */\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  // Validate environment variable\n  const databaseUrl = process.env.DATABASE_URL;\n  \n  if (!databaseUrl) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  // Validate domain parameter\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  let sql: NeonQueryFunction<false, false>;\n\n  try {\n    // Create Neon connection\n    sql = neon(databaseUrl);\n\n    // Run parameterized query to prevent SQL injection\n    // Using LIKE with parameterized query for email domain matching\n    const query = `\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC\n    `;\n\n    // Execute query with parameterized domain\n    const result = await sql(query, [`%@${domain}`]);\n\n    // Map results to User type\n    const users: User[] = result.map((row: any) => ({\n      id: row.id,\n      email: row.email,\n      name: row.name,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n\n    return users;\n\n  } catch (error) {\n    // Log error for debugging (in production, use proper logging service)\n    console.error('Database query error:', error);\n\n    // Throw a more descriptive error\n    if (error instanceof Error) {\n      throw new Error(`Failed to fetch users by domain: ${error.message}`);\n    }\n    \n    throw new Error('Failed to fetch users by domain: Unknown error');\n  }\n}\n\n/**\n * Next.js API route handler\n */\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({\n      success: false,\n      error: 'Method Not Allowed',\n      message: 'Only GET requests are allowed',\n    });\n  }\n\n  try {\n    // Extract domain from query parameters\n    const { domain } = req.query;\n\n    // Validate domain parameter\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({\n        success: false,\n        error: 'Bad Request',\n        message: 'Domain query parameter is required and must be a string',\n      });\n    }\n\n    // Fetch users by domain\n    const users = await getUsersByEmailDomain(domain);\n\n    // Return successful response\n    return res.status(200).json({\n      success: true,\n      data: users,\n      count: users.length,\n    });\n\n  } catch (error) {\n    // Handle errors\n    console.error('API route error:', error);\n\n    const errorMessage = error instanceof Error \n      ? error.message \n      : 'An unexpected error occurred';\n\n    return res.status(500).json({\n      success: false,\n      error: 'Internal Server Error',\n      message: errorMessage,\n    });\n  }\n}\n```\n\n```typescript\n// Alternative: App Router version (app/api/users/by-domain/route.ts)\nimport { NextRequest, NextResponse } from 'next/server';\nimport { neon } from '@neondatabase/serverless';\n\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  const databaseUrl = process.env.DATABASE_URL;\n  \n  if (!databaseUrl) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  try {\n    const sql = neon(databaseUrl);\n\n    const query = `\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC\n    `;\n\n    const result = await sql(query, [`%@${domain}`]);\n\n    const users: User[] = result.map((row: any) => ({\n      id: row.id,\n      email: row.email,\n      name: row.name,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n\n    return users;\n\n  } catch (error) {\n    console.error('Database query error:', error);\n    \n    if (error instanceof Error) {\n      throw new Error(`Failed to fetch users by domain: ${error.message}`);\n    }\n    \n    throw new Error('Failed to fetch users by domain: Unknown error');\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get('domain');\n\n    if (!domain) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Bad Request',\n          message: 'Domain query parameter is required',\n        },\n        { status: 400 }\n      );\n    }\n\n    const users = await getUsersByEmailDomain(domain);\n\n    return NextResponse.json({\n      success: true,\n      data: users,\n      count: users.length,\n    });\n\n  } catch (error) {\n    console.error('API route error:', error);\n\n    const errorMessage = error instanceof Error \n      ? error.message \n      : 'An unexpected error occurred';\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Internal Server Error',\n        message: errorMessage,\n      },\n      { status: 500 }\n    );\n  }\n}\n```\n\n```typescript\n// .env.local (example)\nDATABASE_URL=postgresql://user:password@ep-example-123456.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n```typescript\n// Example usage in a component or another API route\nimport { getUsersByEmailDomain, User } from '@/pages/api/users/by-domain';\n\nasync function example() {\n  try {\n    const users: User[] = await getUsersByEmailDomain('example.com');\n    console.log(`Found ${users.length} users`);\n    users.forEach(user => {\n      console.log(`${user.name} - ${user.email}`);\n    });\n  } catch (error) {\n    console.error('Error fetching users:', error);\n  }\n}\n```\n\nThis module provides:\n\n1. **Proper TypeScript typing** with `User` interface and response types\n2. **Neon Postgres connection** using the `@neondatabase/serverless` driver\n3. **Parameterized queries** to prevent SQL injection\n4. **Comprehensive error handling** with try-catch blocks\n5. **Environment variable validation**\n6. **Both Pages Router and App Router versions**\n7. **Input validation** for query parameters\n8. **Proper HTTP status codes** and response formatting",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 98,
            "output_tokens": 2073,
            "cached": true
          },
          "with_skill": {
            "output": "```typescript\n// app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextResponse } from \"next/server\";\n\n// User interface matching your database schema\ninterface User {\n  id: number;\n  email: string;\n  name: string | null;\n  created_at: Date;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., \"example.com\")\n * @returns Array of User objects\n */\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  // Validate input\n  if (!domain || typeof domain !== \"string\") {\n    throw new Error(\"Invalid domain parameter\");\n  }\n\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  try {\n    // Create connection using neon() function\n    const sql = neon(process.env.DATABASE_URL);\n\n    // Run parameterized query using tagged template literals\n    // This safely interpolates the domain parameter\n    const users = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${\"%\" + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    // Handle connection and query errors\n    console.error(\"Database query failed:\", error);\n    \n    if (error instanceof Error) {\n      throw new Error(`Failed to fetch users: ${error.message}`);\n    }\n    \n    throw new Error(\"Failed to fetch users: Unknown error\");\n  }\n}\n\n/**\n * GET /api/users/by-domain?domain=example.com\n */\nexport async function GET(request: Request) {\n  try {\n    // Extract domain from query parameters\n    const { searchParams } = new URL(request.url);\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Domain parameter is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users by domain\n    const users = await getUsersByDomain(domain);\n\n    return NextResponse.json({\n      success: true,\n      count: users.length,\n      users,\n    });\n  } catch (error) {\n    console.error(\"API route error:\", error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n```\n\n**Alternative: Using `sql.query()` for manual parameterization:**\n\n```typescript\n// If you prefer explicit parameter arrays instead of template literals\nexport async function getUsersByDomainAlt(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  try {\n    const sql = neon(process.env.DATABASE_URL);\n\n    // Using .query() method with $1 placeholder\n    const users = await sql.query<User>(\n      `\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC\n      `,\n      [`%${domain}`]\n    );\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users: ${error instanceof Error ? error.message : \"Unknown error\"}`\n    );\n  }\n}\n```\n\n**Environment setup (.env.local):**\n\n```bash\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-1.aws.neon.tech/neondb\n```\n\n**Usage example:**\n\n```typescript\n// In another API route or server component\nimport { getUsersByDomain } from \"@/app/api/users/by-domain/route\";\n\nconst users = await getUsersByDomain(\"gmail.com\");\nconsole.log(`Found ${users.length} users with @gmail.com emails`);\n```\n\n**Key features:**\n\n1. \u2705 Uses `neon()` function for HTTP-based queries (fastest for serverless)\n2. \u2705 Parameterized queries prevent SQL injection\n3. \u2705 Proper TypeScript typing with `User` interface\n4. \u2705 Environment variable validation\n5. \u2705 Comprehensive error handling\n6. \u2705 Works in Next.js App Router API routes\n7. \u2705 No connection pooling needed (HTTP-based)",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24688,
            "output_tokens": 1158,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Next.js API Route with Neon Serverless Driver\n\nHere's a complete TypeScript module for a Next.js API route that connects to Neon Postgres using the `@neondatabase/serverless` driver:\n\n```typescript\n// app/api/users/by-domain/route.ts (App Router)\n// or pages/api/users/by-domain.ts (Pages Router)\n\nimport { neon } from '@neondatabase/serverless';\nimport { NextRequest, NextResponse } from 'next/server';\n\n// User interface with proper typing\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n// Response type for better type safety\ninterface ApiResponse {\n  success: boolean;\n  data?: User[];\n  error?: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - The email domain to filter by (e.g., 'example.com')\n * @returns Promise resolving to an array of User objects\n * @throws Error if DATABASE_URL is not set or query fails\n */\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  // Validate environment variable\n  const databaseUrl = process.env.DATABASE_URL;\n  \n  if (!databaseUrl) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  try {\n    // Create Neon serverless connection\n    const sql = neon(databaseUrl);\n\n    // Run parameterized query to prevent SQL injection\n    // The % wildcards are included in the parameter for LIKE matching\n    const result = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return result;\n  } catch (error) {\n    // Enhanced error handling with specific error types\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('An unknown error occurred while querying the database');\n  }\n}\n\n// App Router (Next.js 13+) API Route Handler\nexport async function GET(request: NextRequest): Promise<NextResponse<ApiResponse>> {\n  try {\n    // Extract domain from query parameters\n    const { searchParams } = new URL(request.url);\n    const domain = searchParams.get('domain');\n\n    // Validate input\n    if (!domain) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Domain parameter is required',\n        },\n        { status: 400 }\n      );\n    }\n\n    // Basic domain validation\n    if (!/^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Invalid domain format',\n        },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users\n    const users = await getUsersByDomain(domain);\n\n    return NextResponse.json({\n      success: true,\n      data: users,\n    });\n  } catch (error) {\n    console.error('API route error:', error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : 'Internal server error',\n      },\n      { status: 500 }\n    );\n  }\n}\n\n// Pages Router (Next.js 12 and earlier) API Route Handler\n// Uncomment if using Pages Router instead of App Router\n/*\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({\n      success: false,\n      error: 'Method not allowed',\n    });\n  }\n\n  try {\n    const { domain } = req.query;\n\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({\n        success: false,\n        error: 'Domain parameter is required',\n      });\n    }\n\n    if (!/^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid domain format',\n      });\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return res.status(200).json({\n      success: true,\n      data: users,\n    });\n  } catch (error) {\n    console.error('API route error:', error);\n\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Internal server error',\n    });\n  }\n}\n*/\n```\n\n## Installation\n\n```bash\nnpm install @neondatabase/serverless\n```\n\n## Environment Setup\n\nAdd to your `.env.local`:\n\n```bash\nDATABASE_URL=\"postgresql://user:password@ep-xxx.region.aws.neon.tech/dbname?sslmode=require\"\n```\n\n## Database Schema\n\nCreate the users table:\n\n```sql\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email VARCHAR(255) NOT NULL UNIQUE,\n  name VARCHAR(255) NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Add index for email domain queries\nCREATE INDEX idx_users_email ON users(email);\n```\n\n## Usage Examples\n\n### Client-side fetch (App Router)\n\n```typescript\n// app/components/UserList.tsx\n'use client';\n\nimport { useState, useEffect } from 'react';\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\nexport default function UserList() {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchUsers = async (domain: string) => {\n    setLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(`/api/users/by-domain?domain=${encodeURIComponent(domain)}`);\n      const data = await response.json();\n\n      if (!data.success) {\n        throw new Error(data.error);\n      }\n\n      setUsers(data.data || []);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to fetch users');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div>\n      <button onClick={() => fetchUsers('example.com')}>\n        Load Users from example.com\n      </button>\n      {loading && <p>Loading...</p>}\n      {error && <p className=\"error\">{error}</p>}\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            {user.name} ({user.email})\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n### Server-side usage (Server Component)\n\n```typescript\n// app/users/page.tsx\nimport { getUsersByDomain } from '@/app/api/users/by-domain/route';\n\nexport default async function UsersPage() {\n  const users = await getUsersByDomain('example.com');\n\n  return (\n    <div>\n      <h1>Users from example.com</h1>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            {user.name} ({user.email})\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## Key Features\n\n1. **Parameterized Queries**: Uses template literals with `${}` for safe parameter binding\n2. **Type Safety**: Full TypeScript typing for User interface and API responses\n3. **Error Handling**: Comprehensive error handling with specific error messages\n4. **Environment Validation**: Checks for DATABASE_URL before attempting connection\n5. **Input Validation**: Validates domain format to prevent invalid queries\n6. **HTTP over WebSockets**: Uses Neon's HTTP protocol (default for `neon()`)\n\n## Connection Notes\n\n- The `neon()` function uses **HTTP** by default (not WebSockets)\n- No connection pooling needed - each query is a stateless HTTP request\n- Ideal for serverless/edge environments\n- For WebSocket support, use `neonConfig.webSocketConstructor`\n\n## Alternative: Using Connection Pooling\n\nIf you need connection pooling (for traditional Node.js environments), use `@neondatabase/serverless` with the Pool:\n\n```typescript\nimport { Pool } from '@neondatabase/serverless';\n\nconst pool = new Pool({ connectionString: process.env.DATABASE_URL });\n\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  const client = await pool.connect();\n  \n  try {\n    const result = await client.query<User>(\n      'SELECT id, email, name, created_at FROM users WHERE email LIKE $1 ORDER BY created_at DESC',\n      [`%@${domain}`]\n    );\n    return result.rows;\n  } finally {\n    client.release();\n  }\n}\n```\n\nThis implementation provides a production-ready, type-safe API route for querying Neon Postgres with proper error handling and security best practices.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2240,
            "output_tokens": 2405,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a TypeScript module for a Next.js API route that connects to Neon Postgres using the serverless driver.\n\n```typescript\n// src/app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface GetUsersByDomainParams {\n  domain: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., \"example.com\")\n * @returns Array of users matching the domain\n */\nexport async function getUsersByDomain(\n  domain: string,\n): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  try {\n    const sql = neon(process.env.DATABASE_URL);\n    \n    // Parameterized query using tagged template literals\n    // Matches emails ending with @domain\n    const users = await sql<User[]>`\n      SELECT id, email, name, created_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users by domain: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    );\n  }\n}\n\n// Next.js API route handler\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Domain parameter is required\" },\n        { status: 400 },\n      );\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return NextResponse.json({\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error(\"API route error:\", error);\n    return NextResponse.json(\n      {\n        error: error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 },\n    );\n  }\n}\n```\n\nNow let me create a standalone utility module version that can be imported anywhere:\n\n```typescript\n// src/lib/db/users.ts\nimport { neon } from \"@neondatabase/serverless\";\n\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\nexport interface DatabaseError {\n  message: string;\n  code?: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., \"example.com\")\n * @returns Array of users matching the domain\n * @throws {Error} If DATABASE_URL is not set or query fails\n */\nexport async function getUsersByDomain(\n  domain: string,\n): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  if (!domain || domain.trim() === \"\") {\n    throw new Error(\"Domain parameter cannot be empty\");\n  }\n\n  try {\n    const sql = neon(process.env.DATABASE_URL);\n    \n    // Using parameterized query with tagged template literals\n    // This prevents SQL injection by safely interpolating the domain value\n    const users = await sql<User[]>`\n      SELECT id, email, name, created_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    const dbError: DatabaseError = {\n      message: error instanceof Error ? error.message : \"Unknown database error\",\n      code: (error as any)?.code,\n    };\n    \n    console.error(\"Database query failed:\", dbError);\n    throw new Error(`Failed to fetch users by domain: ${dbError.message}`);\n  }\n}\n\n/**\n * Alternative: Fetch users with manual query construction\n * Use this if you need more control over the query\n */\nexport async function getUsersByDomainManual(\n  domain: string,\n): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  try {\n    const sql = neon(process.env.DATABASE_URL);\n    \n    // Using .query() method with positional parameters\n    const users = await sql.query<User>(\n      \"SELECT id, email, name, created_at FROM users WHERE email LIKE $1 ORDER BY created_at DESC\",\n      [`%@${domain}`],\n    );\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users by domain: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    );\n  }\n}\n```\n\nAnd here's the `.env.local` configuration you'll need:\n\n```bash\n# .env.local\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-1.aws.neon.tech/neondb\n```\n\n**Key features:**\n\n1. **Parameterized queries** using tagged template literals to prevent SQL injection\n2. **Proper TypeScript types** with `User` interface\n3. **Error handling** for missing env vars and database errors\n4. **Two query methods**: tagged templates (recommended) and manual `.query()`\n5. **Next.js API route** ready to use at `/api/users/by-domain?domain=example.com`\n\n**Installation:**\n```bash\nnpm install @neondatabase/serverless\n```\n\nWould you like me to add additional features like pagination, multiple domain filtering, or integration with your existing `apiClient` utility?",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25183,
            "output_tokens": 1489,
            "cached": true
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-02",
      "task_type": "cross_language",
      "target_language": "python",
      "expected_patterns": [
        "from fastapi|import fastapi",
        "import asyncpg|from asyncpg",
        "async def",
        "await.*fetch|await.*execute",
        "create_pool|Pool",
        "@app\\.get|@router\\.get"
      ],
      "anti_patterns": [
        "@neondatabase",
        "neon\\(",
        "import.*drizzle",
        "import.*prisma",
        "const\\s+|let\\s+|var\\s+",
        "require\\("
      ],
      "pattern_sources": [
        {
          "url": "https://neon.com/docs/guides/python.md",
          "description": "Python with Neon: asyncpg connection patterns including await asyncpg.connect(), await conn.execute(), await conn.fetch(), async/await usage, asyncio.run() for async functions"
        },
        {
          "url": "https://docs.python.org/3/library/asyncio.html",
          "description": "Python asyncio documentation - source of async def syntax for asynchronous functions"
        },
        {
          "url": "https://raw.githubusercontent.com/fastapi/fastapi/master/README.md",
          "description": "FastAPI README - source of from fastapi import FastAPI, @app.get() and @router.get() decorator patterns, async def endpoint definitions"
        },
        {
          "url": "https://neon.com/docs/serverless/serverless-driver.md",
          "description": "Anti-patterns: TypeScript/JavaScript Neon serverless driver (@neondatabase/serverless, neon() function) that should not appear in Python"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# FastAPI PostgreSQL Products API with asyncpg\n\nHere's a complete implementation with connection pooling, proper async patterns, and error handling:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional, List\nfrom contextlib import asynccontextmanager\nimport asyncpg\nfrom decimal import Decimal\nimport os\n\n# ============================================================================\n# Configuration\n# ============================================================================\n\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql://user:password@localhost:5432/products_db\"\n)\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = Field(None, max_length=1000)\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(..., ge=0)\n    \n    @validator('price')\n    def validate_price(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than 0')\n        return v\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n    \n    class Config:\n        orm_mode = True\n        json_encoders = {\n            Decimal: lambda v: float(v)\n        }\n\nclass ProductListResponse(BaseModel):\n    products: List[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n# ============================================================================\n# Database Connection Pool\n# ============================================================================\n\nclass Database:\n    pool: Optional[asyncpg.Pool] = None\n\ndb = Database()\n\nasync def create_pool():\n    \"\"\"Create database connection pool\"\"\"\n    db.pool = await asyncpg.create_pool(\n        DATABASE_URL,\n        min_size=5,\n        max_size=20,\n        command_timeout=60,\n        max_queries=50000,\n        max_inactive_connection_lifetime=300,\n    )\n    print(\"\u2705 Database pool created\")\n\nasync def close_pool():\n    \"\"\"Close database connection pool\"\"\"\n    if db.pool:\n        await db.pool.close()\n        print(\"\u2705 Database pool closed\")\n\nasync def init_db():\n    \"\"\"Initialize database schema\"\"\"\n    async with db.pool.acquire() as conn:\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price NUMERIC(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create index for better query performance\n        await conn.execute(\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_products_name \n            ON products(name)\n        \"\"\")\n        \n        print(\"\u2705 Database schema initialized\")\n\n# ============================================================================\n# Lifespan Context Manager\n# ============================================================================\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifespan events\"\"\"\n    # Startup\n    await create_pool()\n    await init_db()\n    yield\n    # Shutdown\n    await close_pool()\n\n# ============================================================================\n# FastAPI Application\n# ============================================================================\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# ============================================================================\n# API Endpoints\n# ============================================================================\n\n@app.get(\"/\", tags=[\"Root\"])\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"message\": \"Products API is running\"\n    }\n\n@app.get(\n    \"/products\",\n    response_model=ProductListResponse,\n    tags=[\"Products\"],\n    summary=\"List all products with pagination\"\n)\nasync def get_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: Optional[str] = Query(None, description=\"Search by product name\")\n):\n    \"\"\"\n    Retrieve a paginated list of products.\n    \n    - **page**: Page number (starts from 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term for product name\n    \"\"\"\n    offset = (page - 1) * page_size\n    \n    async with db.pool.acquire() as conn:\n        # Build query based on search parameter\n        if search:\n            count_query = \"\"\"\n                SELECT COUNT(*) FROM products \n                WHERE name ILIKE $1\n            \"\"\"\n            select_query = \"\"\"\n                SELECT id, name, description, price, stock \n                FROM products \n                WHERE name ILIKE $1\n                ORDER BY id DESC\n                LIMIT $2 OFFSET $3\n            \"\"\"\n            search_param = f\"%{search}%\"\n            \n            total = await conn.fetchval(count_query, search_param)\n            rows = await conn.fetch(select_query, search_param, page_size, offset)\n        else:\n            count_query = \"SELECT COUNT(*) FROM products\"\n            select_query = \"\"\"\n                SELECT id, name, description, price, stock \n                FROM products \n                ORDER BY id DESC\n                LIMIT $1 OFFSET $2\n            \"\"\"\n            \n            total = await conn.fetchval(count_query)\n            rows = await conn.fetch(select_query, page_size, offset)\n        \n        # Convert rows to Product models\n        products = [\n            Product(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=row['price'],\n                stock=row['stock']\n            )\n            for row in rows\n        ]\n        \n        total_pages = (total + page_size - 1) // page_size\n        \n        return ProductListResponse(\n            products=products,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=total_pages\n        )\n\n@app.get(\n    \"/products/{product_id}\",\n    response_model=Product,\n    tags=[\"Products\"],\n    summary=\"Get a single product by ID\"\n)\nasync def get_product(product_id: int):\n    \"\"\"\n    Retrieve a specific product by its ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    async with db.pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"\"\"\n            SELECT id, name, description, price, stock \n            FROM products \n            WHERE id = $1\n            \"\"\",\n            product_id\n        )\n        \n        if not row:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock']\n        )\n\n@app.post(\n    \"/products\",\n    response_model=Product,\n    status_code=status.HTTP_201_CREATED,\n    tags=[\"Products\"],\n    summary=\"Create a new product\"\n)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, max 255 characters)\n    - **description**: Product description (optional, max 1000 characters)\n    - **price**: Product price (required, must be greater than 0)\n    - **stock**: Available stock (required, must be non-negative)\n    \"\"\"\n    async with db.pool.acquire() as conn:\n        try:\n            row = await conn.fetchrow(\n                \"\"\"\n                INSERT INTO products (name, description, price, stock)\n                VALUES ($1, $2, $3, $4)\n                RETURNING id, name, description, price, stock\n                \"\"\",\n                product.name,\n                product.description,\n                product.price,\n                product.stock\n            )\n            \n            return Product(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=row['price'],\n                stock=row['stock']\n            )\n        except asyncpg.UniqueViolationError:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"Product with this name already exists\"\n            )\n        except asyncpg.PostgresError as e:\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=f\"Database error: {str(e)}\"\n            )\n\n# ============================================================================\n# Additional Endpoints (Bonus)\n# ============================================================================\n\n@app.put(\n    \"/products/{product_id}\",\n    response_model=Product,\n    tags=[\"Products\"],\n    summary=\"Update a product\"\n)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"Update an existing product\"\"\"\n    async with db.pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"\"\"\n            UPDATE products \n            SET name = $1, description = $2, price = $3, stock = $4,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = $5\n            RETURNING id, name, description, price, stock\n            \"\"\",\n            product.name,\n            product.description,\n            product.price,\n            product.stock,\n            product_id\n        )\n        \n        if not row:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock']\n        )\n\n@app.delete(\n    \"/products/{product_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    tags=[\"Products\"],\n    summary=\"Delete a product\"\n)\nasync def delete_product(product_id: int):\n    \"\"\"Delete a product by ID\"\"\"\n    async with db.pool.acquire() as conn:\n        result = await conn.execute(\n            \"DELETE FROM products WHERE id = $1\",\n            product_id\n        )\n        \n        if result == \"DELETE 0\":\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return None\n\n# ============================================================================\n# Error Handlers\n# ============================================================================\n\n@app.exception_handler(asyncpg.PostgresError)\nasync def postgres_exception_handler(request, exc):\n    \"\"\"Handle PostgreSQL errors\"\"\"\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\n            \"detail\": \"Database error occurred\",\n            \"error\": str(exc)\n        }\n    )\n\n# ============================================================================\n# Run Application\n# ============================================================================\n\nif __name__ == \"__main__\":\n    import uvicorn\n    \n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True,\n        log_level=\"info\"\n    )\n```\n\n## Requirements File (`requirements.txt`)\n\n```txt\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\nasyncpg==0.29.0\npydantic==2.5.0\npython-dotenv==1.0.0\n```\n\n## Environment Variables (`.env`)\n\n```env\nDATABASE_URL=postgresql://user:password@localhost:5432/products_db\n```\n\n## Docker Compose Setup (`docker-compose.yml`)\n\n```yaml\nversion: '3.8'\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: products_db\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U user -d products_db\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      DATABASE_URL: postgresql://user:password@postgres:5432/products_db\n    depends_on:\n      postgres:\n        condition: service_healthy\n    volumes:\n      - .:/app\n\nvolumes:\n  postgres_data:\n```\n\n## Dockerfile\n\n```dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n## Usage Examples\n\n```bash\n# Start the services\ndocker-compose up -d\n\n# Create a product\ncurl -X POST \"http://localhost:8000/products\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# Get all products (paginated)\ncurl \"http://localhost:8000/products?page=1&page_size=10\"\n\n# Search products\ncurl \"http://localhost:8000/products?search=laptop\"\n\n# Get single product\ncurl \"http://localhost:8000/products/1\"\n\n# Update product\ncurl -X PUT \"http://localhost:8000/products/1\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-end gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete product\ncurl -X DELETE \"http://localhost:8000/products/1\"\n```\n\n## Key Features\n\n\u2705 **Connection Pooling** - Efficient database connections with asyncpg  \n\u2705 **Async/Await** - Proper async patterns throughout  \n\u2705 **Pagination** - Efficient data retrieval with offset/limit  \n\u2705 **Search** - Case-insensitive product name search  \n\u2705 **Validation** - Pydantic models with custom validators  \n\u2705 **Error Handling** - Comprehensive error responses  \n\u2705 **Type Safety** - Full type hints  \n\u2705 **Documentation** - Auto-generated OpenAPI docs at `/docs`  \n\u2705 **Health Check** - Root endpoint for monitoring  \n\u2705 **CRUD Operations** - Complete REST API implementation",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 3771,
            "cached": true
          },
          "with_skill": {
            "output": "# FastAPI Products API with asyncpg\n\nI'll create a complete FastAPI application with asyncpg connection pooling and proper async patterns for a products REST API.\n\n## Project Setup\n\n```bash\n# Create project directory\nmkdir fastapi-products-api\ncd fastapi-products-api\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install fastapi uvicorn asyncpg pydantic-settings python-dotenv\n```\n\n## Project Structure\n\n```\nfastapi-products-api/\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .env.example\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u251c\u2500\u2500 database.py\n\u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2514\u2500\u2500 routers/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 products.py\n\u2514\u2500\u2500 migrations/\n    \u2514\u2500\u2500 init.sql\n```\n\n## 1. Environment Configuration\n\n```bash\n# .env.example\nDATABASE_URL=postgresql://user:password@host:5432/database\n```\n\n```bash\n# .env\nDATABASE_URL=postgresql://neondb_owner:your-password@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n## 2. Configuration Module\n\n```python\n# app/config.py\nfrom pydantic_settings import BaseSettings\nfrom functools import lru_cache\n\n\nclass Settings(BaseSettings):\n    database_url: str\n    min_pool_size: int = 5\n    max_pool_size: int = 20\n    \n    class Config:\n        env_file = \".env\"\n        case_sensitive = False\n\n\n@lru_cache()\ndef get_settings() -> Settings:\n    return Settings()\n```\n\n## 3. Database Connection Pool\n\n```python\n# app/database.py\nimport asyncpg\nfrom typing import Optional\nfrom contextlib import asynccontextmanager\nfrom app.config import get_settings\n\nsettings = get_settings()\n\n\nclass Database:\n    def __init__(self):\n        self.pool: Optional[asyncpg.Pool] = None\n    \n    async def connect(self):\n        \"\"\"Create connection pool on startup\"\"\"\n        self.pool = await asyncpg.create_pool(\n            dsn=settings.database_url,\n            min_size=settings.min_pool_size,\n            max_size=settings.max_pool_size,\n            command_timeout=60,\n        )\n        print(f\"\u2705 Database pool created (min={settings.min_pool_size}, max={settings.max_pool_size})\")\n    \n    async def disconnect(self):\n        \"\"\"Close connection pool on shutdown\"\"\"\n        if self.pool:\n            await self.pool.close()\n            print(\"\u2705 Database pool closed\")\n    \n    @asynccontextmanager\n    async def acquire(self):\n        \"\"\"Context manager for acquiring a connection from the pool\"\"\"\n        if not self.pool:\n            raise RuntimeError(\"Database pool not initialized\")\n        \n        async with self.pool.acquire() as connection:\n            yield connection\n\n\n# Global database instance\ndb = Database()\n\n\nasync def get_db():\n    \"\"\"Dependency for FastAPI routes\"\"\"\n    async with db.acquire() as connection:\n        yield connection\n```\n\n## 4. Pydantic Models\n\n```python\n# app/models.py\nfrom pydantic import BaseModel, Field, ConfigDict\nfrom typing import Optional\nfrom datetime import datetime\nfrom decimal import Decimal\n\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(..., ge=0)\n    category: Optional[str] = Field(None, max_length=100)\n\n\nclass ProductCreate(ProductBase):\n    \"\"\"Schema for creating a product\"\"\"\n    pass\n\n\nclass ProductUpdate(BaseModel):\n    \"\"\"Schema for updating a product (all fields optional)\"\"\"\n    name: Optional[str] = Field(None, min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: Optional[Decimal] = Field(None, gt=0, decimal_places=2)\n    stock: Optional[int] = Field(None, ge=0)\n    category: Optional[str] = Field(None, max_length=100)\n\n\nclass Product(ProductBase):\n    \"\"\"Schema for product response\"\"\"\n    id: int\n    created_at: datetime\n    updated_at: datetime\n    \n    model_config = ConfigDict(from_attributes=True)\n\n\nclass ProductList(BaseModel):\n    \"\"\"Schema for paginated product list\"\"\"\n    products: list[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\n## 5. Products Router\n\n```python\n# app/routers/products.py\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom asyncpg import Connection\nfrom typing import List\nfrom app.database import get_db\nfrom app.models import Product, ProductCreate, ProductList\nfrom math import ceil\n\nrouter = APIRouter(prefix=\"/products\", tags=[\"products\"])\n\n\n@router.get(\"\", response_model=ProductList)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    category: str | None = Query(None, description=\"Filter by category\"),\n    conn: Connection = Depends(get_db)\n):\n    \"\"\"\n    List products with pagination and optional category filter.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    - **category**: Optional category filter\n    \"\"\"\n    offset = (page - 1) * page_size\n    \n    # Build query with optional category filter\n    if category:\n        count_query = \"SELECT COUNT(*) FROM products WHERE category = $1\"\n        select_query = \"\"\"\n            SELECT id, name, description, price, stock, category, created_at, updated_at\n            FROM products\n            WHERE category = $1\n            ORDER BY created_at DESC\n            LIMIT $2 OFFSET $3\n        \"\"\"\n        total = await conn.fetchval(count_query, category)\n        rows = await conn.fetch(select_query, category, page_size, offset)\n    else:\n        count_query = \"SELECT COUNT(*) FROM products\"\n        select_query = \"\"\"\n            SELECT id, name, description, price, stock, category, created_at, updated_at\n            FROM products\n            ORDER BY created_at DESC\n            LIMIT $1 OFFSET $2\n        \"\"\"\n        total = await conn.fetchval(count_query)\n        rows = await conn.fetch(select_query, page_size, offset)\n    \n    # Convert rows to Product models\n    products = [Product(**dict(row)) for row in rows]\n    \n    return ProductList(\n        products=products,\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=ceil(total / page_size) if total > 0 else 0\n    )\n\n\n@router.get(\"/{product_id}\", response_model=Product)\nasync def get_product(\n    product_id: int,\n    conn: Connection = Depends(get_db)\n):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The product ID\n    \"\"\"\n    query = \"\"\"\n        SELECT id, name, description, price, stock, category, created_at, updated_at\n        FROM products\n        WHERE id = $1\n    \"\"\"\n    \n    row = await conn.fetchrow(query, product_id)\n    \n    if not row:\n        raise HTTPException(status_code=404, detail=f\"Product {product_id} not found\")\n    \n    return Product(**dict(row))\n\n\n@router.post(\"\", response_model=Product, status_code=201)\nasync def create_product(\n    product: ProductCreate,\n    conn: Connection = Depends(get_db)\n):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be > 0)\n    - **stock**: Stock quantity (required, must be >= 0)\n    - **category**: Product category (optional)\n    \"\"\"\n    query = \"\"\"\n        INSERT INTO products (name, description, price, stock, category)\n        VALUES ($1, $2, $3, $4, $5)\n        RETURNING id, name, description, price, stock, category, created_at, updated_at\n    \"\"\"\n    \n    try:\n        row = await conn.fetchrow(\n            query,\n            product.name,\n            product.description,\n            product.price,\n            product.stock,\n            product.category\n        )\n        \n        return Product(**dict(row))\n    \n    except Exception as e:\n        # Handle unique constraint violations, etc.\n        raise HTTPException(status_code=400, detail=f\"Failed to create product: {str(e)}\")\n\n\n@router.put(\"/{product_id}\", response_model=Product)\nasync def update_product(\n    product_id: int,\n    product: ProductCreate,\n    conn: Connection = Depends(get_db)\n):\n    \"\"\"\n    Update an existing product (full update).\n    \n    - **product_id**: The product ID\n    - All fields are required for full update\n    \"\"\"\n    query = \"\"\"\n        UPDATE products\n        SET name = $2, description = $3, price = $4, stock = $5, category = $6, updated_at = NOW()\n        WHERE id = $1\n        RETURNING id, name, description, price, stock, category, created_at, updated_at\n    \"\"\"\n    \n    row = await conn.fetchrow(\n        query,\n        product_id,\n        product.name,\n        product.description,\n        product.price,\n        product.stock,\n        product.category\n    )\n    \n    if not row:\n        raise HTTPException(status_code=404, detail=f\"Product {product_id} not found\")\n    \n    return Product(**dict(row))\n\n\n@router.delete(\"/{product_id}\", status_code=204)\nasync def delete_product(\n    product_id: int,\n    conn: Connection = Depends(get_db)\n):\n    \"\"\"\n    Delete a product by ID.\n    \n    - **product_id**: The product ID\n    \"\"\"\n    query = \"DELETE FROM products WHERE id = $1 RETURNING id\"\n    \n    row = await conn.fetchrow(query, product_id)\n    \n    if not row:\n        raise HTTPException(status_code=404, detail=f\"Product {product_id} not found\")\n    \n    return None\n```\n\n## 6. Main Application\n\n```python\n# app/main.py\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom app.database import db\nfrom app.routers import products\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifecycle\"\"\"\n    # Startup: Create database pool\n    await db.connect()\n    yield\n    # Shutdown: Close database pool\n    await db.disconnect()\n\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"FastAPI + asyncpg REST API for managing products\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# Include routers\napp.include_router(products.router)\n\n\n@app.get(\"/\")\nasync def root():\n    return {\n        \"message\": \"Products API\",\n        \"docs\": \"/docs\",\n        \"health\": \"/health\"\n    }\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint\"\"\"\n    pool_status = \"connected\" if db.pool else \"disconnected\"\n    return {\n        \"status\": \"healthy\",\n        \"database\": pool_status\n    }\n```\n\n## 7. Database Schema\n\n```sql\n-- migrations/init.sql\nCREATE TABLE IF NOT EXISTS products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    description TEXT,\n    price NUMERIC(10, 2) NOT NULL CHECK (price > 0),\n    stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n    category VARCHAR(100),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Create index on category for filtering\nCREATE INDEX IF NOT EXISTS idx_products_category ON products(category);\n\n-- Create index on created_at for sorting\nCREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at DESC);\n\n-- Insert sample data\nINSERT INTO products (name, description, price, stock, category) VALUES\n    ('Laptop Pro', 'High-performance laptop', 1299.99, 50, 'Electronics'),\n    ('Wireless Mouse', 'Ergonomic wireless mouse', 29.99, 200, 'Electronics'),\n    ('Office Chair', 'Comfortable ergonomic chair', 249.99, 30, 'Furniture'),\n    ('Desk Lamp', 'LED desk lamp with adjustable brightness', 39.99, 100, 'Furniture'),\n    ('Coffee Maker', 'Programmable coffee maker', 79.99, 75, 'Appliances')\nON CONFLICT DO NOTHING;\n```\n\n## 8. Requirements File\n\n```txt\n# requirements.txt\nfastapi==0.109.0\nuvicorn[standard]==0.27.0\nasyncpg==0.29.0\npydantic==2.5.3\npydantic-settings==2.1.0\npython-dotenv==1.0.0\n```\n\n## 9. Router Init File\n\n```python\n# app/routers/__init__.py\nfrom app.routers import products\n\n__all__ = [\"products\"]\n```\n\n## 10. App Init File\n\n```python\n# app/__init__.py\n\"\"\"FastAPI Products API\"\"\"\n__version__ = \"1.0.0\"\n```\n\n## Running the Application\n\n### 1. Set up the database\n\n```bash\n# Connect to your Neon database and run the schema\npsql $DATABASE_URL -f migrations/init.sql\n```\n\n### 2. Start the server\n\n```bash\n# Development mode with auto-reload\nuvicorn app.main:app --reload --host 0.0.0.0 --port 8000\n\n# Production mode\nuvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4\n```\n\n### 3. Access the API\n\n- **API Docs**: http://localhost:8000/docs\n- **Alternative Docs**: http://localhost:8000/redoc\n- **Health Check**: http://localhost:8000/health\n\n## Testing the API\n\n```bash\n# List products (page 1)\ncurl http://localhost:8000/products\n\n# List products with pagination\ncurl \"http://localhost:8000/products?page=1&page_size=5\"\n\n# Filter by category\ncurl \"http://localhost:8000/products?category=Electronics\"\n\n# Get single product\ncurl http://localhost:8000/products/1\n\n# Create product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Mechanical Keyboard\",\n    \"description\": \"RGB mechanical keyboard\",\n    \"price\": 89.99,\n    \"stock\": 150,\n    \"category\": \"Electronics\"\n  }'\n\n# Update product\ncurl -X PUT http://localhost:8000/products/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop Pro Updated\",\n    \"description\": \"Updated description\",\n    \"price\": 1199.99,\n    \"stock\": 45,\n    \"category\": \"Electronics\"\n  }'\n\n# Delete product\ncurl -X DELETE http://localhost:8000/products/1\n```\n\n## Key Features\n\n\u2705 **Async Connection Pooling**: Efficient connection management with asyncpg\n\u2705 **Proper Lifecycle Management**: Pool created on startup, closed on shutdown\n\u2705 **Pagination**: Efficient pagination with total count\n\u2705 **Filtering**: Category-based filtering\n\u2705 **Error Handling**: Proper HTTP status codes and error messages\n\u2705 **Type Safety**: Pydantic models for request/response validation\n\u2705 **API Documentation**: Auto-generated OpenAPI docs\n\u2705 **Health Check**: Endpoint to verify database connectivity\n\n## Performance Tips\n\n1. **Connection Pool Sizing**:",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24674,
            "output_tokens": 4096,
            "cached": true
          },
          "skill_md_only": {
            "output": "# FastAPI with Neon Postgres using asyncpg\n\nHere's a complete implementation of a FastAPI application with asyncpg for connecting to Neon Postgres:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List\nimport asyncpg\nfrom contextlib import asynccontextmanager\nimport os\n\n# Pydantic models\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n\n# Database connection pool\ndb_pool: Optional[asyncpg.Pool] = None\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage database connection pool lifecycle\"\"\"\n    global db_pool\n    \n    # Get connection string from environment\n    database_url = os.getenv(\"DATABASE_URL\")\n    if not database_url:\n        raise ValueError(\"DATABASE_URL environment variable is required\")\n    \n    # Create connection pool\n    db_pool = await asyncpg.create_pool(\n        database_url,\n        min_size=2,\n        max_size=10,\n        command_timeout=60,\n        # SSL is required for Neon\n        ssl='require'\n    )\n    \n    # Initialize database schema\n    async with db_pool.acquire() as conn:\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create index for better query performance\n        await conn.execute(\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_products_name \n            ON products(name)\n        \"\"\")\n    \n    yield\n    \n    # Close pool on shutdown\n    await db_pool.close()\n\n# Initialize FastAPI app with lifespan\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon Postgres\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"message\": \"Products API is running\"\n    }\n\n@app.get(\"/products\", response_model=List[Product])\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\")\n):\n    \"\"\"\n    List products with pagination\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    offset = (page - 1) * page_size\n    \n    async with db_pool.acquire() as conn:\n        rows = await conn.fetch(\"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            ORDER BY id\n            LIMIT $1 OFFSET $2\n        \"\"\", page_size, offset)\n        \n        products = [dict(row) for row in rows]\n        return products\n\n@app.get(\"/products/{product_id}\", response_model=Product)\nasync def get_product(product_id: int):\n    \"\"\"\n    Get a single product by ID\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    async with db_pool.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            WHERE id = $1\n        \"\"\", product_id)\n        \n        if not row:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return dict(row)\n\n@app.post(\"/products\", response_model=Product, status_code=201)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **stock**: Stock quantity (required, must be non-negative)\n    \"\"\"\n    async with db_pool.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            INSERT INTO products (name, description, price, stock)\n            VALUES ($1, $2, $3, $4)\n            RETURNING id, name, description, price, stock\n        \"\"\", product.name, product.description, product.price, product.stock)\n        \n        return dict(row)\n\n@app.get(\"/products/search/{query}\")\nasync def search_products(\n    query: str,\n    page: int = Query(1, ge=1),\n    page_size: int = Query(10, ge=1, le=100)\n):\n    \"\"\"\n    Search products by name (case-insensitive)\n    \n    - **query**: Search term\n    - **page**: Page number\n    - **page_size**: Items per page\n    \"\"\"\n    offset = (page - 1) * page_size\n    search_pattern = f\"%{query}%\"\n    \n    async with db_pool.acquire() as conn:\n        rows = await conn.fetch(\"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            WHERE name ILIKE $1\n            ORDER BY id\n            LIMIT $2 OFFSET $3\n        \"\"\", search_pattern, page_size, offset)\n        \n        products = [dict(row) for row in rows]\n        return products\n\n# Additional endpoints for completeness\n@app.put(\"/products/{product_id}\", response_model=Product)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"Update an existing product\"\"\"\n    async with db_pool.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            UPDATE products\n            SET name = $1, description = $2, price = $3, stock = $4\n            WHERE id = $5\n            RETURNING id, name, description, price, stock\n        \"\"\", product.name, product.description, product.price, product.stock, product_id)\n        \n        if not row:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return dict(row)\n\n@app.delete(\"/products/{product_id}\", status_code=204)\nasync def delete_product(product_id: int):\n    \"\"\"Delete a product\"\"\"\n    async with db_pool.acquire() as conn:\n        result = await conn.execute(\"\"\"\n            DELETE FROM products WHERE id = $1\n        \"\"\", product_id)\n        \n        if result == \"DELETE 0\":\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n```\n\n## Installation & Setup\n\n### 1. Install Dependencies\n\n```bash\npip install fastapi uvicorn asyncpg python-dotenv\n```\n\n### 2. Environment Configuration\n\nCreate a `.env` file:\n\n```bash\n# Get your connection string from Neon Console\nDATABASE_URL=postgresql://user:password@ep-example-123456.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n### 3. Run the Application\n\n```python\n# main.py (add to the bottom of your file)\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8000, reload=True)\n```\n\n```bash\npython main.py\n```\n\nOr using uvicorn directly:\n\n```bash\nuvicorn main:app --reload\n```\n\n## Usage Examples\n\n### List Products (with pagination)\n\n```bash\ncurl http://localhost:8000/products?page=1&page_size=10\n```\n\n### Get Single Product\n\n```bash\ncurl http://localhost:8000/products/1\n```\n\n### Create Product\n\n```bash\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n```\n\n### Search Products\n\n```bash\ncurl http://localhost:8000/products/search/laptop\n```\n\n### Update Product\n\n```bash\ncurl -X PUT http://localhost:8000/products/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-performance gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n```\n\n### Delete Product\n\n```bash\ncurl -X DELETE http://localhost:8000/products/1\n```\n\n## Key Features\n\n### 1. **Connection Pooling**\n- Uses `asyncpg.create_pool()` with configurable min/max connections\n- Pool is created on startup and closed on shutdown\n- Connections are automatically managed and reused\n\n### 2. **Async/Await Patterns**\n- All database operations use `async`/`await`\n- Connection acquisition with `async with db_pool.acquire()`\n- Non-blocking I/O for better performance\n\n### 3. **Lifespan Management**\n- Uses FastAPI's `@asynccontextmanager` for startup/shutdown\n- Automatic schema initialization\n- Graceful connection pool cleanup\n\n### 4. **Security & Best Practices**\n- Parameterized queries (prevents SQL injection)\n- SSL required for Neon connections\n- Input validation with Pydantic\n- Proper error handling with HTTP status codes\n\n### 5. **Pagination**\n- Efficient LIMIT/OFFSET pagination\n- Configurable page size with max limit\n- Query parameters with validation\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive docs:\n\n- **Swagger UI**: http://localhost:8000/docs\n- **ReDoc**: http://localhost:8000/redoc\n\n## Connection String Format\n\nFor Neon, use the **pooled connection string** from your Neon Console:\n\n```\npostgresql://user:password@ep-example-123456.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n**Note**: asyncpg requires `sslmode=require` for Neon connections.\n\n## Production Considerations\n\n1. **Environment Variables**: Use proper secret management\n2. **Connection Pool Sizing**: Adjust based on your workload\n3. **Error Handling**: Add comprehensive logging\n4. **Rate Limiting**: Consider adding rate limiting middleware\n5. **Monitoring**: Add health checks and metrics\n6. **Database Migrations**: Use Alembic for schema management\n\nThis implementation provides a production-ready foundation for building REST APIs with FastAPI and Neon Postgres!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2226,
            "output_tokens": 2769,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a complete FastAPI endpoint for products with PostgreSQL using asyncpg. Let me set this up with proper async patterns and connection pooling.\n\nFirst, let me check the current database setup:\n\n```python\n# src/database.py\n\"\"\"Database configuration and session management.\"\"\"\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker\nfrom sqlalchemy.orm import declarative_base\nimport os\n\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"postgresql+asyncpg://user:password@localhost/dbname\")\n\n# Create async engine with connection pooling\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=True,\n    pool_size=10,\n    max_overflow=20,\n    pool_pre_ping=True,\n    pool_recycle=3600,\n)\n\n# Create async session factory\nAsyncSessionLocal = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\nBase = declarative_base()\n\n\nasync def get_db():\n    \"\"\"Dependency for getting database sessions.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n```\n\nNow let's create the Product model:\n\n```python\n# src/models/product.py\n\"\"\"Product model definition.\"\"\"\nfrom sqlalchemy import Column, Integer, String, Numeric, Text, DateTime\nfrom sqlalchemy.sql import func\nfrom src.database import Base\n\n\nclass Product(Base):\n    __tablename__ = \"products\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(255), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    price = Column(Numeric(10, 2), nullable=False)\n    sku = Column(String(100), unique=True, nullable=False, index=True)\n    stock_quantity = Column(Integer, default=0, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    def __repr__(self):\n        return f\"<Product(id={self.id}, name='{self.name}', sku='{self.sku}')>\"\n```\n\nCreate Pydantic schemas for request/response validation:\n\n```python\n# src/schemas/product.py\n\"\"\"Pydantic schemas for Product API.\"\"\"\nfrom pydantic import BaseModel, Field, ConfigDict\nfrom decimal import Decimal\nfrom datetime import datetime\n\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255, description=\"Product name\")\n    description: str | None = Field(None, description=\"Product description\")\n    price: Decimal = Field(..., gt=0, decimal_places=2, description=\"Product price\")\n    sku: str = Field(..., min_length=1, max_length=100, description=\"Stock keeping unit\")\n    stock_quantity: int = Field(default=0, ge=0, description=\"Available stock quantity\")\n\n\nclass ProductCreate(ProductBase):\n    \"\"\"Schema for creating a new product.\"\"\"\n    pass\n\n\nclass ProductResponse(ProductBase):\n    \"\"\"Schema for product response.\"\"\"\n    id: int\n    created_at: datetime\n    updated_at: datetime | None\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass ProductListResponse(BaseModel):\n    \"\"\"Schema for paginated product list.\"\"\"\n    items: list[ProductResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\nCreate the service layer:\n\n```python\n# src/services/product_service.py\n\"\"\"Product service with business logic.\"\"\"\nimport logging\nfrom sqlalchemy import select, func\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.models.product import Product\nfrom src.schemas.product import ProductCreate\nfrom src.services.base import BaseService\n\nlogger = logging.getLogger(__name__)\n\n\nclass ProductService(BaseService[Product]):\n    \"\"\"Service for managing products.\"\"\"\n\n    async def get_products(\n        self, \n        page: int = 1, \n        page_size: int = 10,\n        search: str | None = None\n    ) -> tuple[list[Product], int]:\n        \"\"\"\n        Get paginated list of products.\n        \n        Args:\n            page: Page number (1-indexed)\n            page_size: Number of items per page\n            search: Optional search term for name/sku\n            \n        Returns:\n            Tuple of (products list, total count)\n        \"\"\"\n        # Build base query\n        query = select(Product)\n        \n        # Add search filter if provided\n        if search:\n            search_filter = f\"%{search}%\"\n            query = query.where(\n                (Product.name.ilike(search_filter)) | \n                (Product.sku.ilike(search_filter))\n            )\n        \n        # Get total count\n        count_query = select(func.count()).select_from(query.subquery())\n        total_result = await self.session.execute(count_query)\n        total = total_result.scalar_one()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        query = query.offset(offset).limit(page_size).order_by(Product.created_at.desc())\n        \n        # Execute query\n        result = await self.session.execute(query)\n        products = result.scalars().all()\n        \n        logger.info(\"Retrieved %d products (page %d, total %d)\", len(products), page, total)\n        return list(products), total\n\n    async def get_product_by_id(self, product_id: int) -> Product | None:\n        \"\"\"Get a single product by ID.\"\"\"\n        return await self.get_by_id(Product, product_id)\n\n    async def create_product(self, product_data: ProductCreate) -> Product:\n        \"\"\"\n        Create a new product.\n        \n        Args:\n            product_data: Product creation data\n            \n        Returns:\n            Created product instance\n        \"\"\"\n        product = Product(**product_data.model_dump())\n        return await self.create(product)\n\n    async def check_sku_exists(self, sku: str) -> bool:\n        \"\"\"Check if a product with the given SKU already exists.\"\"\"\n        query = select(Product).where(Product.sku == sku)\n        result = await self.session.execute(query)\n        return result.scalar_one_or_none() is not None\n```\n\nNow create the API endpoints:\n\n```python\n# src/api/products.py\n\"\"\"Product API endpoints.\"\"\"\nimport logging\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.database import get_db\nfrom src.schemas.product import ProductCreate, ProductResponse, ProductListResponse\nfrom src.services.product_service import ProductService\nimport math\n\nlogger = logging.getLogger(__name__)\nrouter = APIRouter(prefix=\"/products\", tags=[\"products\"])\n\n\n@router.get(\"\", response_model=ProductListResponse)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: str | None = Query(None, description=\"Search by name or SKU\"),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"\n    Get paginated list of products.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term for filtering by name or SKU\n    \"\"\"\n    service = ProductService(db)\n    products, total = await service.get_products(page, page_size, search)\n    \n    total_pages = math.ceil(total / page_size) if total > 0 else 0\n    \n    return ProductListResponse(\n        items=[ProductResponse.model_validate(p) for p in products],\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=total_pages,\n    )\n\n\n@router.get(\"/{product_id}\", response_model=ProductResponse)\nasync def get_product(\n    product_id: int,\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    service = ProductService(db)\n    product = await service.get_product_by_id(product_id)\n    \n    if not product:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {product_id} not found\"\n        )\n    \n    return ProductResponse.model_validate(product)\n\n\n@router.post(\"\", response_model=ProductResponse, status_code=status.HTTP_201_CREATED)\nasync def create_product(\n    product_data: ProductCreate,\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **sku**: Stock keeping unit (required, must be unique)\n    - **stock_quantity**: Available stock (optional, defaults to 0)\n    \"\"\"\n    service = ProductService(db)\n    \n    # Check if SKU already exists\n    if await service.check_sku_exists(product_data.sku):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Product with SKU '{product_data.sku}' already exists\"\n        )\n    \n    try:\n        product = await service.create_product(product_data)\n        logger.info(\"Created product: %s\", product)\n        return ProductResponse.model_validate(product)\n    except Exception as e:\n        logger.error(\"Error creating product: %s\", e)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create product\"\n        )\n```\n\nUpdate the main application file to include the router:\n\n```python\n# src/main.py\n\"\"\"FastAPI application entrypoint.\"\"\"\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom src.database import engine, Base\nfrom src.api.products import router as products_router\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Handle startup and shutdown events.\"\"\"\n    # Startup: Create tables\n    logger.info(\"Creating database tables...\")\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    logger.info(\"Database tables created successfully\")\n    \n    yield\n    \n    # Shutdown: Dispose engine\n    logger.info(\"Disposing database engine...\")\n    await engine.dispose()\n    logger.info(\"Database engine disposed\")\n\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan,\n)\n\n# Include routers\napp.include_router(products_router)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"ok\", \"message\": \"Products API is running\"}\n```\n\nUpdate dependencies in pyproject.toml:\n\n```toml\n# pyproject.toml\n[tool.poetry.dependencies]\npython = \"^3.12\"\nfastapi = \"^0.109.0\"\nuvicorn = {extras = [\"standard\"], version = \"^0.27.0\"}\nsqlalchemy = {extras = [\"asyncio\"], version = \"^2.0.25\"}\nasyncpg = \"^0.29.0\"\npydantic = \"^2.5.3\"\npydantic-settings = \"^2.1.0\"\n```\n\nCreate a test file:\n\n```python\n# tests/test_products.py\n\"\"\"Tests for product endpoints.\"\"\"\nimport pytest\nfrom httpx import AsyncClient\nfrom src.main import app\n\n\n@pytest.mark.asyncio\nasync def test_create_product():\n    \"\"\"Test creating a new product.\"\"\"\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.post(\n            \"/products\",\n            json={\n                \"name\": \"Test Product\",\n                \"description\": \"A test product\",\n                \"price\": \"29.99\",\n                \"sku\": \"TEST-001\",\n                \"stock_quantity\": 100\n            }\n        )\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"name\"] == \"Test Product\"\n        assert data[\"sku\"] == \"TEST-001\"\n        assert \"id\" in data\n\n\n@pytest.mark.asyncio\nasync def test_list_products():\n    \"\"\"Test listing products with pagination.\"\"\"\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/products?page=1&page_size=10\")\n        assert response.status_code == 200\n        data = response.json()\n        assert \"items\" in data\n        assert \"total\" in data\n        assert \"page\" in data\n\n\n@pytest.mark.asyncio\nasync def test_get_product_not_found():\n    \"\"\"Test getting a non-existent product.\"\"\"\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/products/99999\")\n        assert response.status_code == 404\n```\n\nFinally, create an example .env file:\n\n```bash\n# .env.example\nDATABASE_URL=postgresql+asyncpg://postgres:password@localhost:5432/products_db\n```\n\nTo run the application:\n\n```bash\n# Install dependencies\npoetry install\n\n# Set up environment variables\ncp .env.example .env\n# Edit .env with your database credentials\n\n# Run migrations (create tables)\n# Tables are auto-created on startup via lifespan event\n\n# Start the server\npoetry run uvicorn src.main:app --reload --host 0.0.0.0 --port 8000\n\n# Access API docs at http://localhost:8000/docs\n```\n\nThis implementation includes:\n- \u2705 Async/await patterns throughout\n- \u2705 Connection pooling with asyncpg via SQLAlchemy\n- \u2705 Proper dependency injection for database sessions\n- \u2705 Pagination support with search functionality\n- \u2705 Request/response validation with Pydantic\n- \u2705 Error handling and logging\n- \u2705 Service layer for business logic\n- \u2705 Automatic transaction management\n- \u2705 API documentation via FastAPI\n- \u2705 Test examples\n\nThe API is now ready to use at `http://localhost:8000/products`!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25200,
            "output_tokens": 3725,
            "cached": true
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# FastAPI PostgreSQL Products API with asyncpg\n\nHere's a complete implementation with connection pooling, proper async patterns, and error handling:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query, Depends\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional, List\nfrom contextlib import asynccontextmanager\nimport asyncpg\nfrom asyncpg.pool import Pool\nimport os\nfrom decimal import Decimal\n\n# Configuration\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql://user:password@localhost:5432/products_db\"\n)\n\n# Global connection pool\ndb_pool: Optional[Pool] = None\n\n\n# Pydantic Models\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = Field(None, max_length=1000)\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(..., ge=0)\n\n    @validator('price')\n    def validate_price(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than 0')\n        return round(v, 2)\n\n\nclass ProductCreate(ProductBase):\n    pass\n\n\nclass Product(ProductBase):\n    id: int\n    created_at: str\n\n    class Config:\n        from_attributes = True\n\n\nclass ProductList(BaseModel):\n    products: List[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n\n# Database connection pool management\nasync def init_db_pool():\n    \"\"\"Initialize the database connection pool\"\"\"\n    global db_pool\n    db_pool = await asyncpg.create_pool(\n        DATABASE_URL,\n        min_size=5,\n        max_size=20,\n        command_timeout=60,\n        max_queries=50000,\n        max_inactive_connection_lifetime=300,\n    )\n    print(\"Database pool created successfully\")\n\n\nasync def close_db_pool():\n    \"\"\"Close the database connection pool\"\"\"\n    global db_pool\n    if db_pool:\n        await db_pool.close()\n        print(\"Database pool closed\")\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Lifespan context manager for startup and shutdown events\"\"\"\n    # Startup\n    await init_db_pool()\n    await create_products_table()\n    yield\n    # Shutdown\n    await close_db_pool()\n\n\n# Initialize FastAPI app with lifespan\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n\n# Dependency to get database connection\nasync def get_db_connection():\n    \"\"\"Dependency that provides a database connection from the pool\"\"\"\n    if not db_pool:\n        raise HTTPException(status_code=500, detail=\"Database pool not initialized\")\n    \n    async with db_pool.acquire() as connection:\n        yield connection\n\n\n# Database initialization\nasync def create_products_table():\n    \"\"\"Create the products table if it doesn't exist\"\"\"\n    async with db_pool.acquire() as conn:\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price NUMERIC(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create index for better query performance\n        await conn.execute(\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_products_name \n            ON products(name)\n        \"\"\")\n        \n        print(\"Products table created/verified successfully\")\n\n\n# API Endpoints\n\n@app.get(\"/\", tags=[\"Root\"])\nasync def root():\n    \"\"\"Root endpoint\"\"\"\n    return {\n        \"message\": \"Products API\",\n        \"endpoints\": {\n            \"list\": \"GET /products\",\n            \"get\": \"GET /products/{id}\",\n            \"create\": \"POST /products\"\n        }\n    }\n\n\n@app.get(\"/products\", response_model=ProductList, tags=[\"Products\"])\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: Optional[str] = Query(None, description=\"Search by product name\"),\n    conn: asyncpg.Connection = Depends(get_db_connection)\n):\n    \"\"\"\n    Get a paginated list of products\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term for product name\n    \"\"\"\n    try:\n        offset = (page - 1) * page_size\n        \n        # Build query based on search parameter\n        if search:\n            count_query = \"\"\"\n                SELECT COUNT(*) FROM products \n                WHERE name ILIKE $1\n            \"\"\"\n            select_query = \"\"\"\n                SELECT id, name, description, price, stock, \n                       created_at::text as created_at\n                FROM products\n                WHERE name ILIKE $1\n                ORDER BY created_at DESC\n                LIMIT $2 OFFSET $3\n            \"\"\"\n            search_param = f\"%{search}%\"\n            total = await conn.fetchval(count_query, search_param)\n            rows = await conn.fetch(select_query, search_param, page_size, offset)\n        else:\n            count_query = \"SELECT COUNT(*) FROM products\"\n            select_query = \"\"\"\n                SELECT id, name, description, price, stock, \n                       created_at::text as created_at\n                FROM products\n                ORDER BY created_at DESC\n                LIMIT $1 OFFSET $2\n            \"\"\"\n            total = await conn.fetchval(count_query)\n            rows = await conn.fetch(select_query, page_size, offset)\n        \n        # Convert rows to Product models\n        products = [\n            Product(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=row['price'],\n                stock=row['stock'],\n                created_at=row['created_at']\n            )\n            for row in rows\n        ]\n        \n        total_pages = (total + page_size - 1) // page_size\n        \n        return ProductList(\n            products=products,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=total_pages\n        )\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n@app.get(\"/products/{product_id}\", response_model=Product, tags=[\"Products\"])\nasync def get_product(\n    product_id: int,\n    conn: asyncpg.Connection = Depends(get_db_connection)\n):\n    \"\"\"\n    Get a single product by ID\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    try:\n        query = \"\"\"\n            SELECT id, name, description, price, stock, \n                   created_at::text as created_at\n            FROM products\n            WHERE id = $1\n        \"\"\"\n        \n        row = await conn.fetchrow(query, product_id)\n        \n        if not row:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock'],\n            created_at=row['created_at']\n        )\n    \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n@app.post(\"/products\", response_model=Product, status_code=201, tags=[\"Products\"])\nasync def create_product(\n    product: ProductCreate,\n    conn: asyncpg.Connection = Depends(get_db_connection)\n):\n    \"\"\"\n    Create a new product\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional, max 1000 characters)\n    - **price**: Product price (required, must be > 0)\n    - **stock**: Stock quantity (required, must be >= 0)\n    \"\"\"\n    try:\n        query = \"\"\"\n            INSERT INTO products (name, description, price, stock)\n            VALUES ($1, $2, $3, $4)\n            RETURNING id, name, description, price, stock, \n                      created_at::text as created_at\n        \"\"\"\n        \n        row = await conn.fetchrow(\n            query,\n            product.name,\n            product.description,\n            product.price,\n            product.stock\n        )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock'],\n            created_at=row['created_at']\n        )\n    \n    except asyncpg.UniqueViolationError:\n        raise HTTPException(\n            status_code=400,\n            detail=\"A product with this name already exists\"\n        )\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n# Health check endpoint\n@app.get(\"/health\", tags=[\"Health\"])\nasync def health_check(conn: asyncpg.Connection = Depends(get_db_connection)):\n    \"\"\"Check if the API and database are healthy\"\"\"\n    try:\n        # Simple query to check database connectivity\n        await conn.fetchval(\"SELECT 1\")\n        return {\n            \"status\": \"healthy\",\n            \"database\": \"connected\"\n        }\n    except Exception as e:\n        raise HTTPException(\n            status_code=503,\n            detail=f\"Database connection failed: {str(e)}\"\n        )\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True\n    )\n```\n\n## Requirements File (`requirements.txt`)\n\n```txt\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\nasyncpg==0.29.0\npydantic==2.5.0\npython-dotenv==1.0.0\n```\n\n## Environment Configuration (`.env`)\n\n```env\nDATABASE_URL=postgresql://user:password@localhost:5432/products_db\n```\n\n## Docker Compose for PostgreSQL (`docker-compose.yml`)\n\n```yaml\nversion: '3.8'\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: products_db\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U user -d products_db\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\nvolumes:\n  postgres_data:\n```\n\n## Usage Examples\n\n### Start the PostgreSQL database:\n```bash\ndocker-compose up -d\n```\n\n### Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n### Run the application:\n```bash\npython main.py\n# or\nuvicorn main:app --reload\n```\n\n### Test the API:\n\n```bash\n# Create a product\ncurl -X POST \"http://localhost:8000/products\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# Get all products (paginated)\ncurl \"http://localhost:8000/products?page=1&page_size=10\"\n\n# Search products\ncurl \"http://localhost:8000/products?search=Laptop\"\n\n# Get single product\ncurl \"http://localhost:8000/products/1\"\n\n# Health check\ncurl \"http://localhost:8000/health\"\n```\n\n## Key Features:\n\n1. **Connection Pooling**: Uses asyncpg's connection pool for efficient database connections\n2. **Async/Await**: Proper async patterns throughout\n3. **Pagination**: Built-in pagination with configurable page size\n4. **Search**: Optional search functionality\n5. **Validation**: Pydantic models for request/response validation\n6. **Error Handling**: Comprehensive error handling with appropriate HTTP status codes\n7. **Health Check**: Endpoint to verify API and database health\n8. **Type Safety**: Full type hints for better IDE support\n9. **Documentation**: Auto-generated API docs at `/docs`\n\nAccess the interactive API documentation at `http://localhost:8000/docs`!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 3244,
            "cached": true
          },
          "with_skill": {
            "output": "I'll create a complete FastAPI application with asyncpg for Neon Postgres, including connection pooling and proper async patterns.\n\n```python\n# main.py\nimport os\nfrom contextlib import asynccontextmanager\nfrom typing import Optional\n\nimport asyncpg\nfrom fastapi import FastAPI, HTTPException, Query\nfrom pydantic import BaseModel, Field\n\n\n# Pydantic models for request/response validation\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\n\nclass ProductCreate(ProductBase):\n    pass\n\n\nclass Product(ProductBase):\n    id: int\n    created_at: str\n\n    class Config:\n        from_attributes = True\n\n\nclass ProductList(BaseModel):\n    products: list[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n\n# Database connection pool\nclass Database:\n    pool: Optional[asyncpg.Pool] = None\n\n    @classmethod\n    async def connect(cls):\n        \"\"\"Create database connection pool\"\"\"\n        cls.pool = await asyncpg.create_pool(\n            dsn=os.environ[\"DATABASE_URL\"],\n            min_size=2,\n            max_size=10,\n            command_timeout=60,\n        )\n        print(\"\u2713 Database pool created\")\n\n    @classmethod\n    async def disconnect(cls):\n        \"\"\"Close database connection pool\"\"\"\n        if cls.pool:\n            await cls.pool.close()\n            print(\"\u2713 Database pool closed\")\n\n    @classmethod\n    def get_pool(cls) -> asyncpg.Pool:\n        \"\"\"Get the connection pool\"\"\"\n        if not cls.pool:\n            raise RuntimeError(\"Database pool not initialized\")\n        return cls.pool\n\n\n# Lifespan context manager for startup/shutdown\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    await Database.connect()\n    await create_products_table()\n    yield\n    # Shutdown\n    await Database.disconnect()\n\n\n# Initialize FastAPI app\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon Postgres\",\n    version=\"1.0.0\",\n    lifespan=lifespan,\n)\n\n\n# Database initialization\nasync def create_products_table():\n    \"\"\"Create products table if it doesn't exist\"\"\"\n    pool = Database.get_pool()\n    async with pool.acquire() as conn:\n        await conn.execute(\n            \"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n            \"\"\"\n        )\n        print(\"\u2713 Products table ready\")\n\n\n# API Endpoints\n@app.get(\"/products\", response_model=ProductList)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n):\n    \"\"\"\n    List products with pagination.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    pool = Database.get_pool()\n    offset = (page - 1) * page_size\n\n    async with pool.acquire() as conn:\n        # Get total count\n        total = await conn.fetchval(\"SELECT COUNT(*) FROM products\")\n\n        # Get paginated products\n        rows = await conn.fetch(\n            \"\"\"\n            SELECT id, name, description, price, stock, \n                   created_at::text as created_at\n            FROM products\n            ORDER BY created_at DESC\n            LIMIT $1 OFFSET $2\n            \"\"\",\n            page_size,\n            offset,\n        )\n\n    products = [Product(**dict(row)) for row in rows]\n    total_pages = (total + page_size - 1) // page_size\n\n    return ProductList(\n        products=products,\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=total_pages,\n    )\n\n\n@app.get(\"/products/{product_id}\", response_model=Product)\nasync def get_product(product_id: int):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The product ID\n    \"\"\"\n    pool = Database.get_pool()\n\n    async with pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"\"\"\n            SELECT id, name, description, price, stock,\n                   created_at::text as created_at\n            FROM products\n            WHERE id = $1\n            \"\"\",\n            product_id,\n        )\n\n    if not row:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n\n    return Product(**dict(row))\n\n\n@app.post(\"/products\", response_model=Product, status_code=201)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (must be > 0)\n    - **stock**: Stock quantity (must be >= 0)\n    \"\"\"\n    pool = Database.get_pool()\n\n    async with pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"\"\"\n            INSERT INTO products (name, description, price, stock)\n            VALUES ($1, $2, $3, $4)\n            RETURNING id, name, description, price, stock,\n                      created_at::text as created_at\n            \"\"\",\n            product.name,\n            product.description,\n            product.price,\n            product.stock,\n        )\n\n    return Product(**dict(row))\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint\"\"\"\n    pool = Database.get_pool()\n    \n    try:\n        async with pool.acquire() as conn:\n            await conn.fetchval(\"SELECT 1\")\n        return {\"status\": \"healthy\", \"database\": \"connected\"}\n    except Exception as e:\n        raise HTTPException(\n            status_code=503,\n            detail=f\"Database connection failed: {str(e)}\"\n        )\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8000, reload=True)\n```\n\n```python\n# requirements.txt\nfastapi==0.115.0\nuvicorn[standard]==0.32.0\nasyncpg==0.30.0\npydantic==2.10.0\npython-dotenv==1.0.1\n```\n\n```bash\n# .env\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb\n```\n\n```python\n# test_api.py - Example usage/testing\nimport asyncio\nimport httpx\n\n\nasync def test_api():\n    \"\"\"Test the Products API\"\"\"\n    base_url = \"http://localhost:8000\"\n\n    async with httpx.AsyncClient() as client:\n        # Create products\n        print(\"Creating products...\")\n        products_data = [\n            {\n                \"name\": \"Laptop\",\n                \"description\": \"High-performance laptop\",\n                \"price\": 999.99,\n                \"stock\": 50,\n            },\n            {\n                \"name\": \"Mouse\",\n                \"description\": \"Wireless mouse\",\n                \"price\": 29.99,\n                \"stock\": 200,\n            },\n            {\n                \"name\": \"Keyboard\",\n                \"description\": \"Mechanical keyboard\",\n                \"price\": 79.99,\n                \"stock\": 100,\n            },\n        ]\n\n        created_ids = []\n        for product_data in products_data:\n            response = await client.post(f\"{base_url}/products\", json=product_data)\n            product = response.json()\n            created_ids.append(product[\"id\"])\n            print(f\"\u2713 Created: {product['name']} (ID: {product['id']})\")\n\n        # List products with pagination\n        print(\"\\nListing products (page 1, size 2)...\")\n        response = await client.get(f\"{base_url}/products?page=1&page_size=2\")\n        products_list = response.json()\n        print(f\"Total products: {products_list['total']}\")\n        print(f\"Page {products_list['page']}/{products_list['total_pages']}\")\n        for product in products_list[\"products\"]:\n            print(f\"  - {product['name']}: ${product['price']}\")\n\n        # Get single product\n        print(f\"\\nGetting product ID {created_ids[0]}...\")\n        response = await client.get(f\"{base_url}/products/{created_ids[0]}\")\n        product = response.json()\n        print(f\"\u2713 Found: {product['name']} - ${product['price']}\")\n\n        # Test 404\n        print(\"\\nTesting 404...\")\n        response = await client.get(f\"{base_url}/products/99999\")\n        print(f\"Status: {response.status_code} (expected 404)\")\n\n        # Health check\n        print(\"\\nHealth check...\")\n        response = await client.get(f\"{base_url}/health\")\n        health = response.json()\n        print(f\"\u2713 Status: {health['status']}, Database: {health['database']}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(test_api())\n```\n\n## Setup & Run\n\n```bash\n# Install dependencies\npip install -r requirements.txt\n\n# Set your Neon connection string\nexport DATABASE_URL=\"postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb\"\n\n# Run the API\npython main.py\n\n# In another terminal, test the API\npython test_api.py\n```\n\n## Key Features\n\n### 1. **Connection Pooling**\n- `asyncpg.create_pool()` with configurable min/max connections\n- Pool reused across requests for efficiency\n- Proper cleanup on shutdown\n\n### 2. **Async/Await Patterns**\n- All database operations use `async with pool.acquire()`\n- Non-blocking I/O for better performance\n- Lifespan context manager for startup/shutdown\n\n### 3. **Pagination**\n- Efficient `LIMIT/OFFSET` queries\n- Returns total count and page metadata\n- Configurable page size with limits\n\n### 4. **Error Handling**\n- 404 for missing products\n- 503 for database connection issues\n- Pydantic validation for request data\n\n### 5. **Type Safety**\n- Pydantic models for request/response validation\n- Type hints throughout\n- Automatic OpenAPI documentation at `/docs`\n\n## API Documentation\n\nOnce running, visit:\n- **Interactive docs**: http://localhost:8000/docs\n- **Alternative docs**: http://localhost:8000/redoc\n\n## Production Considerations\n\nFor production, consider:\n\n1. **Environment variables**: Use `python-dotenv` or secrets management\n2. **Connection pool tuning**: Adjust `min_size`/`max_size` based on load\n3. **Error logging**: Add structured logging (e.g., `structlog`)\n4. **Rate limiting**: Add middleware for API rate limits\n5. **Authentication**: Add JWT or API key authentication\n6. **Monitoring**: Add metrics and health checks\n\nThis implementation follows FastAPI and asyncpg best practices while leveraging Neon's serverless Postgres capabilities!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24674,
            "output_tokens": 2892,
            "cached": true
          },
          "skill_md_only": {
            "output": "# FastAPI + Neon Postgres with asyncpg\n\nHere's a complete FastAPI application with asyncpg connection pooling for a products REST API:\n\n## Installation\n\n```bash\npip install fastapi uvicorn asyncpg python-dotenv\n```\n\n## Project Structure\n\n```\n.\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 database.py\n\u251c\u2500\u2500 models.py\n\u251c\u2500\u2500 .env\n\u2514\u2500\u2500 requirements.txt\n```\n\n## 1. Environment Configuration (.env)\n\n```env\n# Get your connection string from Neon Console\nDATABASE_URL=postgresql://user:password@ep-example-123456.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n## 2. Database Connection Pool (database.py)\n\n```python\nimport asyncpg\nimport os\nfrom contextlib import asynccontextmanager\nfrom typing import Optional\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nclass Database:\n    def __init__(self):\n        self.pool: Optional[asyncpg.Pool] = None\n        self.database_url = os.getenv(\"DATABASE_URL\")\n        \n        if not self.database_url:\n            raise ValueError(\"DATABASE_URL environment variable is not set\")\n\n    async def connect(self):\n        \"\"\"Create connection pool on startup\"\"\"\n        self.pool = await asyncpg.create_pool(\n            self.database_url,\n            min_size=2,          # Minimum connections in pool\n            max_size=10,         # Maximum connections in pool\n            max_queries=50000,   # Max queries per connection before recycling\n            max_inactive_connection_lifetime=300,  # 5 minutes\n            command_timeout=60,  # Query timeout in seconds\n        )\n        \n        # Create products table if it doesn't exist\n        async with self.pool.acquire() as conn:\n            await conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS products (\n                    id SERIAL PRIMARY KEY,\n                    name VARCHAR(255) NOT NULL,\n                    description TEXT,\n                    price DECIMAL(10, 2) NOT NULL,\n                    stock INTEGER NOT NULL DEFAULT 0,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            \n            # Create index for better query performance\n            await conn.execute(\"\"\"\n                CREATE INDEX IF NOT EXISTS idx_products_name \n                ON products(name)\n            \"\"\")\n\n    async def disconnect(self):\n        \"\"\"Close connection pool on shutdown\"\"\"\n        if self.pool:\n            await self.pool.close()\n\n    @asynccontextmanager\n    async def acquire(self):\n        \"\"\"Context manager for acquiring connections from pool\"\"\"\n        async with self.pool.acquire() as connection:\n            yield connection\n\n# Global database instance\ndb = Database()\n```\n\n## 3. Pydantic Models (models.py)\n\n```python\nfrom pydantic import BaseModel, Field, ConfigDict\nfrom typing import Optional\nfrom datetime import datetime\nfrom decimal import Decimal\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(default=0, ge=0)\n\nclass ProductCreate(ProductBase):\n    \"\"\"Schema for creating a product\"\"\"\n    pass\n\nclass ProductResponse(ProductBase):\n    \"\"\"Schema for product responses\"\"\"\n    id: int\n    created_at: datetime\n    updated_at: datetime\n    \n    model_config = ConfigDict(from_attributes=True)\n\nclass ProductList(BaseModel):\n    \"\"\"Schema for paginated product list\"\"\"\n    products: list[ProductResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\n## 4. FastAPI Application (main.py)\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query\nfrom contextlib import asynccontextmanager\nfrom typing import List\nimport math\n\nfrom database import db\nfrom models import ProductCreate, ProductResponse, ProductList\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifecycle - startup and shutdown\"\"\"\n    # Startup: Create connection pool\n    await db.connect()\n    print(\"\u2705 Database connection pool created\")\n    \n    yield\n    \n    # Shutdown: Close connection pool\n    await db.disconnect()\n    print(\"\u2705 Database connection pool closed\")\n\n# Initialize FastAPI with lifespan\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon Postgres\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"message\": \"Products API is running\",\n        \"database\": \"connected\" if db.pool else \"disconnected\"\n    }\n\n@app.get(\"/products\", response_model=ProductList)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\")\n):\n    \"\"\"\n    List all products with pagination\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    offset = (page - 1) * page_size\n    \n    async with db.acquire() as conn:\n        # Get total count\n        total = await conn.fetchval(\"SELECT COUNT(*) FROM products\")\n        \n        # Get paginated products\n        rows = await conn.fetch(\"\"\"\n            SELECT id, name, description, price, stock, created_at, updated_at\n            FROM products\n            ORDER BY created_at DESC\n            LIMIT $1 OFFSET $2\n        \"\"\", page_size, offset)\n        \n        products = [dict(row) for row in rows]\n        \n        return ProductList(\n            products=products,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=math.ceil(total / page_size) if total > 0 else 0\n        )\n\n@app.get(\"/products/{product_id}\", response_model=ProductResponse)\nasync def get_product(product_id: int):\n    \"\"\"\n    Get a single product by ID\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    async with db.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            SELECT id, name, description, price, stock, created_at, updated_at\n            FROM products\n            WHERE id = $1\n        \"\"\", product_id)\n        \n        if not row:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return dict(row)\n\n@app.post(\"/products\", response_model=ProductResponse, status_code=201)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product\n    \n    - **name**: Product name (required, max 255 chars)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **stock**: Stock quantity (optional, defaults to 0)\n    \"\"\"\n    async with db.acquire() as conn:\n        # Check if product with same name exists\n        exists = await conn.fetchval(\n            \"SELECT EXISTS(SELECT 1 FROM products WHERE name = $1)\",\n            product.name\n        )\n        \n        if exists:\n            raise HTTPException(\n                status_code=400,\n                detail=f\"Product with name '{product.name}' already exists\"\n            )\n        \n        # Insert new product\n        row = await conn.fetchrow(\"\"\"\n            INSERT INTO products (name, description, price, stock)\n            VALUES ($1, $2, $3, $4)\n            RETURNING id, name, description, price, stock, created_at, updated_at\n        \"\"\", product.name, product.description, product.price, product.stock)\n        \n        return dict(row)\n\n@app.put(\"/products/{product_id}\", response_model=ProductResponse)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"\n    Update an existing product\n    \n    - **product_id**: The ID of the product to update\n    - **name**: Updated product name\n    - **description**: Updated description\n    - **price**: Updated price\n    - **stock**: Updated stock quantity\n    \"\"\"\n    async with db.acquire() as conn:\n        # Check if product exists\n        exists = await conn.fetchval(\n            \"SELECT EXISTS(SELECT 1 FROM products WHERE id = $1)\",\n            product_id\n        )\n        \n        if not exists:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        # Update product\n        row = await conn.fetchrow(\"\"\"\n            UPDATE products\n            SET name = $1, description = $2, price = $3, stock = $4,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = $5\n            RETURNING id, name, description, price, stock, created_at, updated_at\n        \"\"\", product.name, product.description, product.price, product.stock, product_id)\n        \n        return dict(row)\n\n@app.delete(\"/products/{product_id}\", status_code=204)\nasync def delete_product(product_id: int):\n    \"\"\"\n    Delete a product\n    \n    - **product_id**: The ID of the product to delete\n    \"\"\"\n    async with db.acquire() as conn:\n        result = await conn.execute(\n            \"DELETE FROM products WHERE id = $1\",\n            product_id\n        )\n        \n        # Check if any row was deleted\n        if result == \"DELETE 0\":\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return None\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n## 5. Requirements (requirements.txt)\n\n```txt\nfastapi==0.109.0\nuvicorn[standard]==0.27.0\nasyncpg==0.29.0\npython-dotenv==1.0.0\npydantic==2.5.3\n```\n\n## Running the Application\n\n1. **Set up your Neon database:**\n   ```bash\n   # Get your connection string from https://console.neon.tech\n   # Add it to .env file\n   ```\n\n2. **Install dependencies:**\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n3. **Run the server:**\n   ```bash\n   python main.py\n   # or\n   uvicorn main:app --reload\n   ```\n\n4. **Access the API:**\n   - API: http://localhost:8000\n   - Interactive docs: http://localhost:8000/docs\n   - Alternative docs: http://localhost:8000/redoc\n\n## Example API Usage\n\n### Create a Product\n```bash\ncurl -X POST \"http://localhost:8000/products\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n```\n\n### List Products (with pagination)\n```bash\ncurl \"http://localhost:8000/products?page=1&page_size=10\"\n```\n\n### Get Single Product\n```bash\ncurl \"http://localhost:8000/products/1\"\n```\n\n### Update Product\n```bash\ncurl -X PUT \"http://localhost:8000/products/1\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-end gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n```\n\n### Delete Product\n```bash\ncurl -X DELETE \"http://localhost:8000/products/1\"\n```\n\n## Key Features\n\n\u2705 **Connection Pooling**: Efficient connection reuse with asyncpg pool  \n\u2705 **Async/Await**: Full async support for non-blocking I/O  \n\u2705 **Pagination**: Built-in pagination for list endpoints  \n\u2705 **Error Handling**: Proper HTTP status codes and error messages  \n\u2705 **Validation**: Pydantic models for request/response validation  \n\u2705 **Lifecycle Management**: Proper startup/shutdown with connection pool  \n\u2705 **Auto Documentation**: Interactive API docs with FastAPI  \n\u2705 **Type Safety**: Full type hints for better IDE support  \n\n## Connection Pool Best Practices\n\nThe asyncpg pool configuration is optimized for Neon:\n\n- **min_size=2**: Keeps 2 connections warm (good for Neon's scale-to-zero)\n- **max_size=10**: Limits concurrent connections (adjust based on your Neon plan)\n- **max_inactive_connection_lifetime=300**: Recycles idle connections after 5 minutes\n- **command_timeout=60**: Prevents long-running queries from blocking\n\nFor production, consider:\n- Monitoring pool usage with `pool.get_size()` and `pool.get_idle_size()`\n- Adjusting pool sizes based on your traffic patterns\n- Using Neon's connection pooling for additional optimization\n\n## Next Steps\n\n- Add authentication (JWT, OAuth)\n- Implement search and filtering\n- Add database migrations (Alembic)\n- Set up logging and monitoring\n- Add caching (Redis)\n- Implement rate limiting",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2226,
            "output_tokens": 3373,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a complete FastAPI endpoint for products with PostgreSQL using asyncpg. Let me set this up with proper async patterns and connection pooling.\n\nFirst, let me check the current database setup:\n\n```python\n# Read: src/database.py\n```\n\nNow I'll create the products implementation:\n\n```python\n# src/models.py - Add Product model\nfrom sqlalchemy import Column, Integer, String, Numeric, Text, DateTime\nfrom sqlalchemy.sql import func\nfrom src.models import Base\n\nclass Product(Base):\n    __tablename__ = \"products\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(255), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    price = Column(Numeric(10, 2), nullable=False)\n    stock = Column(Integer, default=0, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n```\n\n```python\n# src/schemas/product.py - Pydantic schemas\nfrom pydantic import BaseModel, Field, ConfigDict\nfrom decimal import Decimal\nfrom datetime import datetime\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: str | None = None\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(default=0, ge=0)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass ProductResponse(ProductBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime | None\n\n    model_config = ConfigDict(from_attributes=True)\n\nclass ProductListResponse(BaseModel):\n    items: list[ProductResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\n```python\n# src/services/product_service.py\nimport logging\nfrom sqlalchemy import select, func\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.models import Product\nfrom src.services.base import BaseService\nfrom src.schemas.product import ProductCreate\n\nlogger = logging.getLogger(__name__)\n\nclass ProductService(BaseService[Product]):\n    async def get_products(\n        self, \n        page: int = 1, \n        page_size: int = 10\n    ) -> tuple[list[Product], int]:\n        \"\"\"Get paginated list of products with total count.\"\"\"\n        offset = (page - 1) * page_size\n        \n        # Get total count\n        count_query = select(func.count()).select_from(Product)\n        total_result = await self.session.execute(count_query)\n        total = total_result.scalar_one()\n        \n        # Get paginated products\n        query = (\n            select(Product)\n            .order_by(Product.created_at.desc())\n            .offset(offset)\n            .limit(page_size)\n        )\n        result = await self.session.execute(query)\n        products = result.scalars().all()\n        \n        logger.info(\n            \"Retrieved %d products (page %d, total %d)\", \n            len(products), page, total\n        )\n        return list(products), total\n\n    async def get_product(self, product_id: int) -> Product | None:\n        \"\"\"Get single product by ID.\"\"\"\n        return await self.get_by_id(Product, product_id)\n\n    async def create_product(self, product_data: ProductCreate) -> Product:\n        \"\"\"Create a new product.\"\"\"\n        product = Product(**product_data.model_dump())\n        return await self.create(product)\n```\n\n```python\n# src/routers/products.py\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.database import get_db\nfrom src.services.product_service import ProductService\nfrom src.schemas.product import (\n    ProductCreate, \n    ProductResponse, \n    ProductListResponse\n)\nimport math\n\nrouter = APIRouter(prefix=\"/products\", tags=[\"products\"])\n\n@router.get(\"\", response_model=ProductListResponse)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"\n    List all products with pagination.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    service = ProductService(db)\n    products, total = await service.get_products(page=page, page_size=page_size)\n    \n    total_pages = math.ceil(total / page_size) if total > 0 else 0\n    \n    return ProductListResponse(\n        items=[ProductResponse.model_validate(p) for p in products],\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=total_pages\n    )\n\n@router.get(\"/{product_id}\", response_model=ProductResponse)\nasync def get_product(\n    product_id: int,\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    service = ProductService(db)\n    product = await service.get_product(product_id)\n    \n    if not product:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    \n    return ProductResponse.model_validate(product)\n\n@router.post(\"\", response_model=ProductResponse, status_code=201)\nasync def create_product(\n    product: ProductCreate,\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, max 255 chars)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **stock**: Stock quantity (optional, defaults to 0)\n    \"\"\"\n    service = ProductService(db)\n    new_product = await service.create_product(product)\n    await db.commit()\n    await db.refresh(new_product)\n    \n    return ProductResponse.model_validate(new_product)\n```\n\n```python\n# src/main.py - Register the router\nfrom fastapi import FastAPI\nfrom src.routers import products\n\napp = FastAPI(\n    title=\"Product API\",\n    description=\"REST API for managing products\",\n    version=\"1.0.0\"\n)\n\n# Include the products router\napp.include_router(products.router)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Product API is running\"}\n\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\"}\n```\n\n```python\n# src/database.py - Async database setup with connection pooling\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker\nfrom sqlalchemy.pool import NullPool\nimport os\n\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql+asyncpg://user:password@localhost:5432/products_db\"\n)\n\n# Create async engine with connection pooling\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=True,  # Set to False in production\n    pool_size=5,  # Number of connections to maintain\n    max_overflow=10,  # Additional connections when pool is full\n    pool_pre_ping=True,  # Verify connections before using\n    pool_recycle=3600,  # Recycle connections after 1 hour\n)\n\n# Create async session factory\nAsyncSessionLocal = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n    autocommit=False,\n    autoflush=False,\n)\n\nasync def get_db() -> AsyncSession:\n    \"\"\"Dependency for getting async database sessions.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n```\n\nNow let's create a migration script and test file:\n\n```python\n# alembic/versions/001_create_products_table.py\n\"\"\"create products table\n\nRevision ID: 001\nCreate Date: 2024-01-01 00:00:00.000000\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\nrevision = '001'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\ndef upgrade() -> None:\n    op.create_table(\n        'products',\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('name', sa.String(length=255), nullable=False),\n        sa.Column('description', sa.Text(), nullable=True),\n        sa.Column('price', sa.Numeric(precision=10, scale=2), nullable=False),\n        sa.Column('stock', sa.Integer(), nullable=False, server_default='0'),\n        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),\n        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=True),\n        sa.PrimaryKeyConstraint('id')\n    )\n    op.create_index('ix_products_id', 'products', ['id'])\n    op.create_index('ix_products_name', 'products', ['name'])\n\ndef downgrade() -> None:\n    op.drop_index('ix_products_name', table_name='products')\n    op.drop_index('ix_products_id', table_name='products')\n    op.drop_table('products')\n```\n\n```python\n# tests/test_products.py\nimport pytest\nfrom httpx import AsyncClient\nfrom src.main import app\n\n@pytest.mark.asyncio\nasync def test_create_product():\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.post(\n            \"/products\",\n            json={\n                \"name\": \"Test Product\",\n                \"description\": \"A test product\",\n                \"price\": \"29.99\",\n                \"stock\": 100\n            }\n        )\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"name\"] == \"Test Product\"\n        assert data[\"price\"] == \"29.99\"\n        assert \"id\" in data\n\n@pytest.mark.asyncio\nasync def test_list_products():\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/products?page=1&page_size=10\")\n        assert response.status_code == 200\n        data = response.json()\n        assert \"items\" in data\n        assert \"total\" in data\n        assert \"page\" in data\n        assert data[\"page\"] == 1\n\n@pytest.mark.asyncio\nasync def test_get_product_not_found():\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/products/99999\")\n        assert response.status_code == 404\n```\n\n```toml\n# pyproject.toml - Add dependencies\n[tool.poetry.dependencies]\npython = \"^3.12\"\nfastapi = \"^0.109.0\"\nuvicorn = {extras = [\"standard\"], version = \"^0.27.0\"}\nsqlalchemy = \"^2.0.25\"\nasyncpg = \"^0.29.0\"\npydantic = \"^2.5.3\"\nalembic = \"^1.13.1\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.4\"\npytest-asyncio = \"^0.23.3\"\nhttpx = \"^0.26.0\"\n```\n\n```bash\n# .env.example\nDATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/products_db\n```\n\nFinally, a quick start guide:\n\n```markdown\n# README.md - Quick Start\n\n## Setup\n\n1. Install dependencies:\n```bash\npoetry install\n```\n\n2. Set up environment variables:\n```bash\ncp .env.example .env\n# Edit .env with your database credentials\n```\n\n3. Run migrations:\n```bash\nalembic upgrade head\n```\n\n4. Start the server:\n```bash\nuvicorn src.main:app --reload\n```\n\n## API Endpoints\n\n- `GET /products?page=1&page_size=10` - List products with pagination\n- `GET /products/{id}` - Get single product\n- `POST /products` - Create new product\n\n## Example Usage\n\n```bash\n# Create a product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": \"999.99\",\n    \"stock\": 50\n  }'\n\n# List products\ncurl http://localhost:8000/products?page=1&page_size=10\n\n# Get specific product\ncurl http://localhost:8000/products/1\n```\n\n## API Documentation\n\nVisit http://localhost:8000/docs for interactive API documentation.\n```\n\nThis implementation includes:\n\n\u2705 **Async/await patterns** throughout\n\u2705 **Connection pooling** with configurable pool size\n\u2705 **Pagination** with total count and page metadata\n\u2705 **Proper error handling** (404 for not found)\n\u2705 **Input validation** with Pydantic\n\u2705 **Service layer** for business logic\n\u2705 **Database migrations** with Alembic\n\u2705 **Tests** with pytest-asyncio\n\u2705 **API documentation** with FastAPI's built-in Swagger UI\n\nThe code follows the existing project structure and patterns from `BaseService`. Ready to run after setting up the database!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25200,
            "output_tokens": 3462,
            "cached": true
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# FastAPI PostgreSQL Products API with asyncpg\n\nHere's a complete implementation with connection pooling, proper async patterns, and error handling:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional, List\nfrom contextlib import asynccontextmanager\nimport asyncpg\nfrom decimal import Decimal\nimport os\n\n# ============================================================================\n# Configuration\n# ============================================================================\n\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql://user:password@localhost:5432/products_db\"\n)\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = Field(None, max_length=1000)\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(..., ge=0)\n    \n    @validator('price')\n    def validate_price(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than 0')\n        return round(v, 2)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n    created_at: str\n    \n    class Config:\n        orm_mode = True\n        json_encoders = {\n            Decimal: lambda v: float(v)\n        }\n\nclass ProductListResponse(BaseModel):\n    products: List[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n# ============================================================================\n# Database Connection Pool\n# ============================================================================\n\nclass Database:\n    pool: Optional[asyncpg.Pool] = None\n    \n    @classmethod\n    async def connect(cls):\n        \"\"\"Create database connection pool\"\"\"\n        try:\n            cls.pool = await asyncpg.create_pool(\n                DATABASE_URL,\n                min_size=5,\n                max_size=20,\n                command_timeout=60,\n                max_queries=50000,\n                max_inactive_connection_lifetime=300\n            )\n            print(\"\u2705 Database connection pool created successfully\")\n        except Exception as e:\n            print(f\"\u274c Failed to create database pool: {e}\")\n            raise\n    \n    @classmethod\n    async def disconnect(cls):\n        \"\"\"Close database connection pool\"\"\"\n        if cls.pool:\n            await cls.pool.close()\n            print(\"\u2705 Database connection pool closed\")\n    \n    @classmethod\n    async def initialize_schema(cls):\n        \"\"\"Create products table if it doesn't exist\"\"\"\n        async with cls.pool.acquire() as connection:\n            await connection.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS products (\n                    id SERIAL PRIMARY KEY,\n                    name VARCHAR(255) NOT NULL,\n                    description TEXT,\n                    price NUMERIC(10, 2) NOT NULL CHECK (price > 0),\n                    stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                );\n                \n                CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);\n                CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at DESC);\n            \"\"\")\n            print(\"\u2705 Database schema initialized\")\n\n# ============================================================================\n# FastAPI Application with Lifespan\n# ============================================================================\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifespan - startup and shutdown\"\"\"\n    # Startup\n    await Database.connect()\n    await Database.initialize_schema()\n    yield\n    # Shutdown\n    await Database.disconnect()\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\ndef record_to_product(record: asyncpg.Record) -> Product:\n    \"\"\"Convert database record to Product model\"\"\"\n    return Product(\n        id=record['id'],\n        name=record['name'],\n        description=record['description'],\n        price=record['price'],\n        stock=record['stock'],\n        created_at=record['created_at'].isoformat()\n    )\n\n# ============================================================================\n# API Endpoints\n# ============================================================================\n\n@app.get(\"/\", tags=[\"Health\"])\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"service\": \"Products API\",\n        \"version\": \"1.0.0\"\n    }\n\n@app.get(\n    \"/products\",\n    response_model=ProductListResponse,\n    tags=[\"Products\"],\n    summary=\"List all products with pagination\"\n)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: Optional[str] = Query(None, description=\"Search by product name\")\n):\n    \"\"\"\n    Retrieve a paginated list of products.\n    \n    - **page**: Page number (starts from 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term to filter by product name\n    \"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            # Calculate offset\n            offset = (page - 1) * page_size\n            \n            # Build query based on search parameter\n            if search:\n                count_query = \"\"\"\n                    SELECT COUNT(*) FROM products \n                    WHERE name ILIKE $1\n                \"\"\"\n                select_query = \"\"\"\n                    SELECT * FROM products \n                    WHERE name ILIKE $1\n                    ORDER BY created_at DESC\n                    LIMIT $2 OFFSET $3\n                \"\"\"\n                search_pattern = f\"%{search}%\"\n                \n                total = await connection.fetchval(count_query, search_pattern)\n                records = await connection.fetch(\n                    select_query, \n                    search_pattern, \n                    page_size, \n                    offset\n                )\n            else:\n                count_query = \"SELECT COUNT(*) FROM products\"\n                select_query = \"\"\"\n                    SELECT * FROM products \n                    ORDER BY created_at DESC\n                    LIMIT $1 OFFSET $2\n                \"\"\"\n                \n                total = await connection.fetchval(count_query)\n                records = await connection.fetch(select_query, page_size, offset)\n            \n            # Convert records to Product models\n            products = [record_to_product(record) for record in records]\n            \n            # Calculate total pages\n            total_pages = (total + page_size - 1) // page_size\n            \n            return ProductListResponse(\n                products=products,\n                total=total,\n                page=page,\n                page_size=page_size,\n                total_pages=total_pages\n            )\n            \n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n@app.get(\n    \"/products/{product_id}\",\n    response_model=Product,\n    tags=[\"Products\"],\n    summary=\"Get a single product by ID\"\n)\nasync def get_product(product_id: int):\n    \"\"\"\n    Retrieve a specific product by its ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            record = await connection.fetchrow(\n                \"SELECT * FROM products WHERE id = $1\",\n                product_id\n            )\n            \n            if not record:\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=f\"Product with id {product_id} not found\"\n                )\n            \n            return record_to_product(record)\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n@app.post(\n    \"/products\",\n    response_model=Product,\n    status_code=status.HTTP_201_CREATED,\n    tags=[\"Products\"],\n    summary=\"Create a new product\"\n)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional, max 1000 characters)\n    - **price**: Product price (required, must be greater than 0)\n    - **stock**: Stock quantity (required, must be non-negative)\n    \"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            # Check if product with same name already exists\n            existing = await connection.fetchval(\n                \"SELECT id FROM products WHERE name = $1\",\n                product.name\n            )\n            \n            if existing:\n                raise HTTPException(\n                    status_code=status.HTTP_409_CONFLICT,\n                    detail=f\"Product with name '{product.name}' already exists\"\n                )\n            \n            # Insert new product\n            record = await connection.fetchrow(\n                \"\"\"\n                INSERT INTO products (name, description, price, stock)\n                VALUES ($1, $2, $3, $4)\n                RETURNING *\n                \"\"\",\n                product.name,\n                product.description,\n                product.price,\n                product.stock\n            )\n            \n            return record_to_product(record)\n            \n    except HTTPException:\n        raise\n    except asyncpg.exceptions.CheckViolationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Validation error: {str(e)}\"\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n# ============================================================================\n# Additional Endpoints (Bonus)\n# ============================================================================\n\n@app.put(\n    \"/products/{product_id}\",\n    response_model=Product,\n    tags=[\"Products\"],\n    summary=\"Update an existing product\"\n)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"Update an existing product by ID\"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            # Check if product exists\n            exists = await connection.fetchval(\n                \"SELECT id FROM products WHERE id = $1\",\n                product_id\n            )\n            \n            if not exists:\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=f\"Product with id {product_id} not found\"\n                )\n            \n            # Update product\n            record = await connection.fetchrow(\n                \"\"\"\n                UPDATE products \n                SET name = $1, description = $2, price = $3, stock = $4\n                WHERE id = $5\n                RETURNING *\n                \"\"\",\n                product.name,\n                product.description,\n                product.price,\n                product.stock,\n                product_id\n            )\n            \n            return record_to_product(record)\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n@app.delete(\n    \"/products/{product_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    tags=[\"Products\"],\n    summary=\"Delete a product\"\n)\nasync def delete_product(product_id: int):\n    \"\"\"Delete a product by ID\"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            result = await connection.execute(\n                \"DELETE FROM products WHERE id = $1\",\n                product_id\n            )\n            \n            # Check if any row was deleted\n            if result == \"DELETE 0\":\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=f\"Product with id {product_id} not found\"\n                )\n            \n            return None\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n# ============================================================================\n# Run Application\n# ============================================================================\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True,\n        log_level=\"info\"\n    )\n```\n\n## Requirements File (`requirements.txt`)\n\n```txt\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\nasyncpg==0.29.0\npydantic==2.5.0\npython-dotenv==1.0.0\n```\n\n## Environment Configuration (`.env`)\n\n```env\nDATABASE_URL=postgresql://user:password@localhost:5432/products_db\n```\n\n## Docker Compose for PostgreSQL (`docker-compose.yml`)\n\n```yaml\nversion: '3.8'\n\nservices:\n  postgres:\n    image: postgres:16-alpine\n    container_name: products_db\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: products_db\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U user -d products_db\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\nvolumes:\n  postgres_data:\n```\n\n## Usage Examples\n\n### Start the database:\n```bash\ndocker-compose up -d\n```\n\n### Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n### Run the application:\n```bash\npython main.py\n# Or with uvicorn directly:\nuvicorn main:app --reload\n```\n\n### Test the API:\n\n```bash\n# Create a product\ncurl -X POST \"http://localhost:8000/products\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# List products with pagination\ncurl \"http://localhost:8000/products?page=1&page_size=10\"\n\n# Search products\ncurl \"http://localhost:8000/products?search=Laptop\"\n\n# Get single product\ncurl \"http://localhost:8000/products/1\"\n\n# Update product\ncurl -X PUT \"http://localhost:8000/products/1\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-end gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete product\ncurl -X DELETE \"http://localhost:8000/products/1\"\n```\n\n## Key Features\n\n\u2705 **Connection Pooling** - Efficient database connection management  \n\u2705 **Async/Await** - Full async support with asyncpg  \n\u2705 **Pagination** - Efficient data retrieval with offset/limit  \n\u2705 **Search** - Filter products by name  \n\u2705 **Validation** - Pydantic models with custom validators  \n\u2705 **Error Handling** - Comprehensive error responses  \n\u2705 **Auto Documentation** - Swagger UI at `/docs`  \n\u2705 **Type Safety** - Full type hints throughout  \n\u2705 **CRUD Operations** - Complete REST API implementation\n\nVisit `http://localhost:8000/docs` for interactive API documentation!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 4001,
            "cached": true
          },
          "with_skill": {
            "output": "I'll create a complete FastAPI application with asyncpg for PostgreSQL connectivity, including proper connection pooling and async patterns.\n\n```python\n# main.py\nfrom fastapi import FastAPI, HTTPException, Query\nfrom contextlib import asynccontextmanager\nfrom typing import Optional\nimport asyncpg\nfrom pydantic import BaseModel, Field\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Pydantic models for request/response validation\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n    created_at: str\n\n    class Config:\n        from_attributes = True\n\nclass ProductList(BaseModel):\n    products: list[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n# Global connection pool\npool: Optional[asyncpg.Pool] = None\n\n# Lifespan context manager for startup/shutdown\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup: Create connection pool\n    global pool\n    pool = await asyncpg.create_pool(\n        dsn=os.getenv(\"DATABASE_URL\"),\n        min_size=5,\n        max_size=20,\n        command_timeout=60,\n        max_queries=50000,\n        max_inactive_connection_lifetime=300,\n    )\n    print(\"\u2705 Database connection pool created\")\n    \n    yield\n    \n    # Shutdown: Close connection pool\n    if pool:\n        await pool.close()\n        print(\"\u2705 Database connection pool closed\")\n\n# Initialize FastAPI app with lifespan\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# Health check endpoint\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Check if the API and database are healthy\"\"\"\n    try:\n        async with pool.acquire() as conn:\n            await conn.fetchval(\"SELECT 1\")\n        return {\"status\": \"healthy\", \"database\": \"connected\"}\n    except Exception as e:\n        raise HTTPException(status_code=503, detail=f\"Database unhealthy: {str(e)}\")\n\n# GET /products - List products with pagination\n@app.get(\"/products\", response_model=ProductList)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: Optional[str] = Query(None, description=\"Search by product name\")\n):\n    \"\"\"\n    List all products with pagination and optional search.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term for product name\n    \"\"\"\n    offset = (page - 1) * page_size\n    \n    try:\n        async with pool.acquire() as conn:\n            # Build query with optional search\n            if search:\n                count_query = \"\"\"\n                    SELECT COUNT(*) FROM products \n                    WHERE name ILIKE $1\n                \"\"\"\n                products_query = \"\"\"\n                    SELECT id, name, description, price, stock, \n                           created_at::text as created_at\n                    FROM products\n                    WHERE name ILIKE $1\n                    ORDER BY created_at DESC\n                    LIMIT $2 OFFSET $3\n                \"\"\"\n                search_pattern = f\"%{search}%\"\n                total = await conn.fetchval(count_query, search_pattern)\n                rows = await conn.fetch(products_query, search_pattern, page_size, offset)\n            else:\n                count_query = \"SELECT COUNT(*) FROM products\"\n                products_query = \"\"\"\n                    SELECT id, name, description, price, stock,\n                           created_at::text as created_at\n                    FROM products\n                    ORDER BY created_at DESC\n                    LIMIT $1 OFFSET $2\n                \"\"\"\n                total = await conn.fetchval(count_query)\n                rows = await conn.fetch(products_query, page_size, offset)\n            \n            # Convert rows to Product models\n            products = [Product(**dict(row)) for row in rows]\n            \n            total_pages = (total + page_size - 1) // page_size\n            \n            return ProductList(\n                products=products,\n                total=total,\n                page=page,\n                page_size=page_size,\n                total_pages=total_pages\n            )\n    \n    except asyncpg.PostgresError as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n# GET /products/{id} - Get single product\n@app.get(\"/products/{product_id}\", response_model=Product)\nasync def get_product(product_id: int):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    try:\n        async with pool.acquire() as conn:\n            row = await conn.fetchrow(\n                \"\"\"\n                SELECT id, name, description, price, stock,\n                       created_at::text as created_at\n                FROM products\n                WHERE id = $1\n                \"\"\",\n                product_id\n            )\n            \n            if not row:\n                raise HTTPException(\n                    status_code=404,\n                    detail=f\"Product with id {product_id} not found\"\n                )\n            \n            return Product(**dict(row))\n    \n    except asyncpg.PostgresError as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n# POST /products - Create new product\n@app.post(\"/products\", response_model=Product, status_code=201)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **stock**: Stock quantity (required, must be non-negative)\n    \"\"\"\n    try:\n        async with pool.acquire() as conn:\n            # Use RETURNING to get the created product\n            row = await conn.fetchrow(\n                \"\"\"\n                INSERT INTO products (name, description, price, stock)\n                VALUES ($1, $2, $3, $4)\n                RETURNING id, name, description, price, stock,\n                          created_at::text as created_at\n                \"\"\",\n                product.name,\n                product.description,\n                product.price,\n                product.stock\n            )\n            \n            return Product(**dict(row))\n    \n    except asyncpg.UniqueViolationError:\n        raise HTTPException(\n            status_code=409,\n            detail=f\"Product with name '{product.name}' already exists\"\n        )\n    except asyncpg.PostgresError as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n# Error handler for validation errors\n@app.exception_handler(422)\nasync def validation_exception_handler(request, exc):\n    return {\n        \"detail\": \"Validation error\",\n        \"errors\": exc.errors()\n    }\n```\n\n```python\n# schema.sql\n-- Database schema for the products table\n\nCREATE TABLE IF NOT EXISTS products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL UNIQUE,\n    description TEXT,\n    price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n    stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Index for faster name searches\nCREATE INDEX IF NOT EXISTS idx_products_name ON products(name);\n\n-- Index for sorting by creation date\nCREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at DESC);\n\n-- Trigger to automatically update updated_at\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$$ language 'plpgsql';\n\nCREATE TRIGGER update_products_updated_at \n    BEFORE UPDATE ON products \n    FOR EACH ROW \n    EXECUTE FUNCTION update_updated_at_column();\n```\n\n```python\n# requirements.txt\nfastapi==0.109.0\nuvicorn[standard]==0.27.0\nasyncpg==0.29.0\npydantic==2.5.3\npython-dotenv==1.0.0\n```\n\n```bash\n# .env.example\nDATABASE_URL=postgresql://user:password@localhost:5432/products_db\n```\n\n```python\n# test_api.py\n# Example test file using pytest and httpx\nimport pytest\nfrom httpx import AsyncClient\nfrom main import app\nimport asyncpg\nimport os\n\n@pytest.fixture\nasync def client():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        yield ac\n\n@pytest.mark.asyncio\nasync def test_create_product(client):\n    response = await client.post(\n        \"/products\",\n        json={\n            \"name\": \"Test Product\",\n            \"description\": \"A test product\",\n            \"price\": 29.99,\n            \"stock\": 100\n        }\n    )\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"name\"] == \"Test Product\"\n    assert data[\"price\"] == 29.99\n    assert \"id\" in data\n\n@pytest.mark.asyncio\nasync def test_list_products(client):\n    response = await client.get(\"/products?page=1&page_size=10\")\n    assert response.status_code == 200\n    data = response.json()\n    assert \"products\" in data\n    assert \"total\" in data\n    assert \"page\" in data\n\n@pytest.mark.asyncio\nasync def test_get_product_not_found(client):\n    response = await client.get(\"/products/99999\")\n    assert response.status_code == 404\n```\n\n```python\n# seed_data.py\n# Script to seed the database with sample data\nimport asyncio\nimport asyncpg\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nasync def seed_database():\n    conn = await asyncpg.connect(os.getenv(\"DATABASE_URL\"))\n    \n    try:\n        # Create table\n        with open(\"schema.sql\", \"r\") as f:\n            schema = f.read()\n            await conn.execute(schema)\n        \n        # Insert sample products\n        products = [\n            (\"Laptop\", \"High-performance laptop\", 1299.99, 50),\n            (\"Mouse\", \"Wireless optical mouse\", 29.99, 200),\n            (\"Keyboard\", \"Mechanical gaming keyboard\", 149.99, 75),\n            (\"Monitor\", \"27-inch 4K display\", 499.99, 30),\n            (\"Headphones\", \"Noise-cancelling headphones\", 299.99, 100),\n        ]\n        \n        for name, desc, price, stock in products:\n            await conn.execute(\n                \"\"\"\n                INSERT INTO products (name, description, price, stock)\n                VALUES ($1, $2, $3, $4)\n                ON CONFLICT (name) DO NOTHING\n                \"\"\",\n                name, desc, price, stock\n            )\n        \n        print(\"\u2705 Database seeded successfully\")\n    \n    finally:\n        await conn.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(seed_database())\n```\n\n```bash\n# run.sh\n#!/bin/bash\n\n# Setup script to run the application\n\n# Install dependencies\npip install -r requirements.txt\n\n# Create .env file if it doesn't exist\nif [ ! -f .env ]; then\n    cp .env.example .env\n    echo \"\u26a0\ufe0f  Please update .env with your database credentials\"\n    exit 1\nfi\n\n# Seed the database\npython seed_data.py\n\n# Run the application\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n```\n\n## Key Features Implemented:\n\n1. **Connection Pooling**: Uses `asyncpg.create_pool()` with configurable min/max connections\n2. **Lifespan Management**: Proper startup/shutdown with `@asynccontextmanager`\n3. **Async/Await Patterns**: All database operations use `async with pool.acquire()`\n4. **Pagination**: Efficient LIMIT/OFFSET with total count\n5. **Search Functionality**: Optional ILIKE search on product names\n6. **Error Handling**: Proper HTTP status codes and PostgreSQL error handling\n7. **Input Validation**: Pydantic models with constraints\n8. **Type Safety**: Full type hints throughout\n9. **Database Indexes**: Optimized queries with appropriate indexes\n10. **Health Check**: Endpoint to verify database connectivity\n\n## Usage:\n\n```bash\n# Setup\nchmod +x run.sh\n./run.sh\n\n# Or manually:\npip install -r requirements.txt\npython seed_data.py\nuvicorn main:app --reload\n\n# API will be available at http://localhost:8000\n# Interactive docs at http://localhost:8000/docs\n```\n\n## Example API Calls:\n\n```bash\n# List products\ncurl http://localhost:8000/products?page=1&page_size=10\n\n# Search products\ncurl http://localhost:8000/products?search=laptop\n\n# Get single product\ncurl http://localhost:8000/products/1\n\n# Create product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"New Product\",\n    \"description\": \"Description here\",\n    \"price\": 99.99,\n    \"stock\": 50\n  }'\n```\n\nThis implementation follows FastAPI best practices with proper async patterns, connection pooling, and production-ready error handling!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24674,
            "output_tokens": 3530,
            "cached": true
          },
          "skill_md_only": {
            "output": "# FastAPI + Neon PostgreSQL with asyncpg\n\nHere's a complete implementation of a FastAPI REST API for a products table using asyncpg with Neon:\n\n## Complete Implementation\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List\nfrom contextlib import asynccontextmanager\nimport asyncpg\nimport os\n\n# Pydantic models\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n\nclass ProductList(BaseModel):\n    products: List[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n# Database connection pool\npool: Optional[asyncpg.Pool] = None\n\nasync def get_pool() -> asyncpg.Pool:\n    \"\"\"Get the database connection pool.\"\"\"\n    if pool is None:\n        raise RuntimeError(\"Database pool not initialized\")\n    return pool\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage database connection pool lifecycle.\"\"\"\n    global pool\n    \n    # Get connection string from environment\n    database_url = os.getenv(\"DATABASE_URL\")\n    if not database_url:\n        raise ValueError(\"DATABASE_URL environment variable not set\")\n    \n    # Create connection pool\n    pool = await asyncpg.create_pool(\n        database_url,\n        min_size=2,\n        max_size=10,\n        command_timeout=60,\n        # For Neon, you may want to adjust these timeouts\n        timeout=30,\n        max_inactive_connection_lifetime=300\n    )\n    \n    # Initialize database schema\n    async with pool.acquire() as conn:\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create index for better query performance\n        await conn.execute(\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_products_name \n            ON products(name)\n        \"\"\")\n    \n    yield\n    \n    # Close pool on shutdown\n    await pool.close()\n\n# Initialize FastAPI app\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"ok\", \"message\": \"Products API is running\"}\n\n@app.get(\"/products\", response_model=ProductList)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\")\n):\n    \"\"\"\n    List all products with pagination.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    pool = await get_pool()\n    offset = (page - 1) * page_size\n    \n    async with pool.acquire() as conn:\n        # Get total count\n        total = await conn.fetchval(\"SELECT COUNT(*) FROM products\")\n        \n        # Get paginated products\n        rows = await conn.fetch(\"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            ORDER BY id\n            LIMIT $1 OFFSET $2\n        \"\"\", page_size, offset)\n        \n        products = [\n            Product(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=float(row['price']),\n                stock=row['stock']\n            )\n            for row in rows\n        ]\n        \n        total_pages = (total + page_size - 1) // page_size\n        \n        return ProductList(\n            products=products,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=total_pages\n        )\n\n@app.get(\"/products/{product_id}\", response_model=Product)\nasync def get_product(product_id: int):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    pool = await get_pool()\n    \n    async with pool.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            WHERE id = $1\n        \"\"\", product_id)\n        \n        if row is None:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=float(row['price']),\n            stock=row['stock']\n        )\n\n@app.post(\"/products\", response_model=Product, status_code=201)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **stock**: Stock quantity (required, must be non-negative)\n    \"\"\"\n    pool = await get_pool()\n    \n    async with pool.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            INSERT INTO products (name, description, price, stock)\n            VALUES ($1, $2, $3, $4)\n            RETURNING id, name, description, price, stock\n        \"\"\", product.name, product.description, product.price, product.stock)\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=float(row['price']),\n            stock=row['stock']\n        )\n\n@app.put(\"/products/{product_id}\", response_model=Product)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"\n    Update an existing product.\n    \n    - **product_id**: The ID of the product to update\n    - **name**: Updated product name\n    - **description**: Updated product description\n    - **price**: Updated product price\n    - **stock**: Updated stock quantity\n    \"\"\"\n    pool = await get_pool()\n    \n    async with pool.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            UPDATE products\n            SET name = $2, description = $3, price = $4, stock = $5,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = $1\n            RETURNING id, name, description, price, stock\n        \"\"\", product_id, product.name, product.description, product.price, product.stock)\n        \n        if row is None:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=float(row['price']),\n            stock=row['stock']\n        )\n\n@app.delete(\"/products/{product_id}\", status_code=204)\nasync def delete_product(product_id: int):\n    \"\"\"\n    Delete a product by ID.\n    \n    - **product_id**: The ID of the product to delete\n    \"\"\"\n    pool = await get_pool()\n    \n    async with pool.acquire() as conn:\n        result = await conn.execute(\"\"\"\n            DELETE FROM products WHERE id = $1\n        \"\"\", product_id)\n        \n        if result == \"DELETE 0\":\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return None\n```\n\n## Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nfastapi==0.109.0\nuvicorn[standard]==0.27.0\nasyncpg==0.29.0\npydantic==2.5.3\npython-dotenv==1.0.0\n```\n\n## Environment Setup\n\nCreate a `.env` file with your Neon connection string:\n\n```bash\n# Get your connection string from Neon Console\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n## Running the Application\n\n```bash\n# Install dependencies\npip install -r requirements.txt\n\n# Run the server\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n```\n\n## Testing the API\n\n```bash\n# Health check\ncurl http://localhost:8000/\n\n# Create a product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# List products (with pagination)\ncurl http://localhost:8000/products?page=1&page_size=10\n\n# Get a specific product\ncurl http://localhost:8000/products/1\n\n# Update a product\ncurl -X PUT http://localhost:8000/products/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-performance gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete a product\ncurl -X DELETE http://localhost:8000/products/1\n```\n\n## Key Features\n\n### 1. **Connection Pooling**\n- Pool initialized in `lifespan` context manager\n- Min 2, max 10 connections\n- Automatic connection management\n- Proper cleanup on shutdown\n\n### 2. **Async/Await Patterns**\n- All database operations use `async`/`await`\n- Connection acquired from pool for each request\n- Non-blocking I/O for better performance\n\n### 3. **Pagination**\n- Query parameters for `page` and `page_size`\n- Returns total count and page metadata\n- Efficient LIMIT/OFFSET queries\n\n### 4. **Error Handling**\n- 404 for missing resources\n- Validation via Pydantic models\n- Proper HTTP status codes\n\n### 5. **Database Schema**\n- Auto-creates table on startup\n- Constraints for data integrity\n- Indexes for performance\n- Timestamps for audit trail\n\n## Neon-Specific Optimizations\n\nFor Neon, consider these adjustments:\n\n```python\n# Optimized pool settings for Neon\npool = await asyncpg.create_pool(\n    database_url,\n    min_size=1,  # Lower min for scale-to-zero\n    max_size=5,  # Adjust based on your plan\n    command_timeout=60,\n    timeout=30,\n    max_inactive_connection_lifetime=300,\n    # Enable statement cache\n    statement_cache_size=100\n)\n```\n\n## Production Considerations\n\n1. **Environment Variables**: Use proper secrets management\n2. **Logging**: Add structured logging for debugging\n3. **Monitoring**: Track connection pool metrics\n4. **Rate Limiting**: Add rate limiting middleware\n5. **CORS**: Configure CORS for frontend access\n6. **Authentication**: Add JWT or API key authentication\n7. **Database Migrations**: Use Alembic for schema changes\n\nThis implementation provides a solid foundation for a production-ready FastAPI application with Neon PostgreSQL!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2226,
            "output_tokens": 2994,
            "cached": true
          },
          "realistic": {
            "output": "I'll help you create a complete FastAPI endpoint for products with PostgreSQL using asyncpg. Let me set this up following the existing project patterns.\n\nFirst, let me check the current database configuration:\n\n```python\n# src/database.py\n\"\"\"Database configuration and session management.\"\"\"\nimport os\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker\nfrom sqlalchemy.orm import declarative_base\n\n# Use asyncpg driver for PostgreSQL\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"postgresql+asyncpg://user:password@localhost/dbname\")\n\n# Create async engine with connection pooling\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=True,  # Log SQL queries in development\n    pool_size=10,  # Connection pool size\n    max_overflow=20,  # Additional connections beyond pool_size\n    pool_pre_ping=True,  # Verify connections before using\n    pool_recycle=3600,  # Recycle connections after 1 hour\n)\n\n# Session factory\nasync_session_maker = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\nBase = declarative_base()\n\n\nasync def get_db() -> AsyncSession:\n    \"\"\"Dependency for getting database sessions.\"\"\"\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n```\n\nNow, let's create the Product model:\n\n```python\n# src/models/product.py\n\"\"\"Product database model.\"\"\"\nfrom sqlalchemy import Column, Integer, String, Numeric, Text, DateTime\nfrom sqlalchemy.sql import func\nfrom src.database import Base\n\n\nclass Product(Base):\n    __tablename__ = \"products\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(255), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    price = Column(Numeric(10, 2), nullable=False)\n    sku = Column(String(100), unique=True, nullable=False, index=True)\n    stock_quantity = Column(Integer, default=0, nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)\n\n    def __repr__(self):\n        return f\"<Product(id={self.id}, name='{self.name}', sku='{self.sku}')>\"\n```\n\nUpdate the models __init__.py:\n\n```python\n# src/models/__init__.py\n\"\"\"Database models.\"\"\"\nfrom src.database import Base\nfrom src.models.product import Product\n\n__all__ = [\"Base\", \"Product\"]\n```\n\nCreate Pydantic schemas for request/response validation:\n\n```python\n# src/schemas/product.py\n\"\"\"Pydantic schemas for Product API.\"\"\"\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom pydantic import BaseModel, Field, ConfigDict\n\n\nclass ProductBase(BaseModel):\n    \"\"\"Base product schema with common fields.\"\"\"\n    name: str = Field(..., min_length=1, max_length=255, description=\"Product name\")\n    description: str | None = Field(None, description=\"Product description\")\n    price: Decimal = Field(..., gt=0, decimal_places=2, description=\"Product price\")\n    sku: str = Field(..., min_length=1, max_length=100, description=\"Stock keeping unit\")\n    stock_quantity: int = Field(default=0, ge=0, description=\"Available stock quantity\")\n\n\nclass ProductCreate(ProductBase):\n    \"\"\"Schema for creating a new product.\"\"\"\n    pass\n\n\nclass ProductResponse(ProductBase):\n    \"\"\"Schema for product responses.\"\"\"\n    id: int\n    created_at: datetime\n    updated_at: datetime | None\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass ProductListResponse(BaseModel):\n    \"\"\"Schema for paginated product list.\"\"\"\n    items: list[ProductResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\nCreate the product service:\n\n```python\n# src/services/product_service.py\n\"\"\"Product service with business logic.\"\"\"\nimport logging\nfrom sqlalchemy import select, func\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.models.product import Product\nfrom src.schemas.product import ProductCreate\nfrom src.services.base import BaseService\n\nlogger = logging.getLogger(__name__)\n\n\nclass ProductService(BaseService[Product]):\n    \"\"\"Service for managing products.\"\"\"\n\n    async def get_products(\n        self,\n        page: int = 1,\n        page_size: int = 10,\n        search: str | None = None\n    ) -> tuple[list[Product], int]:\n        \"\"\"\n        Get paginated list of products with optional search.\n        \n        Args:\n            page: Page number (1-indexed)\n            page_size: Number of items per page\n            search: Optional search term for name/sku\n            \n        Returns:\n            Tuple of (products list, total count)\n        \"\"\"\n        # Build base query\n        query = select(Product)\n        \n        # Apply search filter if provided\n        if search:\n            search_filter = f\"%{search}%\"\n            query = query.where(\n                (Product.name.ilike(search_filter)) | \n                (Product.sku.ilike(search_filter))\n            )\n        \n        # Get total count\n        count_query = select(func.count()).select_from(query.subquery())\n        total_result = await self.session.execute(count_query)\n        total = total_result.scalar_one()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        query = query.offset(offset).limit(page_size).order_by(Product.created_at.desc())\n        \n        # Execute query\n        result = await self.session.execute(query)\n        products = result.scalars().all()\n        \n        logger.info(\n            \"Retrieved %d products (page %d, page_size %d, total %d)\",\n            len(products), page, page_size, total\n        )\n        \n        return list(products), total\n\n    async def get_product_by_id(self, product_id: int) -> Product | None:\n        \"\"\"Get a single product by ID.\"\"\"\n        return await self.get_by_id(Product, product_id)\n\n    async def create_product(self, product_data: ProductCreate) -> Product:\n        \"\"\"\n        Create a new product.\n        \n        Args:\n            product_data: Product creation data\n            \n        Returns:\n            Created product instance\n        \"\"\"\n        product = Product(**product_data.model_dump())\n        return await self.create(product)\n\n    async def get_product_by_sku(self, sku: str) -> Product | None:\n        \"\"\"Get a product by SKU.\"\"\"\n        query = select(Product).where(Product.sku == sku)\n        result = await self.session.execute(query)\n        return result.scalar_one_or_none()\n```\n\nCreate the API router:\n\n```python\n# src/routers/products.py\n\"\"\"Product API endpoints.\"\"\"\nimport logging\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.database import get_db\nfrom src.schemas.product import ProductCreate, ProductResponse, ProductListResponse\nfrom src.services.product_service import ProductService\n\nlogger = logging.getLogger(__name__)\nrouter = APIRouter(prefix=\"/products\", tags=[\"products\"])\n\n\ndef get_product_service(session: AsyncSession = Depends(get_db)) -> ProductService:\n    \"\"\"Dependency for getting product service.\"\"\"\n    return ProductService(session)\n\n\n@router.get(\"\", response_model=ProductListResponse)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: str | None = Query(None, description=\"Search by name or SKU\"),\n    service: ProductService = Depends(get_product_service),\n):\n    \"\"\"\n    Get paginated list of products.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term for filtering by name or SKU\n    \"\"\"\n    products, total = await service.get_products(page, page_size, search)\n    \n    total_pages = (total + page_size - 1) // page_size  # Ceiling division\n    \n    return ProductListResponse(\n        items=products,\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=total_pages,\n    )\n\n\n@router.get(\"/{product_id}\", response_model=ProductResponse)\nasync def get_product(\n    product_id: int,\n    service: ProductService = Depends(get_product_service),\n):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    product = await service.get_product_by_id(product_id)\n    \n    if not product:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {product_id} not found\"\n        )\n    \n    return product\n\n\n@router.post(\"\", response_model=ProductResponse, status_code=status.HTTP_201_CREATED)\nasync def create_product(\n    product_data: ProductCreate,\n    service: ProductService = Depends(get_product_service),\n):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **sku**: Stock keeping unit (required, must be unique)\n    - **stock_quantity**: Available stock (optional, defaults to 0)\n    \"\"\"\n    # Check if SKU already exists\n    existing = await service.get_product_by_sku(product_data.sku)\n    if existing:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Product with SKU '{product_data.sku}' already exists\"\n        )\n    \n    try:\n        product = await service.create_product(product_data)\n        logger.info(\"Created product: %s\", product)\n        return product\n    except Exception as e:\n        logger.error(\"Error creating product: %s\", e)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create product\"\n        )\n```\n\nUpdate main.py to include the router:\n\n```python\n# src/main.py\n\"\"\"FastAPI application entrypoint.\"\"\"\nimport logging\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom src.database import engine\nfrom src.models import Base\nfrom src.routers import products\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan events.\"\"\"\n    # Startup\n    logger.info(\"Starting application...\")\n    async with engine.begin() as conn:\n        # Create tables if they don't exist\n        await conn.run_sync(Base.metadata.create_all)\n    logger.info(\"Database tables created\")\n    \n    yield\n    \n    # Shutdown\n    logger.info(\"Shutting down application...\")\n    await engine.dispose()\n    logger.info(\"Database connections closed\")\n\n\napp = FastAPI(\n    title=\"Product API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan,\n)\n\n# Include routers\napp.include_router(products.router)\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"healthy\"}\n```\n\nUpdate pyproject.toml to include asyncpg:\n\n```toml\n# pyproject.toml\n[tool.poetry]\nname = \"product-api\"\nversion = \"0.1.0\"\ndescription = \"FastAPI product management API\"\nauthors = [\"Your Name <you@example.com>\"]\n\n[tool.poetry.dependencies]\npython = \"^3.12\"\nfastapi = \"^0.109.0\"\nuvicorn = {extras = [\"standard\"], version = \"^0.27.0\"}\nsqlalchemy = {extras = [\"asyncio\"], version = \"^2.0.25\"}\nasyncpg = \"^0.29.0\"\npydantic = \"^2.5.0\"\npydantic-settings = \"^2.1.0\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-asyncio = \"^0.21.0\"\nhttpx = \"^0.26.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n```\n\nCreate a .env.example file:\n\n```bash\n# .env.example\nDATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/products_db\n```\n\nFinally, create a test file:\n\n```python\n# tests/test_products.py\n\"\"\"Tests for product endpoints.\"\"\"\nimport pytest\nfrom httpx import AsyncClient\nfrom src.main import app\n\n\n@pytest.mark.asyncio\nasync def test_create_product():\n    \"\"\"Test creating a product.\"\"\"\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.post(\n            \"/products\",\n            json={\n                \"name\": \"Test Product\",\n                \"description\": \"A test product\",\n                \"price\": \"29.99\",\n                \"sku\": \"TEST-001\",\n                \"stock_quantity\": 100\n            }\n        )\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"name\"] == \"Test Product\"\n        assert data[\"sku\"] == \"TEST-001\"\n\n\n@pytest.mark.asyncio\nasync def test_list_products():\n    \"\"\"Test listing products with pagination.\"\"\"\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        response = await client.get(\"/products?page=1&page_size=10\")\n        assert response.status_code == 200\n        data = response.json()\n        assert \"items\" in data\n        assert \"total\" in data\n        assert \"page\" in data\n\n\n@pytest.mark.asyncio\nasync def test_get_product():\n    \"\"\"Test getting a single product.\"\"\"\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Create a product first\n        create_response = await client.post(\n            \"/products\",\n            json={\n                \"name\": \"Get Test\",\n                \"price\": \"19.99\",\n                \"sku\": \"GET-001\",\n            }\n        )\n        product_id = create_response.json()[\"id\"]\n        \n        # Get the product\n        response = await client.get(f\"/products/{product_id}\")\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"id\"] == product_id\n```\n\nTo run the application:\n\n```bash\n# Install dependencies\npoetry install\n\n# Set up your database URL\nexport DATABASE_URL=\"postgresql+asyncpg://user:password@localhost:5432/products_db\"\n\n# Run the application\npoetry run uvicorn src.main:app --reload --host 0.0.0.0 --port 8000\n\n# Run tests\npoetry run pytest\n```\n\nThis implementation includes:\n- \u2705 Async/await patterns throughout\n- \u2705 Connection pooling with asyncpg\n- \u2705 Proper dependency injection\n- \u2705 Pagination support\n- \u2705 Search functionality\n- \u2705 Request/response validation with Pydantic\n- \u2705 Error handling\n- \u2705 Logging\n- \u2705 Database session management\n- \u2705 API documentation (auto-generated at /docs)\n\nThe API will be available at `http://localhost:8000/products` with full OpenAPI documentation at `http://localhost:8000/docs`.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25200,
            "output_tokens": 4055,
            "cached": true
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-03",
      "task_type": "similar_syntax",
      "target_language": "javascript",
      "expected_patterns": [
        "require.*pg|import.*pg|Pool",
        "new Pool\\(",
        "pool\\.query|client\\.query",
        "pool\\.connect",
        "max:|connectionTimeoutMillis|idleTimeoutMillis",
        "SIGTERM|process\\.on"
      ],
      "anti_patterns": [
        "@neondatabase/serverless",
        "neon\\(",
        "import.*neon",
        "drizzle\\(",
        "neonConfig",
        "import asyncpg|from asyncpg"
      ],
      "pattern_sources": [
        {
          "url": "https://neon.com/docs/guides/node.md",
          "description": "Node.js with Neon: node-postgres (pg) usage including const { Pool } = require('pg'), new Pool() with config, pool.connect(), client.query(), client.release(), proper connection handling with try-finally"
        },
        {
          "url": "https://node-postgres.com/apis/pool",
          "description": "node-postgres Pool API: max pool size, connectionTimeoutMillis, idleTimeoutMillis configuration options"
        },
        {
          "url": "https://nodejs.org/api/process.html#process_signal_events",
          "description": "Node.js process signal events - source of process.on('SIGTERM') pattern for graceful shutdown handling"
        },
        {
          "url": "https://neon.com/docs/serverless/serverless-driver.md",
          "description": "Anti-patterns: Neon serverless driver (@neondatabase/serverless, neon(), neonConfig) that should not appear when using standard pg library"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# PostgreSQL Connection Pooling Middleware for Express.js\n\nHere's a comprehensive implementation of a PostgreSQL connection pooling middleware with health checks and graceful shutdown:\n\n```javascript\n// db-pool-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool middleware\n * @param {Object} config - Pool configuration options\n * @returns {Object} - Middleware function and pool instance\n */\nfunction createDbPoolMiddleware(config = {}) {\n  // Default configuration\n  const poolConfig = {\n    host: config.host || process.env.DB_HOST || 'localhost',\n    port: config.port || process.env.DB_PORT || 5432,\n    database: config.database || process.env.DB_NAME || 'mydb',\n    user: config.user || process.env.DB_USER || 'postgres',\n    password: config.password || process.env.DB_PASSWORD || '',\n    \n    // Pool configuration\n    max: config.max || 20, // Maximum number of clients in the pool\n    min: config.min || 4, // Minimum number of clients in the pool\n    idleTimeoutMillis: config.idleTimeoutMillis || 30000, // 30 seconds\n    connectionTimeoutMillis: config.connectionTimeoutMillis || 10000, // 10 seconds\n    \n    // Additional options\n    allowExitOnIdle: config.allowExitOnIdle || false,\n    statement_timeout: config.statementTimeout || 30000, // Query timeout\n  };\n\n  // Create the pool instance\n  const pool = new Pool(poolConfig);\n\n  // Pool event handlers\n  pool.on('connect', (client) => {\n    console.log('New client connected to the database pool');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n    // Don't exit the process, let the pool handle it\n  });\n\n  /**\n   * Middleware function to attach pool to request object\n   */\n  const middleware = (req, res, next) => {\n    req.db = pool;\n    \n    // Add helper method for executing queries\n    req.dbQuery = async (text, params) => {\n      const start = Date.now();\n      try {\n        const result = await pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: result.rowCount });\n        return result;\n      } catch (error) {\n        console.error('Database query error', { text, error: error.message });\n        throw error;\n      }\n    };\n\n    // Add helper method for transactions\n    req.dbTransaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    };\n\n    next();\n  };\n\n  /**\n   * Health check endpoint handler\n   */\n  const healthCheck = async (req, res) => {\n    const healthStatus = {\n      status: 'unknown',\n      timestamp: new Date().toISOString(),\n      pool: {\n        total: pool.totalCount,\n        idle: pool.idleCount,\n        waiting: pool.waitingCount,\n      },\n      database: {\n        connected: false,\n        responseTime: null,\n      },\n    };\n\n    try {\n      const start = Date.now();\n      \n      // Test database connection with a simple query\n      const result = await pool.query('SELECT NOW() as current_time, version() as version');\n      \n      const responseTime = Date.now() - start;\n      \n      healthStatus.status = 'healthy';\n      healthStatus.database.connected = true;\n      healthStatus.database.responseTime = `${responseTime}ms`;\n      healthStatus.database.serverTime = result.rows[0].current_time;\n      healthStatus.database.version = result.rows[0].version.split(',')[0]; // Shortened version\n\n      res.status(200).json(healthStatus);\n    } catch (error) {\n      healthStatus.status = 'unhealthy';\n      healthStatus.error = error.message;\n      \n      console.error('Database health check failed:', error);\n      res.status(503).json(healthStatus);\n    }\n  };\n\n  /**\n   * Graceful shutdown handler\n   */\n  const gracefulShutdown = async (signal) => {\n    console.log(`\\n${signal} received. Starting graceful shutdown...`);\n    \n    try {\n      // Stop accepting new connections\n      console.log('Closing database pool...');\n      \n      // Wait for active queries to complete (with timeout)\n      const shutdownTimeout = setTimeout(() => {\n        console.warn('Shutdown timeout reached, forcing pool closure');\n      }, 10000); // 10 second timeout\n\n      await pool.end();\n      \n      clearTimeout(shutdownTimeout);\n      console.log('Database pool closed successfully');\n      \n      process.exit(0);\n    } catch (error) {\n      console.error('Error during graceful shutdown:', error);\n      process.exit(1);\n    }\n  };\n\n  // Register shutdown handlers\n  process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n  process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n  // Handle uncaught exceptions\n  process.on('uncaughtException', (error) => {\n    console.error('Uncaught Exception:', error);\n    gracefulShutdown('uncaughtException');\n  });\n\n  return {\n    middleware,\n    healthCheck,\n    pool,\n    gracefulShutdown,\n  };\n}\n\nmodule.exports = createDbPoolMiddleware;\n```\n\n## Usage Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst createDbPoolMiddleware = require('./db-pool-middleware');\n\nconst app = express();\n\n// Create database pool middleware with custom configuration\nconst dbPool = createDbPoolMiddleware({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'dbuser',\n  password: 'dbpassword',\n  max: 25, // Maximum pool size\n  min: 5, // Minimum pool size\n  idleTimeoutMillis: 30000, // 30 seconds\n  connectionTimeoutMillis: 10000, // 10 seconds\n  statementTimeout: 30000, // 30 seconds query timeout\n});\n\n// Apply middleware globally\napp.use(dbPool.middleware);\n\n// Register health check endpoint\napp.get('/db/health', dbPool.healthCheck);\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.dbQuery('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Database error' });\n  }\n});\n\n// Example route using transactions\napp.post('/transfer', async (req, res) => {\n  try {\n    const { fromAccount, toAccount, amount } = req.body;\n    \n    const result = await req.dbTransaction(async (client) => {\n      // Deduct from source account\n      await client.query(\n        'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n        [amount, fromAccount]\n      );\n      \n      // Add to destination account\n      await client.query(\n        'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n        [amount, toAccount]\n      );\n      \n      return { success: true };\n    });\n    \n    res.json(result);\n  } catch (error) {\n    console.error('Transfer error:', error);\n    res.status(500).json({ error: 'Transaction failed' });\n  }\n});\n\n// Example route with direct pool access\napp.get('/stats', async (req, res) => {\n  const client = await req.db.connect();\n  \n  try {\n    const result = await client.query(`\n      SELECT \n        COUNT(*) as total_users,\n        COUNT(CASE WHEN created_at > NOW() - INTERVAL '24 hours' THEN 1 END) as new_users_today\n      FROM users\n    `);\n    \n    res.json(result.rows[0]);\n  } catch (error) {\n    console.error('Stats error:', error);\n    res.status(500).json({ error: 'Failed to fetch stats' });\n  } finally {\n    client.release(); // Always release the client back to the pool\n  }\n});\n\nconst PORT = process.env.PORT || 3000;\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n\n// Graceful shutdown for the HTTP server\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing HTTP server...');\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n});\n```\n\n## Advanced Usage with Environment Variables\n\n```javascript\n// config/database.js\nrequire('dotenv').config();\n\nmodule.exports = {\n  host: process.env.DB_HOST || 'localhost',\n  port: parseInt(process.env.DB_PORT || '5432'),\n  database: process.env.DB_NAME || 'myapp',\n  user: process.env.DB_USER || 'postgres',\n  password: process.env.DB_PASSWORD || '',\n  \n  // Pool settings\n  max: parseInt(process.env.DB_POOL_MAX || '20'),\n  min: parseInt(process.env.DB_POOL_MIN || '4'),\n  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000'),\n  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || '10000'),\n  statementTimeout: parseInt(process.env.DB_STATEMENT_TIMEOUT || '30000'),\n};\n\n// app.js\nconst express = require('express');\nconst createDbPoolMiddleware = require('./db-pool-middleware');\nconst dbConfig = require('./config/database');\n\nconst app = express();\nconst dbPool = createDbPoolMiddleware(dbConfig);\n\napp.use(dbPool.middleware);\napp.get('/db/health', dbPool.healthCheck);\n\n// ... rest of your routes\n```\n\n## .env Example\n\n```env\n# Database Configuration\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=dbuser\nDB_PASSWORD=secretpassword\n\n# Pool Configuration\nDB_POOL_MAX=25\nDB_POOL_MIN=5\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_STATEMENT_TIMEOUT=30000\n```\n\n## Testing the Health Check\n\n```bash\n# Check database health\ncurl http://localhost:3000/db/health\n\n# Expected response:\n{\n  \"status\": \"healthy\",\n  \"timestamp\": \"2024-01-15T10:30:00.000Z\",\n  \"pool\": {\n    \"total\": 5,\n    \"idle\": 4,\n    \"waiting\": 0\n  },\n  \"database\": {\n    \"connected\": true,\n    \"responseTime\": \"15ms\",\n    \"serverTime\": \"2024-01-15T10:30:00.000Z\",\n    \"version\": \"PostgreSQL 14.5\"\n  }\n}\n```\n\n## Key Features\n\n1. **Connection Pooling**: Efficient reuse of database connections\n2. **Health Checks**: Monitor database connectivity and pool status\n3. **Graceful Shutdown**: Properly closes connections on SIGTERM/SIGINT\n4. **Helper Methods**: Convenient `dbQuery` and `dbTransaction` methods\n5. **Error Handling**: Comprehensive error logging and handling\n6. **Configurable**: Flexible configuration for different environments\n7. **Transaction Support**: Built-in transaction helper with automatic rollback\n8. **Pool Monitoring**: Real-time pool statistics in health check\n\nThis implementation provides a production-ready database connection pooling solution for Express.js applications!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 92,
            "output_tokens": 3111,
            "cached": true
          },
          "with_skill": {
            "output": "# PostgreSQL Connection Pooling Middleware for Express.js\n\nHere's a production-ready middleware implementation with connection pooling, health checks, and graceful shutdown:\n\n```javascript\n// db-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured pg Pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection string from environment\n    connectionString: process.env.DATABASE_URL,\n    \n    // Pool configuration with sensible defaults\n    max: config.max || 20,                    // Maximum pool size\n    idleTimeoutMillis: config.idleTimeout || 30000,  // 30 seconds\n    connectionTimeoutMillis: config.connectionTimeout || 10000, // 10 seconds\n    \n    // Additional recommended settings\n    allowExitOnIdle: false,  // Keep pool alive\n    ...config\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Error handling for idle clients\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n  });\n\n  // Connection event logging (optional, useful for debugging)\n  pool.on('connect', (client) => {\n    console.log('New client connected to database');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  return pool;\n}\n\n/**\n * Express middleware that attaches database pool to request object\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express middleware function\n */\nfunction dbMiddleware(pool) {\n  return (req, res, next) => {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Helper method for executing queries\n    req.query = async (text, params) => {\n      const start = Date.now();\n      try {\n        const result = await pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: result.rowCount });\n        return result;\n      } catch (error) {\n        console.error('Query error', { text, error: error.message });\n        throw error;\n      }\n    };\n\n    // Helper method for transactions\n    req.transaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    };\n\n    next();\n  };\n}\n\n/**\n * Health check endpoint handler\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express route handler\n */\nfunction healthCheckHandler(pool) {\n  return async (req, res) => {\n    const healthcheck = {\n      uptime: process.uptime(),\n      timestamp: Date.now(),\n      status: 'ok',\n      database: {\n        connected: false,\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount\n      }\n    };\n\n    try {\n      // Test database connection\n      const start = Date.now();\n      const result = await pool.query('SELECT NOW() as now, version() as version');\n      const duration = Date.now() - start;\n\n      healthcheck.database.connected = true;\n      healthcheck.database.responseTime = duration;\n      healthcheck.database.serverTime = result.rows[0].now;\n      healthcheck.database.version = result.rows[0].version;\n\n      res.status(200).json(healthcheck);\n    } catch (error) {\n      healthcheck.status = 'error';\n      healthcheck.database.error = error.message;\n      res.status(503).json(healthcheck);\n    }\n  };\n}\n\n/**\n * Graceful shutdown handler\n * @param {Pool} pool - PostgreSQL connection pool\n * @param {Object} server - HTTP server instance\n */\nfunction setupGracefulShutdown(pool, server) {\n  const shutdown = async (signal) => {\n    console.log(`\\n${signal} received. Starting graceful shutdown...`);\n\n    // Stop accepting new connections\n    server.close(async () => {\n      console.log('HTTP server closed');\n\n      try {\n        // Close all database connections\n        await pool.end();\n        console.log('Database pool closed');\n        process.exit(0);\n      } catch (error) {\n        console.error('Error during shutdown:', error);\n        process.exit(1);\n      }\n    });\n\n    // Force shutdown after timeout\n    setTimeout(() => {\n      console.error('Forced shutdown after timeout');\n      process.exit(1);\n    }, 30000); // 30 second timeout\n  };\n\n  // Handle shutdown signals\n  process.on('SIGTERM', () => shutdown('SIGTERM'));\n  process.on('SIGINT', () => shutdown('SIGINT'));\n}\n\nmodule.exports = {\n  createPool,\n  dbMiddleware,\n  healthCheckHandler,\n  setupGracefulShutdown\n};\n```\n\n## Usage Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst {\n  createPool,\n  dbMiddleware,\n  healthCheckHandler,\n  setupGracefulShutdown\n} = require('./db-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Create database pool with custom configuration\nconst pool = createPool({\n  max: 25,                    // Max 25 connections\n  idleTimeout: 60000,         // 60 seconds idle timeout\n  connectionTimeout: 15000    // 15 seconds connection timeout\n});\n\n// Apply database middleware to all routes\napp.use(dbMiddleware(pool));\n\n// Health check endpoint\napp.get('/db/health', healthCheckHandler(pool));\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT id, name, email FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Database query failed' });\n  }\n});\n\n// Example route using transactions\napp.post('/users', async (req, res) => {\n  try {\n    const { name, email } = req.body;\n    \n    const result = await req.transaction(async (client) => {\n      // Insert user\n      const userResult = await client.query(\n        'INSERT INTO users(name, email) VALUES($1, $2) RETURNING id',\n        [name, email]\n      );\n      \n      // Insert user profile\n      await client.query(\n        'INSERT INTO profiles(user_id, created_at) VALUES($1, NOW())',\n        [userResult.rows[0].id]\n      );\n      \n      return userResult.rows[0];\n    });\n\n    res.status(201).json(result);\n  } catch (error) {\n    console.error('Error creating user:', error);\n    res.status(500).json({ error: 'Failed to create user' });\n  }\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n\n// Setup graceful shutdown\nsetupGracefulShutdown(pool, server);\n```\n\n## Environment Variables\n\n```bash\n# .env\nDATABASE_URL=postgresql://username:password@localhost:5432/mydb\n\n# Or for Neon (with connection pooling enabled)\nDATABASE_URL=postgresql://username:password@ep-xxx-pooler.us-east-1.aws.neon.tech/neondb\n```\n\n## Advanced Usage with Neon\n\nFor Neon-specific optimizations:\n\n```javascript\n// neon-db-middleware.js\nconst { Pool } = require('pg');\n\nfunction createNeonPool(config = {}) {\n  const poolConfig = {\n    connectionString: process.env.DATABASE_URL,\n    \n    // Neon-optimized settings\n    max: 10,                      // Lower max for serverless\n    idleTimeoutMillis: 20000,     // Shorter idle timeout\n    connectionTimeoutMillis: 10000,\n    \n    // SSL configuration for Neon\n    ssl: {\n      rejectUnauthorized: false\n    },\n    \n    ...config\n  };\n\n  return new Pool(poolConfig);\n}\n\n// For Neon with connection pooling (add -pooler to hostname)\n// DATABASE_URL should already include -pooler suffix\n// Example: postgresql://user:pass@ep-xxx-pooler.us-east-1.aws.neon.tech/neondb\n\nmodule.exports = { createNeonPool };\n```\n\n## Testing the Health Check\n\n```bash\n# Check database health\ncurl http://localhost:3000/db/health\n\n# Expected response:\n{\n  \"uptime\": 123.456,\n  \"timestamp\": 1704067200000,\n  \"status\": \"ok\",\n  \"database\": {\n    \"connected\": true,\n    \"totalCount\": 2,\n    \"idleCount\": 2,\n    \"waitingCount\": 0,\n    \"responseTime\": 45,\n    \"serverTime\": \"2024-01-01T00:00:00.000Z\",\n    \"version\": \"PostgreSQL 16.0 on x86_64-pc-linux-gnu...\"\n  }\n}\n```\n\n## Key Features\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Helpers**: `req.query()` and `req.transaction()` for easy database access\n3. **Health Check**: Comprehensive endpoint showing pool stats and connection status\n4. **Graceful Shutdown**: Properly closes connections on SIGTERM/SIGINT\n5. **Error Handling**: Catches and logs pool errors\n6. **Query Logging**: Tracks query execution time and results\n7. **Transaction Support**: Built-in transaction helper with automatic rollback\n\nThis implementation follows Node.js best practices and is production-ready for use with Neon or any PostgreSQL database.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24682,
            "output_tokens": 2599,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Express.js PostgreSQL Connection Pooling Middleware\n\nHere's a complete implementation of an Express.js middleware with PostgreSQL connection pooling using `pg`:\n\n```javascript\n// db-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured pg Pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection settings\n    connectionString: process.env.DATABASE_URL,\n    \n    // Pool size configuration\n    max: config.max || parseInt(process.env.DB_POOL_MAX) || 20,\n    min: config.min || parseInt(process.env.DB_POOL_MIN) || 2,\n    \n    // Timeout configuration\n    idleTimeoutMillis: config.idleTimeoutMillis || \n                       parseInt(process.env.DB_IDLE_TIMEOUT) || 30000,\n    connectionTimeoutMillis: config.connectionTimeoutMillis || \n                            parseInt(process.env.DB_CONNECTION_TIMEOUT) || 10000,\n    \n    // Query timeout\n    query_timeout: config.queryTimeout || \n                   parseInt(process.env.DB_QUERY_TIMEOUT) || 30000,\n    \n    // Statement timeout (PostgreSQL-level)\n    statement_timeout: config.statementTimeout || \n                       parseInt(process.env.DB_STATEMENT_TIMEOUT) || 30000,\n    \n    // SSL configuration (important for Neon and other cloud providers)\n    ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false,\n    \n    // Application name for connection tracking\n    application_name: config.applicationName || \n                      process.env.APP_NAME || \n                      'express-app',\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Pool error handler - catches errors on idle clients\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n  });\n\n  // Pool connect event - useful for monitoring\n  pool.on('connect', (client) => {\n    console.log('New client connected to the pool');\n  });\n\n  // Pool acquire event - useful for monitoring\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  // Pool remove event - useful for monitoring\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  return pool;\n}\n\n/**\n * Express middleware that attaches the database pool to the request object\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express middleware function\n */\nfunction dbMiddleware(pool) {\n  return (req, res, next) => {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Add helper method for executing queries\n    req.query = async (text, params) => {\n      const start = Date.now();\n      try {\n        const result = await pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: result.rowCount });\n        return result;\n      } catch (error) {\n        console.error('Query error', { text, error: error.message });\n        throw error;\n      }\n    };\n    \n    // Add helper method for transactions\n    req.transaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    };\n    \n    next();\n  };\n}\n\n/**\n * Creates a health check endpoint handler\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express route handler\n */\nfunction createHealthCheckHandler(pool) {\n  return async (req, res) => {\n    const healthCheck = {\n      status: 'unknown',\n      timestamp: new Date().toISOString(),\n      database: {\n        connected: false,\n        latency: null,\n        pool: {\n          total: pool.totalCount,\n          idle: pool.idleCount,\n          waiting: pool.waitingCount,\n        },\n      },\n    };\n\n    try {\n      const start = Date.now();\n      \n      // Test connection with a simple query\n      const result = await pool.query('SELECT NOW() as current_time, version() as version');\n      \n      const latency = Date.now() - start;\n      \n      healthCheck.status = 'healthy';\n      healthCheck.database.connected = true;\n      healthCheck.database.latency = `${latency}ms`;\n      healthCheck.database.serverTime = result.rows[0].current_time;\n      healthCheck.database.version = result.rows[0].version;\n      \n      res.status(200).json(healthCheck);\n    } catch (error) {\n      healthCheck.status = 'unhealthy';\n      healthCheck.database.error = error.message;\n      \n      console.error('Health check failed:', error);\n      res.status(503).json(healthCheck);\n    }\n  };\n}\n\n/**\n * Sets up graceful shutdown handlers for the pool\n * @param {Pool} pool - PostgreSQL connection pool\n * @param {Object} server - HTTP server instance (optional)\n */\nfunction setupGracefulShutdown(pool, server = null) {\n  const shutdown = async (signal) => {\n    console.log(`\\n${signal} received. Starting graceful shutdown...`);\n    \n    try {\n      // Stop accepting new connections if server is provided\n      if (server) {\n        server.close(() => {\n          console.log('HTTP server closed');\n        });\n      }\n      \n      // Close the database pool\n      await pool.end();\n      console.log('Database pool closed');\n      \n      process.exit(0);\n    } catch (error) {\n      console.error('Error during shutdown:', error);\n      process.exit(1);\n    }\n  };\n\n  // Handle different shutdown signals\n  process.on('SIGTERM', () => shutdown('SIGTERM'));\n  process.on('SIGINT', () => shutdown('SIGINT'));\n  \n  // Handle uncaught errors\n  process.on('uncaughtException', (error) => {\n    console.error('Uncaught Exception:', error);\n    shutdown('UNCAUGHT_EXCEPTION');\n  });\n  \n  process.on('unhandledRejection', (reason, promise) => {\n    console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n    shutdown('UNHANDLED_REJECTION');\n  });\n}\n\nmodule.exports = {\n  createPool,\n  dbMiddleware,\n  createHealthCheckHandler,\n  setupGracefulShutdown,\n};\n```\n\n## Usage Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst {\n  createPool,\n  dbMiddleware,\n  createHealthCheckHandler,\n  setupGracefulShutdown,\n} = require('./db-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Create the database pool\nconst pool = createPool({\n  max: 20,                      // Maximum pool size\n  min: 2,                       // Minimum pool size\n  idleTimeoutMillis: 30000,     // 30 seconds\n  connectionTimeoutMillis: 10000, // 10 seconds\n  queryTimeout: 30000,          // 30 seconds\n  applicationName: 'my-express-app',\n});\n\n// Apply database middleware to all routes\napp.use(dbMiddleware(pool));\n\n// Health check endpoint\napp.get('/db/health', createHealthCheckHandler(pool));\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Failed to fetch users' });\n  }\n});\n\n// Example route using transactions\napp.post('/transfer', async (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  \n  try {\n    const result = await req.transaction(async (client) => {\n      // Debit from account\n      await client.query(\n        'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n        [amount, fromAccount]\n      );\n      \n      // Credit to account\n      await client.query(\n        'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n        [amount, toAccount]\n      );\n      \n      return { success: true };\n    });\n    \n    res.json(result);\n  } catch (error) {\n    console.error('Transfer failed:', error);\n    res.status(500).json({ error: 'Transfer failed' });\n  }\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n\n// Setup graceful shutdown\nsetupGracefulShutdown(pool, server);\n```\n\n## Environment Variables\n\nCreate a `.env` file:\n\n```bash\n# Database connection\nDATABASE_URL=postgresql://user:password@localhost:5432/mydb\n\n# Pool configuration\nDB_POOL_MAX=20\nDB_POOL_MIN=2\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_QUERY_TIMEOUT=30000\nDB_STATEMENT_TIMEOUT=30000\n\n# SSL (set to 'true' for cloud providers like Neon)\nDB_SSL=true\n\n# Application name\nAPP_NAME=my-express-app\n\n# Server\nPORT=3000\n```\n\n## Using with Neon\n\nFor Neon Serverless Postgres, update your configuration:\n\n```javascript\n// neon-config.js\nconst { createPool } = require('./db-middleware');\n\n// Neon connection string format\nconst pool = createPool({\n  connectionString: process.env.DATABASE_URL, // From Neon console\n  max: 10,  // Lower for serverless environments\n  min: 0,   // Allow scaling to zero\n  idleTimeoutMillis: 10000, // Shorter timeout for serverless\n  ssl: { rejectUnauthorized: false }, // Required for Neon\n});\n\nmodule.exports = pool;\n```\n\n## Advanced Features\n\n### Connection Pooling with Read Replicas\n\n```javascript\n// read-replica-pool.js\nconst { Pool } = require('pg');\n\nfunction createReadReplicaPool() {\n  const writePool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    max: 10,\n  });\n\n  const readPool = new Pool({\n    connectionString: process.env.DATABASE_READ_REPLICA_URL,\n    max: 20, // More connections for read operations\n  });\n\n  return {\n    write: writePool,\n    read: readPool,\n    \n    async query(text, params, { preferRead = false } = {}) {\n      const pool = preferRead ? readPool : writePool;\n      return pool.query(text, params);\n    },\n    \n    async end() {\n      await Promise.all([writePool.end(), readPool.end()]);\n    },\n  };\n}\n```\n\n### Monitoring Middleware\n\n```javascript\n// monitoring-middleware.js\nfunction createMonitoringMiddleware(pool) {\n  return (req, res, next) => {\n    const originalQuery = req.query;\n    \n    req.query = async (text, params) => {\n      const start = Date.now();\n      const queryId = Math.random().toString(36).substring(7);\n      \n      console.log(`[${queryId}] Query started:`, text);\n      \n      try {\n        const result = await originalQuery(text, params);\n        const duration = Date.now() - start;\n        \n        console.log(`[${queryId}] Query completed:`, {\n          duration: `${duration}ms`,\n          rows: result.rowCount,\n          poolStats: {\n            total: pool.totalCount,\n            idle: pool.idleCount,\n            waiting: pool.waitingCount,\n          },\n        });\n        \n        return result;\n      } catch (error) {\n        const duration = Date.now() - start;\n        console.error(`[${queryId}] Query failed:`, {\n          duration: `${duration}ms`,\n          error: error.message,\n        });\n        throw error;\n      }\n    };\n    \n    next();\n  };\n}\n```\n\n## Key Features\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Helpers**: `req.query()` and `req.transaction()` for easy database access\n3. **Health Check**: `/db/health` endpoint with connection testing and pool stats\n4. **Graceful Shutdown**: Handles SIGTERM, SIGINT, and uncaught errors\n5. **Comprehensive Configuration**: Pool size, timeouts, SSL, and monitoring\n6. **Error Handling**: Pool-level and query-level error handling\n7. **Transaction Support**: Built-in transaction helper with automatic rollback\n8. **Monitoring**: Query logging with duration and pool statistics\n\nThis implementation is production-ready and works seamlessly with Neon Serverless Postgres!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2234,
            "output_tokens": 3366,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive PostgreSQL connection pooling middleware for your Express.js application.\n\n```javascript\n// src/middleware/postgres.js\nimport pg from \"pg\";\n\nconst { Pool } = pg;\n\n// Configuration from environment variables with sensible defaults\nconst poolConfig = {\n  connectionString: process.env.DATABASE_URL,\n  max: parseInt(process.env.DB_POOL_MAX || \"20\", 10), // Maximum pool size\n  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || \"30000\", 10), // 30 seconds\n  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || \"10000\", 10), // 10 seconds\n  allowExitOnIdle: false, // Keep pool alive even when idle\n};\n\n// Create shared pool instance\nlet pool = null;\n\n/**\n * Initialize the PostgreSQL connection pool\n */\nexport function initializePool() {\n  if (pool) {\n    console.warn(\"Pool already initialized\");\n    return pool;\n  }\n\n  pool = new Pool(poolConfig);\n\n  // Log pool errors\n  pool.on(\"error\", (err, client) => {\n    console.error(\"Unexpected error on idle client\", err);\n  });\n\n  // Log pool connection events (optional, useful for debugging)\n  pool.on(\"connect\", (client) => {\n    console.log(\"New client connected to pool\");\n  });\n\n  pool.on(\"acquire\", (client) => {\n    console.log(\"Client acquired from pool\");\n  });\n\n  pool.on(\"remove\", (client) => {\n    console.log(\"Client removed from pool\");\n  });\n\n  console.log(\"PostgreSQL connection pool initialized\", {\n    max: poolConfig.max,\n    idleTimeout: poolConfig.idleTimeoutMillis,\n    connectionTimeout: poolConfig.connectionTimeoutMillis,\n  });\n\n  return pool;\n}\n\n/**\n * Middleware to attach database pool to request object\n */\nexport function attachPool(req, res, next) {\n  if (!pool) {\n    return res.status(503).json({\n      error: \"Database pool not initialized\",\n      message: \"Service temporarily unavailable\",\n    });\n  }\n\n  req.db = pool;\n  next();\n}\n\n/**\n * Health check endpoint handler\n */\nexport async function healthCheck(req, res) {\n  if (!pool) {\n    return res.status(503).json({\n      status: \"error\",\n      message: \"Database pool not initialized\",\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  const startTime = Date.now();\n  let client;\n\n  try {\n    // Attempt to acquire a client and run a simple query\n    client = await pool.connect();\n    const result = await client.query(\"SELECT NOW() as current_time, version() as pg_version\");\n    const responseTime = Date.now() - startTime;\n\n    // Get pool statistics\n    const poolStats = {\n      totalCount: pool.totalCount,\n      idleCount: pool.idleCount,\n      waitingCount: pool.waitingCount,\n    };\n\n    res.status(200).json({\n      status: \"healthy\",\n      database: \"postgresql\",\n      responseTime: `${responseTime}ms`,\n      timestamp: new Date().toISOString(),\n      connection: {\n        currentTime: result.rows[0].current_time,\n        version: result.rows[0].pg_version,\n      },\n      pool: poolStats,\n    });\n  } catch (err) {\n    const responseTime = Date.now() - startTime;\n    console.error(\"Database health check failed:\", err);\n\n    res.status(503).json({\n      status: \"unhealthy\",\n      database: \"postgresql\",\n      responseTime: `${responseTime}ms`,\n      timestamp: new Date().toISOString(),\n      error: err.message,\n    });\n  } finally {\n    // Always release the client back to the pool\n    if (client) {\n      client.release();\n    }\n  }\n}\n\n/**\n * Gracefully shut down the pool\n */\nexport async function closePool() {\n  if (!pool) {\n    console.log(\"No pool to close\");\n    return;\n  }\n\n  try {\n    console.log(\"Closing PostgreSQL connection pool...\");\n    await pool.end();\n    pool = null;\n    console.log(\"PostgreSQL connection pool closed successfully\");\n  } catch (err) {\n    console.error(\"Error closing pool:\", err);\n    throw err;\n  }\n}\n\n/**\n * Get the current pool instance (useful for direct queries outside middleware)\n */\nexport function getPool() {\n  if (!pool) {\n    throw new Error(\"Database pool not initialized. Call initializePool() first.\");\n  }\n  return pool;\n}\n\n/**\n * Setup graceful shutdown handlers\n */\nexport function setupGracefulShutdown() {\n  const shutdown = async (signal) => {\n    console.log(`\\n${signal} received. Starting graceful shutdown...`);\n\n    try {\n      await closePool();\n      console.log(\"Graceful shutdown completed\");\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error during graceful shutdown:\", err);\n      process.exit(1);\n    }\n  };\n\n  // Handle termination signals\n  process.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\n  process.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\n  // Handle uncaught errors\n  process.on(\"uncaughtException\", async (err) => {\n    console.error(\"Uncaught Exception:\", err);\n    await closePool();\n    process.exit(1);\n  });\n\n  process.on(\"unhandledRejection\", async (reason, promise) => {\n    console.error(\"Unhandled Rejection at:\", promise, \"reason:\", reason);\n    await closePool();\n    process.exit(1);\n  });\n}\n```\n\nNow let's create an example of how to integrate this into your Express app:\n\n```javascript\n// src/app.js (or wherever you initialize your Express app)\nimport express from \"express\";\nimport {\n  initializePool,\n  attachPool,\n  healthCheck,\n  setupGracefulShutdown,\n} from \"./middleware/postgres.js\";\n\nconst app = express();\n\n// Initialize the connection pool before starting the server\ninitializePool();\n\n// Setup graceful shutdown handlers\nsetupGracefulShutdown();\n\n// Middleware\napp.use(express.json());\n\n// Health check endpoint (no auth required)\napp.get(\"/db/health\", healthCheck);\n\n// Attach pool to all subsequent routes\napp.use(attachPool);\n\n// Example protected route using the pool\napp.get(\"/api/users\", async (req, res) => {\n  try {\n    const result = await req.db.query(\"SELECT id, email, created_at FROM users LIMIT 10\");\n    res.json({ users: result.rows });\n  } catch (err) {\n    console.error(\"Database query error:\", err);\n    res.status(500).json({ error: \"Database query failed\" });\n  }\n});\n\n// Example route with parameterized query (prevents SQL injection)\napp.get(\"/api/users/:id\", async (req, res) => {\n  try {\n    const result = await req.db.query(\n      \"SELECT id, email, created_at FROM users WHERE id = $1\",\n      [req.params.id]\n    );\n\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: \"User not found\" });\n    }\n\n    res.json({ user: result.rows[0] });\n  } catch (err) {\n    console.error(\"Database query error:\", err);\n    res.status(500).json({ error: \"Database query failed\" });\n  }\n});\n\nexport default app;\n```\n\nCreate an environment configuration file:\n\n```bash\n# .env.example\nDATABASE_URL=postgresql://username:password@localhost:5432/database_name\nDB_POOL_MAX=20\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nJWT_SECRET=your-secret-key\n```\n\nHere's a helper utility for transactions:\n\n```javascript\n// src/utils/db-transaction.js\nimport { getPool } from \"../middleware/postgres.js\";\n\n/**\n * Execute a function within a database transaction\n * @param {Function} callback - Async function that receives a client\n * @returns {Promise<any>} Result from the callback\n */\nexport async function withTransaction(callback) {\n  const pool = getPool();\n  const client = await pool.connect();\n\n  try {\n    await client.query(\"BEGIN\");\n    const result = await callback(client);\n    await client.query(\"COMMIT\");\n    return result;\n  } catch (err) {\n    await client.query(\"ROLLBACK\");\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n// Example usage:\n// import { withTransaction } from '../utils/db-transaction.js';\n//\n// app.post('/api/transfer', async (req, res) => {\n//   try {\n//     const result = await withTransaction(async (client) => {\n//       await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [100, 1]);\n//       await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [100, 2]);\n//       return { success: true };\n//     });\n//     res.json(result);\n//   } catch (err) {\n//     res.status(500).json({ error: err.message });\n//   }\n// });\n```\n\nAnd here's a test file:\n\n```javascript\n// src/middleware/__tests__/postgres.test.js\nimport { jest } from \"@jest/globals\";\nimport {\n  initializePool,\n  attachPool,\n  healthCheck,\n  closePool,\n  getPool,\n} from \"../postgres.js\";\n\ndescribe(\"PostgreSQL Middleware\", () => {\n  let mockPool;\n  let mockClient;\n\n  beforeEach(() => {\n    mockClient = {\n      query: jest.fn(),\n      release: jest.fn(),\n    };\n\n    mockPool = {\n      connect: jest.fn().mockResolvedValue(mockClient),\n      end: jest.fn().mockResolvedValue(undefined),\n      on: jest.fn(),\n      totalCount: 5,\n      idleCount: 3,\n      waitingCount: 0,\n    };\n  });\n\n  afterEach(async () => {\n    await closePool();\n    jest.clearAllMocks();\n  });\n\n  describe(\"attachPool\", () => {\n    it(\"should attach pool to request object\", () => {\n      const req = {};\n      const res = {};\n      const next = jest.fn();\n\n      initializePool();\n      attachPool(req, res, next);\n\n      expect(req.db).toBeDefined();\n      expect(next).toHaveBeenCalled();\n    });\n\n    it(\"should return 503 if pool not initialized\", () => {\n      const req = {};\n      const res = {\n        status: jest.fn().mockReturnThis(),\n        json: jest.fn(),\n      };\n      const next = jest.fn();\n\n      attachPool(req, res, next);\n\n      expect(res.status).toHaveBeenCalledWith(503);\n      expect(next).not.toHaveBeenCalled();\n    });\n  });\n\n  describe(\"healthCheck\", () => {\n    it(\"should return healthy status on successful connection\", async () => {\n      const req = {};\n      const res = {\n        status: jest.fn().mockReturnThis(),\n        json: jest.fn(),\n      };\n\n      mockClient.query.mockResolvedValue({\n        rows: [\n          {\n            current_time: new Date(),\n            pg_version: \"PostgreSQL 15.0\",\n          },\n        ],\n      });\n\n      await healthCheck(req, res);\n\n      expect(res.status).toHaveBeenCalledWith(200);\n      expect(res.json).toHaveBeenCalledWith(\n        expect.objectContaining({\n          status: \"healthy\",\n          database: \"postgresql\",\n        })\n      );\n      expect(mockClient.release).toHaveBeenCalled();\n    });\n  });\n});\n```\n\n**Key Features:**\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Attachment**: Pool available via `req.db`\n3. **Health Check**: `/db/health` endpoint with connection testing and pool stats\n4. **Graceful Shutdown**: Handles SIGTERM/SIGINT and closes pool cleanly\n5. **Configurable**: Max pool size, idle timeout, connection timeout via env vars\n6. **Error Handling**: Pool error events logged, health check catches failures\n7. **Transaction Support**: Helper utility for transactional operations\n8. **Security**: Parameterized queries prevent SQL injection\n\nThe middleware is production-ready with proper error handling, logging, and graceful shutdown support!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25148,
            "output_tokens": 3182,
            "cached": true
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# PostgreSQL Connection Pooling Middleware for Express.js\n\nHere's a comprehensive implementation of a PostgreSQL connection pooling middleware with health checks and graceful shutdown:\n\n```javascript\n// db-pool-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured PostgreSQL pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection settings\n    host: config.host || process.env.DB_HOST || 'localhost',\n    port: config.port || process.env.DB_PORT || 5432,\n    database: config.database || process.env.DB_NAME || 'mydb',\n    user: config.user || process.env.DB_USER || 'postgres',\n    password: config.password || process.env.DB_PASSWORD || '',\n    \n    // Pool settings\n    max: config.max || parseInt(process.env.DB_POOL_MAX) || 20, // Maximum pool size\n    min: config.min || parseInt(process.env.DB_POOL_MIN) || 2, // Minimum pool size\n    idleTimeoutMillis: config.idleTimeoutMillis || \n                       parseInt(process.env.DB_IDLE_TIMEOUT) || 30000, // 30 seconds\n    connectionTimeoutMillis: config.connectionTimeoutMillis || \n                            parseInt(process.env.DB_CONNECTION_TIMEOUT) || 10000, // 10 seconds\n    \n    // Additional settings\n    allowExitOnIdle: config.allowExitOnIdle || false,\n    statement_timeout: config.statementTimeout || 30000, // Query timeout\n    query_timeout: config.queryTimeout || 30000,\n    \n    // SSL configuration (optional)\n    ssl: config.ssl || (process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false),\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Event handlers for pool monitoring\n  pool.on('connect', (client) => {\n    console.log('New client connected to the pool');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n    // Don't exit the process, just log the error\n  });\n\n  return pool;\n}\n\n/**\n * Middleware factory that creates and attaches pool to request object\n * @param {Object} config - Pool configuration options\n * @returns {Function} Express middleware function\n */\nfunction createPoolMiddleware(config = {}) {\n  const pool = createPool(config);\n  \n  // Store pool instance for access outside middleware\n  createPoolMiddleware.pool = pool;\n\n  return function poolMiddleware(req, res, next) {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Add helper method for executing queries\n    req.query = async (text, params) => {\n      const start = Date.now();\n      try {\n        const result = await pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: result.rowCount });\n        return result;\n      } catch (error) {\n        console.error('Query error', { text, error: error.message });\n        throw error;\n      }\n    };\n\n    // Add helper method for transactions\n    req.transaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    };\n\n    next();\n  };\n}\n\n/**\n * Health check middleware for database connection\n * @param {Pool} pool - PostgreSQL pool instance\n * @returns {Function} Express route handler\n */\nfunction createHealthCheckHandler(pool) {\n  return async (req, res) => {\n    const healthCheck = {\n      status: 'unhealthy',\n      timestamp: new Date().toISOString(),\n      database: {\n        connected: false,\n        responseTime: null,\n        poolStats: null,\n      },\n    };\n\n    try {\n      const start = Date.now();\n      \n      // Test connection with a simple query\n      const result = await pool.query('SELECT NOW() as current_time, version() as version');\n      const responseTime = Date.now() - start;\n\n      // Get pool statistics\n      const poolStats = {\n        total: pool.totalCount,\n        idle: pool.idleCount,\n        waiting: pool.waitingCount,\n      };\n\n      healthCheck.status = 'healthy';\n      healthCheck.database.connected = true;\n      healthCheck.database.responseTime = `${responseTime}ms`;\n      healthCheck.database.poolStats = poolStats;\n      healthCheck.database.serverTime = result.rows[0].current_time;\n      healthCheck.database.version = result.rows[0].version.split(',')[0]; // Shortened version\n\n      res.status(200).json(healthCheck);\n    } catch (error) {\n      healthCheck.error = error.message;\n      healthCheck.database.error = error.message;\n      \n      console.error('Health check failed:', error);\n      res.status(503).json(healthCheck);\n    }\n  };\n}\n\n/**\n * Graceful shutdown handler for the pool\n * @param {Pool} pool - PostgreSQL pool instance\n * @param {Object} options - Shutdown options\n */\nasync function gracefulShutdown(pool, options = {}) {\n  const timeout = options.timeout || 10000; // 10 seconds default\n  \n  console.log('Initiating graceful shutdown of database pool...');\n  \n  try {\n    // Set a timeout for the shutdown process\n    const shutdownPromise = pool.end();\n    const timeoutPromise = new Promise((_, reject) => \n      setTimeout(() => reject(new Error('Shutdown timeout')), timeout)\n    );\n\n    await Promise.race([shutdownPromise, timeoutPromise]);\n    console.log('Database pool closed successfully');\n  } catch (error) {\n    console.error('Error during pool shutdown:', error);\n    // Force close if graceful shutdown fails\n    await pool.end();\n  }\n}\n\n/**\n * Setup signal handlers for graceful shutdown\n * @param {Pool} pool - PostgreSQL pool instance\n * @param {Object} options - Shutdown options\n */\nfunction setupGracefulShutdown(pool, options = {}) {\n  const signals = ['SIGTERM', 'SIGINT'];\n  \n  signals.forEach((signal) => {\n    process.on(signal, async () => {\n      console.log(`Received ${signal}, starting graceful shutdown...`);\n      \n      try {\n        await gracefulShutdown(pool, options);\n        process.exit(0);\n      } catch (error) {\n        console.error('Graceful shutdown failed:', error);\n        process.exit(1);\n      }\n    });\n  });\n\n  // Handle uncaught exceptions\n  process.on('uncaughtException', async (error) => {\n    console.error('Uncaught Exception:', error);\n    await gracefulShutdown(pool, { timeout: 5000 });\n    process.exit(1);\n  });\n\n  // Handle unhandled promise rejections\n  process.on('unhandledRejection', async (reason, promise) => {\n    console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n    await gracefulShutdown(pool, { timeout: 5000 });\n    process.exit(1);\n  });\n}\n\nmodule.exports = {\n  createPool,\n  createPoolMiddleware,\n  createHealthCheckHandler,\n  gracefulShutdown,\n  setupGracefulShutdown,\n};\n```\n\n```javascript\n// app.js - Example usage\nconst express = require('express');\nconst {\n  createPoolMiddleware,\n  createHealthCheckHandler,\n  setupGracefulShutdown,\n} = require('./db-pool-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Database configuration\nconst dbConfig = {\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  max: 20,                      // Maximum pool size\n  min: 2,                       // Minimum pool size\n  idleTimeoutMillis: 30000,     // 30 seconds\n  connectionTimeoutMillis: 10000, // 10 seconds\n};\n\n// Create and apply pool middleware\nconst poolMiddleware = createPoolMiddleware(dbConfig);\napp.use(poolMiddleware);\n\n// Setup health check endpoint\napp.get('/db/health', createHealthCheckHandler(poolMiddleware.pool));\n\n// Setup graceful shutdown\nsetupGracefulShutdown(poolMiddleware.pool, { timeout: 10000 });\n\n// Example routes using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/users/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const result = await req.query('SELECT * FROM users WHERE id = $1', [id]);\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(result.rows[0]);\n  } catch (error) {\n    console.error('Error fetching user:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Example transaction route\napp.post('/transfer', async (req, res) => {\n  try {\n    const { fromAccount, toAccount, amount } = req.body;\n    \n    const result = await req.transaction(async (client) => {\n      // Deduct from sender\n      await client.query(\n        'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n        [amount, fromAccount]\n      );\n      \n      // Add to receiver\n      await client.query(\n        'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n        [amount, toAccount]\n      );\n      \n      return { success: true };\n    });\n    \n    res.json(result);\n  } catch (error) {\n    console.error('Transaction error:', error);\n    res.status(500).json({ error: 'Transaction failed' });\n  }\n});\n\n// Pool statistics endpoint\napp.get('/db/stats', (req, res) => {\n  const pool = poolMiddleware.pool;\n  res.json({\n    totalConnections: pool.totalCount,\n    idleConnections: pool.idleCount,\n    waitingRequests: pool.waitingCount,\n  });\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n\n// Graceful server shutdown\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing HTTP server...');\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n});\n```\n\n```javascript\n// .env.example - Environment variables configuration\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=postgres\nDB_PASSWORD=your_password\nDB_POOL_MAX=20\nDB_POOL_MIN=2\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_SSL=false\nPORT=3000\n```\n\n```javascript\n// package.json\n{\n  \"name\": \"express-pg-pool-middleware\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Express.js middleware with PostgreSQL connection pooling\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\",\n    \"test\": \"jest\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.0\",\n    \"dotenv\": \"^16.0.3\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.22\"\n  }\n}\n```\n\n```javascript\n// advanced-usage.js - Advanced patterns and examples\nconst express = require('express');\nconst {\n  createPoolMiddleware,\n  createHealthCheckHandler,\n  setupGracefulShutdown,\n} = require('./db-pool-middleware');\n\nconst app = express();\n\n// Create pool middleware with advanced configuration\nconst poolMiddleware = createPoolMiddleware({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  max: 20,\n  min: 2,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 10000,\n  statementTimeout: 30000,\n  ssl: false,\n});\n\napp.use(express.json());\napp.use(poolMiddleware);\n\n// Health check with custom logic\napp.get('/db/health', createHealthCheckHandler(poolMiddleware.pool));\n\n// Advanced query with prepared statements\napp.get('/api/search', async (req, res) => {\n  try {\n    const { query, limit = 10, offset = 0 } = req.query;\n    \n    const result = await req.query(\n      `SELECT * FROM products \n       WHERE name ILIKE $1 \n       ORDER BY created_at DESC \n       LIMIT $2 OFFSET $3`,\n      [`%${query}%`, limit, offset]\n    );\n    \n    res.json({\n      data: result.rows,\n      count: result.rowCount,\n      limit: parseInt(limit),\n      offset: parseInt(offset),\n    });\n  } catch (error) {\n    console.error('Search error:', error);\n    res.status(500).json({ error: 'Search failed' });\n  }\n});\n\n// Batch operations with transaction\napp.post('/api/batch-insert', async (req, res) => {\n  try {\n    const { items } = req.body;\n    \n    const result = await req.transaction(async (client) => {\n      const insertedIds = [];\n      \n      for (const item of items) {\n        const result = await client.query(\n          'INSERT INTO items (name, description) VALUES ($1, $2) RETURNING id',\n          [item.name, item.description]\n        );\n        insertedIds.push(result.rows[0].id);\n      }\n      \n      return insertedIds;\n    });\n    \n    res.json({ success: true, ids: result });\n  } catch (error) {\n    console.error('Batch insert error:', error);\n    res.status(500).json({ error: 'Batch insert failed' });\n  }\n});\n\n// Connection pool monitoring\napp.get('/api/pool/monitor', (req, res) => {\n  const pool = poolMiddleware.pool;\n  \n  res.json({\n    timestamp: new Date().toISOString(),\n    pool: {\n      total: pool.totalCount,\n      idle: pool.idleCount,\n      waiting: pool.waitingCount,\n      maxSize: pool.options.max,\n      minSize: pool.options.min,\n    },\n    configuration: {\n      idleTimeout: pool.options.idleTimeoutMillis,\n      connectionTimeout: pool.options.connectionTimeoutMillis,\n    },\n  });\n});\n\nsetupGracefulShutdown(poolMiddleware.pool);\n\nconst server = app.listen(3000, () => {\n  console.log('Advanced server running on port 3",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 92,
            "output_tokens": 4096,
            "cached": true
          },
          "with_skill": {
            "output": "# PostgreSQL Connection Pooling Middleware for Express.js\n\nHere's a production-ready middleware implementation with connection pooling, health checks, and graceful shutdown:\n\n```javascript\n// db-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates a PostgreSQL connection pool middleware for Express.js\n * @param {Object} config - Pool configuration options\n * @returns {Object} Middleware function and pool instance\n */\nfunction createDbMiddleware(config = {}) {\n  // Default configuration with sensible defaults\n  const poolConfig = {\n    connectionString: process.env.DATABASE_URL,\n    max: config.max || 20, // Maximum pool size\n    idleTimeoutMillis: config.idleTimeoutMillis || 30000, // 30 seconds\n    connectionTimeoutMillis: config.connectionTimeoutMillis || 10000, // 10 seconds\n    allowExitOnIdle: config.allowExitOnIdle || false,\n    ...config,\n  };\n\n  // Create the shared pool instance\n  const pool = new Pool(poolConfig);\n\n  // Pool error handler - catches errors on idle clients\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n    // Don't exit the process - let the pool handle reconnection\n  });\n\n  // Pool connect event for monitoring\n  pool.on('connect', (client) => {\n    console.log('New client connected to database');\n  });\n\n  // Pool remove event for monitoring\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  /**\n   * Middleware function that attaches the pool to req.db\n   */\n  const middleware = (req, res, next) => {\n    req.db = pool;\n    next();\n  };\n\n  /**\n   * Health check endpoint handler\n   */\n  const healthCheck = async (req, res) => {\n    const startTime = Date.now();\n    \n    try {\n      // Test the connection with a simple query\n      const result = await pool.query('SELECT NOW() as current_time, version() as pg_version');\n      const responseTime = Date.now() - startTime;\n\n      // Get pool stats\n      const poolStats = {\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount,\n      };\n\n      res.status(200).json({\n        status: 'healthy',\n        database: 'connected',\n        responseTime: `${responseTime}ms`,\n        timestamp: result.rows[0].current_time,\n        postgresVersion: result.rows[0].pg_version.split(' ')[1],\n        pool: poolStats,\n      });\n    } catch (error) {\n      console.error('Database health check failed:', error);\n      \n      res.status(503).json({\n        status: 'unhealthy',\n        database: 'disconnected',\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      });\n    }\n  };\n\n  /**\n   * Graceful shutdown handler\n   */\n  const shutdown = async () => {\n    console.log('Shutting down database connection pool...');\n    \n    try {\n      // Wait for all clients to finish their work\n      await pool.end();\n      console.log('Database pool has been closed gracefully');\n    } catch (error) {\n      console.error('Error during pool shutdown:', error);\n      throw error;\n    }\n  };\n\n  // Register shutdown handlers\n  process.on('SIGTERM', async () => {\n    console.log('SIGTERM received');\n    try {\n      await shutdown();\n      process.exit(0);\n    } catch (error) {\n      console.error('Error during shutdown:', error);\n      process.exit(1);\n    }\n  });\n\n  process.on('SIGINT', async () => {\n    console.log('SIGINT received');\n    try {\n      await shutdown();\n      process.exit(0);\n    } catch (error) {\n      console.error('Error during shutdown:', error);\n      process.exit(1);\n    }\n  });\n\n  return {\n    middleware,\n    healthCheck,\n    pool,\n    shutdown,\n  };\n}\n\nmodule.exports = { createDbMiddleware };\n```\n\n```javascript\n// app.js - Example usage\nconst express = require('express');\nconst { createDbMiddleware } = require('./db-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Create the database middleware with custom configuration\nconst db = createDbMiddleware({\n  max: 25, // Maximum 25 connections in the pool\n  idleTimeoutMillis: 60000, // Close idle clients after 1 minute\n  connectionTimeoutMillis: 15000, // Fail after 15 seconds if can't connect\n});\n\n// Apply the middleware globally\napp.use(db.middleware);\n\n// Register the health check endpoint\napp.get('/db/health', db.healthCheck);\n\n// Example route using the database pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.db.query('SELECT id, name, email FROM users LIMIT 10');\n    res.json({\n      success: true,\n      count: result.rowCount,\n      users: result.rows,\n    });\n  } catch (error) {\n    console.error('Database query error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database query failed',\n    });\n  }\n});\n\n// Example route with parameterized query\napp.get('/users/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const result = await req.db.query(\n      'SELECT id, name, email, created_at FROM users WHERE id = $1',\n      [id]\n    );\n\n    if (result.rowCount === 0) {\n      return res.status(404).json({\n        success: false,\n        error: 'User not found',\n      });\n    }\n\n    res.json({\n      success: true,\n      user: result.rows[0],\n    });\n  } catch (error) {\n    console.error('Database query error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database query failed',\n    });\n  }\n});\n\n// Example route with transaction\napp.post('/users', async (req, res) => {\n  const client = await req.db.connect();\n  \n  try {\n    await client.query('BEGIN');\n    \n    const { name, email } = req.body;\n    \n    // Insert user\n    const userResult = await client.query(\n      'INSERT INTO users(name, email) VALUES($1, $2) RETURNING id, name, email',\n      [name, email]\n    );\n    \n    // Insert audit log\n    await client.query(\n      'INSERT INTO audit_log(action, user_id) VALUES($1, $2)',\n      ['user_created', userResult.rows[0].id]\n    );\n    \n    await client.query('COMMIT');\n    \n    res.status(201).json({\n      success: true,\n      user: userResult.rows[0],\n    });\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('Transaction error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to create user',\n    });\n  } finally {\n    client.release(); // Always release the client back to the pool\n  }\n});\n\n// Start the server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n\n// Graceful shutdown on server close\nserver.on('close', async () => {\n  console.log('Server closing, shutting down database pool...');\n  await db.shutdown();\n});\n```\n\n```javascript\n// .env.example\nDATABASE_URL=postgresql://username:password@localhost:5432/mydb\nPORT=3000\n```\n\n```javascript\n// package.json\n{\n  \"name\": \"express-pg-pooling\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Express.js with PostgreSQL connection pooling\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.3\",\n    \"dotenv\": \"^16.3.1\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.1\"\n  }\n}\n```\n\n## Key Features\n\n### 1. **Shared Pool Instance**\n- Single pool shared across all requests\n- Efficient connection reuse\n- Automatic connection management\n\n### 2. **Configuration Options**\n- `max`: Maximum pool size (default: 20)\n- `idleTimeoutMillis`: Close idle connections after timeout (default: 30s)\n- `connectionTimeoutMillis`: Fail if connection takes too long (default: 10s)\n\n### 3. **Health Check Endpoint**\n- Tests actual database connectivity\n- Returns pool statistics\n- Includes response time and PostgreSQL version\n\n### 4. **Graceful Shutdown**\n- Handles SIGTERM and SIGINT signals\n- Waits for active queries to complete\n- Closes all connections cleanly\n\n### 5. **Error Handling**\n- Pool-level error handler for idle clients\n- Query-level error handling in routes\n- Transaction rollback on errors\n\n### 6. **Transaction Support**\n- Acquire dedicated client with `req.db.connect()`\n- Always release client in `finally` block\n- Proper BEGIN/COMMIT/ROLLBACK handling\n\n## Usage Tips\n\n**For Neon Serverless Postgres:**\n- Use connection pooling (add `-pooler` to hostname)\n- Consider `@neondatabase/serverless` for edge environments\n- See connection methods guide for platform-specific recommendations\n\n**Production Considerations:**\n- Set `max` based on your database plan limits\n- Monitor pool stats via health endpoint\n- Use environment variables for configuration\n- Implement connection retry logic for resilience\n\nThis implementation provides a robust foundation for PostgreSQL connection pooling in Express.js applications with proper resource management and monitoring capabilities.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24682,
            "output_tokens": 2567,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Express.js PostgreSQL Connection Pooling Middleware\n\nHere's a complete implementation of a connection pooling middleware for Express.js using the `pg` library:\n\n```javascript\n// db-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured pg Pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection string (supports Neon connection strings)\n    connectionString: config.connectionString || process.env.DATABASE_URL,\n    \n    // Pool configuration\n    max: config.max || parseInt(process.env.DB_POOL_MAX || '20', 10), // Maximum pool size\n    idleTimeoutMillis: config.idleTimeoutMillis || parseInt(process.env.DB_IDLE_TIMEOUT || '30000', 10), // 30 seconds\n    connectionTimeoutMillis: config.connectionTimeoutMillis || parseInt(process.env.DB_CONNECTION_TIMEOUT || '10000', 10), // 10 seconds\n    \n    // Additional recommended settings\n    allowExitOnIdle: config.allowExitOnIdle !== undefined ? config.allowExitOnIdle : false,\n    \n    // SSL configuration (important for Neon and other cloud providers)\n    ssl: config.ssl !== undefined ? config.ssl : {\n      rejectUnauthorized: false // Set to true in production with proper certificates\n    },\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Error handling for the pool\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n  });\n\n  // Optional: Log pool events for monitoring\n  pool.on('connect', (client) => {\n    console.log('New client connected to the pool');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  return pool;\n}\n\n/**\n * Express middleware that attaches the database pool to the request object\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express middleware function\n */\nfunction dbMiddleware(pool) {\n  return (req, res, next) => {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Helper method to get a client from the pool\n    req.getDbClient = async () => {\n      try {\n        const client = await pool.connect();\n        return client;\n      } catch (error) {\n        console.error('Error acquiring client from pool:', error);\n        throw error;\n      }\n    };\n\n    // Helper method for simple queries\n    req.query = async (text, params) => {\n      try {\n        const result = await pool.query(text, params);\n        return result;\n      } catch (error) {\n        console.error('Database query error:', error);\n        throw error;\n      }\n    };\n\n    // Helper method for transactions\n    req.transaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    };\n\n    next();\n  };\n}\n\n/**\n * Health check endpoint handler\n * Tests database connectivity and returns pool statistics\n */\nasync function healthCheckHandler(req, res) {\n  const startTime = Date.now();\n  \n  try {\n    // Test database connection with a simple query\n    const result = await req.db.query('SELECT NOW() as current_time, version() as pg_version');\n    const responseTime = Date.now() - startTime;\n\n    // Get pool statistics\n    const poolStats = {\n      totalCount: req.db.totalCount,\n      idleCount: req.db.idleCount,\n      waitingCount: req.db.waitingCount,\n    };\n\n    res.status(200).json({\n      status: 'healthy',\n      database: {\n        connected: true,\n        currentTime: result.rows[0].current_time,\n        version: result.rows[0].pg_version,\n        responseTime: `${responseTime}ms`,\n      },\n      pool: poolStats,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('Health check failed:', error);\n    \n    res.status(503).json({\n      status: 'unhealthy',\n      database: {\n        connected: false,\n        error: error.message,\n      },\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Gracefully shuts down the connection pool\n * @param {Pool} pool - PostgreSQL connection pool\n * @param {number} timeout - Maximum time to wait for shutdown (ms)\n */\nasync function gracefulShutdown(pool, timeout = 10000) {\n  console.log('Shutting down database connection pool...');\n  \n  const shutdownPromise = pool.end();\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => reject(new Error('Pool shutdown timeout')), timeout);\n  });\n\n  try {\n    await Promise.race([shutdownPromise, timeoutPromise]);\n    console.log('Database pool closed successfully');\n  } catch (error) {\n    console.error('Error during pool shutdown:', error);\n    // Force exit if graceful shutdown fails\n    process.exit(1);\n  }\n}\n\n/**\n * Sets up signal handlers for graceful shutdown\n * @param {Pool} pool - PostgreSQL connection pool\n */\nfunction setupGracefulShutdown(pool) {\n  const signals = ['SIGTERM', 'SIGINT'];\n  \n  signals.forEach((signal) => {\n    process.on(signal, async () => {\n      console.log(`Received ${signal}, starting graceful shutdown...`);\n      \n      try {\n        await gracefulShutdown(pool);\n        process.exit(0);\n      } catch (error) {\n        console.error('Graceful shutdown failed:', error);\n        process.exit(1);\n      }\n    });\n  });\n\n  // Handle uncaught exceptions\n  process.on('uncaughtException', async (error) => {\n    console.error('Uncaught exception:', error);\n    await gracefulShutdown(pool);\n    process.exit(1);\n  });\n\n  // Handle unhandled promise rejections\n  process.on('unhandledRejection', async (reason, promise) => {\n    console.error('Unhandled rejection at:', promise, 'reason:', reason);\n    await gracefulShutdown(pool);\n    process.exit(1);\n  });\n}\n\nmodule.exports = {\n  createPool,\n  dbMiddleware,\n  healthCheckHandler,\n  gracefulShutdown,\n  setupGracefulShutdown,\n};\n```\n\n## Usage Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst {\n  createPool,\n  dbMiddleware,\n  healthCheckHandler,\n  setupGracefulShutdown,\n} = require('./db-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Create the connection pool\nconst pool = createPool({\n  connectionString: process.env.DATABASE_URL,\n  max: 20,                      // Maximum 20 connections\n  idleTimeoutMillis: 30000,     // Close idle clients after 30 seconds\n  connectionTimeoutMillis: 10000, // Timeout after 10 seconds\n});\n\n// Apply the database middleware globally\napp.use(dbMiddleware(pool));\n\n// Health check endpoint\napp.get('/db/health', healthCheckHandler);\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Database error' });\n  }\n});\n\n// Example route using a transaction\napp.post('/users', async (req, res) => {\n  try {\n    const result = await req.transaction(async (client) => {\n      const userResult = await client.query(\n        'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',\n        [req.body.name, req.body.email]\n      );\n      \n      await client.query(\n        'INSERT INTO audit_log (action, user_id) VALUES ($1, $2)',\n        ['user_created', userResult.rows[0].id]\n      );\n      \n      return userResult.rows[0];\n    });\n    \n    res.status(201).json(result);\n  } catch (error) {\n    console.error('Error creating user:', error);\n    res.status(500).json({ error: 'Database error' });\n  }\n});\n\n// Example route using a dedicated client\napp.get('/complex-query', async (req, res) => {\n  const client = await req.getDbClient();\n  \n  try {\n    await client.query('BEGIN');\n    \n    const result1 = await client.query('SELECT * FROM table1');\n    const result2 = await client.query('SELECT * FROM table2 WHERE id = $1', [result1.rows[0].id]);\n    \n    await client.query('COMMIT');\n    \n    res.json({ result1: result1.rows, result2: result2.rows });\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('Complex query error:', error);\n    res.status(500).json({ error: 'Database error' });\n  } finally {\n    client.release(); // Always release the client back to the pool\n  }\n});\n\n// Setup graceful shutdown handlers\nsetupGracefulShutdown(pool);\n\n// Start the server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n\n// Graceful shutdown for the HTTP server\nprocess.on('SIGTERM', () => {\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n});\n```\n\n## Environment Variables (.env)\n\n```bash\n# Database connection\nDATABASE_URL=postgresql://user:password@host:5432/database\n\n# Pool configuration\nDB_POOL_MAX=20\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\n\n# Server configuration\nPORT=3000\nNODE_ENV=production\n```\n\n## Package.json Dependencies\n\n```json\n{\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.3\",\n    \"dotenv\": \"^16.3.1\"\n  }\n}\n```\n\n## Key Features\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Helpers**: Convenient methods (`req.query`, `req.transaction`, `req.getDbClient`)\n3. **Health Check**: `/db/health` endpoint with connection testing and pool statistics\n4. **Graceful Shutdown**: Proper cleanup on SIGTERM/SIGINT signals\n5. **Error Handling**: Comprehensive error handling and logging\n6. **Transaction Support**: Built-in transaction helper with automatic rollback\n7. **Pool Monitoring**: Event listeners for debugging and monitoring\n8. **Configurable**: Environment variables for all pool settings\n\n## Best Practices Implemented\n\n- Connection pooling prevents connection exhaustion\n- Proper client release to avoid pool leaks\n- Transaction rollback on errors\n- SSL support for secure connections (important for Neon)\n- Graceful shutdown with timeout\n- Health check for monitoring and load balancers\n- Error event handlers to prevent crashes\n\nThis middleware is production-ready and works seamlessly with Neon's serverless Postgres!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2234,
            "output_tokens": 2984,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive PostgreSQL connection pooling middleware for your Express.js application.\n\n```javascript\n// src/middleware/postgres.js\nimport pg from \"pg\";\n\nconst { Pool } = pg;\n\n// Configuration from environment variables with sensible defaults\nconst poolConfig = {\n  connectionString: process.env.DATABASE_URL,\n  max: parseInt(process.env.DB_POOL_MAX_SIZE) || 20, // Maximum pool size\n  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT) || 30000, // 30 seconds\n  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT) || 10000, // 10 seconds\n  allowExitOnIdle: false, // Keep pool alive even when idle\n};\n\n// Create a single shared pool instance\nlet pool = null;\n\n/**\n * Initialize the PostgreSQL connection pool\n * @returns {Pool} The initialized pool instance\n */\nexport function initializePool() {\n  if (pool) {\n    return pool;\n  }\n\n  pool = new Pool(poolConfig);\n\n  // Log pool errors\n  pool.on(\"error\", (err, client) => {\n    console.error(\"Unexpected error on idle client\", err);\n  });\n\n  // Log when a new client is created\n  pool.on(\"connect\", (client) => {\n    console.log(\"New client connected to PostgreSQL pool\");\n  });\n\n  // Log when a client is removed\n  pool.on(\"remove\", (client) => {\n    console.log(\"Client removed from PostgreSQL pool\");\n  });\n\n  console.log(\"PostgreSQL connection pool initialized\", {\n    max: poolConfig.max,\n    idleTimeoutMillis: poolConfig.idleTimeoutMillis,\n    connectionTimeoutMillis: poolConfig.connectionTimeoutMillis,\n  });\n\n  return pool;\n}\n\n/**\n * Middleware to attach the database pool to the request object\n */\nexport function attachPool(req, res, next) {\n  if (!pool) {\n    pool = initializePool();\n  }\n  req.db = pool;\n  next();\n}\n\n/**\n * Health check endpoint handler\n * Tests the database connection and returns pool statistics\n */\nexport async function healthCheck(req, res) {\n  if (!pool) {\n    return res.status(503).json({\n      status: \"error\",\n      message: \"Database pool not initialized\",\n    });\n  }\n\n  try {\n    // Test the connection with a simple query\n    const start = Date.now();\n    const result = await pool.query(\"SELECT NOW() as current_time, version()\");\n    const duration = Date.now() - start;\n\n    // Get pool statistics\n    const poolStats = {\n      totalCount: pool.totalCount,\n      idleCount: pool.idleCount,\n      waitingCount: pool.waitingCount,\n    };\n\n    res.status(200).json({\n      status: \"healthy\",\n      database: {\n        connected: true,\n        responseTime: `${duration}ms`,\n        currentTime: result.rows[0].current_time,\n        version: result.rows[0].version,\n      },\n      pool: poolStats,\n      config: {\n        maxConnections: poolConfig.max,\n        idleTimeout: `${poolConfig.idleTimeoutMillis}ms`,\n        connectionTimeout: `${poolConfig.connectionTimeoutMillis}ms`,\n      },\n    });\n  } catch (error) {\n    console.error(\"Database health check failed:\", error);\n    res.status(503).json({\n      status: \"unhealthy\",\n      error: error.message,\n      pool: {\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount,\n      },\n    });\n  }\n}\n\n/**\n * Gracefully shut down the connection pool\n * @returns {Promise<void>}\n */\nexport async function closePool() {\n  if (!pool) {\n    console.log(\"No pool to close\");\n    return;\n  }\n\n  try {\n    console.log(\"Closing PostgreSQL connection pool...\");\n    await pool.end();\n    pool = null;\n    console.log(\"PostgreSQL connection pool closed successfully\");\n  } catch (error) {\n    console.error(\"Error closing PostgreSQL pool:\", error);\n    throw error;\n  }\n}\n\n/**\n * Setup graceful shutdown handlers\n * @param {Object} server - Express server instance (optional)\n */\nexport function setupGracefulShutdown(server = null) {\n  const shutdown = async (signal) => {\n    console.log(`\\n${signal} received. Starting graceful shutdown...`);\n\n    // Close the HTTP server first (stop accepting new requests)\n    if (server) {\n      server.close(() => {\n        console.log(\"HTTP server closed\");\n      });\n    }\n\n    try {\n      // Close the database pool\n      await closePool();\n\n      console.log(\"Graceful shutdown completed\");\n      process.exit(0);\n    } catch (error) {\n      console.error(\"Error during graceful shutdown:\", error);\n      process.exit(1);\n    }\n  };\n\n  // Handle termination signals\n  process.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\n  process.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\n  // Handle uncaught errors\n  process.on(\"uncaughtException\", async (error) => {\n    console.error(\"Uncaught Exception:\", error);\n    await closePool();\n    process.exit(1);\n  });\n\n  process.on(\"unhandledRejection\", async (reason, promise) => {\n    console.error(\"Unhandled Rejection at:\", promise, \"reason:\", reason);\n    await closePool();\n    process.exit(1);\n  });\n}\n\n/**\n * Get the current pool instance\n * @returns {Pool|null}\n */\nexport function getPool() {\n  return pool;\n}\n```\n\nNow let's create an example of how to integrate this into your Express app:\n\n```javascript\n// src/app.js (or wherever you initialize your Express app)\nimport express from \"express\";\nimport {\n  initializePool,\n  attachPool,\n  healthCheck,\n  setupGracefulShutdown,\n} from \"./middleware/postgres.js\";\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Initialize the database pool on startup\ninitializePool();\n\n// Attach the pool to all requests\napp.use(attachPool);\n\n// Health check endpoint\napp.get(\"/db/health\", healthCheck);\n\n// Example route using the database\napp.get(\"/users\", async (req, res) => {\n  try {\n    const result = await req.db.query(\"SELECT * FROM users LIMIT 10\");\n    res.json(result.rows);\n  } catch (error) {\n    console.error(\"Database query error:\", error);\n    res.status(500).json({ error: \"Database query failed\" });\n  }\n});\n\n// Start the server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n\n// Setup graceful shutdown\nsetupGracefulShutdown(server);\n\nexport default app;\n```\n\nAnd here's an example `.env` file with the configuration:\n\n```bash\n# .env\nDATABASE_URL=postgresql://username:password@localhost:5432/dbname\n\n# Pool configuration (optional - defaults shown)\nDB_POOL_MAX_SIZE=20\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\n```\n\nFinally, here's a test file to verify the middleware works:\n\n```javascript\n// src/middleware/__tests__/postgres.test.js\nimport {\n  initializePool,\n  attachPool,\n  healthCheck,\n  closePool,\n  getPool,\n} from \"../postgres.js\";\n\ndescribe(\"PostgreSQL Middleware\", () => {\n  let mockReq, mockRes;\n\n  beforeEach(() => {\n    mockReq = {};\n    mockRes = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn(),\n    };\n  });\n\n  afterAll(async () => {\n    await closePool();\n  });\n\n  describe(\"initializePool\", () => {\n    it(\"should create a pool instance\", () => {\n      const pool = initializePool();\n      expect(pool).toBeDefined();\n      expect(pool.totalCount).toBeDefined();\n    });\n\n    it(\"should return the same pool instance on multiple calls\", () => {\n      const pool1 = initializePool();\n      const pool2 = initializePool();\n      expect(pool1).toBe(pool2);\n    });\n  });\n\n  describe(\"attachPool\", () => {\n    it(\"should attach pool to request object\", () => {\n      const next = jest.fn();\n      attachPool(mockReq, mockRes, next);\n\n      expect(mockReq.db).toBeDefined();\n      expect(next).toHaveBeenCalled();\n    });\n  });\n\n  describe(\"healthCheck\", () => {\n    it(\"should return healthy status when database is connected\", async () => {\n      mockReq.db = getPool();\n\n      await healthCheck(mockReq, mockRes);\n\n      expect(mockRes.status).toHaveBeenCalledWith(200);\n      expect(mockRes.json).toHaveBeenCalledWith(\n        expect.objectContaining({\n          status: \"healthy\",\n          database: expect.any(Object),\n          pool: expect.any(Object),\n        }),\n      );\n    });\n  });\n});\n```\n\n**Key Features:**\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Attachment**: Pool available via `req.db` in all routes\n3. **Health Check**: `/db/health` endpoint with connection test and pool stats\n4. **Graceful Shutdown**: Handles SIGTERM/SIGINT and closes pool cleanly\n5. **Configurable**: Max size, idle timeout, connection timeout via env vars\n6. **Error Handling**: Pool error events logged, uncaught exceptions handled\n7. **Pool Statistics**: Real-time monitoring of active/idle/waiting connections\n\n**Usage in routes:**\n```javascript\napp.get('/data', async (req, res) => {\n  const result = await req.db.query('SELECT * FROM table');\n  res.json(result.rows);\n});\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25148,
            "output_tokens": 2530,
            "cached": true
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "```javascript\n// db-pool-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Database Connection Pool Middleware for Express.js\n * Implements PostgreSQL connection pooling with health checks and graceful shutdown\n */\n\nclass DatabasePoolMiddleware {\n  constructor(config = {}) {\n    // Pool configuration with defaults\n    this.poolConfig = {\n      host: config.host || process.env.DB_HOST || 'localhost',\n      port: config.port || process.env.DB_PORT || 5432,\n      database: config.database || process.env.DB_NAME || 'mydb',\n      user: config.user || process.env.DB_USER || 'postgres',\n      password: config.password || process.env.DB_PASSWORD || '',\n      \n      // Pool-specific settings\n      max: config.max || 20, // Maximum number of clients in the pool\n      min: config.min || 5, // Minimum number of clients in the pool\n      idleTimeoutMillis: config.idleTimeoutMillis || 30000, // 30 seconds\n      connectionTimeoutMillis: config.connectionTimeoutMillis || 10000, // 10 seconds\n      \n      // Additional settings\n      allowExitOnIdle: config.allowExitOnIdle || false,\n      statement_timeout: config.statementTimeout || 30000, // Query timeout\n    };\n\n    // Create the pool instance\n    this.pool = new Pool(this.poolConfig);\n\n    // Pool event handlers\n    this.setupPoolEventHandlers();\n\n    // Setup graceful shutdown\n    this.setupGracefulShutdown();\n\n    // Track pool statistics\n    this.stats = {\n      totalConnections: 0,\n      activeConnections: 0,\n      idleConnections: 0,\n      waitingRequests: 0,\n      errors: 0,\n    };\n  }\n\n  /**\n   * Setup event handlers for the pool\n   */\n  setupPoolEventHandlers() {\n    // Client connection event\n    this.pool.on('connect', (client) => {\n      this.stats.totalConnections++;\n      console.log(`[DB Pool] New client connected. Total connections: ${this.pool.totalCount}`);\n    });\n\n    // Client acquisition event\n    this.pool.on('acquire', (client) => {\n      this.stats.activeConnections = this.pool.totalCount - this.pool.idleCount;\n      console.log(`[DB Pool] Client acquired. Active: ${this.stats.activeConnections}, Idle: ${this.pool.idleCount}`);\n    });\n\n    // Client release event\n    this.pool.on('release', (err, client) => {\n      if (err) {\n        console.error('[DB Pool] Error releasing client:', err);\n      }\n      this.stats.idleConnections = this.pool.idleCount;\n    });\n\n    // Error event\n    this.pool.on('error', (err, client) => {\n      this.stats.errors++;\n      console.error('[DB Pool] Unexpected error on idle client:', err);\n    });\n\n    // Remove event (client removed from pool)\n    this.pool.on('remove', (client) => {\n      console.log(`[DB Pool] Client removed. Total connections: ${this.pool.totalCount}`);\n    });\n  }\n\n  /**\n   * Setup graceful shutdown handlers\n   */\n  setupGracefulShutdown() {\n    const gracefulShutdown = async (signal) => {\n      console.log(`\\n[DB Pool] ${signal} received. Starting graceful shutdown...`);\n      \n      try {\n        // Wait for active queries to complete (with timeout)\n        const shutdownTimeout = setTimeout(() => {\n          console.warn('[DB Pool] Shutdown timeout reached, forcing pool closure');\n        }, 10000);\n\n        await this.pool.end();\n        clearTimeout(shutdownTimeout);\n        \n        console.log('[DB Pool] All connections closed successfully');\n        process.exit(0);\n      } catch (err) {\n        console.error('[DB Pool] Error during shutdown:', err);\n        process.exit(1);\n      }\n    };\n\n    // Handle different termination signals\n    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n    process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n    \n    // Handle uncaught exceptions\n    process.on('uncaughtException', (err) => {\n      console.error('[DB Pool] Uncaught exception:', err);\n      gracefulShutdown('UNCAUGHT_EXCEPTION');\n    });\n  }\n\n  /**\n   * Middleware function to attach pool to request object\n   */\n  middleware() {\n    return (req, res, next) => {\n      // Attach pool instance to request\n      req.db = this.pool;\n      \n      // Attach helper methods\n      req.dbQuery = async (text, params) => {\n        const start = Date.now();\n        try {\n          const result = await this.pool.query(text, params);\n          const duration = Date.now() - start;\n          console.log(`[DB Query] Executed query in ${duration}ms`);\n          return result;\n        } catch (err) {\n          console.error('[DB Query] Error:', err);\n          throw err;\n        }\n      };\n\n      // Attach transaction helper\n      req.dbTransaction = async (callback) => {\n        const client = await this.pool.connect();\n        try {\n          await client.query('BEGIN');\n          const result = await callback(client);\n          await client.query('COMMIT');\n          return result;\n        } catch (err) {\n          await client.query('ROLLBACK');\n          throw err;\n        } finally {\n          client.release();\n        }\n      };\n\n      next();\n    };\n  }\n\n  /**\n   * Health check endpoint handler\n   */\n  healthCheckHandler() {\n    return async (req, res) => {\n      const healthCheck = {\n        status: 'unknown',\n        timestamp: new Date().toISOString(),\n        pool: {\n          total: this.pool.totalCount,\n          idle: this.pool.idleCount,\n          waiting: this.pool.waitingCount,\n        },\n        stats: this.stats,\n        config: {\n          max: this.poolConfig.max,\n          min: this.poolConfig.min,\n          idleTimeout: this.poolConfig.idleTimeoutMillis,\n          connectionTimeout: this.poolConfig.connectionTimeoutMillis,\n        },\n      };\n\n      try {\n        // Test database connectivity\n        const start = Date.now();\n        const result = await this.pool.query('SELECT NOW() as current_time, version() as version');\n        const responseTime = Date.now() - start;\n\n        healthCheck.status = 'healthy';\n        healthCheck.database = {\n          connected: true,\n          responseTime: `${responseTime}ms`,\n          currentTime: result.rows[0].current_time,\n          version: result.rows[0].version.split(',')[0], // Simplified version\n        };\n\n        res.status(200).json(healthCheck);\n      } catch (err) {\n        healthCheck.status = 'unhealthy';\n        healthCheck.error = {\n          message: err.message,\n          code: err.code,\n        };\n\n        console.error('[DB Health Check] Failed:', err);\n        res.status(503).json(healthCheck);\n      }\n    };\n  }\n\n  /**\n   * Get pool statistics\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      pool: {\n        total: this.pool.totalCount,\n        idle: this.pool.idleCount,\n        waiting: this.pool.waitingCount,\n      },\n    };\n  }\n\n  /**\n   * Manual pool shutdown (for testing or manual cleanup)\n   */\n  async shutdown() {\n    console.log('[DB Pool] Manual shutdown initiated');\n    await this.pool.end();\n  }\n}\n\n/**\n * Factory function to create and configure the middleware\n */\nfunction createDatabasePoolMiddleware(config) {\n  return new DatabasePoolMiddleware(config);\n}\n\nmodule.exports = {\n  DatabasePoolMiddleware,\n  createDatabasePoolMiddleware,\n};\n\n// Example usage file: app.js\n/*\nconst express = require('express');\nconst { createDatabasePoolMiddleware } = require('./db-pool-middleware');\n\nconst app = express();\n\n// Create database pool middleware\nconst dbPool = createDatabasePoolMiddleware({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  max: 20,\n  min: 5,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 10000,\n});\n\n// Apply middleware globally\napp.use(dbPool.middleware());\n\n// Register health check endpoint\napp.get('/db/health', dbPool.healthCheckHandler());\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.dbQuery('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Example route using transactions\napp.post('/transfer', async (req, res) => {\n  try {\n    const result = await req.dbTransaction(async (client) => {\n      await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [100, 1]);\n      await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [100, 2]);\n      return { success: true };\n    });\n    res.json(result);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Pool statistics endpoint\napp.get('/db/stats', (req, res) => {\n  res.json(dbPool.getStats());\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n*/\n\n// Example .env file\n/*\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=postgres\nDB_PASSWORD=your_password\n*/\n```\n\nThis comprehensive implementation includes:\n\n## Key Features:\n\n1. **Connection Pooling**: Configurable pool with max/min connections, idle timeout, and connection timeout\n2. **Request Integration**: Attaches pool and helper methods to Express request object\n3. **Health Check Endpoint**: `/db/health` tests connectivity and returns pool statistics\n4. **Graceful Shutdown**: Handles SIGTERM, SIGINT, and uncaught exceptions\n5. **Event Monitoring**: Tracks pool events and maintains statistics\n6. **Transaction Support**: Helper method for database transactions\n7. **Query Helper**: Simplified query execution with timing\n8. **Error Handling**: Comprehensive error logging and handling\n\n## Usage:\n\n```javascript\n// Initialize with custom config\nconst dbPool = createDatabasePoolMiddleware({\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 10000\n});\n\n// Apply middleware\napp.use(dbPool.middleware());\n\n// Register health check\napp.get('/db/health', dbPool.healthCheckHandler());\n```\n\nThe middleware provides production-ready database connection pooling with monitoring, health checks, and graceful shutdown capabilities.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 92,
            "output_tokens": 2825,
            "cached": true
          },
          "with_skill": {
            "output": "# PostgreSQL Connection Pooling Middleware for Express.js\n\nHere's a complete implementation of a PostgreSQL connection pooling middleware with health checks and graceful shutdown:\n\n```javascript\n// db-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured pg Pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection string from environment\n    connectionString: process.env.DATABASE_URL,\n    \n    // Pool configuration with sensible defaults\n    max: config.max || parseInt(process.env.DB_POOL_MAX) || 20,\n    min: config.min || parseInt(process.env.DB_POOL_MIN) || 2,\n    \n    // Idle timeout: close idle clients after 30 seconds\n    idleTimeoutMillis: config.idleTimeoutMillis || 30000,\n    \n    // Connection timeout: fail after 10 seconds\n    connectionTimeoutMillis: config.connectionTimeoutMillis || 10000,\n    \n    // Maximum time a client can remain checked out\n    maxUses: config.maxUses || 7500,\n    \n    // Allow graceful shutdown\n    allowExitOnIdle: config.allowExitOnIdle !== false,\n    \n    // SSL configuration (important for production)\n    ssl: process.env.NODE_ENV === 'production' \n      ? { rejectUnauthorized: false }\n      : false,\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Log pool errors\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n  });\n\n  // Log when a client is acquired (optional, useful for debugging)\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  // Log when a client is released back to the pool\n  pool.on('release', (client) => {\n    console.log('Client released back to pool');\n  });\n\n  // Log when a new client is created\n  pool.on('connect', (client) => {\n    console.log('New client connected to database');\n  });\n\n  // Log when a client is removed from the pool\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  return pool;\n}\n\n/**\n * Express middleware that attaches the database pool to the request object\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express middleware function\n */\nfunction dbMiddleware(pool) {\n  return (req, res, next) => {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Helper method to get a client from the pool\n    req.getDbClient = async () => {\n      try {\n        const client = await pool.connect();\n        return client;\n      } catch (err) {\n        console.error('Error acquiring client from pool:', err);\n        throw err;\n      }\n    };\n\n    // Helper method for simple queries\n    req.query = async (text, params) => {\n      try {\n        const result = await pool.query(text, params);\n        return result;\n      } catch (err) {\n        console.error('Database query error:', err);\n        throw err;\n      }\n    };\n\n    // Helper method for transactions\n    req.transaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (err) {\n        await client.query('ROLLBACK');\n        throw err;\n      } finally {\n        client.release();\n      }\n    };\n\n    next();\n  };\n}\n\n/**\n * Health check endpoint handler\n * Tests database connectivity and returns pool statistics\n */\nasync function healthCheckHandler(pool) {\n  return async (req, res) => {\n    const startTime = Date.now();\n    \n    try {\n      // Test connection with a simple query\n      const result = await pool.query('SELECT NOW() as current_time, version() as pg_version');\n      const responseTime = Date.now() - startTime;\n      \n      // Get pool statistics\n      const poolStats = {\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount,\n      };\n\n      res.status(200).json({\n        status: 'healthy',\n        database: 'connected',\n        responseTime: `${responseTime}ms`,\n        timestamp: result.rows[0].current_time,\n        postgresVersion: result.rows[0].pg_version,\n        pool: poolStats,\n      });\n    } catch (err) {\n      const responseTime = Date.now() - startTime;\n      \n      console.error('Health check failed:', err);\n      \n      res.status(503).json({\n        status: 'unhealthy',\n        database: 'disconnected',\n        responseTime: `${responseTime}ms`,\n        error: err.message,\n        pool: {\n          totalCount: pool.totalCount,\n          idleCount: pool.idleCount,\n          waitingCount: pool.waitingCount,\n        },\n      });\n    }\n  };\n}\n\n/**\n * Graceful shutdown handler\n * Closes all pool connections and exits the process\n */\nfunction setupGracefulShutdown(pool, server) {\n  const shutdown = async (signal) => {\n    console.log(`\\n${signal} received. Starting graceful shutdown...`);\n    \n    // Stop accepting new connections\n    server.close(async () => {\n      console.log('HTTP server closed');\n      \n      try {\n        // Close all database connections\n        await pool.end();\n        console.log('Database pool closed');\n        \n        console.log('Graceful shutdown completed');\n        process.exit(0);\n      } catch (err) {\n        console.error('Error during shutdown:', err);\n        process.exit(1);\n      }\n    });\n\n    // Force shutdown after 30 seconds\n    setTimeout(() => {\n      console.error('Forced shutdown after timeout');\n      process.exit(1);\n    }, 30000);\n  };\n\n  // Handle termination signals\n  process.on('SIGTERM', () => shutdown('SIGTERM'));\n  process.on('SIGINT', () => shutdown('SIGINT'));\n  \n  // Handle uncaught errors\n  process.on('uncaughtException', (err) => {\n    console.error('Uncaught exception:', err);\n    shutdown('UNCAUGHT_EXCEPTION');\n  });\n\n  process.on('unhandledRejection', (reason, promise) => {\n    console.error('Unhandled rejection at:', promise, 'reason:', reason);\n    shutdown('UNHANDLED_REJECTION');\n  });\n}\n\nmodule.exports = {\n  createPool,\n  dbMiddleware,\n  healthCheckHandler,\n  setupGracefulShutdown,\n};\n```\n\n## Complete Express.js Application Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst {\n  createPool,\n  dbMiddleware,\n  healthCheckHandler,\n  setupGracefulShutdown,\n} = require('./db-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(express.json());\n\n// Create database pool with custom configuration\nconst pool = createPool({\n  max: 20,                      // Maximum pool size\n  min: 2,                       // Minimum pool size\n  idleTimeoutMillis: 30000,     // 30 seconds\n  connectionTimeoutMillis: 10000, // 10 seconds\n});\n\n// Attach database pool to all requests\napp.use(dbMiddleware(pool));\n\n// Health check endpoint\napp.get('/db/health', healthCheckHandler(pool));\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT id, name, email FROM users LIMIT 10');\n    res.json({\n      success: true,\n      count: result.rowCount,\n      users: result.rows,\n    });\n  } catch (err) {\n    console.error('Error fetching users:', err);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch users',\n    });\n  }\n});\n\n// Example route using a transaction\napp.post('/users', async (req, res) => {\n  const { name, email } = req.body;\n\n  try {\n    const result = await req.transaction(async (client) => {\n      // Insert user\n      const userResult = await client.query(\n        'INSERT INTO users(name, email) VALUES($1, $2) RETURNING *',\n        [name, email]\n      );\n      \n      // Insert audit log\n      await client.query(\n        'INSERT INTO audit_logs(action, user_id) VALUES($1, $2)',\n        ['user_created', userResult.rows[0].id]\n      );\n      \n      return userResult.rows[0];\n    });\n\n    res.status(201).json({\n      success: true,\n      user: result,\n    });\n  } catch (err) {\n    console.error('Error creating user:', err);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to create user',\n    });\n  }\n});\n\n// Example route using manual client management\napp.get('/users/:id', async (req, res) => {\n  const client = await req.getDbClient();\n  \n  try {\n    const result = await client.query(\n      'SELECT * FROM users WHERE id = $1',\n      [req.params.id]\n    );\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({\n        success: false,\n        error: 'User not found',\n      });\n    }\n    \n    res.json({\n      success: true,\n      user: result.rows[0],\n    });\n  } catch (err) {\n    console.error('Error fetching user:', err);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch user',\n    });\n  } finally {\n    // Always release the client back to the pool\n    client.release();\n  }\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n\n// Setup graceful shutdown\nsetupGracefulShutdown(pool, server);\n```\n\n## Environment Variables (.env)\n\n```bash\n# Database connection\nDATABASE_URL=postgresql://username:password@localhost:5432/mydb\n\n# Pool configuration (optional, defaults are provided)\nDB_POOL_MAX=20\nDB_POOL_MIN=2\n\n# Application\nNODE_ENV=development\nPORT=3000\n```\n\n## Package.json\n\n```json\n{\n  \"name\": \"express-pg-pooling\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Express.js with PostgreSQL connection pooling\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.3\",\n    \"dotenv\": \"^16.3.1\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.1\"\n  }\n}\n```\n\n## Key Features\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Helpers**: `req.query()`, `req.transaction()`, `req.getDbClient()`\n3. **Health Check**: `/db/health` endpoint with connection testing and pool stats\n4. **Graceful Shutdown**: Handles SIGTERM/SIGINT, closes connections cleanly\n5. **Configurable**: Max pool size, idle timeout, connection timeout\n6. **Error Handling**: Pool error events, query error handling\n7. **Production Ready**: SSL support, proper timeouts, connection limits\n\n## Usage Tips\n\n- Always use parameterized queries (`$1`, `$2`) to prevent SQL injection\n- Release clients manually when using `getDbClient()`\n- Use `req.query()` for simple queries\n- Use `req.transaction()` for multi-query transactions\n- Monitor the health check endpoint for pool statistics\n- Adjust pool size based on your workload and database limits\n\nThis implementation provides a robust, production-ready connection pooling solution for Express.js applications using PostgreSQL!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24682,
            "output_tokens": 3165,
            "cached": true
          },
          "skill_md_only": {
            "output": "# PostgreSQL Connection Pooling Middleware for Express.js\n\nHere's a complete implementation of an Express.js middleware with PostgreSQL connection pooling using the `pg` library:\n\n```javascript\n// db-pool-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured pg Pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection settings\n    connectionString: config.connectionString || process.env.DATABASE_URL,\n    \n    // Pool size configuration\n    max: config.max || parseInt(process.env.DB_POOL_MAX) || 20,\n    min: config.min || parseInt(process.env.DB_POOL_MIN) || 2,\n    \n    // Timeout configuration (in milliseconds)\n    idleTimeoutMillis: config.idleTimeoutMillis || \n                       parseInt(process.env.DB_IDLE_TIMEOUT) || 30000,\n    connectionTimeoutMillis: config.connectionTimeoutMillis || \n                            parseInt(process.env.DB_CONNECTION_TIMEOUT) || 10000,\n    \n    // Query timeout\n    query_timeout: config.queryTimeout || \n                   parseInt(process.env.DB_QUERY_TIMEOUT) || 30000,\n    \n    // Statement timeout (PostgreSQL server-side)\n    statement_timeout: config.statementTimeout || \n                       parseInt(process.env.DB_STATEMENT_TIMEOUT) || 30000,\n    \n    // SSL configuration for production (Neon requires SSL)\n    ssl: config.ssl !== undefined ? config.ssl : \n         (process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false),\n    \n    // Application name for connection tracking\n    application_name: config.applicationName || \n                      process.env.APP_NAME || \n                      'express-app',\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Pool event handlers for monitoring\n  pool.on('connect', (client) => {\n    console.log('New client connected to the pool');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n    // Don't exit the process, let the pool handle it\n  });\n\n  return pool;\n}\n\n/**\n * Express middleware that attaches the database pool to the request object\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express middleware function\n */\nfunction dbPoolMiddleware(pool) {\n  return (req, res, next) => {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Helper method to get a client from the pool\n    req.getDbClient = async () => {\n      try {\n        const client = await pool.connect();\n        \n        // Wrap the release method to ensure it's called\n        const originalRelease = client.release.bind(client);\n        client.release = () => {\n          console.log('Client released back to pool');\n          originalRelease();\n        };\n        \n        return client;\n      } catch (error) {\n        console.error('Error acquiring client from pool:', error);\n        throw error;\n      }\n    };\n    \n    // Helper method for simple queries\n    req.query = async (text, params) => {\n      const start = Date.now();\n      try {\n        const result = await pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: result.rowCount });\n        return result;\n      } catch (error) {\n        console.error('Query error:', error);\n        throw error;\n      }\n    };\n    \n    next();\n  };\n}\n\n/**\n * Health check endpoint handler\n * Tests database connectivity and returns pool statistics\n */\nasync function healthCheckHandler(req, res) {\n  const startTime = Date.now();\n  \n  try {\n    // Test database connection with a simple query\n    const result = await req.db.query('SELECT NOW() as current_time, version() as pg_version');\n    \n    const responseTime = Date.now() - startTime;\n    \n    // Get pool statistics\n    const poolStats = {\n      totalCount: req.db.totalCount,\n      idleCount: req.db.idleCount,\n      waitingCount: req.db.waitingCount,\n    };\n    \n    res.status(200).json({\n      status: 'healthy',\n      database: {\n        connected: true,\n        currentTime: result.rows[0].current_time,\n        version: result.rows[0].pg_version,\n        responseTime: `${responseTime}ms`,\n      },\n      pool: poolStats,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('Health check failed:', error);\n    \n    res.status(503).json({\n      status: 'unhealthy',\n      database: {\n        connected: false,\n        error: error.message,\n      },\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Graceful shutdown handler\n * Closes all connections in the pool\n */\nasync function gracefulShutdown(pool, signal) {\n  console.log(`\\n${signal} received. Starting graceful shutdown...`);\n  \n  try {\n    // Stop accepting new connections\n    console.log('Closing database connection pool...');\n    \n    // End the pool (waits for all clients to be released)\n    await pool.end();\n    \n    console.log('Database pool closed successfully');\n    process.exit(0);\n  } catch (error) {\n    console.error('Error during graceful shutdown:', error);\n    process.exit(1);\n  }\n}\n\n/**\n * Initialize database pool and middleware\n * @param {Object} app - Express application instance\n * @param {Object} config - Pool configuration options\n * @returns {Pool} The created pool instance\n */\nfunction initializeDatabase(app, config = {}) {\n  // Create the pool\n  const pool = createPool(config);\n  \n  // Apply middleware to all routes\n  app.use(dbPoolMiddleware(pool));\n  \n  // Add health check endpoint\n  app.get('/db/health', healthCheckHandler);\n  \n  // Setup graceful shutdown handlers\n  process.on('SIGTERM', () => gracefulShutdown(pool, 'SIGTERM'));\n  process.on('SIGINT', () => gracefulShutdown(pool, 'SIGINT'));\n  \n  // Test initial connection\n  pool.query('SELECT NOW()')\n    .then(() => {\n      console.log('Database pool initialized successfully');\n      console.log(`Pool configuration: max=${pool.options.max}, idle_timeout=${pool.options.idleTimeoutMillis}ms`);\n    })\n    .catch((error) => {\n      console.error('Failed to initialize database pool:', error);\n      process.exit(1);\n    });\n  \n  return pool;\n}\n\nmodule.exports = {\n  createPool,\n  dbPoolMiddleware,\n  healthCheckHandler,\n  gracefulShutdown,\n  initializeDatabase,\n};\n```\n\n## Usage Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst { initializeDatabase } = require('./db-pool-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Initialize database with custom configuration\nconst pool = initializeDatabase(app, {\n  max: 25,                      // Maximum pool size\n  min: 5,                       // Minimum pool size\n  idleTimeoutMillis: 60000,     // 60 seconds\n  connectionTimeoutMillis: 5000, // 5 seconds\n  queryTimeout: 30000,          // 30 seconds\n});\n\n// Example route using the pool directly\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Database error' });\n  }\n});\n\n// Example route using a dedicated client (for transactions)\napp.post('/users', async (req, res) => {\n  const client = await req.getDbClient();\n  \n  try {\n    await client.query('BEGIN');\n    \n    const insertResult = await client.query(\n      'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',\n      [req.body.name, req.body.email]\n    );\n    \n    await client.query('COMMIT');\n    \n    res.status(201).json(insertResult.rows[0]);\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('Transaction error:', error);\n    res.status(500).json({ error: 'Transaction failed' });\n  } finally {\n    client.release();\n  }\n});\n\n// Example route with error handling\napp.get('/stats', async (req, res) => {\n  try {\n    const result = await req.query(`\n      SELECT \n        COUNT(*) as total_users,\n        COUNT(CASE WHEN created_at > NOW() - INTERVAL '24 hours' THEN 1 END) as new_users_24h\n      FROM users\n    `);\n    \n    res.json(result.rows[0]);\n  } catch (error) {\n    console.error('Error fetching stats:', error);\n    res.status(500).json({ error: 'Failed to fetch statistics' });\n  }\n});\n\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n```\n\n## Environment Variables\n\nCreate a `.env` file:\n\n```bash\n# Database connection\nDATABASE_URL=postgresql://user:password@host:5432/database\n\n# For Neon (example)\n# DATABASE_URL=postgresql://user:password@ep-cool-name-123456.us-east-2.aws.neon.tech/neondb?sslmode=require\n\n# Pool configuration\nDB_POOL_MAX=20\nDB_POOL_MIN=2\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_QUERY_TIMEOUT=30000\nDB_STATEMENT_TIMEOUT=30000\n\n# Application\nNODE_ENV=production\nAPP_NAME=my-express-app\nPORT=3000\n```\n\n## Package.json\n\n```json\n{\n  \"name\": \"express-pg-pool\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Express.js with PostgreSQL connection pooling\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.3\",\n    \"dotenv\": \"^16.3.1\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.1\"\n  }\n}\n```\n\n## Testing the Health Check\n\n```bash\n# Check database health\ncurl http://localhost:3000/db/health\n\n# Expected response:\n{\n  \"status\": \"healthy\",\n  \"database\": {\n    \"connected\": true,\n    \"currentTime\": \"2024-01-15T10:30:45.123Z\",\n    \"version\": \"PostgreSQL 16.0 on x86_64-pc-linux-gnu...\",\n    \"responseTime\": \"15ms\"\n  },\n  \"pool\": {\n    \"totalCount\": 5,\n    \"idleCount\": 4,\n    \"waitingCount\": 0\n  },\n  \"timestamp\": \"2024-01-15T10:30:45.123Z\"\n}\n```\n\n## Key Features\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Attachment**: Pool accessible via `req.db`\n3. **Helper Methods**: \n   - `req.query()` for simple queries\n   - `req.getDbClient()` for transactions\n4. **Health Check**: `/db/health` endpoint with pool statistics\n5. **Graceful Shutdown**: Handles SIGTERM/SIGINT properly\n6. **Configurable**: All timeouts and pool sizes configurable\n7. **Error Handling**: Comprehensive error logging\n8. **Monitoring**: Pool event handlers for debugging\n\n## Best Practices for Neon\n\nWhen using with Neon Serverless Postgres:\n\n1. **Use Connection Pooling**: Neon recommends pooled connections for serverless\n2. **SSL Required**: Always use SSL in production (`sslmode=require`)\n3. **Reasonable Pool Size**: Start with 10-20 connections\n4. **Monitor Connections**: Use the health check to track pool usage\n5. **Handle Timeouts**: Set appropriate query and connection timeouts\n\nFor more information on Neon connection pooling, see: https://neon.com/docs/connect/connection-pooling.md",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2234,
            "output_tokens": 3329,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive PostgreSQL connection pooling middleware for your Express.js application.\n\n```javascript\n// src/middleware/postgres.js\nimport pg from \"pg\";\n\nconst { Pool } = pg;\n\n// Pool configuration\nconst poolConfig = {\n  connectionString: process.env.DATABASE_URL,\n  max: parseInt(process.env.DB_POOL_MAX || \"20\", 10), // Maximum pool size\n  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || \"30000\", 10), // 30 seconds\n  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || \"10000\", 10), // 10 seconds\n  allowExitOnIdle: false, // Keep pool alive\n};\n\n// Create shared pool instance\nlet pool = null;\n\n/**\n * Initialize the PostgreSQL connection pool\n */\nexport function initializePool() {\n  if (pool) {\n    console.warn(\"Pool already initialized\");\n    return pool;\n  }\n\n  pool = new Pool(poolConfig);\n\n  // Handle pool errors\n  pool.on(\"error\", (err, client) => {\n    console.error(\"Unexpected error on idle client\", err);\n  });\n\n  // Log pool events in development\n  if (process.env.NODE_ENV === \"development\") {\n    pool.on(\"connect\", () => {\n      console.log(\"New client connected to pool\");\n    });\n\n    pool.on(\"acquire\", () => {\n      console.log(\"Client acquired from pool\");\n    });\n\n    pool.on(\"remove\", () => {\n      console.log(\"Client removed from pool\");\n    });\n  }\n\n  console.log(\"PostgreSQL pool initialized with config:\", {\n    max: poolConfig.max,\n    idleTimeoutMillis: poolConfig.idleTimeoutMillis,\n    connectionTimeoutMillis: poolConfig.connectionTimeoutMillis,\n  });\n\n  return pool;\n}\n\n/**\n * Middleware to attach pool to request object\n */\nexport function attachPool(req, res, next) {\n  if (!pool) {\n    return res.status(503).json({\n      error: \"Database pool not initialized\",\n    });\n  }\n\n  req.db = pool;\n  next();\n}\n\n/**\n * Health check endpoint handler\n */\nexport async function healthCheck(req, res) {\n  if (!pool) {\n    return res.status(503).json({\n      status: \"error\",\n      message: \"Database pool not initialized\",\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  const startTime = Date.now();\n  let client;\n\n  try {\n    // Acquire a client from the pool\n    client = await pool.connect();\n\n    // Test the connection with a simple query\n    const result = await client.query(\"SELECT NOW() as current_time, version() as pg_version\");\n\n    const responseTime = Date.now() - startTime;\n\n    // Get pool stats\n    const poolStats = {\n      totalCount: pool.totalCount,\n      idleCount: pool.idleCount,\n      waitingCount: pool.waitingCount,\n    };\n\n    res.status(200).json({\n      status: \"healthy\",\n      message: \"Database connection successful\",\n      timestamp: new Date().toISOString(),\n      responseTime: `${responseTime}ms`,\n      database: {\n        currentTime: result.rows[0].current_time,\n        version: result.rows[0].pg_version,\n      },\n      pool: poolStats,\n    });\n  } catch (error) {\n    const responseTime = Date.now() - startTime;\n\n    console.error(\"Database health check failed:\", error);\n\n    res.status(503).json({\n      status: \"unhealthy\",\n      message: \"Database connection failed\",\n      error: error.message,\n      timestamp: new Date().toISOString(),\n      responseTime: `${responseTime}ms`,\n    });\n  } finally {\n    // Always release the client back to the pool\n    if (client) {\n      client.release();\n    }\n  }\n}\n\n/**\n * Gracefully shut down the pool\n */\nexport async function shutdownPool() {\n  if (!pool) {\n    console.log(\"No pool to shut down\");\n    return;\n  }\n\n  console.log(\"Shutting down PostgreSQL pool...\");\n\n  try {\n    await pool.end();\n    console.log(\"PostgreSQL pool shut down successfully\");\n    pool = null;\n  } catch (error) {\n    console.error(\"Error shutting down pool:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get the current pool instance (for direct access if needed)\n */\nexport function getPool() {\n  if (!pool) {\n    throw new Error(\"Pool not initialized. Call initializePool() first.\");\n  }\n  return pool;\n}\n\n/**\n * Helper function to execute a query with automatic client management\n */\nexport async function query(text, params) {\n  if (!pool) {\n    throw new Error(\"Pool not initialized\");\n  }\n\n  const start = Date.now();\n  try {\n    const result = await pool.query(text, params);\n    const duration = Date.now() - start;\n\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(\"Executed query\", { text, duration, rows: result.rowCount });\n    }\n\n    return result;\n  } catch (error) {\n    console.error(\"Query error:\", { text, error: error.message });\n    throw error;\n  }\n}\n\n/**\n * Helper function for transactions\n */\nexport async function transaction(callback) {\n  if (!pool) {\n    throw new Error(\"Pool not initialized\");\n  }\n\n  const client = await pool.connect();\n\n  try {\n    await client.query(\"BEGIN\");\n    const result = await callback(client);\n    await client.query(\"COMMIT\");\n    return result;\n  } catch (error) {\n    await client.query(\"ROLLBACK\");\n    throw error;\n  } finally {\n    client.release();\n  }\n}\n```\n\nNow let's create the integration file for your Express app:\n\n```javascript\n// src/app.js (or wherever you initialize your Express app)\nimport express from \"express\";\nimport {\n  initializePool,\n  attachPool,\n  healthCheck,\n  shutdownPool,\n} from \"./middleware/postgres.js\";\n\nconst app = express();\n\n// Initialize the pool when the app starts\ninitializePool();\n\n// Attach pool to all requests (optional - only if you want it on all routes)\napp.use(attachPool);\n\n// Health check endpoint\napp.get(\"/db/health\", healthCheck);\n\n// Your other routes here...\n\n// Graceful shutdown handlers\nconst gracefulShutdown = async (signal) => {\n  console.log(`\\n${signal} received. Starting graceful shutdown...`);\n\n  try {\n    // Close the database pool\n    await shutdownPool();\n\n    // Close the Express server\n    if (server) {\n      server.close(() => {\n        console.log(\"HTTP server closed\");\n        process.exit(0);\n      });\n    } else {\n      process.exit(0);\n    }\n  } catch (error) {\n    console.error(\"Error during shutdown:\", error);\n    process.exit(1);\n  }\n};\n\n// Handle shutdown signals\nprocess.on(\"SIGTERM\", () => gracefulShutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => gracefulShutdown(\"SIGINT\"));\n\n// Handle uncaught errors\nprocess.on(\"uncaughtException\", (error) => {\n  console.error(\"Uncaught Exception:\", error);\n  gracefulShutdown(\"UNCAUGHT_EXCEPTION\");\n});\n\nprocess.on(\"unhandledRejection\", (reason, promise) => {\n  console.error(\"Unhandled Rejection at:\", promise, \"reason:\", reason);\n  gracefulShutdown(\"UNHANDLED_REJECTION\");\n});\n\nconst PORT = process.env.PORT || 3000;\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n\nexport default app;\n```\n\nCreate an example `.env` file:\n\n```bash\n# .env.example\nDATABASE_URL=postgresql://username:password@localhost:5432/database_name\n\n# Pool configuration (optional - defaults shown)\nDB_POOL_MAX=20\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\n\n# Other config\nNODE_ENV=development\nPORT=3000\nJWT_SECRET=your-secret-key\n```\n\nHere's an example route showing how to use the pool:\n\n```javascript\n// src/routes/users.js\nimport express from \"express\";\nimport { query, transaction } from \"../middleware/postgres.js\";\n\nconst router = express.Router();\n\n// Example: Simple query using the helper\nrouter.get(\"/users\", async (req, res) => {\n  try {\n    const result = await query(\"SELECT id, email, name FROM users ORDER BY created_at DESC\");\n    res.json({ users: result.rows });\n  } catch (error) {\n    console.error(\"Error fetching users:\", error);\n    res.status(500).json({ error: \"Failed to fetch users\" });\n  }\n});\n\n// Example: Parameterized query\nrouter.get(\"/users/:id\", async (req, res) => {\n  try {\n    const result = await query(\"SELECT id, email, name FROM users WHERE id = $1\", [req.params.id]);\n\n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: \"User not found\" });\n    }\n\n    res.json({ user: result.rows[0] });\n  } catch (error) {\n    console.error(\"Error fetching user:\", error);\n    res.status(500).json({ error: \"Failed to fetch user\" });\n  }\n});\n\n// Example: Using the pool directly from req.db\nrouter.post(\"/users\", async (req, res) => {\n  const { email, name, password } = req.body;\n\n  try {\n    const result = await req.db.query(\n      \"INSERT INTO users (email, name, password) VALUES ($1, $2, $3) RETURNING id, email, name\",\n      [email, name, password]\n    );\n\n    res.status(201).json({ user: result.rows[0] });\n  } catch (error) {\n    console.error(\"Error creating user:\", error);\n    res.status(500).json({ error: \"Failed to create user\" });\n  }\n});\n\n// Example: Transaction\nrouter.post(\"/users/:id/transfer\", async (req, res) => {\n  const { toUserId, amount } = req.body;\n  const fromUserId = req.params.id;\n\n  try {\n    const result = await transaction(async (client) => {\n      // Deduct from sender\n      await client.query(\"UPDATE accounts SET balance = balance - $1 WHERE user_id = $2\", [\n        amount,\n        fromUserId,\n      ]);\n\n      // Add to receiver\n      await client.query(\"UPDATE accounts SET balance = balance + $1 WHERE user_id = $2\", [\n        amount,\n        toUserId,\n      ]);\n\n      // Get updated balances\n      const balances = await client.query(\n        \"SELECT user_id, balance FROM accounts WHERE user_id IN ($1, $2)\",\n        [fromUserId, toUserId]\n      );\n\n      return balances.rows;\n    });\n\n    res.json({ success: true, balances: result });\n  } catch (error) {\n    console.error(\"Transfer failed:\", error);\n    res.status(500).json({ error: \"Transfer failed\" });\n  }\n});\n\nexport default router;\n```\n\nAnd a test file:\n\n```javascript\n// src/middleware/__tests__/postgres.test.js\nimport { jest } from \"@jest/globals\";\nimport { initializePool, shutdownPool, query, healthCheck } from \"../postgres.js\";\n\ndescribe(\"PostgreSQL Middleware\", () => {\n  beforeAll(() => {\n    process.env.DATABASE_URL = \"postgresql://test:test@localhost:5432/testdb\";\n  });\n\n  afterAll(async () => {\n    await shutdownPool();\n  });\n\n  describe(\"initializePool\", () => {\n    it(\"should initialize pool successfully\", () => {\n      const pool = initializePool();\n      expect(pool).toBeDefined();\n      expect(pool.totalCount).toBeDefined();\n    });\n\n    it(\"should warn when initializing pool twice\", () => {\n      const consoleSpy = jest.spyOn(console, \"warn\").mockImplementation();\n      initializePool();\n      expect(consoleSpy).toHaveBeenCalledWith(\"Pool already initialized\");\n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe(\"healthCheck\", () => {\n    it(\"should return healthy status when database is available\", async () => {\n      const req = {};\n      const res = {\n        status: jest.fn().mockReturnThis(),\n        json: jest.fn(),\n      };\n\n      await healthCheck(req, res);\n\n      expect(res.status).toHaveBeenCalledWith(expect.any(Number));\n      expect(res.json).toHaveBeenCalledWith(\n        expect.objectContaining({\n          status: expect.any(String),\n          timestamp: expect.any(String),\n        })\n      );\n    });\n  });\n});\n```\n\n## Key Features:\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Configuration**: Environment variables for max pool size, timeouts\n3. **Health Check**: `/db/health` endpoint with connection testing and pool stats\n4. **Graceful Shutdown**: Handles SIGTERM, SIGINT, and uncaught errors\n5. **Helper Functions**: `query()` and `transaction()` for easier database operations\n6. **Error Handling**: Comprehensive error logging and handling\n7. **Pool Monitoring**: Event listeners for debugging in development\n8. **Request Attachment**: Pool available via `req.db` on all routes\n\nThe middleware is production-ready with proper error handling, logging, and graceful shutdown capabilities!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25148,
            "output_tokens": 3441,
            "cached": true
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-04",
      "task_type": "grounded",
      "target_language": "typescript",
      "expected_patterns": [
        "import.*drizzle-orm|from.*drizzle",
        "pgTable|serial|varchar|timestamp",
        "relations\\(|one\\(|many\\(",
        "eq\\(|and\\(",
        "export\\s+const",
        "InferSelectModel|InferInsertModel|typeof"
      ],
      "anti_patterns": [
        "import.*prisma|@prisma",
        "neon_api|NeonAPI",
        "from neon_api",
        "import psycopg",
        "class.*Model.*:",
        "def\\s+"
      ],
      "pattern_sources": [
        {
          "url": "https://neon.com/docs/guides/drizzle.md",
          "description": "Drizzle ORM with Neon: import from drizzle-orm, schema definition with pgTable/serial/text/timestamp, db.insert().values(), db.select().from(), connection setup with drizzle(neon()) or drizzle(new Pool())"
        },
        {
          "url": "https://orm.drizzle.team/docs/column-types/pg",
          "description": "Drizzle ORM PostgreSQL column types: pgTable, serial, varchar, timestamp schema definition patterns"
        },
        {
          "url": "https://orm.drizzle.team/docs/rqb",
          "description": "Drizzle ORM relational queries: relations(), one(), many() relationship patterns, eq() filter operator"
        },
        {
          "url": "https://orm.drizzle.team/docs/operators",
          "description": "Drizzle ORM query operators - source of and() operator for combining multiple filter conditions in WHERE clauses"
        },
        {
          "url": "https://orm.drizzle.team/docs/goodies#type-api",
          "description": "Drizzle ORM type helpers: InferSelectModel, InferInsertModel, typeof for TypeScript type inference"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "```typescript\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { \n  pgTable, \n  serial, \n  varchar, \n  integer, \n  timestamp,\n  unique\n} from 'drizzle-orm/pg-core';\nimport { relations, eq, sql } from 'drizzle-orm';\nimport { InferSelectModel, InferInsertModel } from 'drizzle-orm';\nimport { Pool } from 'pg';\n\n// ============================================\n// Schema Definitions\n// ============================================\n\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// ============================================\n// Relations\n// ============================================\n\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// ============================================\n// Types\n// ============================================\n\nexport type Organization = InferSelectModel<typeof organizations>;\nexport type NewOrganization = InferInsertModel<typeof organizations>;\n\nexport type Member = InferSelectModel<typeof members>;\nexport type NewMember = InferInsertModel<typeof members>;\n\nexport type OrganizationWithMemberCount = Organization & {\n  memberCount: number;\n};\n\n// ============================================\n// Database Setup\n// ============================================\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle(pool);\n\n// ============================================\n// Query Functions\n// ============================================\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List all members with organization details\n */\nexport async function listOrgMembersWithDetails(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n      organization: {\n        id: organizations.id,\n        name: organizations.name,\n        slug: organizations.slug,\n      },\n    })\n    .from(members)\n    .innerJoin(organizations, eq(members.orgId, organizations.id))\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a member to an organization\n */\nexport async function addMember(data: {\n  orgId: number;\n  email: string;\n  role?: string;\n}) {\n  const [newMember] = await db\n    .insert(members)\n    .values({\n      orgId: data.orgId,\n      email: data.email,\n      role: data.role || 'member',\n    })\n    .returning();\n  \n  return newMember;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(\n  orgId: number\n): Promise<OrganizationWithMemberCount | undefined> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as integer)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0];\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(\n  slug: string\n): Promise<OrganizationWithMemberCount | undefined> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as integer)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0];\n}\n\n/**\n * Remove a member from an organization\n */\nexport async function removeMember(memberId: number) {\n  const [deleted] = await db\n    .delete(members)\n    .where(eq(members.id, memberId))\n    .returning();\n  \n  return deleted;\n}\n\n/**\n * Update member role\n */\nexport async function updateMemberRole(memberId: number, role: string) {\n  const [updated] = await db\n    .update(members)\n    .set({ role })\n    .where(eq(members.id, memberId))\n    .returning();\n  \n  return updated;\n}\n\n/**\n * Check if member exists in organization\n */\nexport async function memberExists(orgId: number, email: string): Promise<boolean> {\n  const result = await db\n    .select({ id: members.id })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .where(eq(members.email, email))\n    .limit(1);\n  \n  return result.length > 0;\n}\n\n// ============================================\n// Usage Examples\n// ============================================\n\n/*\n// List all members of an organization\nconst orgMembers = await listOrgMembers(1);\n\n// Add a new member\nconst newMember = await addMember({\n  orgId: 1,\n  email: 'user@example.com',\n  role: 'admin'\n});\n\n// Get organization with member count\nconst orgDetails = await getOrgWithMemberCount(1);\nconsole.log(`${orgDetails?.name} has ${orgDetails?.memberCount} members`);\n\n// Get organization by slug\nconst org = await getOrgBySlugWithMemberCount('acme-corp');\n\n// Update member role\nawait updateMemberRole(1, 'admin');\n\n// Remove a member\nawait removeMember(1);\n\n// Check if member exists\nconst exists = await memberExists(1, 'user@example.com');\n*/\n```\n\nThis code provides:\n\n1. **Complete schema definition** with proper types, constraints, and relations\n2. **Type safety** using Drizzle's inference utilities\n3. **All requested query functions** plus additional useful ones\n4. **Proper foreign key relationships** with cascade delete\n5. **Unique constraint** on org_id + email combination\n6. **Aggregation query** for member count using SQL template\n7. **Returning clauses** for insert/update/delete operations\n8. **Usage examples** in comments\n\nThe schema is fully typed and provides excellent TypeScript autocomplete support!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 202,
            "output_tokens": 1961,
            "cached": true
          },
          "with_skill": {
            "output": "# Drizzle Schema and Query Functions\n\nHere's a complete implementation with schema definition, relations, and typed query functions:\n\n## Schema Definition\n\n```typescript\n// src/db/schema.ts\nimport { relations } from \"drizzle-orm\";\nimport {\n  pgTable,\n  serial,\n  varchar,\n  timestamp,\n  integer,\n  unique,\n} from \"drizzle-orm/pg-core\";\n\n// Organizations table\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable(\n  \"members\",\n  {\n    id: serial(\"id\").primaryKey(),\n    orgId: integer(\"org_id\")\n      .notNull()\n      .references(() => organizations.id, { onDelete: \"cascade\" }),\n    email: varchar(\"email\", { length: 255 }).notNull(),\n    role: varchar(\"role\", { length: 50 }).default(\"member\").notNull(),\n    joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => ({\n    // Composite unique constraint\n    uniqueOrgEmail: unique().on(table.orgId, table.email),\n  }),\n);\n\n// Relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## Database Client Setup\n\n```typescript\n// src/db/client.ts\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { Pool } from \"pg\";\nimport * as schema from \"./schema\";\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle({ client: pool, schema });\n```\n\n## Query Functions\n\n```typescript\n// src/db/queries.ts\nimport { eq, sql, count } from \"drizzle-orm\";\nimport { db } from \"./client\";\nimport { organizations, members, type NewMember } from \"./schema\";\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a member to an organization\n * Returns the created member or null if already exists\n */\nexport async function addOrgMember(\n  orgId: number,\n  email: string,\n  role: string = \"member\",\n) {\n  try {\n    const [newMember] = await db\n      .insert(members)\n      .values({\n        orgId,\n        email,\n        role,\n      })\n      .returning();\n\n    return { success: true, member: newMember };\n  } catch (error: any) {\n    // Handle unique constraint violation\n    if (error.code === \"23505\") {\n      return {\n        success: false,\n        error: \"Member with this email already exists in the organization\",\n      };\n    }\n    throw error;\n  }\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Alternative: Get org with member count using subquery\n */\nexport async function getOrgWithMemberCountSubquery(orgId: number) {\n  const [org] = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`(\n        SELECT COUNT(*)::int \n        FROM ${members} \n        WHERE ${members.orgId} = ${organizations.id}\n      )`.as(\"member_count\"),\n    })\n    .from(organizations)\n    .where(eq(organizations.id, orgId));\n\n  return org || null;\n}\n\n/**\n * Get organization by slug with all members\n */\nexport async function getOrgBySlugWithMembers(slug: string) {\n  return await db.query.organizations.findFirst({\n    where: eq(organizations.slug, slug),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n## Usage Examples\n\n```typescript\n// src/examples.ts\nimport {\n  listOrgMembers,\n  addOrgMember,\n  getOrgWithMemberCount,\n  getOrgBySlugWithMembers,\n} from \"./db/queries\";\n\nasync function examples() {\n  // List all members of organization with ID 1\n  const members = await listOrgMembers(1);\n  console.log(\"Members:\", members);\n\n  // Add a new member\n  const result = await addOrgMember(1, \"user@example.com\", \"admin\");\n  if (result.success) {\n    console.log(\"Added member:\", result.member);\n  } else {\n    console.error(\"Error:\", result.error);\n  }\n\n  // Get organization with member count\n  const orgDetails = await getOrgWithMemberCount(1);\n  console.log(\"Organization:\", orgDetails);\n  // Output: { id: 1, name: \"...\", slug: \"...\", createdAt: ..., memberCount: 5 }\n\n  // Get organization by slug with all members\n  const orgWithMembers = await getOrgBySlugWithMembers(\"acme-corp\");\n  console.log(\"Organization:\", orgWithMembers?.name);\n  console.log(\"Members:\", orgWithMembers?.members);\n}\n```\n\n## Drizzle Config\n\n```typescript\n// drizzle.config.ts\nimport { config } from \"dotenv\";\nimport { defineConfig } from \"drizzle-kit\";\n\nconfig({ path: \".env\" });\n\nexport default defineConfig({\n  schema: \"./src/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n## Key Features\n\n1. **Type Safety**: Full TypeScript inference for all queries\n2. **Relations**: Defined for easy joins and nested queries\n3. **Error Handling**: Catches unique constraint violations gracefully\n4. **Flexible Queries**: Multiple approaches (joins, subqueries, relational queries)\n5. **Composite Unique Constraint**: Properly defined using Drizzle's `unique()` helper\n\n## Running Migrations\n\n```bash\n# Generate migration from schema\nnpx drizzle-kit generate\n\n# Apply migrations\nnpx drizzle-kit migrate\n```\n\nThis implementation provides a solid foundation for working with your schema using Drizzle ORM with full type safety and idiomatic patterns.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24792,
            "output_tokens": 1986,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Drizzle ORM Schema and Queries for Neon\n\nHere's a complete Drizzle ORM implementation for your schema with typed query functions.\n\n## 1. Install Dependencies\n\n```bash\nnpm install drizzle-orm @neondatabase/serverless\nnpm install -D drizzle-kit\n```\n\n## 2. Schema Definition\n\nCreate `src/db/schema.ts`:\n\n```typescript\nimport { pgTable, serial, varchar, integer, timestamp } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\n// Organizations table\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n});\n\n// Define relations for type-safe joins\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// TypeScript types inferred from schema\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## 3. Database Connection\n\nCreate `src/db/client.ts`:\n\n```typescript\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport { neon } from '@neondatabase/serverless';\nimport * as schema from './schema';\n\nif (!process.env.DATABASE_URL) {\n  throw new Error('DATABASE_URL environment variable is required');\n}\n\n// Create Neon HTTP client\nconst sql = neon(process.env.DATABASE_URL);\n\n// Create Drizzle instance with schema\nexport const db = drizzle(sql, { schema });\n```\n\n## 4. Query Functions\n\nCreate `src/db/queries.ts`:\n\n```typescript\nimport { eq, sql, count } from 'drizzle-orm';\nimport { db } from './client';\nimport { organizations, members, type Member, type NewMember } from './schema';\n\n/**\n * List all members of an organization by org ID\n */\nexport async function listOrgMembers(orgId: number): Promise<Member[]> {\n  return db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List all members of an organization by slug (with join)\n */\nexport async function listOrgMembersBySlug(slug: string): Promise<Member[]> {\n  return db\n    .select({\n      id: members.id,\n      orgId: members.orgId,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .innerJoin(organizations, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n * Returns the created member or null if org doesn't exist\n */\nexport async function addMember(\n  orgId: number,\n  email: string,\n  role: string = 'member'\n): Promise<Member | null> {\n  try {\n    const [member] = await db\n      .insert(members)\n      .values({\n        orgId,\n        email,\n        role,\n      })\n      .returning();\n    \n    return member;\n  } catch (error) {\n    // Handle unique constraint violation (duplicate email in org)\n    if (error instanceof Error && error.message.includes('unique')) {\n      throw new Error(`Member with email ${email} already exists in this organization`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(slug: string) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Get organization with all members (using relations)\n */\nexport async function getOrgWithMembers(orgId: number) {\n  return db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n## 5. Usage Examples\n\nCreate `src/examples.ts`:\n\n```typescript\nimport {\n  listOrgMembers,\n  addMember,\n  getOrgWithMemberCount,\n  getOrgWithMembers,\n} from './db/queries';\n\nasync function examples() {\n  // List all members of organization with ID 1\n  const members = await listOrgMembers(1);\n  console.log('Members:', members);\n\n  // Add a new member\n  try {\n    const newMember = await addMember(1, 'alice@example.com', 'admin');\n    console.log('Added member:', newMember);\n  } catch (error) {\n    console.error('Failed to add member:', error);\n  }\n\n  // Get org details with member count\n  const orgDetails = await getOrgWithMemberCount(1);\n  console.log('Organization:', orgDetails);\n  // Output: { id: 1, name: '...', slug: '...', createdAt: ..., memberCount: 5 }\n\n  // Get org with all members (using relations)\n  const orgWithMembers = await getOrgWithMembers(1);\n  console.log('Org with members:', orgWithMembers);\n  // Output: { id: 1, name: '...', members: [...] }\n}\n\nexamples().catch(console.error);\n```\n\n## 6. Drizzle Configuration\n\nCreate `drizzle.config.ts` for migrations:\n\n```typescript\nimport type { Config } from 'drizzle-kit';\n\nexport default {\n  schema: './src/db/schema.ts',\n  out: './drizzle',\n  dialect: 'postgresql',\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n} satisfies Config;\n```\n\n## 7. Environment Variables\n\nCreate `.env`:\n\n```bash\n# Get your connection string from Neon Console\nDATABASE_URL=\"postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/dbname?sslmode=require\"\n```\n\n## Key Features\n\n\u2705 **Type-safe queries** - Full TypeScript inference  \n\u2705 **Relations** - Type-safe joins using `with` syntax  \n\u2705 **Aggregations** - Member count using `count()`  \n\u2705 **Error handling** - Unique constraint violations  \n\u2705 **Flexible queries** - By ID or slug  \n\u2705 **Neon HTTP driver** - Optimized for serverless/edge\n\n## Additional Query Patterns\n\n```typescript\n// Update member role\nexport async function updateMemberRole(memberId: number, newRole: string) {\n  const [updated] = await db\n    .update(members)\n    .set({ role: newRole })\n    .where(eq(members.id, memberId))\n    .returning();\n  return updated;\n}\n\n// Remove member\nexport async function removeMember(memberId: number) {\n  await db.delete(members).where(eq(members.id, memberId));\n}\n\n// Search members by email pattern\nexport async function searchMembers(emailPattern: string) {\n  return db\n    .select()\n    .from(members)\n    .where(sql`${members.email} ILIKE ${`%${emailPattern}%`}`);\n}\n```\n\nFor more Drizzle patterns with Neon, see the [Drizzle guide](https://neon.com/docs/guides/drizzle.md).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2344,
            "output_tokens": 2401,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a complete Drizzle ORM setup with schema definitions, relations, and typed query functions.\n\n```typescript\n// src/lib/db/schema.ts\nimport {\n  pgTable,\n  serial,\n  varchar,\n  timestamp,\n  integer,\n  unique,\n} from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable(\n  \"members\",\n  {\n    id: serial(\"id\").primaryKey(),\n    orgId: integer(\"org_id\")\n      .notNull()\n      .references(() => organizations.id, { onDelete: \"cascade\" }),\n    email: varchar(\"email\", { length: 255 }).notNull(),\n    role: varchar(\"role\", { length: 50 }).default(\"member\"),\n    joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => ({\n    uniqueOrgEmail: unique().on(table.orgId, table.email),\n  }),\n);\n\n// Relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Inferred types\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n```typescript\n// src/lib/db/client.ts\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { Pool } from \"pg\";\nimport * as schema from \"./schema\";\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle({ client: pool, schema });\n```\n\n```typescript\n// src/lib/db/queries.ts\nimport { eq, sql } from \"drizzle-orm\";\nimport { db } from \"./client\";\nimport { organizations, members, type NewMember } from \"./schema\";\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a member to an organization\n */\nexport async function addMember(member: NewMember) {\n  const [newMember] = await db\n    .insert(members)\n    .values(member)\n    .returning({\n      id: members.id,\n      orgId: members.orgId,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    });\n\n  return newMember;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id)\n    .limit(1);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(slug: string) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id)\n    .limit(1);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get member by email within an organization\n */\nexport async function getMemberByEmail(orgId: number, email: string) {\n  const [member] = await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .where(eq(members.email, email))\n    .limit(1);\n\n  return member ?? null;\n}\n```\n\n```typescript\n// drizzle.config.ts\nimport { config } from \"dotenv\";\nimport { defineConfig } from \"drizzle-kit\";\n\nconfig({ path: \".env.local\" });\n\nexport default defineConfig({\n  schema: \"./src/lib/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n```typescript\n// Example usage in an API route: src/app/api/orgs/[orgId]/members/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { listOrgMembers, addMember } from \"@/lib/db/queries\";\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ orgId: string }> },\n) {\n  const { orgId } = await params;\n  const members = await listOrgMembers(parseInt(orgId));\n  return NextResponse.json({ data: members });\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ orgId: string }> },\n) {\n  const { orgId } = await params;\n  const body = await request.json();\n\n  try {\n    const member = await addMember({\n      orgId: parseInt(orgId),\n      email: body.email,\n      role: body.role ?? \"member\",\n    });\n    return NextResponse.json({ data: member }, { status: 201 });\n  } catch (error: any) {\n    // Handle unique constraint violation\n    if (error.code === \"23505\") {\n      return NextResponse.json(\n        { error: \"Member already exists in this organization\" },\n        { status: 409 },\n      );\n    }\n    return NextResponse.json(\n      { error: \"Failed to add member\" },\n      { status: 500 },\n    );\n  }\n}\n```\n\n**Key features:**\n\n1. **Proper schema definition** with all constraints (unique, foreign keys, cascading deletes)\n2. **Relations defined** for type-safe joins\n3. **Inferred types** exported for use throughout the app\n4. **Typed query functions** with proper return types\n5. **SQL aggregation** for member count using `sql` template\n6. **Error handling** for unique constraint violations\n7. **Drizzle config** ready for migrations\n\nTo use this:\n\n```bash\n# Install dependencies\npnpm add drizzle-orm pg\npnpm add -D drizzle-kit @types/pg\n\n# Generate migrations\npnpm drizzle-kit generate\n\n# Apply migrations\npnpm drizzle-kit migrate\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25287,
            "output_tokens": 1967,
            "cached": true
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "```typescript\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { \n  pgTable, \n  serial, \n  varchar, \n  integer, \n  timestamp,\n  unique\n} from 'drizzle-orm/pg-core';\nimport { relations, eq, sql } from 'drizzle-orm';\nimport { InferSelectModel, InferInsertModel } from 'drizzle-orm';\nimport { Pool } from 'pg';\n\n// ============================================\n// Schema Definitions\n// ============================================\n\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  // Composite unique constraint\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// ============================================\n// Relations\n// ============================================\n\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// ============================================\n// Types\n// ============================================\n\nexport type Organization = InferSelectModel<typeof organizations>;\nexport type NewOrganization = InferInsertModel<typeof organizations>;\n\nexport type Member = InferSelectModel<typeof members>;\nexport type NewMember = InferInsertModel<typeof members>;\n\nexport type OrganizationWithMemberCount = Organization & {\n  memberCount: number;\n};\n\n// ============================================\n// Database Setup\n// ============================================\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle(pool);\n\n// ============================================\n// Query Functions\n// ============================================\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  const result = await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n  \n  return result;\n}\n\n/**\n * List all members with organization details (using relations)\n */\nexport async function listOrgMembersWithDetails(orgId: number) {\n  const result = await db.query.members.findMany({\n    where: eq(members.orgId, orgId),\n    with: {\n      organization: true,\n    },\n    orderBy: (members, { asc }) => [asc(members.joinedAt)],\n  });\n  \n  return result;\n}\n\n/**\n * Add a new member to an organization\n */\nexport async function addMember(\n  orgId: number, \n  email: string, \n  role: string = 'member'\n): Promise<Member> {\n  const result = await db\n    .insert(members)\n    .values({\n      orgId,\n      email,\n      role,\n    })\n    .returning();\n  \n  return result[0];\n}\n\n/**\n * Add multiple members at once\n */\nexport async function addMembers(\n  newMembers: NewMember[]\n): Promise<Member[]> {\n  const result = await db\n    .insert(members)\n    .values(newMembers)\n    .returning();\n  \n  return result;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(\n  orgId: number\n): Promise<OrganizationWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n  \n  return result[0] || null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(\n  slug: string\n): Promise<OrganizationWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n  \n  return result[0] || null;\n}\n\n/**\n * Get all organizations with their member counts\n */\nexport async function getAllOrgsWithMemberCount(): Promise<OrganizationWithMemberCount[]> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .groupBy(organizations.id)\n    .orderBy(organizations.name);\n  \n  return result;\n}\n\n/**\n * Remove a member from an organization\n */\nexport async function removeMember(memberId: number): Promise<void> {\n  await db\n    .delete(members)\n    .where(eq(members.id, memberId));\n}\n\n/**\n * Update member role\n */\nexport async function updateMemberRole(\n  memberId: number, \n  newRole: string\n): Promise<Member> {\n  const result = await db\n    .update(members)\n    .set({ role: newRole })\n    .where(eq(members.id, memberId))\n    .returning();\n  \n  return result[0];\n}\n\n// ============================================\n// Usage Examples\n// ============================================\n\n/*\n// Example 1: List all members of an organization\nconst orgMembers = await listOrgMembers(1);\nconsole.log(orgMembers);\n\n// Example 2: Add a new member\nconst newMember = await addMember(1, 'user@example.com', 'admin');\nconsole.log(newMember);\n\n// Example 3: Get organization with member count\nconst orgDetails = await getOrgWithMemberCount(1);\nconsole.log(orgDetails);\n// Output: { id: 1, name: 'Acme Corp', slug: 'acme', createdAt: ..., memberCount: 5 }\n\n// Example 4: Get organization by slug\nconst org = await getOrgBySlugWithMemberCount('acme');\nconsole.log(org);\n\n// Example 5: Add multiple members\nconst bulkMembers = await addMembers([\n  { orgId: 1, email: 'user1@example.com', role: 'member' },\n  { orgId: 1, email: 'user2@example.com', role: 'admin' },\n]);\n\n// Example 6: Update member role\nconst updatedMember = await updateMemberRole(1, 'admin');\n*/\n```\n\nThis code provides:\n\n1. **Complete schema definitions** with proper types and constraints\n2. **Relations** for easy querying with joins\n3. **Type safety** using TypeScript inference\n4. **Query functions** for common operations:\n   - Listing members\n   - Adding members (single and bulk)\n   - Getting org details with member count\n   - Updating and removing members\n5. **Flexible queries** using both the query builder and relational query API\n\nThe schema properly handles the CASCADE delete and composite unique constraint from your SQL definition.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 202,
            "output_tokens": 2143,
            "cached": true
          },
          "with_skill": {
            "output": "# Drizzle ORM Schema and Query Functions\n\nHere's a complete implementation with schema definitions, relations, and typed query functions:\n\n## Schema Definition\n\n```typescript\n// src/db/schema.ts\nimport { relations } from \"drizzle-orm\";\nimport {\n  pgTable,\n  serial,\n  varchar,\n  timestamp,\n  integer,\n  unique,\n} from \"drizzle-orm/pg-core\";\n\n// Organizations table\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable(\n  \"members\",\n  {\n    id: serial(\"id\").primaryKey(),\n    orgId: integer(\"org_id\")\n      .notNull()\n      .references(() => organizations.id, { onDelete: \"cascade\" }),\n    email: varchar(\"email\", { length: 255 }).notNull(),\n    role: varchar(\"role\", { length: 50 }).default(\"member\").notNull(),\n    joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => ({\n    // Composite unique constraint\n    uniqueOrgEmail: unique().on(table.orgId, table.email),\n  }),\n);\n\n// Relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## Database Client Setup\n\n```typescript\n// src/db/client.ts\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { Pool } from \"pg\";\nimport * as schema from \"./schema\";\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle({ client: pool, schema });\n```\n\n## Query Functions\n\n```typescript\n// src/db/queries.ts\nimport { eq, sql, count } from \"drizzle-orm\";\nimport { db } from \"./client\";\nimport { organizations, members, type NewMember } from \"./schema\";\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n */\nexport async function addMember(data: {\n  orgId: number;\n  email: string;\n  role?: string;\n}) {\n  const [newMember] = await db\n    .insert(members)\n    .values({\n      orgId: data.orgId,\n      email: data.email,\n      role: data.role ?? \"member\",\n    })\n    .returning();\n\n  return newMember;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const [result] = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result;\n}\n\n/**\n * Alternative: Get org with member count using subquery\n */\nexport async function getOrgWithMemberCountSubquery(orgId: number) {\n  const [org] = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`(\n        SELECT COUNT(*)::int \n        FROM ${members} \n        WHERE ${members.orgId} = ${organizations.id}\n      )`.as(\"member_count\"),\n    })\n    .from(organizations)\n    .where(eq(organizations.id, orgId));\n\n  return org;\n}\n\n/**\n * Get organization by slug with all members (using relations)\n */\nexport async function getOrgBySlugWithMembers(slug: string) {\n  return await db.query.organizations.findFirst({\n    where: eq(organizations.slug, slug),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n## Usage Examples\n\n```typescript\n// src/examples.ts\nimport {\n  listOrgMembers,\n  addMember,\n  getOrgWithMemberCount,\n  getOrgBySlugWithMembers,\n} from \"./db/queries\";\n\nasync function examples() {\n  // List all members of org with ID 1\n  const members = await listOrgMembers(1);\n  console.log(\"Members:\", members);\n\n  // Add a new member\n  const newMember = await addMember({\n    orgId: 1,\n    email: \"user@example.com\",\n    role: \"admin\",\n  });\n  console.log(\"New member:\", newMember);\n\n  // Get org details with member count\n  const orgDetails = await getOrgWithMemberCount(1);\n  console.log(\"Organization:\", orgDetails);\n  // Output: { id: 1, name: \"...\", slug: \"...\", createdAt: ..., memberCount: 5 }\n\n  // Get org by slug with all members\n  const orgWithMembers = await getOrgBySlugWithMembers(\"acme-corp\");\n  console.log(\"Org with members:\", orgWithMembers);\n  // Output: { id: 1, name: \"...\", members: [...] }\n}\n```\n\n## Error Handling\n\n```typescript\n// src/db/queries.ts (continued)\nimport { DatabaseError } from \"pg\";\n\n/**\n * Add member with error handling\n */\nexport async function addMemberSafe(data: {\n  orgId: number;\n  email: string;\n  role?: string;\n}) {\n  try {\n    return await addMember(data);\n  } catch (error) {\n    if (error instanceof DatabaseError) {\n      // Handle unique constraint violation (duplicate email in org)\n      if (error.code === \"23505\") {\n        throw new Error(\n          `Member with email ${data.email} already exists in this organization`,\n        );\n      }\n      // Handle foreign key violation (org doesn't exist)\n      if (error.code === \"23503\") {\n        throw new Error(`Organization with ID ${data.orgId} does not exist`);\n      }\n    }\n    throw error;\n  }\n}\n```\n\n## Drizzle Config\n\n```typescript\n// drizzle.config.ts\nimport { config } from \"dotenv\";\nimport { defineConfig } from \"drizzle-kit\";\n\nconfig({ path: \".env.local\" });\n\nexport default defineConfig({\n  schema: \"./src/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n## Key Features\n\n1. **Type Safety**: Full TypeScript inference for queries and results\n2. **Relations**: Defined for easy joins and nested queries\n3. **Composite Unique Constraint**: Enforces one email per org\n4. **Cascade Delete**: Members are deleted when org is deleted\n5. **Default Values**: Automatic timestamps and default role\n6. **Multiple Query Patterns**: Joins, subqueries, and relational queries\n7. **Error Handling**: Handles unique violations and FK constraints\n\n## Running Migrations\n\n```bash\n# Generate migration files\nnpx drizzle-kit generate\n\n# Apply migrations\nnpx drizzle-kit migrate\n```\n\nThis implementation provides a complete, type-safe foundation for working with your database schema using Drizzle ORM.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24792,
            "output_tokens": 2150,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Drizzle ORM Schema and Query Functions\n\nHere's a complete implementation with Drizzle ORM for your database schema:\n\n## 1. Schema Definition\n\n```typescript\n// db/schema.ts\nimport { pgTable, serial, varchar, timestamp, integer, unique } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\n// Organizations table\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  // Composite unique constraint\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// Define relations for type-safe joins\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type exports\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## 2. Database Connection Setup\n\n```typescript\n// db/index.ts\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport { neon } from '@neondatabase/serverless';\nimport * as schema from './schema';\n\n// Get connection string from environment\nconst sql = neon(process.env.DATABASE_URL!);\n\n// Create Drizzle instance with schema\nexport const db = drizzle(sql, { schema });\n```\n\n## 3. Query Functions\n\n```typescript\n// db/queries.ts\nimport { eq, sql, count } from 'drizzle-orm';\nimport { db } from './index';\nimport { organizations, members, type NewMember } from './schema';\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a member to an organization\n */\nexport async function addMember(data: {\n  orgId: number;\n  email: string;\n  role?: string;\n}) {\n  const newMember: NewMember = {\n    orgId: data.orgId,\n    email: data.email,\n    role: data.role || 'member',\n  };\n\n  const [member] = await db\n    .insert(members)\n    .values(newMember)\n    .returning();\n\n  return member;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Alternative: Get org with member count using subquery\n */\nexport async function getOrgWithMemberCountAlt(orgId: number) {\n  const org = await db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        columns: { id: true },\n      },\n    },\n  });\n\n  if (!org) return null;\n\n  return {\n    ...org,\n    memberCount: org.members.length,\n    members: undefined, // Remove members array from result\n  };\n}\n\n/**\n * Bonus: Get org by slug with full member details\n */\nexport async function getOrgBySlugWithMembers(slug: string) {\n  return await db.query.organizations.findFirst({\n    where: eq(organizations.slug, slug),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n## 4. Usage Examples\n\n```typescript\n// Example usage in your application\nimport { \n  listOrgMembers, \n  addMember, \n  getOrgWithMemberCount,\n  getOrgBySlugWithMembers \n} from './db/queries';\n\n// List members\nconst members = await listOrgMembers(1);\nconsole.log('Members:', members);\n\n// Add a new member\nconst newMember = await addMember({\n  orgId: 1,\n  email: 'user@example.com',\n  role: 'admin',\n});\nconsole.log('Added member:', newMember);\n\n// Get org with member count\nconst orgDetails = await getOrgWithMemberCount(1);\nconsole.log('Organization:', orgDetails);\n// Output: { id: 1, name: '...', slug: '...', createdAt: ..., memberCount: 5 }\n\n// Get org by slug with all members\nconst orgWithMembers = await getOrgBySlugWithMembers('acme-corp');\nconsole.log('Org with members:', orgWithMembers);\n```\n\n## 5. Package Dependencies\n\n```json\n{\n  \"dependencies\": {\n    \"@neondatabase/serverless\": \"^0.10.4\",\n    \"drizzle-orm\": \"^0.36.4\"\n  },\n  \"devDependencies\": {\n    \"drizzle-kit\": \"^0.28.1\"\n  }\n}\n```\n\n## 6. Drizzle Configuration\n\n```typescript\n// drizzle.config.ts\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  schema: './db/schema.ts',\n  out: './drizzle',\n  dialect: 'postgresql',\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n## Key Features\n\n\u2705 **Type-safe schema** with proper TypeScript types  \n\u2705 **Relations defined** for relational queries  \n\u2705 **Composite unique constraint** on `(org_id, email)`  \n\u2705 **Cascade delete** configured on foreign key  \n\u2705 **Query functions** with proper typing and error handling  \n\u2705 **Multiple query patterns** (select builder + relational queries)  \n\u2705 **Neon HTTP driver** for serverless/edge compatibility\n\n## Additional Query Patterns\n\nFor more complex queries, refer to the [Drizzle ORM documentation](https://neon.com/docs/guides/drizzle.md) and [Drizzle's query examples](https://orm.drizzle.team/docs/rqb).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2344,
            "output_tokens": 1947,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a complete Drizzle ORM setup for your schema with typed query functions.\n\n```typescript\n// src/lib/db/schema.ts\nimport {\n  pgTable,\n  serial,\n  varchar,\n  timestamp,\n  integer,\n  unique,\n} from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable(\n  \"members\",\n  {\n    id: serial(\"id\").primaryKey(),\n    orgId: integer(\"org_id\")\n      .notNull()\n      .references(() => organizations.id, { onDelete: \"cascade\" }),\n    email: varchar(\"email\", { length: 255 }).notNull(),\n    role: varchar(\"role\", { length: 50 }).default(\"member\").notNull(),\n    joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => ({\n    uniqueOrgEmail: unique().on(table.orgId, table.email),\n  }),\n);\n\n// Define relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n```typescript\n// src/lib/db/client.ts\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { Pool } from \"pg\";\nimport * as schema from \"./schema\";\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle({ client: pool, schema });\n```\n\n```typescript\n// src/lib/db/queries.ts\nimport { eq, sql } from \"drizzle-orm\";\nimport { db } from \"./client\";\nimport { organizations, members, type NewMember, type Member } from \"./schema\";\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number): Promise<Member[]> {\n  return db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n */\nexport async function addMember(\n  member: NewMember,\n): Promise<Member | { error: string }> {\n  try {\n    const [newMember] = await db\n      .insert(members)\n      .values(member)\n      .returning();\n    \n    return newMember;\n  } catch (error: any) {\n    // Handle unique constraint violation (duplicate email in org)\n    if (error.code === \"23505\") {\n      return { error: \"Member with this email already exists in the organization\" };\n    }\n    // Handle foreign key violation (org doesn't exist)\n    if (error.code === \"23503\") {\n      return { error: \"Organization not found\" };\n    }\n    throw error;\n  }\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(slug: string) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get organization with all members (using relations)\n */\nexport async function getOrgWithMembers(orgId: number) {\n  return db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n```typescript\n// drizzle.config.ts\nimport { config } from \"dotenv\";\nimport { defineConfig } from \"drizzle-kit\";\n\nconfig({ path: \".env.local\" });\n\nexport default defineConfig({\n  schema: \"./src/lib/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n```typescript\n// Example usage in an API route or server component\nimport { listOrgMembers, addMember, getOrgWithMemberCount } from \"@/lib/db/queries\";\n\n// List members\nconst members = await listOrgMembers(1);\n\n// Add a member\nconst result = await addMember({\n  orgId: 1,\n  email: \"user@example.com\",\n  role: \"admin\",\n});\n\nif (\"error\" in result) {\n  console.error(result.error);\n} else {\n  console.log(\"Member added:\", result);\n}\n\n// Get org with member count\nconst org = await getOrgWithMemberCount(1);\nconsole.log(`${org?.name} has ${org?.memberCount} members`);\n```\n\n**Key features:**\n\n1. **Proper type inference** - `Organization`, `Member`, `NewMember` types\n2. **Relations defined** - Can use relational queries with `.with()`\n3. **Error handling** - Catches unique constraint and FK violations\n4. **Multiple query patterns** - Both SQL-style and relational queries\n5. **Type-safe** - Full TypeScript support throughout\n\n**To use:**\n```bash\nnpm install drizzle-orm pg\nnpm install -D drizzle-kit @types/pg\n\n# Generate migrations\nnpx drizzle-kit generate\n\n# Apply migrations\nnpx drizzle-kit migrate\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25287,
            "output_tokens": 1788,
            "cached": true
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "```typescript\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { \n  pgTable, \n  serial, \n  varchar, \n  integer, \n  timestamp,\n  unique\n} from 'drizzle-orm/pg-core';\nimport { relations, eq, sql } from 'drizzle-orm';\nimport { InferSelectModel, InferInsertModel } from 'drizzle-orm';\nimport { Pool } from 'pg';\n\n// ============================================\n// Schema Definitions\n// ============================================\n\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// ============================================\n// Relations\n// ============================================\n\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// ============================================\n// Types\n// ============================================\n\nexport type Organization = InferSelectModel<typeof organizations>;\nexport type NewOrganization = InferInsertModel<typeof organizations>;\n\nexport type Member = InferSelectModel<typeof members>;\nexport type NewMember = InferInsertModel<typeof members>;\n\nexport type OrganizationWithMemberCount = Organization & {\n  memberCount: number;\n};\n\n// ============================================\n// Database Setup\n// ============================================\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle(pool);\n\n// ============================================\n// Query Functions\n// ============================================\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List all members with organization details\n */\nexport async function listOrgMembersWithDetails(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n      organization: {\n        id: organizations.id,\n        name: organizations.name,\n        slug: organizations.slug,\n      },\n    })\n    .from(members)\n    .innerJoin(organizations, eq(members.orgId, organizations.id))\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a member to an organization\n */\nexport async function addMember(\n  orgId: number, \n  email: string, \n  role: string = 'member'\n) {\n  const [newMember] = await db\n    .insert(members)\n    .values({\n      orgId,\n      email,\n      role,\n    })\n    .returning();\n  \n  return newMember;\n}\n\n/**\n * Add a member with error handling for duplicates\n */\nexport async function addMemberSafe(\n  orgId: number, \n  email: string, \n  role: string = 'member'\n): Promise<{ success: boolean; member?: Member; error?: string }> {\n  try {\n    const member = await addMember(orgId, email, role);\n    return { success: true, member };\n  } catch (error: any) {\n    if (error.code === '23505') { // Unique violation\n      return { \n        success: false, \n        error: 'Member with this email already exists in the organization' \n      };\n    }\n    throw error;\n  }\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(\n  orgId: number\n): Promise<OrganizationWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(\n  slug: string\n): Promise<OrganizationWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Get all organizations with their member counts\n */\nexport async function getAllOrgsWithMemberCount(): Promise<OrganizationWithMemberCount[]> {\n  return await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .groupBy(organizations.id)\n    .orderBy(organizations.name);\n}\n\n// ============================================\n// Usage Examples\n// ============================================\n\n/*\n// List members\nconst members = await listOrgMembers(1);\n\n// Add a member\nconst newMember = await addMember(1, 'user@example.com', 'admin');\n\n// Add member with safety\nconst result = await addMemberSafe(1, 'user@example.com');\nif (result.success) {\n  console.log('Member added:', result.member);\n} else {\n  console.error('Error:', result.error);\n}\n\n// Get org with member count\nconst org = await getOrgWithMemberCount(1);\nconsole.log(`${org?.name} has ${org?.memberCount} members`);\n\n// Get org by slug\nconst orgBySlug = await getOrgBySlugWithMemberCount('acme-corp');\n*/\n```\n\nThis code provides:\n\n1. **Proper schema definitions** with all constraints (foreign keys, unique constraints, defaults)\n2. **Relations** for easy joins between tables\n3. **Type safety** with inferred types for select and insert operations\n4. **Query functions** for:\n   - Listing organization members\n   - Adding members (with safe variant for duplicate handling)\n   - Getting organization details with member counts\n   - Multiple lookup methods (by ID and slug)\n5. **Proper SQL aggregation** using Drizzle's `sql` template for counting members\n6. **Usage examples** in comments",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 202,
            "output_tokens": 2016,
            "cached": true
          },
          "with_skill": {
            "output": "# Drizzle ORM Schema and Query Functions\n\nHere's a complete implementation with schema definitions, relations, and typed query functions:\n\n## Schema Definition\n\n```typescript\n// src/db/schema.ts\nimport {\n  pgTable,\n  serial,\n  varchar,\n  timestamp,\n  integer,\n  unique,\n} from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\n// Organizations table\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable(\n  \"members\",\n  {\n    id: serial(\"id\").primaryKey(),\n    orgId: integer(\"org_id\")\n      .notNull()\n      .references(() => organizations.id, { onDelete: \"cascade\" }),\n    email: varchar(\"email\", { length: 255 }).notNull(),\n    role: varchar(\"role\", { length: 50 }).default(\"member\").notNull(),\n    joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => ({\n    // Composite unique constraint\n    uniqueOrgEmail: unique().on(table.orgId, table.email),\n  }),\n);\n\n// Relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## Database Client Setup\n\n```typescript\n// src/db/client.ts\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { Pool } from \"pg\";\nimport * as schema from \"./schema\";\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle({ client: pool, schema });\n```\n\n## Query Functions\n\n```typescript\n// src/db/queries.ts\nimport { eq, sql, count } from \"drizzle-orm\";\nimport { db } from \"./client\";\nimport { organizations, members, type NewMember } from \"./schema\";\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n      orgId: members.orgId,\n    })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List members with organization details\n */\nexport async function listOrgMembersWithOrg(orgId: number) {\n  return await db\n    .select({\n      member: members,\n      organization: organizations,\n    })\n    .from(members)\n    .innerJoin(organizations, eq(members.orgId, organizations.id))\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a member to an organization\n */\nexport async function addMember(memberData: NewMember) {\n  const [newMember] = await db\n    .insert(members)\n    .values(memberData)\n    .returning();\n\n  return newMember;\n}\n\n/**\n * Add a member with conflict handling\n */\nexport async function addMemberSafe(\n  orgId: number,\n  email: string,\n  role: string = \"member\",\n) {\n  try {\n    return await addMember({ orgId, email, role });\n  } catch (error: any) {\n    // Handle unique constraint violation (duplicate email in org)\n    if (error.code === \"23505\") {\n      throw new Error(`Member with email ${email} already exists in this organization`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const [result] = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(slug: string) {\n  const [result] = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result;\n}\n\n/**\n * Get organization with all members (using relations)\n */\nexport async function getOrgWithMembers(orgId: number) {\n  return await db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n## Usage Examples\n\n```typescript\n// src/examples.ts\nimport {\n  listOrgMembers,\n  addMember,\n  addMemberSafe,\n  getOrgWithMemberCount,\n  getOrgBySlugWithMemberCount,\n  getOrgWithMembers,\n} from \"./db/queries\";\n\n// Example 1: List all members of an organization\nasync function example1() {\n  const members = await listOrgMembers(1);\n  console.log(\"Members:\", members);\n  // Returns: Array of member objects with full type safety\n}\n\n// Example 2: Add a new member\nasync function example2() {\n  const newMember = await addMember({\n    orgId: 1,\n    email: \"user@example.com\",\n    role: \"admin\",\n  });\n  console.log(\"New member:\", newMember);\n  // Returns: { id: 123, orgId: 1, email: \"user@example.com\", role: \"admin\", joinedAt: Date }\n}\n\n// Example 3: Add member with error handling\nasync function example3() {\n  try {\n    const member = await addMemberSafe(1, \"user@example.com\", \"member\");\n    console.log(\"Member added:\", member);\n  } catch (error) {\n    console.error(\"Failed to add member:\", error.message);\n  }\n}\n\n// Example 4: Get org details with member count\nasync function example4() {\n  const org = await getOrgWithMemberCount(1);\n  console.log(`${org.name} has ${org.memberCount} members`);\n  // Returns: { id: 1, name: \"Acme Corp\", slug: \"acme\", createdAt: Date, memberCount: 5 }\n}\n\n// Example 5: Get org by slug with member count\nasync function example5() {\n  const org = await getOrgBySlugWithMemberCount(\"acme\");\n  if (!org) {\n    console.log(\"Organization not found\");\n    return;\n  }\n  console.log(`Found: ${org.name} with ${org.memberCount} members`);\n}\n\n// Example 6: Get org with nested members (using relations)\nasync function example6() {\n  const org = await getOrgWithMembers(1);\n  if (!org) {\n    console.log(\"Organization not found\");\n    return;\n  }\n  console.log(`${org.name} members:`, org.members);\n  // Returns: { id: 1, name: \"Acme\", slug: \"acme\", members: [...] }\n}\n```\n\n## Drizzle Config\n\n```typescript\n// drizzle.config.ts\nimport { config } from \"dotenv\";\nimport { defineConfig } from \"drizzle-kit\";\n\nconfig({ path: \".env.local\" });\n\nexport default defineConfig({\n  schema: \"./src/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n## Key Features\n\n1. **Full Type Safety**: All queries return properly typed results\n2. **Relations**: Defined for easy nested queries\n3. **Composite Unique Constraint**: Enforces unique email per organization\n4. **Cascade Delete**: Members are automatically deleted when org is deleted\n5. **Default Values**: Role defaults to \"member\", timestamps auto-populate\n6. **Error Handling**: Safe insert function handles duplicate email errors\n7. **Multiple Query Patterns**: Both SQL-style and relational query API examples\n\n## Running Migrations\n\n```bash\n# Generate migration files\nnpx drizzle-kit generate\n\n# Apply migrations to database\nnpx drizzle-kit migrate\n```\n\nThis implementation provides a complete, production-ready setup for working with these tables using Drizzle ORM with Neon Postgres.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24792,
            "output_tokens": 2444,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Drizzle ORM Schema and Queries for Neon\n\nHere's a complete implementation with Drizzle ORM schema definitions, relations, and typed query functions:\n\n## 1. Schema Definition\n\n```typescript\n// db/schema.ts\nimport { pgTable, serial, varchar, timestamp, integer, unique } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\n// Organizations table\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  // Composite unique constraint\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// Define relations for type-safe joins\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type exports for use in application code\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## 2. Database Connection Setup\n\n```typescript\n// db/index.ts\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport { neon } from '@neondatabase/serverless';\nimport * as schema from './schema';\n\n// Get connection string from environment\nconst sql = neon(process.env.DATABASE_URL!);\n\n// Create Drizzle instance with schema for relational queries\nexport const db = drizzle(sql, { schema });\n```\n\n## 3. Query Functions\n\n```typescript\n// db/queries.ts\nimport { eq, sql, count } from 'drizzle-orm';\nimport { db } from './index';\nimport { organizations, members, type NewMember } from './schema';\n\n/**\n * List all members of an organization by org ID\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List all members with organization details (using relations)\n */\nexport async function listOrgMembersWithDetails(orgId: number) {\n  return await db.query.members.findMany({\n    where: eq(members.orgId, orgId),\n    with: {\n      organization: {\n        columns: {\n          name: true,\n          slug: true,\n        },\n      },\n    },\n    orderBy: (members, { asc }) => [asc(members.joinedAt)],\n  });\n}\n\n/**\n * Add a new member to an organization\n */\nexport async function addMember(memberData: NewMember) {\n  const [newMember] = await db\n    .insert(members)\n    .values(memberData)\n    .returning();\n  \n  return newMember;\n}\n\n/**\n * Add a member with conflict handling (upsert pattern)\n */\nexport async function addOrUpdateMember(memberData: NewMember) {\n  const [member] = await db\n    .insert(members)\n    .values(memberData)\n    .onConflictDoUpdate({\n      target: [members.orgId, members.email],\n      set: {\n        role: memberData.role,\n        joinedAt: sql`NOW()`,\n      },\n    })\n    .returning();\n  \n  return member;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Get organization by slug with member count (using relational query)\n */\nexport async function getOrgBySlugWithMembers(slug: string) {\n  const org = await db.query.organizations.findFirst({\n    where: eq(organizations.slug, slug),\n    with: {\n      members: {\n        columns: {\n          id: true,\n          email: true,\n          role: true,\n          joinedAt: true,\n        },\n      },\n    },\n  });\n\n  if (!org) return null;\n\n  return {\n    ...org,\n    memberCount: org.members.length,\n  };\n}\n\n/**\n * Get all organizations with their member counts\n */\nexport async function listOrgsWithMemberCounts() {\n  return await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .groupBy(organizations.id)\n    .orderBy(organizations.name);\n}\n```\n\n## 4. Usage Examples\n\n```typescript\n// Example usage in your application\nimport { \n  listOrgMembers, \n  addMember, \n  getOrgWithMemberCount,\n  addOrUpdateMember \n} from './db/queries';\n\n// List members\nconst members = await listOrgMembers(1);\nconsole.log(members);\n// [{ id: 1, email: 'user@example.com', role: 'member', joinedAt: ... }]\n\n// Add a new member\nconst newMember = await addMember({\n  orgId: 1,\n  email: 'newuser@example.com',\n  role: 'admin',\n});\nconsole.log(newMember);\n\n// Add or update member (handles duplicates)\nconst member = await addOrUpdateMember({\n  orgId: 1,\n  email: 'user@example.com',\n  role: 'admin', // Updates role if exists\n});\n\n// Get org with member count\nconst org = await getOrgWithMemberCount(1);\nconsole.log(org);\n// { id: 1, name: 'Acme Corp', slug: 'acme', createdAt: ..., memberCount: 5 }\n```\n\n## 5. Package Dependencies\n\n```json\n{\n  \"dependencies\": {\n    \"@neondatabase/serverless\": \"^0.10.4\",\n    \"drizzle-orm\": \"^0.36.4\"\n  },\n  \"devDependencies\": {\n    \"drizzle-kit\": \"^0.28.1\"\n  }\n}\n```\n\n## 6. Drizzle Configuration\n\n```typescript\n// drizzle.config.ts\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  schema: './db/schema.ts',\n  out: './drizzle',\n  dialect: 'postgresql',\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n## Key Features\n\n1. **Type Safety**: Full TypeScript types inferred from schema\n2. **Relations**: Defined for type-safe joins and nested queries\n3. **Composite Unique Constraint**: Enforces `UNIQUE(org_id, email)`\n4. **Cascade Delete**: Handled via `onDelete: 'cascade'`\n5. **Default Values**: `NOW()` for timestamps, `'member'` for role\n6. **Query Patterns**: Both SQL-style and relational query APIs\n7. **Conflict Handling**: Upsert pattern for duplicate prevention\n\nThis implementation provides a production-ready foundation for working with Drizzle ORM and Neon Postgres. The queries are fully typed and leverage Drizzle's relational query API for cleaner, more maintainable code.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2344,
            "output_tokens": 2251,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a complete Drizzle ORM setup for your schema with typed query functions.\n\n```typescript\n// src/lib/db/schema.ts\nimport {\n  pgTable,\n  serial,\n  varchar,\n  timestamp,\n  integer,\n  unique,\n} from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable(\n  \"members\",\n  {\n    id: serial(\"id\").primaryKey(),\n    orgId: integer(\"org_id\")\n      .notNull()\n      .references(() => organizations.id, { onDelete: \"cascade\" }),\n    email: varchar(\"email\", { length: 255 }).notNull(),\n    role: varchar(\"role\", { length: 50 }).default(\"member\"),\n    joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => ({\n    uniqueOrgEmail: unique().on(table.orgId, table.email),\n  }),\n);\n\n// Relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n```typescript\n// src/lib/db/client.ts\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { Pool } from \"pg\";\nimport * as schema from \"./schema\";\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle({ client: pool, schema });\n```\n\n```typescript\n// src/lib/db/queries.ts\nimport { eq, sql } from \"drizzle-orm\";\nimport { db } from \"./client\";\nimport { organizations, members, type NewMember } from \"./schema\";\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a member to an organization\n */\nexport async function addMember(member: NewMember) {\n  const [newMember] = await db\n    .insert(members)\n    .values(member)\n    .returning();\n  \n  return newMember;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id)\n    .limit(1);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlug(slug: string) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id)\n    .limit(1);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get member by email within an organization\n */\nexport async function getMemberByEmail(orgId: number, email: string) {\n  const [member] = await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .where(eq(members.email, email))\n    .limit(1);\n\n  return member ?? null;\n}\n```\n\n```typescript\n// drizzle.config.ts\nimport { config } from \"dotenv\";\nimport { defineConfig } from \"drizzle-kit\";\n\nconfig({ path: \".env.local\" });\n\nexport default defineConfig({\n  schema: \"./src/lib/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n```typescript\n// Example usage in an API route: src/app/api/orgs/[slug]/members/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { listOrgMembers, addMember, getOrgBySlug } from \"@/lib/db/queries\";\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ slug: string }> },\n) {\n  const { slug } = await params;\n  \n  const org = await getOrgBySlug(slug);\n  if (!org) {\n    return NextResponse.json({ error: \"Organization not found\" }, { status: 404 });\n  }\n\n  const members = await listOrgMembers(org.id);\n  return NextResponse.json({ members });\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ slug: string }> },\n) {\n  const { slug } = await params;\n  \n  const org = await getOrgBySlug(slug);\n  if (!org) {\n    return NextResponse.json({ error: \"Organization not found\" }, { status: 404 });\n  }\n\n  const body = await request.json();\n  const { email, role = \"member\" } = body;\n\n  if (!email) {\n    return NextResponse.json({ error: \"Email is required\" }, { status: 400 });\n  }\n\n  try {\n    const member = await addMember({\n      orgId: org.id,\n      email,\n      role,\n    });\n    \n    return NextResponse.json({ member }, { status: 201 });\n  } catch (error: any) {\n    if (error.code === \"23505\") { // Unique constraint violation\n      return NextResponse.json(\n        { error: \"Member already exists in this organization\" },\n        { status: 409 },\n      );\n    }\n    throw error;\n  }\n}\n```\n\n**Installation:**\n```bash\npnpm add drizzle-orm pg\npnpm add -D drizzle-kit @types/pg\n```\n\n**Generate and run migrations:**\n```bash\n# Generate migration from schema\npnpm drizzle-kit generate\n\n# Apply migrations\npnpm drizzle-kit migrate\n```\n\nThe code includes:\n- \u2705 Full schema definition with proper types and constraints\n- \u2705 Relations for type-safe joins\n- \u2705 Type inference for selects and inserts\n- \u2705 Typed query functions with proper error handling\n- \u2705 Example API route showing real-world usage\n- \u2705 Unique constraint on (org_id, email)\n- \u2705 Cascade delete behavior",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25287,
            "output_tokens": 2018,
            "cached": true
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-05",
      "task_type": "adjacent_domain",
      "target_language": "typescript",
      "expected_patterns": [
        "import.*ioredis|import.*Redis",
        "class Cache|export class Cache",
        "<T>|generic",
        "JSON\\.parse|JSON\\.stringify",
        "get\\(|set\\(",
        "async\\s+"
      ],
      "anti_patterns": [
        "@neondatabase",
        "neon\\(",
        "DATABASE_URL",
        "postgres|pg\\b|sql`",
        "drizzle|prisma",
        "SELECT|INSERT|CREATE TABLE"
      ],
      "pattern_sources": [
        {
          "url": "https://github.com/redis/ioredis#readme",
          "description": "ioredis docs - source of import Redis/ioredis, get/set/del commands, and connection patterns"
        },
        {
          "url": "https://redis.io/docs/latest/commands/",
          "description": "Redis commands reference - source of key-value operations, TTL, and pattern-based key scanning"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html",
          "description": "TypeScript classes - source of class keyword and export class patterns for defining Cache class"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
          "description": "TypeScript generics - source of <T> generic type parameter syntax for type-safe get/set methods"
        },
        {
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
          "description": "JSON object documentation - source of JSON.parse() and JSON.stringify() for serialization/deserialization"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Redis Caching Layer Utility Module\n\n```typescript\n// cache.ts\nimport Redis, { Redis as RedisClient, RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig extends RedisOptions {\n  keyPrefix?: string;\n  defaultTTL?: number;\n  enableLogging?: boolean;\n}\n\n/**\n * Serialized cache entry with metadata\n */\ninterface CacheEntry<T> {\n  value: T;\n  timestamp: number;\n  type: string;\n}\n\n/**\n * Custom error class for cache-related errors\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Generic caching layer using Redis with TypeScript support\n */\nexport class Cache {\n  private client: RedisClient;\n  private readonly config: Required<Pick<CacheConfig, 'keyPrefix' | 'defaultTTL' | 'enableLogging'>>;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      keyPrefix: config.keyPrefix || 'cache:',\n      defaultTTL: config.defaultTTL || 3600, // 1 hour default\n      enableLogging: config.enableLogging ?? true,\n    };\n\n    // Initialize Redis client with configuration\n    this.client = new Redis({\n      host: config.host || 'localhost',\n      port: config.port || 6379,\n      password: config.password,\n      db: config.db || 0,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection (attempt ${times}) in ${delay}ms`);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      enableReadyCheck: true,\n      lazyConnect: true,\n      ...config,\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup Redis client event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client connected and ready');\n    });\n\n    this.client.on('error', (error: Error) => {\n      this.isConnected = false;\n      this.log(`Redis client error: ${error.message}`, 'error');\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Ensure Redis connection is established\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    this.connectionPromise = this.client.connect().then(() => {\n      this.connectionPromise = null;\n    });\n\n    return this.connectionPromise;\n  }\n\n  /**\n   * Generate full key with prefix\n   */\n  private getFullKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    const entry: CacheEntry<T> = {\n      value,\n      timestamp: Date.now(),\n      type: typeof value,\n    };\n    return JSON.stringify(entry);\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(data: string): T {\n    try {\n      const entry: CacheEntry<T> = JSON.parse(data);\n      return entry.value;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to deserialize cache entry',\n        'deserialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Log messages if logging is enabled\n   */\n  private log(message: string, level: 'info' | 'error' = 'info'): void {\n    if (this.config.enableLogging) {\n      const timestamp = new Date().toISOString();\n      const prefix = `[Cache ${timestamp}]`;\n      \n      if (level === 'error') {\n        console.error(`${prefix} ${message}`);\n      } else {\n        console.log(`${prefix} ${message}`);\n      }\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.getFullKey(key);\n      const data = await this.client.get(fullKey);\n\n      if (data === null) {\n        this.log(`Cache miss: ${key}`);\n        return null;\n      }\n\n      this.log(`Cache hit: ${key}`);\n      return this.deserialize<T>(data);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get key \"${key}\"`,\n        'get',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n        this.log(`Set key \"${key}\" with TTL ${ttl}s`);\n      } else {\n        await this.client.set(fullKey, serialized);\n        this.log(`Set key \"${key}\" without TTL`);\n      }\n    } catch (error) {\n      throw new CacheError(\n        `Failed to set key \"${key}\"`,\n        'set',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key to delete\n   * @returns Number of keys deleted (0 or 1)\n   */\n  async delete(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.del(fullKey);\n      \n      this.log(`Deleted key \"${key}\" (${result} keys removed)`);\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to delete key \"${key}\"`,\n        'delete',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullPattern = this.getFullKey(pattern);\n      let cursor = '0';\n      let deletedCount = 0;\n      const batchSize = 100;\n\n      do {\n        // Use SCAN to iterate through keys matching the pattern\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          batchSize\n        );\n\n        cursor = nextCursor;\n\n        if (keys.length > 0) {\n          // Delete keys in pipeline for better performance\n          const pipeline = this.client.pipeline();\n          keys.forEach((key) => pipeline.del(key));\n          const results = await pipeline.exec();\n          \n          // Count successful deletions\n          deletedCount += results?.filter(([err, result]) => !err && result === 1).length || 0;\n        }\n      } while (cursor !== '0');\n\n      this.log(`Invalidated pattern \"${pattern}\" (${deletedCount} keys removed)`);\n      return deletedCount;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to invalidate pattern \"${pattern}\"`,\n        'invalidatePattern',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns True if key exists, false otherwise\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.exists(fullKey);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key \"${key}\"`,\n        'exists',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key \"${key}\"`,\n        'getTTL',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set expiration time for an existing key\n   * @param key - Cache key\n   * @param ttlSeconds - Time to live in seconds\n   * @returns True if TTL was set, false if key doesn't exist\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.expire(fullKey, ttlSeconds);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to set expiration for key \"${key}\"`,\n        'expire',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get multiple values at once\n   * @param keys - Array of cache keys\n   * @returns Map of keys to values (null for missing keys)\n   */\n  async mget<T>(keys: string[]): Promise<Map<string, T | null>> {\n    try {\n      await this.ensureConnection();\n\n      const fullKeys = keys.map((key) => this.getFullKey(key));\n      const values = await this.client.mget(...fullKeys);\n      \n      const result = new Map<string, T | null>();\n      keys.forEach((key, index) => {\n        const value = values[index];\n        result.set(key, value ? this.deserialize<T>(value) : null);\n      });\n\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to get multiple keys',\n        'mget',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set multiple values at once\n   * @param entries - Map of keys to values\n   * @param ttlSeconds - Optional TTL for all entries\n   */\n  async mset<T>(\n    entries: Map<string, T>,\n    ttlSeconds?: number\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      const pipeline = this.client.pipeline();\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      entries.forEach((value, key) => {\n        const fullKey = this.getFullKey(key);\n        const serialized = this.serialize(value);\n\n        if (ttl > 0) {\n          pipeline.setex(fullKey, ttl, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      });\n\n      await pipeline.exec();\n      this.log(`Set ${entries.size} keys in batch`);\n    } catch (error) {\n      throw new CacheError(\n        'Failed to set multiple keys',\n        'mset',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern('*');\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Object with cache statistics\n   */\n  async getStats(): Promise<{\n    connected: boolean;\n    keyCount: number;\n    memoryUsed: string;\n    uptime: number;\n  }> {\n    try {\n      await this.ensureConnection();\n\n      const info = await this.client.info('stats');\n      const memory = await this.client.info('memory');\n      const server = await this.client.info('server');\n      \n      // Count keys with our prefix\n      const pattern = this.getFullKey('*');\n      let keyCount = 0;\n      let cursor = '0';\n\n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          pattern,\n          'COUNT',\n          1000\n        );\n        cursor = nextCursor;\n        keyCount += keys.length;\n      } while (cursor !== '0');\n\n      // Parse memory usage\n      const memoryMatch = memory.match(/used_memory_human:([^\\r\\n]+)/);\n      const memoryUsed = memoryMatch ? memoryMatch[1] : 'unknown';\n\n      // Parse uptime\n      const uptimeMatch = server.match(/uptime_in_seconds:(\\d+)/);\n      const uptime = uptimeMatch ? parseInt(uptimeMatch[1], 10) : 0;\n\n      return {\n        connected: this.isConnected,\n        keyCount,\n        memoryUsed,\n        uptime,\n      };\n    } catch (error) {\n      throw new CacheError(\n        'Failed to get cache statistics',\n        'getStats',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Close the Redis connection\n   */\n  async disconnect(): Promise<void> {\n    try {\n      await this.client.quit();\n      this.isConnected = false;\n      this.log('Redis client disconnected');\n    } catch (error) {\n      throw new CacheError(\n        'Failed to disconnect',\n        'disconnect',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get the underlying Redis client (for advanced operations)\n   */\n  getClient(): RedisClient {\n    return this.client;\n  }\n\n  /**\n   * Check if cache is connected\n   */\n  isReady(): boolean {\n    return this.isConnected;\n  }\n}\n\n// Export a singleton instance factory\nlet defaultInstance: Cache | null = null;\n\nexport function getDefaultCache(config?: CacheConfig): Cache {\n  if (!defaultInstance) {\n    defaultInstance = new Cache(config);\n  }\n  return defaultInstance;\n}\n\nexport default Cache;\n```\n\n```typescript\n// cache.test.ts\nimport { Cache, CacheError, CacheConfig } from './cache';\n\n/**\n * Example usage and tests\n */\n\n// Example 1: Basic usage\nasync function basicUsageExample() {\n  const cache = new Cache({\n    host: 'localhost',\n    port: 6379,\n    keyPrefix: 'myapp:',\n    defaultTTL: 300, // 5 minutes\n  });",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 94,
            "output_tokens": 4096,
            "cached": true
          },
          "with_skill": {
            "output": "```typescript\nimport Redis, { Redis as RedisClient, RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache instance\n */\nexport interface CacheConfig extends RedisOptions {\n  /**\n   * Default TTL in seconds for cached items (optional)\n   */\n  defaultTTL?: number;\n  /**\n   * Prefix for all cache keys (optional)\n   */\n  keyPrefix?: string;\n  /**\n   * Enable debug logging (optional)\n   */\n  debug?: boolean;\n}\n\n/**\n * Error thrown when cache operations fail\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error,\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Generic caching layer using Redis with TypeScript support\n */\nexport class Cache {\n  private client: RedisClient;\n  private readonly config: Required<Pick<CacheConfig, 'defaultTTL' | 'keyPrefix' | 'debug'>>;\n  private isConnected: boolean = false;\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      defaultTTL: config.defaultTTL ?? 3600, // 1 hour default\n      keyPrefix: config.keyPrefix ?? 'cache:',\n      debug: config.debug ?? false,\n    };\n\n    // Initialize Redis client with connection options\n    this.client = new Redis({\n      host: config.host ?? 'localhost',\n      port: config.port ?? 6379,\n      password: config.password,\n      db: config.db ?? 0,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      enableReadyCheck: true,\n      ...config,\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup Redis client event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.isConnected = true;\n      this.log('Redis client connected');\n    });\n\n    this.client.on('ready', () => {\n      this.log('Redis client ready');\n    });\n\n    this.client.on('error', (error: Error) => {\n      this.isConnected = false;\n      console.error('Redis client error:', error);\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Internal logging method\n   */\n  private log(message: string): void {\n    if (this.config.debug) {\n      console.log(`[Cache] ${message}`);\n    }\n  }\n\n  /**\n   * Build the full cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`;\n  }\n\n  /**\n   * Check if the client is connected\n   */\n  private ensureConnected(): void {\n    if (!this.isConnected && this.client.status !== 'ready') {\n      throw new CacheError(\n        'Redis client is not connected',\n        'connection_check',\n      );\n    }\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify(value);\n    } catch (error) {\n      throw new CacheError(\n        'Failed to serialize value',\n        'serialize',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      return JSON.parse(value) as T;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to deserialize value',\n        'deserialize',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get a cached value by key\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      this.ensureConnected();\n      const fullKey = this.buildKey(key);\n      this.log(`GET ${fullKey}`);\n\n      const value = await this.client.get(fullKey);\n      \n      if (value === null) {\n        this.log(`Cache miss: ${fullKey}`);\n        return null;\n      }\n\n      this.log(`Cache hit: ${fullKey}`);\n      return this.deserialize<T>(value);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get key: ${key}`,\n        'get',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set a cached value with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses defaultTTL if not provided)\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number,\n  ): Promise<void> {\n    try {\n      this.ensureConnected();\n      const fullKey = this.buildKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      this.log(`SET ${fullKey} (TTL: ${ttl}s)`);\n\n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n      } else {\n        // If TTL is 0 or negative, set without expiration\n        await this.client.set(fullKey, serialized);\n      }\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set key: ${key}`,\n        'set',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Delete a cached value by key\n   * @param key - Cache key\n   * @returns True if the key was deleted, false if it didn't exist\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      this.ensureConnected();\n      const fullKey = this.buildKey(key);\n      this.log(`DELETE ${fullKey}`);\n\n      const result = await this.client.del(fullKey);\n      return result > 0;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        'delete',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Pattern to match (e.g., \"user:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      this.ensureConnected();\n      const fullPattern = this.buildKey(pattern);\n      this.log(`INVALIDATE PATTERN ${fullPattern}`);\n\n      let cursor = '0';\n      let deletedCount = 0;\n      const keysToDelete: string[] = [];\n\n      // Use SCAN to find all matching keys\n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100,\n        );\n        cursor = nextCursor;\n        keysToDelete.push(...keys);\n      } while (cursor !== '0');\n\n      // Delete keys in batches using pipeline for efficiency\n      if (keysToDelete.length > 0) {\n        const pipeline = this.client.pipeline();\n        keysToDelete.forEach((key) => pipeline.del(key));\n        const results = await pipeline.exec();\n        \n        // Count successful deletions\n        deletedCount = results?.reduce((count, [err, result]) => {\n          return err ? count : count + (result as number);\n        }, 0) ?? 0;\n      }\n\n      this.log(`Invalidated ${deletedCount} keys matching pattern: ${fullPattern}`);\n      return deletedCount;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        'invalidatePattern',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in the cache\n   * @param key - Cache key\n   * @returns True if the key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      this.ensureConnected();\n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        'exists',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get the TTL (time to live) of a key in seconds\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiration, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      this.ensureConnected();\n      const fullKey = this.buildKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        'getTTL',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern('*');\n  }\n\n  /**\n   * Get multiple values at once\n   * @param keys - Array of cache keys\n   * @returns Map of keys to values (null for missing keys)\n   */\n  async getMany<T>(keys: string[]): Promise<Map<string, T | null>> {\n    try {\n      this.ensureConnected();\n      const fullKeys = keys.map((key) => this.buildKey(key));\n      \n      if (fullKeys.length === 0) {\n        return new Map();\n      }\n\n      const values = await this.client.mget(...fullKeys);\n      const result = new Map<string, T | null>();\n\n      keys.forEach((key, index) => {\n        const value = values[index];\n        result.set(key, value ? this.deserialize<T>(value) : null);\n      });\n\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to get multiple keys',\n        'getMany',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set multiple values at once\n   * @param entries - Array of [key, value, ttl?] tuples\n   */\n  async setMany<T>(\n    entries: Array<[string, T, number?]>,\n  ): Promise<void> {\n    try {\n      this.ensureConnected();\n      \n      if (entries.length === 0) {\n        return;\n      }\n\n      const pipeline = this.client.pipeline();\n\n      entries.forEach(([key, value, ttl]) => {\n        const fullKey = this.buildKey(key);\n        const serialized = this.serialize(value);\n        const ttlToUse = ttl ?? this.config.defaultTTL;\n\n        if (ttlToUse > 0) {\n          pipeline.setex(fullKey, ttlToUse, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      });\n\n      await pipeline.exec();\n    } catch (error) {\n      throw new CacheError(\n        'Failed to set multiple keys',\n        'setMany',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Gracefully disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    try {\n      this.log('Disconnecting from Redis...');\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to disconnect from Redis',\n        'disconnect',\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get the underlying Redis client (for advanced operations)\n   */\n  getClient(): RedisClient {\n    return this.client;\n  }\n\n  /**\n   * Check connection status\n   */\n  isReady(): boolean {\n    return this.isConnected && this.client.status === 'ready';\n  }\n}\n\n// Export a singleton instance factory\nlet defaultInstance: Cache | null = null;\n\n/**\n * Get or create the default cache instance\n */\nexport function getCache(config?: CacheConfig): Cache {\n  if (!defaultInstance) {\n    defaultInstance = new Cache(config);\n  }\n  return defaultInstance;\n}\n\n/**\n * Reset the default cache instance (useful for testing)\n */\nexport async function resetCache(): Promise<void> {\n  if (defaultInstance) {\n    await defaultInstance.disconnect();\n    defaultInstance = null;\n  }\n}\n```\n\n## Usage Examples\n\n```typescript\n// Basic usage\nimport { Cache } from './cache';\n\nconst cache = new Cache({\n  host: 'localhost',\n  port: 6379,\n  defaultTTL: 3600,\n  keyPrefix: 'myapp:',\n});\n\n// Store and retrieve typed data\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst user: User = { id: 1, name: 'John', email: 'john@example.com' };\nawait cache.set('user:1', user, 7200); // 2 hours TTL\n\nconst cachedUser = await cache.get<User>('user:1');\nconsole.log(cachedUser?.name); // 'John'\n\n// Delete a key\nawait cache.delete('user:1');\n\n// Invalidate by pattern\nawait cache.invalidatePattern('user:*'); // Delete all user keys\n\n// Batch operations\nawait cache.setMany([\n  ['user:1', { id: 1, name: 'John' }, 3600],\n  ['user:2', { id: 2, name: 'Jane' }, 3600],\n]);\n\nconst users = await cache.getMany<User>(['user:1', 'user:2']);\n\n// Using singleton\nimport { getCache } from './cache';\nconst cache = getCache({ host: 'localhost' });\n```\n\n## Key Features\n\n1. **TypeScript Generics**: Full type safety for cached values\n2. **JSON Serialization**: Automatic serialization/deserialization\n3. **Error Handling**: Custom `CacheError` class with operation context\n4. **Connection Management**: Automatic reconnection with retry strategy\n5. **Pattern Invalidation**: Efficient SCAN-based pattern matching\n6. **Batch Operations**: `getMany` and `setMany` for performance\n7. **TTL Support**: Configurable per-key or default TTL\n8. **Key Prefixing**: Namespace isolation\n9. **Debug Logging**: Optional verbose logging\n10. **Singleton Pattern**: Optional shared instance",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24684,
            "output_tokens": 3922,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Redis Caching Layer with TypeScript\n\nI'll create a comprehensive caching utility module with proper TypeScript generics, error handling, and Redis integration.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig {\n  /** Redis connection options */\n  redis?: RedisOptions;\n  /** Default TTL in seconds (optional) */\n  defaultTTL?: number;\n  /** Key prefix for all cache entries */\n  keyPrefix?: string;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n/**\n * Cache operation result\n */\nexport interface CacheResult<T> {\n  success: boolean;\n  data?: T;\n  error?: Error;\n}\n\n/**\n * Custom error types for cache operations\n */\nexport class CacheError extends Error {\n  constructor(message: string, public readonly operation: string, public readonly cause?: Error) {\n    super(message);\n    this.name = 'CacheError';\n  }\n}\n\nexport class CacheConnectionError extends CacheError {\n  constructor(message: string, cause?: Error) {\n    super(message, 'connection', cause);\n    this.name = 'CacheConnectionError';\n  }\n}\n\nexport class CacheSerializationError extends CacheError {\n  constructor(message: string, cause?: Error) {\n    super(message, 'serialization', cause);\n    this.name = 'CacheSerializationError';\n  }\n}\n\n/**\n * Generic caching layer using Redis with ioredis\n */\nexport class Cache {\n  private client: Redis;\n  private readonly config: Required<CacheConfig>;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      redis: config.redis || {},\n      defaultTTL: config.defaultTTL || 3600, // 1 hour default\n      keyPrefix: config.keyPrefix || 'cache:',\n      debug: config.debug || false,\n    };\n\n    // Initialize Redis client with retry strategy\n    this.client = new Redis({\n      ...this.config.redis,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection (attempt ${times}), delay: ${delay}ms`);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n    });\n\n    this.setupEventHandlers();\n    this.connectionPromise = this.waitForConnection();\n  }\n\n  /**\n   * Setup Redis event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client connected and ready');\n    });\n\n    this.client.on('error', (error: Error) => {\n      this.isConnected = false;\n      this.log(`Redis client error: ${error.message}`, 'error');\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Wait for Redis connection to be ready\n   */\n  private async waitForConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new CacheConnectionError('Connection timeout after 10 seconds'));\n      }, 10000);\n\n      this.client.once('ready', () => {\n        clearTimeout(timeout);\n        resolve();\n      });\n\n      this.client.once('error', (error: Error) => {\n        clearTimeout(timeout);\n        reject(new CacheConnectionError('Failed to connect to Redis', error));\n      });\n    });\n  }\n\n  /**\n   * Ensure connection is ready before operations\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n    } else {\n      throw new CacheConnectionError('Redis client is not connected');\n    }\n  }\n\n  /**\n   * Build full cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify({\n        data: value,\n        timestamp: Date.now(),\n      });\n    } catch (error) {\n      throw new CacheSerializationError(\n        `Failed to serialize value for caching`,\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const parsed = JSON.parse(value);\n      return parsed.data as T;\n    } catch (error) {\n      throw new CacheSerializationError(\n        `Failed to deserialize cached value`,\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Log messages if debug is enabled\n   */\n  private log(message: string, level: 'info' | 'error' = 'info'): void {\n    if (this.config.debug) {\n      const timestamp = new Date().toISOString();\n      const prefix = `[Cache ${timestamp}]`;\n      if (level === 'error') {\n        console.error(`${prefix} ${message}`);\n      } else {\n        console.log(`${prefix} ${message}`);\n      }\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      this.log(`GET ${fullKey}`);\n      \n      const value = await this.client.get(fullKey);\n      \n      if (value === null) {\n        this.log(`Cache miss: ${fullKey}`);\n        return null;\n      }\n      \n      this.log(`Cache hit: ${fullKey}`);\n      return this.deserialize<T>(value);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get value for key: ${key}`,\n        'get',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses default if not provided)\n   */\n  async set<T>(key: string, value: T, ttlSeconds?: number): Promise<void> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n      \n      this.log(`SET ${fullKey} (TTL: ${ttl}s)`);\n      \n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n      } else {\n        await this.client.set(fullKey, serialized);\n      }\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set value for key: ${key}`,\n        'set',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Delete a value from cache\n   * @param key - Cache key\n   * @returns Number of keys deleted (0 or 1)\n   */\n  async delete(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      this.log(`DELETE ${fullKey}`);\n      \n      const result = await this.client.del(fullKey);\n      this.log(`Deleted ${result} key(s)`);\n      \n      return result;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        'delete',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:123:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n      \n      const fullPattern = this.buildKey(pattern);\n      this.log(`INVALIDATE PATTERN ${fullPattern}`);\n      \n      // Use SCAN to find matching keys (safer than KEYS for production)\n      const keys: string[] = [];\n      let cursor = '0';\n      \n      do {\n        const [nextCursor, matchedKeys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100\n        );\n        cursor = nextCursor;\n        keys.push(...matchedKeys);\n      } while (cursor !== '0');\n      \n      if (keys.length === 0) {\n        this.log(`No keys found matching pattern: ${fullPattern}`);\n        return 0;\n      }\n      \n      // Delete in batches using pipeline for better performance\n      const pipeline = this.client.pipeline();\n      keys.forEach(key => pipeline.del(key));\n      await pipeline.exec();\n      \n      this.log(`Invalidated ${keys.length} key(s) matching pattern: ${fullPattern}`);\n      return keys.length;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        'invalidatePattern',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns True if key exists, false otherwise\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        'exists',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async ttl(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        'ttl',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get or set pattern: retrieve from cache or compute and cache\n   * @param key - Cache key\n   * @param factory - Function to compute value if not in cache\n   * @param ttlSeconds - TTL for cached value\n   * @returns The cached or computed value\n   */\n  async getOrSet<T>(\n    key: string,\n    factory: () => Promise<T>,\n    ttlSeconds?: number\n  ): Promise<T> {\n    try {\n      // Try to get from cache first\n      const cached = await this.get<T>(key);\n      if (cached !== null) {\n        return cached;\n      }\n      \n      // Compute value\n      this.log(`Computing value for key: ${key}`);\n      const value = await factory();\n      \n      // Cache the computed value\n      await this.set(key, value, ttlSeconds);\n      \n      return value;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get or set value for key: ${key}`,\n        'getOrSet',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * WARNING: Use with caution in production\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern('*');\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Object with cache statistics\n   */\n  async stats(): Promise<{\n    connected: boolean;\n    keyCount: number;\n    memoryUsed: string;\n  }> {\n    try {\n      await this.ensureConnection();\n      \n      const info = await this.client.info('memory');\n      const memoryMatch = info.match(/used_memory_human:(.+)/);\n      const memoryUsed = memoryMatch ? memoryMatch[1].trim() : 'unknown';\n      \n      // Count keys with our prefix\n      let keyCount = 0;\n      let cursor = '0';\n      \n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          `${this.config.keyPrefix}*`,\n          'COUNT',\n          100\n        );\n        cursor = nextCursor;\n        keyCount += keys.length;\n      } while (cursor !== '0');\n      \n      return {\n        connected: this.isConnected,\n        keyCount,\n        memoryUsed,\n      };\n    } catch (error) {\n      throw new CacheError(\n        'Failed to get cache statistics',\n        'stats',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    this.log('Disconnecting from Redis...');\n    await this.client.quit();\n    this.isConnected = false;\n  }\n\n  /**\n   * Get the underlying Redis client (for advanced operations)\n   */\n  getClient(): Redis {\n    return this.client;\n  }\n}\n\n/**\n * Create a singleton cache instance\n */\nlet cacheInstance: Cache | null = null;\n\nexport function createCache(config?: CacheConfig): Cache {\n  if (!cacheInstance) {\n    cacheInstance = new Cache(config);\n  }\n  return cacheInstance;\n}\n\nexport function getCache(): Cache {\n  if (!cacheInstance) {\n    throw new Error('Cache not initialized. Call createCache() first.');\n  }\n  return cacheInstance;\n}\n```\n\nNow let's create usage examples and tests:\n\n```typescript\n// examples/basic-usage.ts\nimport { Cache } from '../cache';\n\nasync function basicUsageExample() {\n  // Initialize cache with custom configuration\n  const cache = new Cache({\n    redis: {\n      host: 'localhost',\n      port: 6379,\n      // password: 'your-password', // if needed\n    },\n    defaultTTL: 300, // 5 minutes\n    keyPrefix: 'myapp:',\n    debug: true,\n  });\n\n  try {\n    // Set a value\n    await cache.set('user:123', { id: 123, name: 'John Doe', email: 'john@example.com' });\n    console.log('User cached');\n\n    // Get a value\n    const user = await cache.get<{ id: number; name: string; email: string }>('user:123');\n    console.log('Retrieved user:', user);\n\n    // Set with custom TTL (10 seconds)\n    await cache.set('temp:data', { value: 'temporary' }, 10);\n\n    // Check if key exists\n    const",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2236,
            "output_tokens": 4096,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive Redis caching utility module with proper TypeScript generics, error handling, and all the requested methods.\n\n```typescript\n// src/lib/cache.ts\nimport Redis, { Redis as RedisClient, RedisOptions } from \"ioredis\";\n\nexport interface CacheOptions extends RedisOptions {\n  keyPrefix?: string;\n  defaultTTL?: number;\n}\n\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly cause?: Error,\n  ) {\n    super(message);\n    this.name = \"CacheError\";\n  }\n}\n\nexport class Cache {\n  private client: RedisClient;\n  private keyPrefix: string;\n  private defaultTTL: number;\n  private isConnected: boolean = false;\n\n  constructor(options: CacheOptions = {}) {\n    const { keyPrefix = \"cache:\", defaultTTL = 3600, ...redisOptions } = options;\n\n    this.keyPrefix = keyPrefix;\n    this.defaultTTL = defaultTTL;\n\n    this.client = new Redis({\n      host: process.env.REDIS_HOST ?? \"localhost\",\n      port: parseInt(process.env.REDIS_PORT ?? \"6379\", 10),\n      password: process.env.REDIS_PASSWORD,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      ...redisOptions,\n    });\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.client.on(\"connect\", () => {\n      this.isConnected = true;\n      console.log(\"Redis cache connected\");\n    });\n\n    this.client.on(\"error\", (error: Error) => {\n      console.error(\"Redis cache error:\", error);\n      this.isConnected = false;\n    });\n\n    this.client.on(\"close\", () => {\n      this.isConnected = false;\n      console.log(\"Redis cache connection closed\");\n    });\n  }\n\n  private getPrefixedKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  private ensureConnection(): void {\n    if (!this.isConnected) {\n      throw new CacheError(\n        \"Redis client is not connected\",\n        \"connection_check\",\n      );\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns Parsed value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const value = await this.client.get(prefixedKey);\n\n      if (value === null) {\n        return null;\n      }\n\n      return JSON.parse(value) as T;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n\n      throw new CacheError(\n        `Failed to get cache key: ${key}`,\n        \"get\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses defaultTTL if not provided)\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number,\n  ): Promise<void> {\n    try {\n      this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const serialized = JSON.stringify(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      if (ttl > 0) {\n        await this.client.setex(prefixedKey, ttl, serialized);\n      } else {\n        await this.client.set(prefixedKey, serialized);\n      }\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n\n      throw new CacheError(\n        `Failed to set cache key: ${key}`,\n        \"set\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Delete a specific key from cache\n   * @param key - Cache key to delete\n   * @returns Number of keys deleted (0 or 1)\n   */\n  async delete(key: string): Promise<number> {\n    try {\n      this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      return await this.client.del(prefixedKey);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n\n      throw new CacheError(\n        `Failed to delete cache key: ${key}`,\n        \"delete\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Pattern to match (e.g., \"user:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      this.ensureConnection();\n\n      const prefixedPattern = this.getPrefixedKey(pattern);\n      const keys = await this.scanKeys(prefixedPattern);\n\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      // Delete in batches to avoid blocking Redis\n      const batchSize = 100;\n      let deletedCount = 0;\n\n      for (let i = 0; i < keys.length; i += batchSize) {\n        const batch = keys.slice(i, i + batchSize);\n        const deleted = await this.client.del(...batch);\n        deletedCount += deleted;\n      }\n\n      return deletedCount;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        \"invalidatePattern\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Scan for keys matching a pattern using SCAN command\n   * @param pattern - Pattern to match\n   * @returns Array of matching keys\n   */\n  private async scanKeys(pattern: string): Promise<string[]> {\n    const keys: string[] = [];\n    let cursor = \"0\";\n\n    do {\n      const [nextCursor, matchedKeys] = await this.client.scan(\n        cursor,\n        \"MATCH\",\n        pattern,\n        \"COUNT\",\n        100,\n      );\n\n      cursor = nextCursor;\n      keys.push(...matchedKeys);\n    } while (cursor !== \"0\");\n\n    return keys;\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns True if key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.exists(prefixedKey);\n      return result === 1;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        \"exists\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async ttl(key: string): Promise<number> {\n    try {\n      this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      return await this.client.ttl(prefixedKey);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        \"ttl\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern(\"*\");\n  }\n\n  /**\n   * Get multiple keys at once\n   * @param keys - Array of cache keys\n   * @returns Array of values (null for missing keys)\n   */\n  async mget<T>(keys: string[]): Promise<(T | null)[]> {\n    try {\n      this.ensureConnection();\n\n      if (keys.length === 0) {\n        return [];\n      }\n\n      const prefixedKeys = keys.map((key) => this.getPrefixedKey(key));\n      const values = await this.client.mget(...prefixedKeys);\n\n      return values.map((value) => {\n        if (value === null) {\n          return null;\n        }\n        return JSON.parse(value) as T;\n      });\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n\n      throw new CacheError(\n        \"Failed to get multiple cache keys\",\n        \"mget\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set multiple key-value pairs at once\n   * @param entries - Array of [key, value, ttl?] tuples\n   */\n  async mset<T>(\n    entries: Array<[string, T, number?]>,\n  ): Promise<void> {\n    try {\n      this.ensureConnection();\n\n      if (entries.length === 0) {\n        return;\n      }\n\n      // Use pipeline for better performance\n      const pipeline = this.client.pipeline();\n\n      for (const [key, value, ttl] of entries) {\n        const prefixedKey = this.getPrefixedKey(key);\n        const serialized = JSON.stringify(value);\n        const ttlToUse = ttl ?? this.defaultTTL;\n\n        if (ttlToUse > 0) {\n          pipeline.setex(prefixedKey, ttlToUse, serialized);\n        } else {\n          pipeline.set(prefixedKey, serialized);\n        }\n      }\n\n      await pipeline.exec();\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n\n      throw new CacheError(\n        \"Failed to set multiple cache keys\",\n        \"mset\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Close the Redis connection\n   */\n  async disconnect(): Promise<void> {\n    try {\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to disconnect from Redis\",\n        \"disconnect\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get connection status\n   */\n  get connected(): boolean {\n    return this.isConnected;\n  }\n}\n\n// Export a singleton instance\nlet cacheInstance: Cache | null = null;\n\nexport function getCache(options?: CacheOptions): Cache {\n  if (!cacheInstance) {\n    cacheInstance = new Cache(options);\n  }\n  return cacheInstance;\n}\n\nexport function resetCache(): void {\n  if (cacheInstance) {\n    cacheInstance.disconnect().catch(console.error);\n    cacheInstance = null;\n  }\n}\n```\n\nNow let's create a test file to demonstrate usage:\n\n```typescript\n// src/lib/cache.test.ts\nimport { describe, it, expect, beforeEach, afterEach, vi } from \"vitest\";\nimport { Cache, CacheError, getCache, resetCache } from \"./cache\";\n\ndescribe(\"Cache\", () => {\n  let cache: Cache;\n\n  beforeEach(() => {\n    cache = new Cache({\n      keyPrefix: \"test:\",\n      defaultTTL: 60,\n    });\n  });\n\n  afterEach(async () => {\n    await cache.clear();\n    await cache.disconnect();\n    resetCache();\n  });\n\n  describe(\"get and set\", () => {\n    it(\"should set and get a string value\", async () => {\n      await cache.set(\"key1\", \"value1\");\n      const result = await cache.get<string>(\"key1\");\n      expect(result).toBe(\"value1\");\n    });\n\n    it(\"should set and get an object value\", async () => {\n      const obj = { name: \"John\", age: 30 };\n      await cache.set(\"user:1\", obj);\n      const result = await cache.get<typeof obj>(\"user:1\");\n      expect(result).toEqual(obj);\n    });\n\n    it(\"should return null for non-existent key\", async () => {\n      const result = await cache.get<string>(\"nonexistent\");\n      expect(result).toBeNull();\n    });\n\n    it(\"should respect custom TTL\", async () => {\n      await cache.set(\"short-lived\", \"value\", 1);\n      const ttl = await cache.ttl(\"short-lived\");\n      expect(ttl).toBeLessThanOrEqual(1);\n      expect(ttl).toBeGreaterThan(0);\n    });\n  });\n\n  describe(\"delete\", () => {\n    it(\"should delete an existing key\", async () => {\n      await cache.set(\"key1\", \"value1\");\n      const deleted = await cache.delete(\"key1\");\n      expect(deleted).toBe(1);\n\n      const result = await cache.get<string>(\"key1\");\n      expect(result).toBeNull();\n    });\n\n    it(\"should return 0 for non-existent key\", async () => {\n      const deleted = await cache.delete(\"nonexistent\");\n      expect(deleted).toBe(0);\n    });\n  });\n\n  describe(\"invalidatePattern\", () => {\n    it(\"should delete all keys matching pattern\", async () => {\n      await cache.set(\"user:1\", { id: 1 });\n      await cache.set(\"user:2\", { id: 2 });\n      await cache.set(\"post:1\", { id: 1 });\n\n      const deleted = await cache.invalidatePattern(\"user:*\");\n      expect(deleted).toBe(2);\n\n      const user1 = await cache.get(\"user:1\");\n      const user2 = await cache.get(\"user:2\");\n      const post1 = await cache.get(\"post:1\");\n\n      expect(user1).toBeNull();\n      expect(user2).toBeNull();\n      expect(post1).not.toBeNull();\n    });\n\n    it(\"should return 0 when no keys match\", async () => {\n      const deleted = await cache.invalidatePattern(\"nonexistent:*\");\n      expect(deleted).toBe(0);\n    });\n  });\n\n  describe(\"exists\", () => {\n    it(\"should return true for existing key\", async () => {\n      await cache.set(\"key1\", \"value1\");\n      const exists = await cache.exists(\"key1\");\n      expect(exists).toBe(true);\n    });\n\n    it(\"should return false for non-existent key\", async () => {\n      const exists = await cache.exists(\"nonexistent\");\n      expect(exists).toBe(false);\n    });\n  });\n\n  describe(\"mget and mset\", () => {\n    it(\"should get multiple keys at once\", async () => {\n      await cache.set(\"key1\", \"value1\");\n      await cache.set(\"key2\", \"value2\");\n      await cache.set(\"key3\", \"value3\");\n\n      const results = await cache.mget<string>([\"key1\", \"key2\", \"key3\"]);\n      expect(results).toEqual([\"value1\", \"value2\", \"value3\"]);\n    });\n\n    it(\"should return null for missing keys in mget\", async () => {\n      await cache.set(\"key1\", \"value1\");\n\n      const results = await cache.mget<string>([\"key1\", \"missing\", \"key3\"]);\n      expect(results).toEqual([\"value1\", null, null]);\n    });\n\n    it(\"should set multiple keys at once\", async () => {\n      await cache.mset([\n        [\"key1\", \"value1\", 60],\n        [\"key2\", \"value2\", ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25179,
            "output_tokens": 4096,
            "cached": true
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Redis Caching Layer Utility Module\n\n```typescript\n// cache.ts\nimport Redis, { Redis as RedisClient, RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig extends RedisOptions {\n  keyPrefix?: string;\n  defaultTTL?: number;\n  enableLogging?: boolean;\n}\n\n/**\n * Custom error class for cache-related errors\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Serialized cache value wrapper\n */\ninterface CacheValue<T> {\n  data: T;\n  timestamp: number;\n  type: string;\n}\n\n/**\n * Generic Redis caching layer with TypeScript support\n */\nexport class Cache {\n  private client: RedisClient;\n  private keyPrefix: string;\n  private defaultTTL: number;\n  private enableLogging: boolean;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.keyPrefix = config.keyPrefix || 'cache:';\n    this.defaultTTL = config.defaultTTL || 3600; // 1 hour default\n    this.enableLogging = config.enableLogging ?? false;\n\n    // Initialize Redis client with default configuration\n    const redisConfig: RedisOptions = {\n      host: config.host || 'localhost',\n      port: config.port || 6379,\n      password: config.password,\n      db: config.db || 0,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection... Attempt ${times}`);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      enableReadyCheck: true,\n      ...config,\n    };\n\n    this.client = new Redis(redisConfig);\n\n    // Set up event handlers\n    this.setupEventHandlers();\n\n    // Initialize connection\n    this.connectionPromise = this.initialize();\n  }\n\n  /**\n   * Set up Redis client event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client connected and ready');\n    });\n\n    this.client.on('error', (error: Error) => {\n      this.isConnected = false;\n      this.log(`Redis client error: ${error.message}`, 'error');\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Initialize the cache connection\n   */\n  private async initialize(): Promise<void> {\n    try {\n      await this.client.ping();\n      this.isConnected = true;\n      this.log('Cache initialized successfully');\n    } catch (error) {\n      this.isConnected = false;\n      throw new CacheError(\n        'Failed to initialize cache connection',\n        'initialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Ensure the client is connected before operations\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n    }\n\n    if (!this.isConnected) {\n      throw new CacheError(\n        'Redis client is not connected',\n        'ensureConnection'\n      );\n    }\n  }\n\n  /**\n   * Generate a prefixed cache key\n   */\n  private getPrefixedKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value for storage\n   */\n  private serialize<T>(value: T): string {\n    try {\n      const cacheValue: CacheValue<T> = {\n        data: value,\n        timestamp: Date.now(),\n        type: typeof value,\n      };\n      return JSON.stringify(cacheValue);\n    } catch (error) {\n      throw new CacheError(\n        'Failed to serialize cache value',\n        'serialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Deserialize value from storage\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const cacheValue: CacheValue<T> = JSON.parse(value);\n      return cacheValue.data;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to deserialize cache value',\n        'deserialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Log messages if logging is enabled\n   */\n  private log(message: string, level: 'info' | 'error' = 'info'): void {\n    if (this.enableLogging) {\n      const timestamp = new Date().toISOString();\n      const prefix = `[Cache ${timestamp}]`;\n      \n      if (level === 'error') {\n        console.error(`${prefix} ${message}`);\n      } else {\n        console.log(`${prefix} ${message}`);\n      }\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n      \n      const prefixedKey = this.getPrefixedKey(key);\n      const value = await this.client.get(prefixedKey);\n\n      if (value === null) {\n        this.log(`Cache miss: ${key}`);\n        return null;\n      }\n\n      this.log(`Cache hit: ${key}`);\n      return this.deserialize<T>(value);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get value for key: ${key}`,\n        'get',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const serializedValue = this.serialize(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      if (ttl > 0) {\n        await this.client.setex(prefixedKey, ttl, serializedValue);\n      } else {\n        await this.client.set(prefixedKey, serializedValue);\n      }\n\n      this.log(`Cache set: ${key} (TTL: ${ttl}s)`);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set value for key: ${key}`,\n        'set',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Delete a value from cache\n   * @param key - Cache key\n   * @returns True if the key was deleted, false if it didn't exist\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.del(prefixedKey);\n\n      const deleted = result > 0;\n      this.log(`Cache delete: ${key} (deleted: ${deleted})`);\n      \n      return deleted;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        'delete',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Pattern to match (e.g., \"user:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedPattern = this.getPrefixedKey(pattern);\n      const keys = await this.scanKeys(prefixedPattern);\n\n      if (keys.length === 0) {\n        this.log(`No keys found for pattern: ${pattern}`);\n        return 0;\n      }\n\n      // Delete keys in batches using pipeline for better performance\n      const pipeline = this.client.pipeline();\n      keys.forEach((key) => pipeline.del(key));\n      await pipeline.exec();\n\n      this.log(`Invalidated ${keys.length} keys for pattern: ${pattern}`);\n      return keys.length;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        'invalidatePattern',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Scan for keys matching a pattern using SCAN command\n   * @param pattern - Pattern to match\n   * @returns Array of matching keys\n   */\n  private async scanKeys(pattern: string): Promise<string[]> {\n    const keys: string[] = [];\n    let cursor = '0';\n\n    do {\n      const [nextCursor, foundKeys] = await this.client.scan(\n        cursor,\n        'MATCH',\n        pattern,\n        'COUNT',\n        100\n      );\n      \n      cursor = nextCursor;\n      keys.push(...foundKeys);\n    } while (cursor !== '0');\n\n    return keys;\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns True if the key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.exists(prefixedKey);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        'exists',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get the TTL (time to live) of a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      return await this.client.ttl(prefixedKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        'getTTL',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set expiry on an existing key\n   * @param key - Cache key\n   * @param ttlSeconds - Time to live in seconds\n   * @returns True if expiry was set\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.expire(prefixedKey, ttlSeconds);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to set expiry for key: ${key}`,\n        'expire',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get multiple values at once\n   * @param keys - Array of cache keys\n   * @returns Map of key-value pairs\n   */\n  async getMany<T>(keys: string[]): Promise<Map<string, T | null>> {\n    try {\n      await this.ensureConnection();\n\n      if (keys.length === 0) {\n        return new Map();\n      }\n\n      const prefixedKeys = keys.map((key) => this.getPrefixedKey(key));\n      const values = await this.client.mget(...prefixedKeys);\n\n      const result = new Map<string, T | null>();\n      keys.forEach((key, index) => {\n        const value = values[index];\n        result.set(key, value ? this.deserialize<T>(value) : null);\n      });\n\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to get multiple values',\n        'getMany',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set multiple values at once\n   * @param entries - Array of [key, value, ttl?] tuples\n   */\n  async setMany<T>(\n    entries: Array<[string, T, number?]>\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      if (entries.length === 0) {\n        return;\n      }\n\n      const pipeline = this.client.pipeline();\n\n      entries.forEach(([key, value, ttl]) => {\n        const prefixedKey = this.getPrefixedKey(key);\n        const serializedValue = this.serialize(value);\n        const ttlSeconds = ttl ?? this.defaultTTL;\n\n        if (ttlSeconds > 0) {\n          pipeline.setex(prefixedKey, ttlSeconds, serializedValue);\n        } else {\n          pipeline.set(prefixedKey, serializedValue);\n        }\n      });\n\n      await pipeline.exec();\n      this.log(`Cache set many: ${entries.length} entries`);\n    } catch (error) {\n      throw new CacheError(\n        'Failed to set multiple values',\n        'setMany',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    try {\n      return await this.invalidatePattern('*');\n    } catch (error) {\n      throw new CacheError(\n        'Failed to clear cache',\n        'clear',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Object containing cache statistics\n   */\n  async getStats(): Promise<{\n    connected: boolean;\n    keyCount: number;\n    memoryUsed?: string;\n    uptime?: number;\n  }> {\n    try {\n      await this.ensureConnection();\n\n      const pattern = this.getPrefixedKey('*');\n      const keys = await this.scanKeys(pattern);\n      \n      let memoryUsed: string | undefined;\n      let uptime: number | undefined;\n\n      try {\n        const info = await this.client.info('memory');\n        const memoryMatch = info.match(/used_memory_human:(.+)/);\n        if (memoryMatch) {\n          memoryUsed = memoryMatch[1].trim();\n        }\n\n        const serverInfo = await this.client.info('server');\n        const uptimeMatch = serverInfo.match(/uptime_in_seconds:(\\d+)/);\n        if (uptimeMatch) {\n          uptime = parseInt(uptimeMatch[1], 10);\n        }\n      } catch (error) {\n        // INFO command might not be available in some Redis configurations\n        this.log('Could not retrieve detailed stats', 'error');\n      }\n\n      return {\n        connected: this.isConnected,\n        keyCount: keys.length,\n        memoryUsed,\n        uptime,\n      };\n    } catch (error) {\n      throw new C",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 94,
            "output_tokens": 4096,
            "cached": true
          },
          "with_skill": {
            "output": "# Redis Caching Layer Module\n\nI'll create a comprehensive TypeScript caching utility module with proper error handling, generics, and Redis integration.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions } from \"ioredis\";\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig {\n  /**\n   * Redis connection options (ioredis format)\n   */\n  redis?: RedisOptions;\n  /**\n   * Connection string (alternative to redis options)\n   * Format: redis://[:password@]host[:port][/db-number]\n   */\n  connectionString?: string;\n  /**\n   * Default TTL in seconds for cached items (optional)\n   */\n  defaultTTL?: number;\n  /**\n   * Prefix for all cache keys (useful for namespacing)\n   */\n  keyPrefix?: string;\n  /**\n   * Enable debug logging\n   */\n  debug?: boolean;\n}\n\n/**\n * Custom error class for cache-related errors\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error,\n  ) {\n    super(message);\n    this.name = \"CacheError\";\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Generic caching layer using Redis with TypeScript support\n */\nexport class Cache {\n  private client: Redis;\n  private readonly keyPrefix: string;\n  private readonly defaultTTL?: number;\n  private readonly debug: boolean;\n  private isConnected: boolean = false;\n\n  constructor(config: CacheConfig = {}) {\n    this.keyPrefix = config.keyPrefix || \"cache:\";\n    this.defaultTTL = config.defaultTTL;\n    this.debug = config.debug || false;\n\n    // Initialize Redis client\n    if (config.connectionString) {\n      this.client = new Redis(config.connectionString, {\n        maxRetriesPerRequest: 3,\n        enableReadyCheck: true,\n        lazyConnect: true,\n        ...config.redis,\n      });\n    } else {\n      this.client = new Redis({\n        host: \"localhost\",\n        port: 6379,\n        maxRetriesPerRequest: 3,\n        enableReadyCheck: true,\n        lazyConnect: true,\n        ...config.redis,\n      });\n    }\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup Redis event handlers for connection management\n   */\n  private setupEventHandlers(): void {\n    this.client.on(\"connect\", () => {\n      this.isConnected = true;\n      this.log(\"Redis client connected\");\n    });\n\n    this.client.on(\"ready\", () => {\n      this.log(\"Redis client ready\");\n    });\n\n    this.client.on(\"error\", (error) => {\n      this.isConnected = false;\n      console.error(\"Redis client error:\", error);\n    });\n\n    this.client.on(\"close\", () => {\n      this.isConnected = false;\n      this.log(\"Redis client connection closed\");\n    });\n\n    this.client.on(\"reconnecting\", () => {\n      this.log(\"Redis client reconnecting...\");\n    });\n  }\n\n  /**\n   * Ensure Redis connection is established\n   */\n  private async ensureConnection(): Promise<void> {\n    if (!this.isConnected) {\n      try {\n        await this.client.connect();\n      } catch (error) {\n        throw new CacheError(\n          \"Failed to connect to Redis\",\n          \"connect\",\n          error as Error,\n        );\n      }\n    }\n  }\n\n  /**\n   * Generate full cache key with prefix\n   */\n  private getFullKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Debug logging helper\n   */\n  private log(message: string, ...args: any[]): void {\n    if (this.debug) {\n      console.log(`[Cache] ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify({\n        data: value,\n        timestamp: Date.now(),\n        type: typeof value,\n      });\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to serialize value\",\n        \"serialize\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const parsed = JSON.parse(value);\n      return parsed.data as T;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to deserialize value\",\n        \"deserialize\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get a cached value by key\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      this.log(`Getting key: ${fullKey}`);\n\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        this.log(`Cache miss for key: ${fullKey}`);\n        return null;\n      }\n\n      this.log(`Cache hit for key: ${fullKey}`);\n      return this.deserialize<T>(value);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get key: ${key}`,\n        \"get\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set a cached value with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses defaultTTL if not provided)\n   */\n  async set<T>(key: string, value: T, ttlSeconds?: number): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      this.log(`Setting key: ${fullKey} with TTL: ${ttl || \"none\"}`);\n\n      if (ttl !== undefined && ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n      } else {\n        await this.client.set(fullKey, serialized);\n      }\n\n      this.log(`Successfully set key: ${fullKey}`);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set key: ${key}`,\n        \"set\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Delete a cached value by key\n   * @param key - Cache key to delete\n   * @returns True if the key was deleted, false if it didn't exist\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      this.log(`Deleting key: ${fullKey}`);\n\n      const result = await this.client.del(fullKey);\n\n      this.log(`Delete result for key ${fullKey}: ${result > 0}`);\n      return result > 0;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        \"delete\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:123:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullPattern = this.getFullKey(pattern);\n      this.log(`Invalidating pattern: ${fullPattern}`);\n\n      let cursor = \"0\";\n      let deletedCount = 0;\n      const keysToDelete: string[] = [];\n\n      // Use SCAN to find all matching keys (safer than KEYS for production)\n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          \"MATCH\",\n          fullPattern,\n          \"COUNT\",\n          100,\n        );\n\n        cursor = nextCursor;\n        keysToDelete.push(...keys);\n\n        // Delete in batches to avoid blocking\n        if (keysToDelete.length >= 100 || cursor === \"0\") {\n          if (keysToDelete.length > 0) {\n            const deleted = await this.client.del(...keysToDelete);\n            deletedCount += deleted;\n            this.log(`Deleted ${deleted} keys in batch`);\n            keysToDelete.length = 0; // Clear array\n          }\n        }\n      } while (cursor !== \"0\");\n\n      this.log(`Total keys deleted for pattern ${fullPattern}: ${deletedCount}`);\n      return deletedCount;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        \"invalidatePattern\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in the cache\n   * @param key - Cache key\n   * @returns True if the key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.exists(fullKey);\n\n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        \"exists\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get the TTL (time to live) of a key in seconds\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        \"getTTL\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set a new TTL for an existing key\n   * @param key - Cache key\n   * @param ttlSeconds - New TTL in seconds\n   * @returns True if TTL was set successfully\n   */\n  async setTTL(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.expire(fullKey, ttlSeconds);\n\n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to set TTL for key: ${key}`,\n        \"setTTL\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get multiple keys at once\n   * @param keys - Array of cache keys\n   * @returns Map of key to value (null for missing keys)\n   */\n  async getMany<T>(keys: string[]): Promise<Map<string, T | null>> {\n    try {\n      await this.ensureConnection();\n\n      if (keys.length === 0) {\n        return new Map();\n      }\n\n      const fullKeys = keys.map((key) => this.getFullKey(key));\n      const values = await this.client.mget(...fullKeys);\n\n      const result = new Map<string, T | null>();\n\n      keys.forEach((key, index) => {\n        const value = values[index];\n        result.set(key, value ? this.deserialize<T>(value) : null);\n      });\n\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to get multiple keys\",\n        \"getMany\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set multiple key-value pairs at once\n   * @param entries - Array of [key, value, ttl?] tuples\n   */\n  async setMany<T>(\n    entries: Array<[string, T, number?]>,\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      if (entries.length === 0) {\n        return;\n      }\n\n      // Use pipeline for better performance\n      const pipeline = this.client.pipeline();\n\n      for (const [key, value, ttl] of entries) {\n        const fullKey = this.getFullKey(key);\n        const serialized = this.serialize(value);\n        const ttlToUse = ttl ?? this.defaultTTL;\n\n        if (ttlToUse !== undefined && ttlToUse > 0) {\n          pipeline.setex(fullKey, ttlToUse, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      }\n\n      await pipeline.exec();\n      this.log(`Successfully set ${entries.length} keys`);\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to set multiple keys\",\n        \"setMany\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern(\"*\");\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Object with cache statistics\n   */\n  async getStats(): Promise<{\n    connected: boolean;\n    keyCount: number;\n    memoryUsed: string;\n  }> {\n    try {\n      await this.ensureConnection();\n\n      const info = await this.client.info(\"memory\");\n      const memoryMatch = info.match(/used_memory_human:([^\\r\\n]+)/);\n      const memoryUsed = memoryMatch ? memoryMatch[1] : \"unknown\";\n\n      // Count keys with our prefix\n      let cursor = \"0\";\n      let keyCount = 0;\n\n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          \"MATCH\",\n          `${this.keyPrefix}*`,\n          \"COUNT\",\n          1000,\n        );\n        cursor = nextCursor;\n        keyCount += keys.length;\n      } while (cursor !== \"0\");\n\n      return {\n        connected: this.isConnected,\n        keyCount,\n        memoryUsed,\n      };\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to get cache statistics\",\n        \"getStats\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Gracefully disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    try {\n      this.log(\"Disconnecting from Redis...\");\n      await this.client.quit();\n      this.isConnected = false;\n      this.log(\"Disconnected from Redis\");\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to disconnect from Redis\",\n        \"disconnect\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Force disconnect from Redis (use when quit() hangs)\n   */\n  forceDisconnect(): void {\n    this.log(\"Force disconnecting from Redis...\");\n    this.client.disconnect();\n    this.isConnected = false;\n  }\n\n  /**\n   * Check if the cache is connected\n   */\n  isReady(): boolean {\n    return this.isConnected;\n  }\n}\n```\n\nNow let's create comprehensive examples and tests:\n\n```typescript\n// cache.example.ts\nimport { Cache, CacheConfig, CacheError } from \"./cache\";\n\n/**\n * Example usage of the Cache class\n */\n\n// Example 1: Basic usage with connection string\nasync function basicExample() {",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24684,
            "output_tokens": 4096,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Redis Caching Layer with TypeScript\n\nI'll create a comprehensive caching utility module with proper TypeScript generics, error handling, and Redis integration.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig {\n  /** Redis connection options */\n  redis?: RedisOptions;\n  /** Default TTL in seconds (0 = no expiration) */\n  defaultTTL?: number;\n  /** Key prefix for all cache entries */\n  keyPrefix?: string;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n/**\n * Cache operation result\n */\nexport interface CacheResult<T> {\n  success: boolean;\n  data?: T;\n  error?: Error;\n}\n\n/**\n * Cache statistics\n */\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  sets: number;\n  deletes: number;\n  errors: number;\n}\n\n/**\n * Generic caching layer using Redis with TypeScript support\n */\nexport class Cache {\n  private client: Redis;\n  private config: Required<CacheConfig>;\n  private stats: CacheStats;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      redis: config.redis || {},\n      defaultTTL: config.defaultTTL ?? 3600, // 1 hour default\n      keyPrefix: config.keyPrefix || 'cache:',\n      debug: config.debug ?? false,\n    };\n\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      deletes: 0,\n      errors: 0,\n    };\n\n    // Initialize Redis client with connection handling\n    this.client = new Redis({\n      ...this.config.redis,\n      lazyConnect: true,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection (attempt ${times}) in ${delay}ms`);\n        return delay;\n      },\n      reconnectOnError: (err: Error) => {\n        const targetError = 'READONLY';\n        if (err.message.includes(targetError)) {\n          // Reconnect on READONLY errors\n          return true;\n        }\n        return false;\n      },\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup Redis event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client ready');\n    });\n\n    this.client.on('error', (err: Error) => {\n      this.isConnected = false;\n      this.stats.errors++;\n      this.log(`Redis error: ${err.message}`, 'error');\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Ensure Redis connection is established\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    // Reuse existing connection attempt if in progress\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    this.connectionPromise = this.client\n      .connect()\n      .then(() => {\n        this.connectionPromise = null;\n      })\n      .catch((err) => {\n        this.connectionPromise = null;\n        throw new Error(`Failed to connect to Redis: ${err.message}`);\n      });\n\n    return this.connectionPromise;\n  }\n\n  /**\n   * Build full cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify({\n        data: value,\n        timestamp: Date.now(),\n      });\n    } catch (err) {\n      throw new Error(\n        `Failed to serialize value: ${err instanceof Error ? err.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const parsed = JSON.parse(value);\n      return parsed.data as T;\n    } catch (err) {\n      throw new Error(\n        `Failed to deserialize value: ${err instanceof Error ? err.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Log debug messages\n   */\n  private log(message: string, level: 'info' | 'error' = 'info'): void {\n    if (this.config.debug) {\n      const timestamp = new Date().toISOString();\n      const prefix = `[Cache ${timestamp}]`;\n      if (level === 'error') {\n        console.error(`${prefix} ${message}`);\n      } else {\n        console.log(`${prefix} ${message}`);\n      }\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns Promise resolving to the cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`GET ${fullKey}`);\n\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        this.stats.misses++;\n        this.log(`MISS ${fullKey}`);\n        return null;\n      }\n\n      this.stats.hits++;\n      this.log(`HIT ${fullKey}`);\n\n      return this.deserialize<T>(value);\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error getting key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Set a value in cache\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses defaultTTL if not provided)\n   * @returns Promise resolving to true if successful\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      this.log(`SET ${fullKey} (TTL: ${ttl}s)`);\n\n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n      } else {\n        await this.client.set(fullKey, serialized);\n      }\n\n      this.stats.sets++;\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error setting key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key was deleted, false if key didn't exist\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`DELETE ${fullKey}`);\n\n      const result = await this.client.del(fullKey);\n      this.stats.deletes++;\n\n      return result > 0;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error deleting key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:*\")\n   * @returns Promise resolving to the number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullPattern = this.buildKey(pattern);\n      this.log(`INVALIDATE PATTERN ${fullPattern}`);\n\n      let cursor = '0';\n      let totalDeleted = 0;\n\n      // Use SCAN to avoid blocking Redis with KEYS\n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100\n        );\n\n        cursor = nextCursor;\n\n        if (keys.length > 0) {\n          const deleted = await this.client.del(...keys);\n          totalDeleted += deleted;\n          this.stats.deletes += deleted;\n          this.log(`Deleted ${deleted} keys matching ${fullPattern}`);\n        }\n      } while (cursor !== '0');\n\n      this.log(`Total deleted: ${totalDeleted} keys`);\n      return totalDeleted;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(\n        `Error invalidating pattern ${pattern}: ${error.message}`,\n        'error'\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n\n      return result === 1;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error checking existence of key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns Promise resolving to TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async ttl(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error getting TTL for key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Update TTL for an existing key\n   * @param key - Cache key\n   * @param ttlSeconds - New TTL in seconds\n   * @returns Promise resolving to true if successful\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const result = await this.client.expire(fullKey, ttlSeconds);\n\n      return result === 1;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error setting expiry for key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Get multiple values at once\n   * @param keys - Array of cache keys\n   * @returns Promise resolving to array of values (null for missing keys)\n   */\n  async mget<T>(keys: string[]): Promise<(T | null)[]> {\n    try {\n      await this.ensureConnection();\n\n      const fullKeys = keys.map((k) => this.buildKey(k));\n      this.log(`MGET ${fullKeys.length} keys`);\n\n      const values = await this.client.mget(...fullKeys);\n\n      return values.map((value, index) => {\n        if (value === null) {\n          this.stats.misses++;\n          return null;\n        }\n        this.stats.hits++;\n        try {\n          return this.deserialize<T>(value);\n        } catch (err) {\n          this.log(\n            `Error deserializing key ${keys[index]}: ${err instanceof Error ? err.message : 'Unknown error'}`,\n            'error'\n          );\n          return null;\n        }\n      });\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error in mget: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Set multiple values at once\n   * @param entries - Array of [key, value, ttl?] tuples\n   * @returns Promise resolving to true if all successful\n   */\n  async mset<T>(\n    entries: Array<[string, T, number?]>\n  ): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      this.log(`MSET ${entries.length} keys`);\n\n      // Use pipeline for atomic operations\n      const pipeline = this.client.pipeline();\n\n      for (const [key, value, ttl] of entries) {\n        const fullKey = this.buildKey(key);\n        const serialized = this.serialize(value);\n        const ttlToUse = ttl ?? this.config.defaultTTL;\n\n        if (ttlToUse > 0) {\n          pipeline.setex(fullKey, ttlToUse, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      }\n\n      await pipeline.exec();\n      this.stats.sets += entries.length;\n\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error in mset: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Promise resolving to the number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern('*');\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Current cache statistics\n   */\n  getStats(): Readonly<CacheStats> {\n    return { ...this.stats };\n  }\n\n  /**\n   * Reset cache statistics\n   */\n  resetStats(): void {\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      deletes: 0,\n      errors: 0,\n    };\n  }\n\n  /**\n   * Get cache hit rate\n   * @returns Hit rate as a percentage (0-100)\n   */\n  getHitRate(): number {\n    const total = this.stats.hits + this.stats.misses;\n    if (total === 0) return 0;\n    return (this.stats.hits / total) * 100;\n  }\n\n  /**\n   * Check if cache is connected\n   * @returns True if connected to Redis\n   */\n  isReady(): boolean {\n    return this.isConnected;\n  }\n\n  /**\n   * Disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    this.log('Disconnecting from Redis...');\n    await this.client.quit();\n    this.isConnected = false;\n  }\n\n  /**\n   * Get the underlying Redis client (for advanced operations)\n   * @returns",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2236,
            "output_tokens": 4096,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive Redis caching utility module with proper TypeScript generics and error handling.\n\n```typescript\n// src/lib/cache.ts\nimport Redis, { RedisOptions } from \"ioredis\";\n\nexport interface CacheOptions {\n  redis?: RedisOptions;\n  keyPrefix?: string;\n  defaultTTL?: number;\n}\n\nexport interface CacheResult<T> {\n  data: T | null;\n  error?: string;\n}\n\nexport class Cache {\n  private client: Redis;\n  private keyPrefix: string;\n  private defaultTTL: number;\n  private isConnected: boolean = false;\n\n  constructor(options: CacheOptions = {}) {\n    this.keyPrefix = options.keyPrefix ?? \"cache:\";\n    this.defaultTTL = options.defaultTTL ?? 3600; // 1 hour default\n\n    const redisOptions: RedisOptions = {\n      host: process.env.REDIS_HOST ?? \"localhost\",\n      port: parseInt(process.env.REDIS_PORT ?? \"6379\", 10),\n      password: process.env.REDIS_PASSWORD,\n      db: parseInt(process.env.REDIS_DB ?? \"0\", 10),\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      ...options.redis,\n    };\n\n    this.client = new Redis(redisOptions);\n\n    this.client.on(\"connect\", () => {\n      this.isConnected = true;\n      console.log(\"Redis connected\");\n    });\n\n    this.client.on(\"error\", (error: Error) => {\n      this.isConnected = false;\n      console.error(\"Redis connection error:\", error.message);\n    });\n\n    this.client.on(\"close\", () => {\n      this.isConnected = false;\n      console.log(\"Redis connection closed\");\n    });\n  }\n\n  /**\n   * Get a value from cache\n   */\n  async get<T>(key: string): Promise<CacheResult<T>> {\n    if (!this.isConnected) {\n      return {\n        data: null,\n        error: \"Redis client not connected\",\n      };\n    }\n\n    try {\n      const fullKey = this.buildKey(key);\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        return { data: null };\n      }\n\n      const parsed = JSON.parse(value) as T;\n      return { data: parsed };\n    } catch (error) {\n      const message =\n        error instanceof Error ? error.message : \"Unknown error\";\n      console.error(`Cache get error for key \"${key}\":`, message);\n      return {\n        data: null,\n        error: `Failed to get cache: ${message}`,\n      };\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number,\n  ): Promise<{ success: boolean; error?: string }> {\n    if (!this.isConnected) {\n      return {\n        success: false,\n        error: \"Redis client not connected\",\n      };\n    }\n\n    try {\n      const fullKey = this.buildKey(key);\n      const serialized = JSON.stringify(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n      } else {\n        await this.client.set(fullKey, serialized);\n      }\n\n      return { success: true };\n    } catch (error) {\n      const message =\n        error instanceof Error ? error.message : \"Unknown error\";\n      console.error(`Cache set error for key \"${key}\":`, message);\n      return {\n        success: false,\n        error: `Failed to set cache: ${message}`,\n      };\n    }\n  }\n\n  /**\n   * Delete a specific key from cache\n   */\n  async delete(key: string): Promise<{ success: boolean; error?: string }> {\n    if (!this.isConnected) {\n      return {\n        success: false,\n        error: \"Redis client not connected\",\n      };\n    }\n\n    try {\n      const fullKey = this.buildKey(key);\n      await this.client.del(fullKey);\n      return { success: true };\n    } catch (error) {\n      const message =\n        error instanceof Error ? error.message : \"Unknown error\";\n      console.error(`Cache delete error for key \"${key}\":`, message);\n      return {\n        success: false,\n        error: `Failed to delete cache: ${message}`,\n      };\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * Pattern examples: \"user:*\", \"*:profile\", \"session:*:data\"\n   */\n  async invalidatePattern(\n    pattern: string,\n  ): Promise<{ deletedCount: number; error?: string }> {\n    if (!this.isConnected) {\n      return {\n        deletedCount: 0,\n        error: \"Redis client not connected\",\n      };\n    }\n\n    try {\n      const fullPattern = this.buildKey(pattern);\n      const keys = await this.scanKeys(fullPattern);\n\n      if (keys.length === 0) {\n        return { deletedCount: 0 };\n      }\n\n      // Delete in batches to avoid blocking Redis\n      const batchSize = 100;\n      let deletedCount = 0;\n\n      for (let i = 0; i < keys.length; i += batchSize) {\n        const batch = keys.slice(i, i + batchSize);\n        const result = await this.client.del(...batch);\n        deletedCount += result;\n      }\n\n      return { deletedCount };\n    } catch (error) {\n      const message =\n        error instanceof Error ? error.message : \"Unknown error\";\n      console.error(`Cache invalidate pattern error for \"${pattern}\":`, message);\n      return {\n        deletedCount: 0,\n        error: `Failed to invalidate pattern: ${message}`,\n      };\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   */\n  async exists(key: string): Promise<boolean> {\n    if (!this.isConnected) {\n      return false;\n    }\n\n    try {\n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n      return result === 1;\n    } catch (error) {\n      console.error(`Cache exists error for key \"${key}\":`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key (in seconds)\n   */\n  async getTTL(key: string): Promise<number | null> {\n    if (!this.isConnected) {\n      return null;\n    }\n\n    try {\n      const fullKey = this.buildKey(key);\n      const ttl = await this.client.ttl(fullKey);\n      // -2 means key doesn't exist, -1 means no expiry\n      return ttl >= -1 ? ttl : null;\n    } catch (error) {\n      console.error(`Cache getTTL error for key \"${key}\":`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   */\n  async clear(): Promise<{ deletedCount: number; error?: string }> {\n    return this.invalidatePattern(\"*\");\n  }\n\n  /**\n   * Close the Redis connection\n   */\n  async disconnect(): Promise<void> {\n    try {\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (error) {\n      console.error(\"Error disconnecting from Redis:\", error);\n      // Force disconnect even if quit fails\n      this.client.disconnect();\n    }\n  }\n\n  /**\n   * Get connection status\n   */\n  getConnectionStatus(): boolean {\n    return this.isConnected;\n  }\n\n  /**\n   * Build full key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Scan for keys matching a pattern using SCAN (non-blocking)\n   */\n  private async scanKeys(pattern: string): Promise<string[]> {\n    const keys: string[] = [];\n    let cursor = \"0\";\n\n    do {\n      const [nextCursor, foundKeys] = await this.client.scan(\n        cursor,\n        \"MATCH\",\n        pattern,\n        \"COUNT\",\n        100,\n      );\n      cursor = nextCursor;\n      keys.push(...foundKeys);\n    } while (cursor !== \"0\");\n\n    return keys;\n  }\n}\n\n// Singleton instance for convenience\nlet cacheInstance: Cache | null = null;\n\nexport function getCache(options?: CacheOptions): Cache {\n  if (!cacheInstance) {\n    cacheInstance = new Cache(options);\n  }\n  return cacheInstance;\n}\n\nexport function resetCache(): void {\n  if (cacheInstance) {\n    cacheInstance.disconnect();\n    cacheInstance = null;\n  }\n}\n```\n\nNow let's create a comprehensive test suite:\n\n```typescript\n// src/lib/cache.test.ts\nimport { describe, it, expect, beforeEach, afterEach, vi } from \"vitest\";\nimport { Cache } from \"./cache\";\n\n// Mock ioredis\nvi.mock(\"ioredis\", () => {\n  const mockRedis = vi.fn().mockImplementation(() => {\n    const store = new Map<string, { value: string; ttl?: number }>();\n    let connected = false;\n    const listeners: Record<string, Function[]> = {};\n\n    const emit = (event: string, ...args: any[]) => {\n      if (listeners[event]) {\n        listeners[event].forEach((fn) => fn(...args));\n      }\n    };\n\n    // Simulate connection after a tick\n    setTimeout(() => {\n      connected = true;\n      emit(\"connect\");\n    }, 0);\n\n    return {\n      on: vi.fn((event: string, callback: Function) => {\n        if (!listeners[event]) listeners[event] = [];\n        listeners[event].push(callback);\n      }),\n      get: vi.fn(async (key: string) => {\n        if (!connected) throw new Error(\"Not connected\");\n        return store.get(key)?.value ?? null;\n      }),\n      set: vi.fn(async (key: string, value: string) => {\n        if (!connected) throw new Error(\"Not connected\");\n        store.set(key, { value });\n        return \"OK\";\n      }),\n      setex: vi.fn(async (key: string, ttl: number, value: string) => {\n        if (!connected) throw new Error(\"Not connected\");\n        store.set(key, { value, ttl });\n        return \"OK\";\n      }),\n      del: vi.fn(async (...keys: string[]) => {\n        if (!connected) throw new Error(\"Not connected\");\n        let count = 0;\n        keys.forEach((key) => {\n          if (store.delete(key)) count++;\n        });\n        return count;\n      }),\n      exists: vi.fn(async (key: string) => {\n        if (!connected) throw new Error(\"Not connected\");\n        return store.has(key) ? 1 : 0;\n      }),\n      ttl: vi.fn(async (key: string) => {\n        if (!connected) throw new Error(\"Not connected\");\n        const entry = store.get(key);\n        if (!entry) return -2;\n        return entry.ttl ?? -1;\n      }),\n      scan: vi.fn(async (cursor: string, ...args: any[]) => {\n        if (!connected) throw new Error(\"Not connected\");\n        const pattern = args[args.indexOf(\"MATCH\") + 1];\n        const keys = Array.from(store.keys()).filter((key) => {\n          const regex = new RegExp(\n            \"^\" + pattern.replace(/\\*/g, \".*\").replace(/\\?/g, \".\") + \"$\",\n          );\n          return regex.test(key);\n        });\n        return [\"0\", keys];\n      }),\n      quit: vi.fn(async () => {\n        connected = false;\n        emit(\"close\");\n        return \"OK\";\n      }),\n      disconnect: vi.fn(() => {\n        connected = false;\n        emit(\"close\");\n      }),\n    };\n  });\n\n  return { default: mockRedis };\n});\n\ndescribe(\"Cache\", () => {\n  let cache: Cache;\n\n  beforeEach(async () => {\n    cache = new Cache({ keyPrefix: \"test:\" });\n    // Wait for connection\n    await new Promise((resolve) => setTimeout(resolve, 10));\n  });\n\n  afterEach(async () => {\n    await cache.disconnect();\n  });\n\n  describe(\"get\", () => {\n    it(\"should return null for non-existent key\", async () => {\n      const result = await cache.get<string>(\"nonexistent\");\n      expect(result.data).toBeNull();\n      expect(result.error).toBeUndefined();\n    });\n\n    it(\"should retrieve and deserialize stored value\", async () => {\n      const testData = { id: 1, name: \"Test User\" };\n      await cache.set(\"user:1\", testData);\n\n      const result = await cache.get<typeof testData>(\"user:1\");\n      expect(result.data).toEqual(testData);\n      expect(result.error).toBeUndefined();\n    });\n\n    it(\"should handle different data types\", async () => {\n      await cache.set(\"string\", \"hello\");\n      await cache.set(\"number\", 42);\n      await cache.set(\"boolean\", true);\n      await cache.set(\"array\", [1, 2, 3]);\n\n      expect((await cache.get<string>(\"string\")).data).toBe(\"hello\");\n      expect((await cache.get<number>(\"number\")).data).toBe(42);\n      expect((await cache.get<boolean>(\"boolean\")).data).toBe(true);\n      expect((await cache.get<number[]>(\"array\")).data).toEqual([1, 2, 3]);\n    });\n  });\n\n  describe(\"set\", () => {\n    it(\"should store value with default TTL\", async () => {\n      const result = await cache.set(\"key1\", \"value1\");\n      expect(result.success).toBe(true);\n      expect(result.error).toBeUndefined();\n\n      const retrieved = await cache.get<string>(\"key1\");\n      expect(retrieved.data).toBe(\"value1\");\n    });\n\n    it(\"should store value with custom TTL\", async () => {\n      const result = await cache.set(\"key2\", \"value2\", 300);\n      expect(result.success).toBe(true);\n\n      const retrieved = await cache.get<string>(\"key2\");\n      expect(retrieved.data).toBe(\"value2\");\n    });\n\n    it(\"should serialize complex objects\", async () => {\n      const complexData = {\n        user: { id: 1, name: \"John\" },\n        posts: [\n          { id: 1, title: \"Post 1\" },\n          { id: 2, title: \"Post 2\" },\n        ],\n        metadata: { created: new Date().toISOString() },\n      };\n\n      await cache.set(\"complex\", complexData);\n      const result = await cache.get<typeof complexData>(\"complex\");\n      expect(result.data).toEqual(complexData);\n    });\n  });\n\n  describe(\"delete\", () => {\n    it(\"should delete existing key\", async () => {\n      await cache.set(\"toDelete\", \"value\");\n      expect(await cache.exists(\"toDelete\")).toBe(true);\n\n      const result = await cache.delete(\"toDelete\");\n      expect(result.success).toBe(true);\n      expect(await cache.exists(\"toDelete\")).toBe(false);\n    });\n\n    it(\"should succeed even if key doesn't exist\", async () => {\n      const result = await cache.delete(\"nonexistent\");\n      expect(result.success).toBe(true);\n    });\n  });\n\n  describe(\"invalidatePattern\", () => {\n    it(\"should delete all keys matching pattern\", async () => {\n      await cache.set(\"user:1\", { id: 1 });\n      await cache.set(\"user:2\", { id: 2 });\n      await cache.set(\"user:3\", { id: 3 });\n      await cache.set(\"post:1\", { id: 1 });",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25179,
            "output_tokens": 4096,
            "cached": true
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Redis Caching Layer Utility Module\n\n```typescript\n// cache.ts\nimport Redis, { Redis as RedisClient, RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig extends RedisOptions {\n  host?: string;\n  port?: number;\n  password?: string;\n  db?: number;\n  keyPrefix?: string;\n  retryStrategy?: (times: number) => number | void;\n  maxRetriesPerRequest?: number;\n}\n\n/**\n * Custom error class for cache-related errors\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Result wrapper for cache operations\n */\nexport interface CacheResult<T> {\n  success: boolean;\n  data?: T;\n  error?: CacheError;\n}\n\n/**\n * Generic Redis caching layer with TypeScript support\n */\nexport class Cache {\n  private client: RedisClient;\n  private isConnected: boolean = false;\n  private readonly keyPrefix: string;\n\n  constructor(config: CacheConfig = {}) {\n    this.keyPrefix = config.keyPrefix || 'cache:';\n\n    const defaultConfig: CacheConfig = {\n      host: config.host || process.env.REDIS_HOST || 'localhost',\n      port: config.port || parseInt(process.env.REDIS_PORT || '6379'),\n      password: config.password || process.env.REDIS_PASSWORD,\n      db: config.db || 0,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      lazyConnect: true,\n      ...config,\n    };\n\n    this.client = new Redis(defaultConfig);\n\n    // Connection event handlers\n    this.client.on('connect', () => {\n      this.isConnected = true;\n      console.log('Redis client connected');\n    });\n\n    this.client.on('ready', () => {\n      console.log('Redis client ready');\n    });\n\n    this.client.on('error', (err: Error) => {\n      console.error('Redis client error:', err);\n      this.isConnected = false;\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      console.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      console.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Establish connection to Redis\n   */\n  async connect(): Promise<void> {\n    try {\n      await this.client.connect();\n      this.isConnected = true;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to connect to Redis',\n        'connect',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if the client is connected\n   */\n  public get connected(): boolean {\n    return this.isConnected && this.client.status === 'ready';\n  }\n\n  /**\n   * Get the full key with prefix\n   */\n  private getFullKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify({\n        data: value,\n        timestamp: Date.now(),\n        type: typeof value,\n      });\n    } catch (error) {\n      throw new CacheError(\n        'Failed to serialize value',\n        'serialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const parsed = JSON.parse(value);\n      return parsed.data as T;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to deserialize value',\n        'deserialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns Promise resolving to the cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'get'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        return null;\n      }\n\n      return this.deserialize<T>(value);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get key: ${key}`,\n        'get',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get a value from cache with error handling wrapper\n   * @param key - Cache key\n   * @returns Promise resolving to CacheResult\n   */\n  async getSafe<T>(key: string): Promise<CacheResult<T>> {\n    try {\n      const data = await this.get<T>(key);\n      return {\n        success: true,\n        data: data || undefined,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error as CacheError,\n      };\n    }\n  }\n\n  /**\n   * Set a value in cache\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   * @returns Promise resolving to true if successful\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'set'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const serialized = this.serialize(value);\n\n      if (ttlSeconds && ttlSeconds > 0) {\n        const result = await this.client.setex(\n          fullKey,\n          ttlSeconds,\n          serialized\n        );\n        return result === 'OK';\n      } else {\n        const result = await this.client.set(fullKey, serialized);\n        return result === 'OK';\n      }\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set key: ${key}`,\n        'set',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with error handling wrapper\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   * @returns Promise resolving to CacheResult\n   */\n  async setSafe<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<CacheResult<boolean>> {\n    try {\n      const success = await this.set(key, value, ttlSeconds);\n      return {\n        success: true,\n        data: success,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error as CacheError,\n      };\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key to delete\n   * @returns Promise resolving to true if key was deleted\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'delete'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.del(fullKey);\n      return result > 0;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        'delete',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Delete multiple keys from cache\n   * @param keys - Array of cache keys to delete\n   * @returns Promise resolving to number of keys deleted\n   */\n  async deleteMany(keys: string[]): Promise<number> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'deleteMany'\n        );\n      }\n\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      const fullKeys = keys.map((key) => this.getFullKey(key));\n      const result = await this.client.del(...fullKeys);\n      return result;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        'Failed to delete multiple keys',\n        'deleteMany',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Pattern to match (e.g., \"user:*\")\n   * @returns Promise resolving to number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'invalidatePattern'\n        );\n      }\n\n      const fullPattern = this.getFullKey(pattern);\n      const keys: string[] = [];\n\n      // Use SCAN to find all matching keys (safer than KEYS for production)\n      let cursor = '0';\n      do {\n        const [nextCursor, foundKeys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100\n        );\n        cursor = nextCursor;\n        keys.push(...foundKeys);\n      } while (cursor !== '0');\n\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      // Delete all found keys\n      const result = await this.client.del(...keys);\n      return result;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        'invalidatePattern',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'exists'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.exists(fullKey);\n      return result === 1;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        'exists',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get the TTL (time to live) of a key in seconds\n   * @param key - Cache key\n   * @returns Promise resolving to TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'getTTL'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        'getTTL',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set expiry time for a key\n   * @param key - Cache key\n   * @param ttlSeconds - Time to live in seconds\n   * @returns Promise resolving to true if expiry was set\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'expire'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.expire(fullKey, ttlSeconds);\n      return result === 1;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set expiry for key: ${key}`,\n        'expire',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * WARNING: Use with caution in production\n   * @returns Promise resolving to number of keys deleted\n   */\n  async clear(): Promise<number> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'clear'\n        );\n      }\n\n      return await this.invalidatePattern('*');\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        'Failed to clear cache',\n        'clear',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get multiple values from cache\n   * @param keys - Array of cache keys\n   * @returns Promise resolving to array of values (null for missing keys)\n   */\n  async getMany<T>(keys: string[]): Promise<(T | null)[]> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'getMany'\n        );\n      }\n\n      if (keys.length === 0) {\n        return [];\n      }\n\n      const fullKeys = keys.map((key) => this.getFullKey(key));\n      const values = await this.client.mget(...fullKeys);\n\n      return values.map((value) => {\n        if (value === null) {\n          return null;\n        }\n        return this.deserialize<T>(value);\n      });\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        'Failed to get multiple keys',\n        'getMany',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set multiple key-value pairs\n   * @param entries - Array of [key, value, ttl?] tuples\n   * @returns Promise resolving to true if all operations succeeded\n   */\n  async setMany<T>(\n    entries: Array<[string, T, number?]>\n  ): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'setMany'\n        );\n      }\n\n      if (entries.length === 0) {\n        return true;\n      }\n\n      const pipeline = this.client.pipeline();\n\n      for (const [key, value, ttl] of entries) {\n        const fullKey = this.getFullKey(key);\n        const serialized = this.serialize(value);\n\n        if (ttl && ttl > 0) {\n          pipeline.setex(fullKey, ttl, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      }\n\n      const results = await pipeline.exec();\n\n      if (!results) {\n        return false;\n      }\n\n      // Check if all operations succeeded\n      return results.every(\n        ([error, result]) => error === null && result === '",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 94,
            "output_tokens": 4096,
            "cached": true
          },
          "with_skill": {
            "output": "```typescript\nimport Redis, { RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig extends RedisOptions {\n  /**\n   * Prefix to add to all cache keys (useful for namespacing)\n   */\n  keyPrefix?: string;\n  /**\n   * Default TTL in seconds if not specified in set()\n   */\n  defaultTTL?: number;\n  /**\n   * Whether to throw errors or return null on failures\n   */\n  throwOnError?: boolean;\n}\n\n/**\n * Error thrown when cache operations fail\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Generic caching layer using Redis with TypeScript support\n */\nexport class Cache {\n  private client: Redis;\n  private keyPrefix: string;\n  private defaultTTL: number;\n  private throwOnError: boolean;\n  private isConnected: boolean = false;\n\n  constructor(config: CacheConfig = {}) {\n    const {\n      keyPrefix = 'cache:',\n      defaultTTL = 3600,\n      throwOnError = false,\n      ...redisOptions\n    } = config;\n\n    this.keyPrefix = keyPrefix;\n    this.defaultTTL = defaultTTL;\n    this.throwOnError = throwOnError;\n\n    // Initialize Redis client\n    this.client = new Redis({\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      enableReadyCheck: true,\n      ...redisOptions,\n    });\n\n    // Set up event handlers\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Set up Redis client event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.isConnected = true;\n      console.log('Redis client connected');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      console.log('Redis client ready');\n    });\n\n    this.client.on('error', (error: Error) => {\n      console.error('Redis client error:', error);\n      this.isConnected = false;\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      console.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      console.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Build the full cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Handle errors based on configuration\n   */\n  private handleError(\n    operation: string,\n    error: Error,\n    defaultValue: any = null\n  ): any {\n    const cacheError = new CacheError(\n      `Cache ${operation} failed: ${error.message}`,\n      operation,\n      error\n    );\n\n    if (this.throwOnError) {\n      throw cacheError;\n    }\n\n    console.error(cacheError.message, cacheError.originalError);\n    return defaultValue;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify(value);\n    } catch (error) {\n      throw new CacheError(\n        'Failed to serialize value',\n        'serialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      return JSON.parse(value) as T;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to deserialize value',\n        'deserialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if the client is connected\n   */\n  public isReady(): boolean {\n    return this.isConnected && this.client.status === 'ready';\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns The cached value or null if not found/error\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      if (!this.isReady()) {\n        throw new Error('Redis client is not ready');\n      }\n\n      const fullKey = this.buildKey(key);\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        return null;\n      }\n\n      return this.deserialize<T>(value);\n    } catch (error) {\n      return this.handleError('get', error as Error, null);\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   * @returns true if successful, false otherwise\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<boolean> {\n    try {\n      if (!this.isReady()) {\n        throw new Error('Redis client is not ready');\n      }\n\n      const fullKey = this.buildKey(key);\n      const serializedValue = this.serialize(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serializedValue);\n      } else {\n        await this.client.set(fullKey, serializedValue);\n      }\n\n      return true;\n    } catch (error) {\n      return this.handleError('set', error as Error, false);\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key to delete\n   * @returns true if key was deleted, false otherwise\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      if (!this.isReady()) {\n        throw new Error('Redis client is not ready');\n      }\n\n      const fullKey = this.buildKey(key);\n      const result = await this.client.del(fullKey);\n\n      return result > 0;\n    } catch (error) {\n      return this.handleError('delete', error as Error, false);\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Pattern to match (e.g., \"user:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      if (!this.isReady()) {\n        throw new Error('Redis client is not ready');\n      }\n\n      const fullPattern = this.buildKey(pattern);\n      const keys: string[] = [];\n      let cursor = '0';\n\n      // Use SCAN to find all matching keys\n      do {\n        const [nextCursor, foundKeys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100\n        );\n        cursor = nextCursor;\n        keys.push(...foundKeys);\n      } while (cursor !== '0');\n\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      // Delete all found keys using pipeline for efficiency\n      const pipeline = this.client.pipeline();\n      keys.forEach((key) => pipeline.del(key));\n      await pipeline.exec();\n\n      return keys.length;\n    } catch (error) {\n      return this.handleError('invalidatePattern', error as Error, 0);\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns true if key exists, false otherwise\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      if (!this.isReady()) {\n        throw new Error('Redis client is not ready');\n      }\n\n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n\n      return result === 1;\n    } catch (error) {\n      return this.handleError('exists', error as Error, false);\n    }\n  }\n\n  /**\n   * Get the remaining TTL for a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist, null on error\n   */\n  async ttl(key: string): Promise<number | null> {\n    try {\n      if (!this.isReady()) {\n        throw new Error('Redis client is not ready');\n      }\n\n      const fullKey = this.buildKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (error) {\n      return this.handleError('ttl', error as Error, null);\n    }\n  }\n\n  /**\n   * Set multiple key-value pairs at once\n   * @param entries - Array of [key, value, ttl?] tuples\n   * @returns true if all operations succeeded, false otherwise\n   */\n  async setMany<T>(\n    entries: Array<[string, T, number?]>\n  ): Promise<boolean> {\n    try {\n      if (!this.isReady()) {\n        throw new Error('Redis client is not ready');\n      }\n\n      const pipeline = this.client.pipeline();\n\n      for (const [key, value, ttl] of entries) {\n        const fullKey = this.buildKey(key);\n        const serializedValue = this.serialize(value);\n        const ttlSeconds = ttl ?? this.defaultTTL;\n\n        if (ttlSeconds > 0) {\n          pipeline.setex(fullKey, ttlSeconds, serializedValue);\n        } else {\n          pipeline.set(fullKey, serializedValue);\n        }\n      }\n\n      const results = await pipeline.exec();\n\n      // Check if all operations succeeded\n      return results?.every(([error]) => error === null) ?? false;\n    } catch (error) {\n      return this.handleError('setMany', error as Error, false);\n    }\n  }\n\n  /**\n   * Get multiple values at once\n   * @param keys - Array of cache keys\n   * @returns Array of values (null for missing keys)\n   */\n  async getMany<T>(keys: string[]): Promise<Array<T | null>> {\n    try {\n      if (!this.isReady()) {\n        throw new Error('Redis client is not ready');\n      }\n\n      if (keys.length === 0) {\n        return [];\n      }\n\n      const fullKeys = keys.map((key) => this.buildKey(key));\n      const values = await this.client.mget(...fullKeys);\n\n      return values.map((value) =>\n        value === null ? null : this.deserialize<T>(value)\n      );\n    } catch (error) {\n      return this.handleError(\n        'getMany',\n        error as Error,\n        new Array(keys.length).fill(null)\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern('*');\n  }\n\n  /**\n   * Close the Redis connection\n   */\n  async disconnect(): Promise<void> {\n    try {\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (error) {\n      console.error('Error disconnecting from Redis:', error);\n      // Force close if graceful quit fails\n      this.client.disconnect();\n    }\n  }\n\n  /**\n   * Get the underlying Redis client (for advanced operations)\n   */\n  getClient(): Redis {\n    return this.client;\n  }\n}\n\n/**\n * Create a cache instance with default configuration\n */\nexport function createCache(config?: CacheConfig): Cache {\n  return new Cache(config);\n}\n\n// Export types for consumers\nexport type { RedisOptions };\n```\n\n```typescript\n// Example usage file: cache.example.ts\n\nimport { Cache, createCache, CacheError } from './cache';\n\n// Example 1: Basic usage\nasync function basicExample() {\n  const cache = createCache({\n    host: 'localhost',\n    port: 6379,\n    keyPrefix: 'myapp:',\n    defaultTTL: 3600,\n  });\n\n  // Set a value\n  await cache.set('user:123', { id: 123, name: 'John Doe' }, 300);\n\n  // Get a value with type safety\n  interface User {\n    id: number;\n    name: string;\n  }\n  const user = await cache.get<User>('user:123');\n  console.log(user); // { id: 123, name: 'John Doe' }\n\n  // Delete a key\n  await cache.delete('user:123');\n\n  // Clean up\n  await cache.disconnect();\n}\n\n// Example 2: Pattern invalidation\nasync function patternExample() {\n  const cache = createCache();\n\n  // Set multiple user keys\n  await cache.set('user:1', { id: 1, name: 'Alice' });\n  await cache.set('user:2', { id: 2, name: 'Bob' });\n  await cache.set('post:1', { id: 1, title: 'Hello' });\n\n  // Invalidate all user keys\n  const deleted = await cache.invalidatePattern('user:*');\n  console.log(`Deleted ${deleted} user keys`);\n\n  await cache.disconnect();\n}\n\n// Example 3: Batch operations\nasync function batchExample() {\n  const cache = createCache();\n\n  // Set multiple values at once\n  await cache.setMany([\n    ['product:1', { id: 1, name: 'Widget' }, 600],\n    ['product:2', { id: 2, name: 'Gadget' }, 600],\n    ['product:3', { id: 3, name: 'Doohickey' }], // Uses default TTL\n  ]);\n\n  // Get multiple values at once\n  const products = await cache.getMany<{ id: number; name: string }>([\n    'product:1',\n    'product:2',\n    'product:3',\n  ]);\n  console.log(products);\n\n  await cache.disconnect();\n}\n\n// Example 4: Error handling with throwOnError\nasync function errorHandlingExample() {\n  const cache = new Cache({\n    host: 'invalid-host',\n    throwOnError: true,\n  });\n\n  try {\n    await cache.set('key', 'value');\n  } catch (error) {\n    if (error instanceof CacheError) {\n      console.error(`Operation ${error.operation} failed:`, error.message);\n    }\n  }\n\n  await cache.disconnect();\n}\n\n// Example 5: TTL management\nasync function ttlExample() {\n  const cache = createCache();\n\n  await cache.set('session:abc', { userId: 123 }, 60);\n\n  // Check if key exists\n  const exists = await cache.exists('session:abc');\n  console.log('Session exists:', exists);\n\n  // Get remaining TTL\n  const ttl = await cache.ttl('session:abc');\n  console.log('TTL remaining:', ttl, 'seconds');\n\n  await cache.disconnect();\n}\n```\n\nThis implementation provides:\n\n1. **Generic TypeScript support** - Full type safety with `get<T>()` and `set<T>()`\n2. **JSON serialization** - Automatic serialization/deserialization with error handling\n3. **Connection management** - Event handlers for connection states with retry strategy\n4. **Error handling** - Configurable error behavior (throw or return null)\n5. **Key prefixing** - Namespace support for multi-tenant applications\n6. **Pattern invalidation** - Efficient bulk deletion using SCAN\n7. **Batch operations** - `setMany()` and `getMany()` using pipelines\n8. **TTL management** - Configurable default TTL with per-key override\n9. **Additional utilities** - `exists()`, `ttl()`, `clear()`, connection status checks\n\nThe module is production-ready with proper error handling",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 24684,
            "output_tokens": 4096,
            "cached": true
          },
          "skill_md_only": {
            "output": "# Redis Caching Layer with TypeScript\n\nI'll create a comprehensive caching utility module with proper TypeScript generics, error handling, and Redis integration.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig {\n  /** Redis connection options */\n  redis?: RedisOptions;\n  /** Default TTL in seconds (optional) */\n  defaultTTL?: number;\n  /** Key prefix for all cache entries */\n  keyPrefix?: string;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n/**\n * Cache operation result\n */\nexport interface CacheResult<T> {\n  success: boolean;\n  data?: T;\n  error?: Error;\n}\n\n/**\n * Cache statistics\n */\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  errors: number;\n}\n\n/**\n * Custom error class for cache operations\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'CacheError';\n  }\n}\n\n/**\n * Generic caching layer using Redis with ioredis\n */\nexport class Cache {\n  private client: Redis;\n  private readonly config: Required<CacheConfig>;\n  private stats: CacheStats = { hits: 0, misses: 0, errors: 0 };\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      redis: config.redis || {},\n      defaultTTL: config.defaultTTL || 3600,\n      keyPrefix: config.keyPrefix || 'cache:',\n      debug: config.debug || false,\n    };\n\n    // Initialize Redis client with error handling\n    this.client = new Redis({\n      ...this.config.redis,\n      lazyConnect: true,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection (attempt ${times}) in ${delay}ms`);\n        return delay;\n      },\n      reconnectOnError: (err: Error) => {\n        const targetError = 'READONLY';\n        if (err.message.includes(targetError)) {\n          // Reconnect on READONLY errors\n          return true;\n        }\n        return false;\n      },\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup Redis event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client ready');\n    });\n\n    this.client.on('error', (err: Error) => {\n      this.isConnected = false;\n      this.stats.errors++;\n      this.log(`Redis client error: ${err.message}`, true);\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Ensure Redis connection is established\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    // Reuse existing connection attempt if in progress\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    this.connectionPromise = this.client\n      .connect()\n      .then(() => {\n        this.connectionPromise = null;\n      })\n      .catch((err: Error) => {\n        this.connectionPromise = null;\n        throw new CacheError(\n          'Failed to connect to Redis',\n          'connect',\n          err\n        );\n      });\n\n    return this.connectionPromise;\n  }\n\n  /**\n   * Build full cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`;\n  }\n\n  /**\n   * Log debug messages\n   */\n  private log(message: string, isError: boolean = false): void {\n    if (this.config.debug) {\n      const timestamp = new Date().toISOString();\n      const prefix = isError ? '[ERROR]' : '[DEBUG]';\n      console.log(`${timestamp} ${prefix} Cache: ${message}`);\n    }\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify({\n        data: value,\n        timestamp: Date.now(),\n      });\n    } catch (err) {\n      throw new CacheError(\n        'Failed to serialize value',\n        'serialize',\n        err as Error\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const parsed = JSON.parse(value);\n      return parsed.data as T;\n    } catch (err) {\n      throw new CacheError(\n        'Failed to deserialize value',\n        'deserialize',\n        err as Error\n      );\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns Promise resolving to the cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`GET ${fullKey}`);\n\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        this.stats.misses++;\n        this.log(`MISS ${fullKey}`);\n        return null;\n      }\n\n      this.stats.hits++;\n      this.log(`HIT ${fullKey}`);\n\n      return this.deserialize<T>(value);\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error getting key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to get key: ${key}`,\n        'get',\n        error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses default if not provided)\n   * @returns Promise resolving to true if successful\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      this.log(`SET ${fullKey} (TTL: ${ttl}s)`);\n\n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n      } else {\n        await this.client.set(fullKey, serialized);\n      }\n\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error setting key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to set key: ${key}`,\n        'set',\n        error\n      );\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key was deleted, false if key didn't exist\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`DELETE ${fullKey}`);\n\n      const result = await this.client.del(fullKey);\n      return result > 0;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error deleting key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        'delete',\n        error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:*\")\n   * @returns Promise resolving to the number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullPattern = this.buildKey(pattern);\n      this.log(`INVALIDATE PATTERN ${fullPattern}`);\n\n      let cursor = '0';\n      let deletedCount = 0;\n\n      // Use SCAN to iterate through keys matching pattern\n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100\n        );\n\n        cursor = nextCursor;\n\n        if (keys.length > 0) {\n          const deleted = await this.client.del(...keys);\n          deletedCount += deleted;\n          this.log(`Deleted ${deleted} keys matching pattern`);\n        }\n      } while (cursor !== '0');\n\n      this.log(`Total deleted: ${deletedCount} keys`);\n      return deletedCount;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(\n        `Error invalidating pattern ${pattern}: ${error.message}`,\n        true\n      );\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        'invalidatePattern',\n        error\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n      return result === 1;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error checking key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to check key existence: ${key}`,\n        'exists',\n        error\n      );\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns Promise resolving to TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error getting TTL for key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        'getTTL',\n        error\n      );\n    }\n  }\n\n  /**\n   * Set multiple key-value pairs atomically\n   * @param entries - Array of [key, value, ttl?] tuples\n   * @returns Promise resolving to true if successful\n   */\n  async setMultiple<T>(\n    entries: Array<[string, T, number?]>\n  ): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const pipeline = this.client.pipeline();\n\n      for (const [key, value, ttl] of entries) {\n        const fullKey = this.buildKey(key);\n        const serialized = this.serialize(value);\n        const ttlValue = ttl ?? this.config.defaultTTL;\n\n        if (ttlValue > 0) {\n          pipeline.setex(fullKey, ttlValue, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      }\n\n      await pipeline.exec();\n      this.log(`SET MULTIPLE: ${entries.length} keys`);\n\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error setting multiple keys: ${error.message}`, true);\n      throw new CacheError(\n        'Failed to set multiple keys',\n        'setMultiple',\n        error\n      );\n    }\n  }\n\n  /**\n   * Get multiple values by keys\n   * @param keys - Array of cache keys\n   * @returns Promise resolving to Map of key-value pairs\n   */\n  async getMultiple<T>(keys: string[]): Promise<Map<string, T>> {\n    try {\n      await this.ensureConnection();\n\n      const fullKeys = keys.map((key) => this.buildKey(key));\n      const values = await this.client.mget(...fullKeys);\n\n      const result = new Map<string, T>();\n\n      values.forEach((value, index) => {\n        if (value !== null) {\n          const originalKey = keys[index];\n          result.set(originalKey, this.deserialize<T>(value));\n          this.stats.hits++;\n        } else {\n          this.stats.misses++;\n        }\n      });\n\n      this.log(`GET MULTIPLE: ${keys.length} keys, ${result.size} hits`);\n\n      return result;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error getting multiple keys: ${error.message}`, true);\n      throw new CacheError(\n        'Failed to get multiple keys',\n        'getMultiple',\n        error\n      );\n    }\n  }\n\n  /**\n   * Clear all cache entries (use with caution)\n   * @returns Promise resolving to true if successful\n   */\n  async clear(): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      this.log('CLEAR ALL CACHE');\n      await this.client.flushdb();\n\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error clearing cache: ${error.message}`, true);\n      throw new CacheError('Failed to clear cache', 'clear', error);\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Current cache statistics\n   */\n  getStats(): Readonly<CacheStats> {\n    return { ...this.stats };\n  }\n\n  /**\n   * Reset cache statistics\n   */\n  resetStats(): void {\n    this.stats = { hits: 0, misses: 0, errors: 0 };\n    this.log('Statistics reset');\n  }\n\n  /**\n   * Check if cache is connected\n   * @returns Current connection status\n   */\n  isReady(): boolean {\n    return this.isConnected;\n  }\n\n  /**\n   * Ping Redis server\n   * @returns Promise resolving to true if server responds\n   */\n  async ping(): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n      const result = await this.client.ping();\n      return result === 'PONG';\n    } catch (err) {\n      return false;\n    }\n  }\n\n  /**\n   * Close Redis connection\n   * @returns Promise that resolves when connection is closed\n   */\n  async disconnect(): Promise<void> {\n    try {\n      this.log('Disconnecting from Redis');\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (err) {\n      const error = err as Error;\n      this.log(`Error disconnecting: ${error.message}`, true);\n      throw new CacheError('Failed to disconnect', 'disconnect', error);\n    }\n  }\n}\n\n/**\n ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2236,
            "output_tokens": 4096,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive Redis caching utility module with proper TypeScript types, error handling, and all the requested methods.\n\n```typescript\n// src/lib/cache.ts\nimport Redis, { RedisOptions } from \"ioredis\";\n\nexport interface CacheOptions {\n  host?: string;\n  port?: number;\n  password?: string;\n  db?: number;\n  keyPrefix?: string;\n  maxRetriesPerRequest?: number;\n  enableReadyCheck?: boolean;\n  lazyConnect?: boolean;\n}\n\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  errors: number;\n}\n\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error,\n  ) {\n    super(message);\n    this.name = \"CacheError\";\n  }\n}\n\nexport class Cache {\n  private client: Redis;\n  private stats: CacheStats = { hits: 0, misses: 0, errors: 0 };\n  private isConnected: boolean = false;\n  private readonly keyPrefix: string;\n\n  constructor(options: CacheOptions = {}) {\n    const redisOptions: RedisOptions = {\n      host: options.host ?? process.env.REDIS_HOST ?? \"localhost\",\n      port: options.port ?? Number(process.env.REDIS_PORT) ?? 6379,\n      password: options.password ?? process.env.REDIS_PASSWORD,\n      db: options.db ?? Number(process.env.REDIS_DB) ?? 0,\n      maxRetriesPerRequest: options.maxRetriesPerRequest ?? 3,\n      enableReadyCheck: options.enableReadyCheck ?? true,\n      lazyConnect: options.lazyConnect ?? false,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n    };\n\n    this.keyPrefix = options.keyPrefix ?? \"\";\n    this.client = new Redis(redisOptions);\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.client.on(\"connect\", () => {\n      this.isConnected = true;\n      console.log(\"Redis client connected\");\n    });\n\n    this.client.on(\"ready\", () => {\n      console.log(\"Redis client ready\");\n    });\n\n    this.client.on(\"error\", (error: Error) => {\n      this.isConnected = false;\n      this.stats.errors++;\n      console.error(\"Redis client error:\", error);\n    });\n\n    this.client.on(\"close\", () => {\n      this.isConnected = false;\n      console.log(\"Redis client connection closed\");\n    });\n\n    this.client.on(\"reconnecting\", () => {\n      console.log(\"Redis client reconnecting...\");\n    });\n  }\n\n  private getPrefixedKey(key: string): string {\n    return this.keyPrefix ? `${this.keyPrefix}:${key}` : key;\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns Parsed value or null if not found\n   * @throws CacheError if operation fails\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const value = await this.client.get(prefixedKey);\n\n      if (value === null) {\n        this.stats.misses++;\n        return null;\n      }\n\n      this.stats.hits++;\n      return JSON.parse(value) as T;\n    } catch (error) {\n      this.stats.errors++;\n      throw new CacheError(\n        `Failed to get key \"${key}\"`,\n        \"get\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   * @throws CacheError if operation fails\n   */\n  async set<T>(key: string, value: T, ttlSeconds?: number): Promise<void> {\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const serialized = JSON.stringify(value);\n\n      if (ttlSeconds !== undefined && ttlSeconds > 0) {\n        await this.client.setex(prefixedKey, ttlSeconds, serialized);\n      } else {\n        await this.client.set(prefixedKey, serialized);\n      }\n    } catch (error) {\n      this.stats.errors++;\n      throw new CacheError(\n        `Failed to set key \"${key}\"`,\n        \"set\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key to delete\n   * @returns Number of keys deleted (0 or 1)\n   * @throws CacheError if operation fails\n   */\n  async delete(key: string): Promise<number> {\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      return await this.client.del(prefixedKey);\n    } catch (error) {\n      this.stats.errors++;\n      throw new CacheError(\n        `Failed to delete key \"${key}\"`,\n        \"delete\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:*\")\n   * @returns Number of keys deleted\n   * @throws CacheError if operation fails\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      const prefixedPattern = this.getPrefixedKey(pattern);\n      const keys = await this.client.keys(prefixedPattern);\n\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      // Use pipeline for better performance with multiple deletes\n      const pipeline = this.client.pipeline();\n      keys.forEach((key) => pipeline.del(key));\n      const results = await pipeline.exec();\n\n      // Count successful deletions\n      return results?.filter(([err]) => err === null).length ?? 0;\n    } catch (error) {\n      this.stats.errors++;\n      throw new CacheError(\n        `Failed to invalidate pattern \"${pattern}\"`,\n        \"invalidatePattern\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns true if key exists, false otherwise\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.exists(prefixedKey);\n      return result === 1;\n    } catch (error) {\n      this.stats.errors++;\n      throw new CacheError(\n        `Failed to check existence of key \"${key}\"`,\n        \"exists\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async ttl(key: string): Promise<number> {\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      return await this.client.ttl(prefixedKey);\n    } catch (error) {\n      this.stats.errors++;\n      throw new CacheError(\n        `Failed to get TTL for key \"${key}\"`,\n        \"ttl\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set expiry on an existing key\n   * @param key - Cache key\n   * @param ttlSeconds - Time to live in seconds\n   * @returns true if expiry was set, false if key doesn't exist\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.expire(prefixedKey, ttlSeconds);\n      return result === 1;\n    } catch (error) {\n      this.stats.errors++;\n      throw new CacheError(\n        `Failed to set expiry for key \"${key}\"`,\n        \"expire\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Clear all keys in the current database\n   * WARNING: This will delete ALL keys in the selected Redis database\n   */\n  async clear(): Promise<void> {\n    try {\n      await this.client.flushdb();\n    } catch (error) {\n      this.stats.errors++;\n      throw new CacheError(\"Failed to clear cache\", \"clear\", error as Error);\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): Readonly<CacheStats> {\n    return { ...this.stats };\n  }\n\n  /**\n   * Reset cache statistics\n   */\n  resetStats(): void {\n    this.stats = { hits: 0, misses: 0, errors: 0 };\n  }\n\n  /**\n   * Check if Redis client is connected\n   */\n  isReady(): boolean {\n    return this.isConnected && this.client.status === \"ready\";\n  }\n\n  /**\n   * Manually connect to Redis (useful with lazyConnect option)\n   */\n  async connect(): Promise<void> {\n    try {\n      await this.client.connect();\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to connect to Redis\",\n        \"connect\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Gracefully disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    try {\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to disconnect from Redis\",\n        \"disconnect\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get the underlying Redis client for advanced operations\n   */\n  getClient(): Redis {\n    return this.client;\n  }\n}\n\n// Singleton instance for convenience\nlet cacheInstance: Cache | null = null;\n\n/**\n * Get or create a singleton cache instance\n */\nexport function getCache(options?: CacheOptions): Cache {\n  if (!cacheInstance) {\n    cacheInstance = new Cache(options);\n  }\n  return cacheInstance;\n}\n\n/**\n * Create a new cache instance (useful for testing or multiple connections)\n */\nexport function createCache(options?: CacheOptions): Cache {\n  return new Cache(options);\n}\n```\n\nNow let me create a comprehensive test file:\n\n```typescript\n// src/lib/cache.test.ts\nimport { describe, it, expect, beforeEach, afterEach, vi } from \"vitest\";\nimport { Cache, CacheError, createCache } from \"./cache\";\n\ndescribe(\"Cache\", () => {\n  let cache: Cache;\n\n  beforeEach(async () => {\n    cache = createCache({\n      host: process.env.REDIS_HOST ?? \"localhost\",\n      port: Number(process.env.REDIS_PORT) ?? 6379,\n      keyPrefix: \"test\",\n    });\n    await cache.connect();\n    await cache.clear();\n  });\n\n  afterEach(async () => {\n    await cache.clear();\n    await cache.disconnect();\n  });\n\n  describe(\"get and set\", () => {\n    it(\"should set and get a string value\", async () => {\n      await cache.set(\"key1\", \"value1\");\n      const result = await cache.get<string>(\"key1\");\n      expect(result).toBe(\"value1\");\n    });\n\n    it(\"should set and get an object value\", async () => {\n      const obj = { name: \"John\", age: 30, active: true };\n      await cache.set(\"user:1\", obj);\n      const result = await cache.get<typeof obj>(\"user:1\");\n      expect(result).toEqual(obj);\n    });\n\n    it(\"should set and get an array value\", async () => {\n      const arr = [1, 2, 3, 4, 5];\n      await cache.set(\"numbers\", arr);\n      const result = await cache.get<number[]>(\"numbers\");\n      expect(result).toEqual(arr);\n    });\n\n    it(\"should return null for non-existent key\", async () => {\n      const result = await cache.get(\"nonexistent\");\n      expect(result).toBeNull();\n    });\n\n    it(\"should set value with TTL\", async () => {\n      await cache.set(\"temp\", \"temporary\", 2);\n      const result = await cache.get<string>(\"temp\");\n      expect(result).toBe(\"temporary\");\n\n      // Wait for expiry\n      await new Promise((resolve) => setTimeout(resolve, 2100));\n      const expired = await cache.get<string>(\"temp\");\n      expect(expired).toBeNull();\n    });\n\n    it(\"should handle complex nested objects\", async () => {\n      const complex = {\n        user: {\n          id: 1,\n          profile: {\n            name: \"Jane\",\n            settings: {\n              theme: \"dark\",\n              notifications: true,\n            },\n          },\n        },\n        tags: [\"admin\", \"user\"],\n      };\n      await cache.set(\"complex\", complex);\n      const result = await cache.get<typeof complex>(\"complex\");\n      expect(result).toEqual(complex);\n    });\n  });\n\n  describe(\"delete\", () => {\n    it(\"should delete an existing key\", async () => {\n      await cache.set(\"key1\", \"value1\");\n      const deleted = await cache.delete(\"key1\");\n      expect(deleted).toBe(1);\n\n      const result = await cache.get(\"key1\");\n      expect(result).toBeNull();\n    });\n\n    it(\"should return 0 when deleting non-existent key\", async () => {\n      const deleted = await cache.delete(\"nonexistent\");\n      expect(deleted).toBe(0);\n    });\n  });\n\n  describe(\"invalidatePattern\", () => {\n    it(\"should invalidate all keys matching pattern\", async () => {\n      await cache.set(\"user:1\", { name: \"John\" });\n      await cache.set(\"user:2\", { name: \"Jane\" });\n      await cache.set(\"user:3\", { name: \"Bob\" });\n      await cache.set(\"post:1\", { title: \"Hello\" });\n\n      const deleted = await cache.invalidatePattern(\"user:*\");\n      expect(deleted).toBe(3);\n\n      const user1 = await cache.get(\"user:1\");\n      const user2 = await cache.get(\"user:2\");\n      const post1 = await cache.get(\"post:1\");\n\n      expect(user1).toBeNull();\n      expect(user2).toBeNull();\n      expect(post1).toEqual({ title: \"Hello\" });\n    });\n\n    it(\"should return 0 when no keys match pattern\", async () => {\n      const deleted = await cache.invalidatePattern(\"nonexistent:*\");\n      expect(deleted).toBe(0);\n    });\n  });\n\n  describe(\"exists\", () => {\n    it(\"should return true for existing key\", async () => {\n      await cache.set(\"key1\", \"value1\");\n      const exists = await cache.exists(\"key1\");\n      expect(exists).toBe(true);\n    });\n\n    it(\"should return false for non-existent key\", async () => {\n      const exists = await cache.exists(\"nonexistent\");\n      expect(exists).toBe(false);\n    });\n  });\n\n  describe(\"ttl\", () => {\n    it(\"should return TTL for key with expiry\", async () => {\n      await cache.set(\"temp\", \"value\", 10);\n      const ttl = await cache.ttl(\"temp\");\n      expect(ttl).toBeGreaterThan(0);\n      expect(ttl).toBeLessThanOrEqual(10);\n    });\n\n    it(\"should return -1 for key without expiry\", async () => {\n      await cache.set(\"permanent\", \"value\");\n      const ttl = await cache.ttl(\"permanent\");\n      expect(ttl).toBe(-1);\n    });\n\n    it(\"should return -2 for non-existent key\", async () => {\n      const ttl = await cache.ttl(\"non",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 25179,
            "output_tokens": 4096,
            "cached": true
          }
        }
      ]
    }
  ]
}