{
  "skill_name": "neon-postgres",
  "generated_at": "2026-02-16T19:52:51.901502+00:00",
  "model": "claude-sonnet-4-5-20250929",
  "temperature": 0.3,
  "runs_per_condition": 3,
  "contamination_score": 0.0,
  "risk_level": "medium",
  "test_category": "hidden_contamination",
  "tasks": [
    {
      "task_id": "neon-postgres-01",
      "task_type": "direct_target",
      "target_language": "typescript",
      "expected_patterns": [
        "import.*@neondatabase/serverless|neon.*serverless",
        "neon\\(",
        "process\\.env\\.DATABASE_URL|DATABASE_URL",
        "interface\\s+User|type\\s+User",
        "async\\s+function|async\\s+\\(",
        "export"
      ],
      "anti_patterns": [
        "import psycopg|import asyncpg",
        "neon_api|NeonAPI",
        "from neon_api",
        "pip install",
        "def\\s+\\w+\\(",
        "class\\s+.*Model"
      ],
      "pattern_sources": [
        {
          "url": "https://neon.com/docs/serverless/serverless-driver.md",
          "description": "Neon serverless driver: import { neon } from '@neondatabase/serverless', neon(process.env.DATABASE_URL) function, template literal queries with sql``, TypeScript usage with async/await"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/2/objects.html",
          "description": "TypeScript object types - source of interface and type declarations for User interface definition"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/2/functions.html",
          "description": "TypeScript functions - source of async function syntax for database queries"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/modules.html",
          "description": "TypeScript modules - source of export keyword for exporting functions from modules"
        },
        {
          "url": "https://neon.com/docs/guides/python.md",
          "description": "Anti-patterns: Python database drivers (psycopg, asyncpg imports) that should not appear in TypeScript"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "```typescript\n// pages/api/users/by-domain.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { neon, NeonQueryFunction } from '@neondatabase/serverless';\n\n/**\n * User interface representing the database schema\n */\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\n/**\n * API Response type\n */\ninterface ApiResponse {\n  success: boolean;\n  data?: User[];\n  error?: string;\n  message?: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres database\n * @param domain - The email domain to filter by (e.g., 'example.com')\n * @returns Array of User objects matching the domain\n * @throws Error if database connection or query fails\n */\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  // Validate input\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  let sql: NeonQueryFunction<false, false>;\n\n  try {\n    // Create connection to Neon Postgres\n    sql = neon(process.env.DATABASE_URL);\n\n    // Run parameterized query to prevent SQL injection\n    // Using LIKE with parameterized query for email domain matching\n    const emailPattern = `%@${domain}`;\n    \n    const result = await sql`\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE ${emailPattern}\n      ORDER BY created_at DESC\n    `;\n\n    // Type assertion and data transformation\n    const users: User[] = result.map((row: any) => ({\n      id: row.id,\n      email: row.email,\n      name: row.name,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n\n    return users;\n  } catch (error) {\n    // Enhanced error handling with specific error types\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('An unknown database error occurred');\n  }\n}\n\n/**\n * Next.js API route handler\n */\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({\n      success: false,\n      error: 'Method not allowed',\n      message: 'Only GET requests are supported',\n    });\n  }\n\n  try {\n    // Extract domain from query parameters\n    const { domain } = req.query;\n\n    // Validate domain parameter\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({\n        success: false,\n        error: 'Bad request',\n        message: 'Domain query parameter is required and must be a string',\n      });\n    }\n\n    // Fetch users by domain\n    const users = await getUsersByEmailDomain(domain);\n\n    // Return successful response\n    return res.status(200).json({\n      success: true,\n      data: users,\n      message: `Found ${users.length} user(s) with email domain: ${domain}`,\n    });\n  } catch (error) {\n    // Log error for debugging (in production, use proper logging service)\n    console.error('API Error:', error);\n\n    // Determine error status and message\n    const errorMessage = error instanceof Error ? error.message : 'Internal server error';\n    const statusCode = errorMessage.includes('DATABASE_URL') ? 500 : \n                       errorMessage.includes('Invalid domain') ? 400 : 500;\n\n    return res.status(statusCode).json({\n      success: false,\n      error: 'Database error',\n      message: errorMessage,\n    });\n  }\n}\n```\n\n```typescript\n// Alternative: App Router version (app/api/users/by-domain/route.ts)\nimport { NextRequest, NextResponse } from 'next/server';\nimport { neon } from '@neondatabase/serverless';\n\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  try {\n    const sql = neon(process.env.DATABASE_URL);\n    const emailPattern = `%@${domain}`;\n    \n    const result = await sql`\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE ${emailPattern}\n      ORDER BY created_at DESC\n    `;\n\n    return result.map((row: any) => ({\n      id: row.id,\n      email: row.email,\n      name: row.name,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('An unknown database error occurred');\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get('domain');\n\n    if (!domain) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Bad request',\n          message: 'Domain query parameter is required',\n        },\n        { status: 400 }\n      );\n    }\n\n    const users = await getUsersByEmailDomain(domain);\n\n    return NextResponse.json({\n      success: true,\n      data: users,\n      message: `Found ${users.length} user(s) with email domain: ${domain}`,\n    });\n  } catch (error) {\n    console.error('API Error:', error);\n    \n    const errorMessage = error instanceof Error ? error.message : 'Internal server error';\n    const statusCode = errorMessage.includes('DATABASE_URL') ? 500 : \n                       errorMessage.includes('Invalid domain') ? 400 : 500;\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Database error',\n        message: errorMessage,\n      },\n      { status: statusCode }\n    );\n  }\n}\n```\n\n```typescript\n// Example usage in a component or another API route\n// lib/userService.ts\nimport { getUsersByEmailDomain, User } from '@/pages/api/users/by-domain';\n\nexport async function fetchCompanyUsers(companyDomain: string): Promise<User[]> {\n  try {\n    const users = await getUsersByEmailDomain(companyDomain);\n    return users;\n  } catch (error) {\n    console.error('Failed to fetch users:', error);\n    throw error;\n  }\n}\n```\n\n```env\n# .env.local\nDATABASE_URL=postgresql://user:password@ep-xxx-xxx.us-east-2.aws.neon.tech/dbname?sslmode=require\n```\n\nThis module provides:\n\n1. **Proper TypeScript typing** with the `User` interface\n2. **Parameterized queries** to prevent SQL injection\n3. **Comprehensive error handling** for connection and query failures\n4. **Environment variable validation**\n5. **Input validation** for the domain parameter\n6. **Both Pages Router and App Router** implementations\n7. **Reusable async function** that can be imported elsewhere\n8. **Proper HTTP status codes** and error messages\n9. **Type-safe database results** with proper date conversion",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 98,
            "output_tokens": 2031,
            "cached": false
          },
          "with_skill": {
            "output": "```typescript\n// app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextResponse } from \"next/server\";\n\n// User interface matching the database schema\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n/**\n * Fetches users by email domain using Neon's HTTP-based serverless driver.\n * Uses parameterized queries for SQL injection protection.\n * \n * @param domain - Email domain to filter by (e.g., \"example.com\")\n * @returns Array of User objects matching the domain\n * @throws Error if DATABASE_URL is not configured or query fails\n */\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not configured\");\n  }\n\n  // Initialize Neon HTTP client\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Execute parameterized query using tagged template literals\n    // The LIKE pattern is constructed safely with the parameter\n    const users = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${\"%\" + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    // Log the error for debugging\n    console.error(\"Database query failed:\", error);\n    \n    // Re-throw with more context\n    throw new Error(\n      `Failed to fetch users by domain: ${error instanceof Error ? error.message : \"Unknown error\"}`\n    );\n  }\n}\n\n/**\n * GET /api/users/by-domain?domain=example.com\n * Returns users matching the specified email domain\n */\nexport async function GET(request: Request) {\n  try {\n    // Extract domain from query parameters\n    const { searchParams } = new URL(request.url);\n    const domain = searchParams.get(\"domain\");\n\n    // Validate required parameter\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Missing required parameter: domain\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate domain format (basic check)\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json(\n        { error: \"Invalid domain format\" },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users from database\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return NextResponse.json({\n      success: true,\n      count: users.length,\n      data: users,\n    });\n  } catch (error) {\n    // Handle database or configuration errors\n    console.error(\"API route error:\", error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * POST /api/users/by-domain\n * Alternative endpoint accepting domain in request body\n */\nexport async function POST(request: Request) {\n  try {\n    // Parse request body\n    const body = await request.json();\n    const { domain } = body;\n\n    // Validate required field\n    if (!domain || typeof domain !== \"string\") {\n      return NextResponse.json(\n        { error: \"Missing or invalid field: domain\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate domain format\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json(\n        { error: \"Invalid domain format\" },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users from database\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return NextResponse.json({\n      success: true,\n      count: users.length,\n      data: users,\n    });\n  } catch (error) {\n    // Handle parsing, database, or configuration errors\n    console.error(\"API route error:\", error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n```\n\n**Usage Example:**\n\n```typescript\n// Client-side component or another API route\nasync function fetchUsersByDomain(domain: string) {\n  const response = await fetch(`/api/users/by-domain?domain=${encodeURIComponent(domain)}`);\n  const result = await response.json();\n  \n  if (!result.success) {\n    throw new Error(result.error);\n  }\n  \n  return result.data; // User[]\n}\n\n// Usage\nconst gmailUsers = await fetchUsersByDomain(\"gmail.com\");\nconsole.log(`Found ${gmailUsers.length} Gmail users`);\n```\n\n**Environment Setup (.env.local):**\n\n```bash\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-1.aws.neon.tech/neondb?sslmode=require\n```\n\n**Key Features:**\n\n1. **Parameterized Queries**: Uses tagged template literals to prevent SQL injection\n2. **TypeScript Types**: Strongly typed `User` interface for compile-time safety\n3. **Error Handling**: Comprehensive try-catch with meaningful error messages\n4. **Input Validation**: Validates domain format and required parameters\n5. **HTTP Methods**: Supports both GET (query params) and POST (body) patterns\n6. **Neon HTTP Driver**: Uses `neon()` function for fast, single-query execution\n7. **Environment Validation**: Checks for DATABASE_URL before attempting connection",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 9855,
            "output_tokens": 1470,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Next.js API Route with Neon Serverless Driver\n\nHere's a complete TypeScript module for a Next.js API route that connects to Neon Postgres using the `@neondatabase/serverless` driver:\n\n```typescript\n// app/api/users/route.ts (App Router)\n// or pages/api/users.ts (Pages Router)\n\nimport { neon } from '@neondatabase/serverless';\nimport { NextRequest, NextResponse } from 'next/server';\n\n// User interface matching your database schema\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n// Response type for better type safety\ninterface UsersResponse {\n  users: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  error: string;\n  details?: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., 'example.com')\n * @returns Array of users matching the domain\n */\nexport async function getUsersByDomain(\n  domain: string\n): Promise<User[]> {\n  // Validate DATABASE_URL exists\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  // Create Neon serverless connection\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Parameterized query to prevent SQL injection\n    // The pattern '%@domain.com' is constructed safely\n    const emailPattern = `%@${domain}`;\n    \n    const result = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${emailPattern}\n      ORDER BY created_at DESC\n    `;\n\n    return result;\n  } catch (error) {\n    // Log error for debugging\n    console.error('Database query error:', error);\n    \n    // Re-throw with more context\n    if (error instanceof Error) {\n      throw new Error(`Failed to fetch users: ${error.message}`);\n    }\n    throw new Error('Failed to fetch users: Unknown error');\n  }\n}\n\n// App Router API Route Handler (Next.js 13+)\nexport async function GET(request: NextRequest) {\n  try {\n    // Get domain from query parameters\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get('domain');\n\n    // Validate domain parameter\n    if (!domain) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Missing required parameter: domain' },\n        { status: 400 }\n      );\n    }\n\n    // Basic domain validation\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Invalid domain format' },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return NextResponse.json<UsersResponse>(\n      {\n        users,\n        count: users.length,\n      },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('API route error:', error);\n\n    // Handle different error types\n    if (error instanceof Error) {\n      return NextResponse.json<ErrorResponse>(\n        {\n          error: 'Internal server error',\n          details: process.env.NODE_ENV === 'development' ? error.message : undefined,\n        },\n        { status: 500 }\n      );\n    }\n\n    return NextResponse.json<ErrorResponse>(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n## Pages Router Version (Alternative)\n\nIf you're using the Pages Router instead of App Router:\n\n```typescript\n// pages/api/users.ts\n\nimport { neon } from '@neondatabase/serverless';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface UsersResponse {\n  users: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  error: string;\n  details?: string;\n}\n\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    const emailPattern = `%@${domain}`;\n    \n    const result = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${emailPattern}\n      ORDER BY created_at DESC\n    `;\n\n    return result;\n  } catch (error) {\n    console.error('Database query error:', error);\n    \n    if (error instanceof Error) {\n      throw new Error(`Failed to fetch users: ${error.message}`);\n    }\n    throw new Error('Failed to fetch users: Unknown error');\n  }\n}\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<UsersResponse | ErrorResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { domain } = req.query;\n\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({ \n        error: 'Missing required parameter: domain' \n      });\n    }\n\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return res.status(400).json({ \n        error: 'Invalid domain format' \n      });\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return res.status(200).json({\n      users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error('API route error:', error);\n\n    if (error instanceof Error) {\n      return res.status(500).json({\n        error: 'Internal server error',\n        details: process.env.NODE_ENV === 'development' ? error.message : undefined,\n      });\n    }\n\n    return res.status(500).json({ \n      error: 'Internal server error' \n    });\n  }\n}\n```\n\n## Environment Setup\n\nCreate a `.env.local` file:\n\n```bash\nDATABASE_URL=\"postgresql://user:password@ep-xxx.region.aws.neon.tech/dbname?sslmode=require\"\n```\n\n## Installation\n\n```bash\nnpm install @neondatabase/serverless\n# or\npnpm add @neondatabase/serverless\n# or\nyarn add @neondatabase/serverless\n```\n\n## Usage Examples\n\n### Client-side fetch (App Router)\n\n```typescript\n// app/users/page.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\nexport default function UsersPage() {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    async function fetchUsers() {\n      try {\n        const response = await fetch('/api/users?domain=example.com');\n        \n        if (!response.ok) {\n          throw new Error('Failed to fetch users');\n        }\n\n        const data = await response.json();\n        setUsers(data.users);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Unknown error');\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchUsers();\n  }, []);\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n\n  return (\n    <div>\n      <h1>Users ({users.length})</h1>\n      <ul>\n        {users.map((user) => (\n          <li key={user.id}>\n            {user.name} - {user.email}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n### Server-side usage (Server Component)\n\n```typescript\n// app/users/page.tsx\nimport { getUsersByDomain } from '@/app/api/users/route';\n\nexport default async function UsersPage() {\n  const users = await getUsersByDomain('example.com');\n\n  return (\n    <div>\n      <h1>Users ({users.length})</h1>\n      <ul>\n        {users.map((user) => (\n          <li key={user.id}>\n            {user.name} - {user.email}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## Key Features\n\n1. **Type Safety**: Full TypeScript support with typed query results\n2. **Parameterized Queries**: SQL injection protection using tagged template literals\n3. **Error Handling**: Comprehensive error catching and logging\n4. **Environment Validation**: Checks for DATABASE_URL before connecting\n5. **HTTP over WebSockets**: Uses HTTP by default (faster for serverless)\n6. **Input Validation**: Domain format validation before querying\n\n## Additional Configuration\n\nFor WebSocket connections (if needed for long-running queries):\n\n```typescript\nimport { neon, neonConfig } from '@neondatabase/serverless';\n\n// Force WebSocket usage\nneonConfig.useSecureWebSocket = true;\nneonConfig.wsProxy = (host) => `${host}/v2`;\n\nconst sql = neon(process.env.DATABASE_URL!);\n```\n\nThis implementation follows Neon's best practices for serverless environments and provides a production-ready foundation for your Next.js API routes.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2240,
            "output_tokens": 2525,
            "cached": false
          },
          "realistic": {
            "output": "I'll create a TypeScript module for a Next.js API route that connects to Neon Postgres using the serverless driver.\n\n```typescript\n// src/app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextResponse } from \"next/server\";\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface GetUsersByDomainParams {\n  domain: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - The email domain to filter by (e.g., \"example.com\")\n * @returns Array of users matching the domain\n */\nexport async function getUsersByDomain(\n  domain: string,\n): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Use parameterized query with LIKE pattern for email domain matching\n    const users = await sql<User[]>`\n      SELECT id, email, name, created_at\n      FROM users\n      WHERE email LIKE ${\"%\" + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users by domain: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    );\n  }\n}\n\n// Next.js API route handler\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Domain parameter is required\" },\n        { status: 400 },\n      );\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return NextResponse.json({\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error(\"API route error:\", error);\n    return NextResponse.json(\n      {\n        error:\n          error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 },\n    );\n  }\n}\n```\n\nThis module:\n\n1. **Uses the `neon()` function** for HTTP-based queries (fastest for single queries in serverless)\n2. **Defines a typed `User` interface** for type safety\n3. **Uses parameterized queries** via tagged template literals to prevent SQL injection\n4. **Handles errors properly** with try-catch and meaningful error messages\n5. **Exports a reusable function** (`getUsersByDomain`) that can be imported elsewhere\n6. **Implements the Next.js App Router API route** pattern with GET handler\n7. **Validates input** (checks for required domain parameter)\n8. **Returns typed responses** with proper HTTP status codes\n\nTo use this API route, make a request to:\n```\nGET /api/users/by-domain?domain=example.com\n```\n\nThe response will be:\n```json\n{\n  \"data\": [\n    {\n      \"id\": 1,\n      \"email\": \"user@example.com\",\n      \"name\": \"John Doe\",\n      \"created_at\": \"2024-01-15T10:30:00Z\"\n    }\n  ],\n  \"count\": 1\n}\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10350,
            "output_tokens": 862,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "```typescript\n// pages/api/users/by-domain.ts\nimport { neon, NeonQueryFunction } from '@neondatabase/serverless';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\n// User interface definition\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\n// API Response types\ntype SuccessResponse = {\n  success: true;\n  data: User[];\n  count: number;\n};\n\ntype ErrorResponse = {\n  success: false;\n  error: string;\n  details?: string;\n};\n\ntype ApiResponse = SuccessResponse | ErrorResponse;\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - The email domain to filter by (e.g., 'example.com')\n * @returns Array of User objects matching the domain\n * @throws Error if DATABASE_URL is not configured or query fails\n */\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not configured');\n  }\n\n  // Validate domain parameter\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  let sql: NeonQueryFunction<false, false>;\n\n  try {\n    // Create Neon connection\n    sql = neon(process.env.DATABASE_URL);\n\n    // Run parameterized query to prevent SQL injection\n    // The % wildcards are included in the parameter for LIKE matching\n    const result = await sql<User[]>(\n      `SELECT \n        id, \n        email, \n        name, \n        created_at, \n        updated_at \n      FROM users \n      WHERE email LIKE $1\n      ORDER BY created_at DESC`,\n      [`%@${domain}`]\n    );\n\n    // Transform dates from string to Date objects if needed\n    const users: User[] = result.map((row) => ({\n      ...row,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n\n    return users;\n  } catch (error) {\n    // Handle connection and query errors\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('An unknown database error occurred');\n  }\n}\n\n/**\n * Next.js API route handler\n * GET /api/users/by-domain?domain=example.com\n */\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({\n      success: false,\n      error: 'Method not allowed',\n    });\n  }\n\n  try {\n    // Extract domain from query parameters\n    const { domain } = req.query;\n\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing or invalid domain parameter',\n        details: 'Please provide a domain query parameter (e.g., ?domain=example.com)',\n      });\n    }\n\n    // Fetch users by domain\n    const users = await getUsersByEmailDomain(domain);\n\n    // Return successful response\n    return res.status(200).json({\n      success: true,\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    // Log error for debugging (in production, use proper logging service)\n    console.error('API Error:', error);\n\n    // Return error response\n    return res.status(500).json({\n      success: false,\n      error: 'Internal server error',\n      details: error instanceof Error ? error.message : 'Unknown error occurred',\n    });\n  }\n}\n```\n\n```typescript\n// Alternative: App Router version (app/api/users/by-domain/route.ts)\nimport { neon } from '@neondatabase/serverless';\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not configured');\n  }\n\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  try {\n    const sql = neon(process.env.DATABASE_URL);\n\n    const result = await sql<User[]>(\n      `SELECT \n        id, \n        email, \n        name, \n        created_at, \n        updated_at \n      FROM users \n      WHERE email LIKE $1\n      ORDER BY created_at DESC`,\n      [`%@${domain}`]\n    );\n\n    return result.map((row) => ({\n      ...row,\n      created_at: new Date(row.created_at),\n      updated_at: new Date(row.updated_at),\n    }));\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('An unknown database error occurred');\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get('domain');\n\n    if (!domain) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Missing domain parameter',\n        },\n        { status: 400 }\n      );\n    }\n\n    const users = await getUsersByEmailDomain(domain);\n\n    return NextResponse.json({\n      success: true,\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error('API Error:', error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Internal server error',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n```\n\n```typescript\n// Example .env.local file\n// DATABASE_URL=postgresql://user:password@ep-cool-darkness-123456.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\nThis module provides:\n\n1. **Proper TypeScript typing** with a `User` interface\n2. **Parameterized queries** to prevent SQL injection\n3. **Error handling** for connection and query failures\n4. **Environment variable validation**\n5. **Both Pages Router and App Router** implementations\n6. **Type-safe responses** with success/error types\n7. **Input validation** for the domain parameter\n8. **Date transformation** for proper Date object handling\n\nUsage example:\n```bash\ncurl http://localhost:3000/api/users/by-domain?domain=example.com\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 98,
            "output_tokens": 1777,
            "cached": false
          },
          "with_skill": {
            "output": "```typescript\n// app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\n/**\n * User interface matching the database schema\n */\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\n/**\n * Response type for the API\n */\ninterface ApiResponse {\n  users?: User[];\n  error?: string;\n  count?: number;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - The email domain to filter by (e.g., \"example.com\")\n * @returns Array of users matching the domain\n */\nexport async function getUsersByDomain(\n  domain: string\n): Promise<{ users: User[]; count: number }> {\n  // Validate input\n  if (!domain || typeof domain !== \"string\") {\n    throw new Error(\"Invalid domain parameter\");\n  }\n\n  // Initialize connection using environment variable\n  const sql = neon(process.env.DATABASE_URL!);\n\n  try {\n    // Run parameterized query using tagged template literals\n    // The LIKE pattern matches emails ending with @domain\n    const users = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE ${\"%\" + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return {\n      users,\n      count: users.length,\n    };\n  } catch (error) {\n    // Re-throw with more context\n    const errorMessage =\n      error instanceof Error ? error.message : \"Unknown database error\";\n    throw new Error(`Failed to fetch users by domain: ${errorMessage}`);\n  }\n}\n\n/**\n * GET handler for the API route\n * Usage: /api/users/by-domain?domain=example.com\n */\nexport async function GET(request: NextRequest): Promise<NextResponse> {\n  try {\n    // Extract domain from query parameters\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Missing required parameter: domain\" } as ApiResponse,\n        { status: 400 }\n      );\n    }\n\n    // Fetch users\n    const { users, count } = await getUsersByDomain(domain);\n\n    // Return successful response\n    return NextResponse.json(\n      {\n        users,\n        count,\n      } as ApiResponse,\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error(\"API route error:\", error);\n\n    // Return error response\n    const errorMessage =\n      error instanceof Error ? error.message : \"Internal server error\";\n\n    return NextResponse.json(\n      { error: errorMessage } as ApiResponse,\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Alternative implementation using manual query construction\n * (if you prefer explicit parameter binding)\n */\nexport async function getUsersByDomainManual(\n  domain: string\n): Promise<{ users: User[]; count: number }> {\n  const sql = neon(process.env.DATABASE_URL!);\n\n  try {\n    const users = await sql.query<User>(\n      `\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC\n    `,\n      [`%${domain}`]\n    );\n\n    return {\n      users,\n      count: users.length,\n    };\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : \"Unknown database error\";\n    throw new Error(`Failed to fetch users by domain: ${errorMessage}`);\n  }\n}\n```\n\n**Usage example:**\n\n```typescript\n// In another file or component\nimport { getUsersByDomain } from \"@/app/api/users/by-domain/route\";\n\n// Fetch users with @gmail.com emails\nconst { users, count } = await getUsersByDomain(\"@gmail.com\");\nconsole.log(`Found ${count} users with Gmail addresses`);\n```\n\n**Environment setup (.env.local):**\n\n```bash\nDATABASE_URL=postgresql://username:password@ep-xxx.us-east-1.aws.neon.tech/neondb?sslmode=require\n```\n\n**Key features:**\n\n1. **Parameterized queries** - Uses tagged template literals to prevent SQL injection\n2. **TypeScript types** - Strongly typed `User` interface and API responses\n3. **Error handling** - Catches and formats database errors appropriately\n4. **HTTP status codes** - Returns 400 for bad requests, 500 for server errors\n5. **Input validation** - Checks for required parameters\n6. **Two query methods** - Shows both tagged template and manual `.query()` approaches\n\nThe module follows Neon serverless driver best practices by using the `neon()` function for fast HTTP-based queries, which is ideal for Next.js API routes.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 9855,
            "output_tokens": 1264,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Next.js API Route with Neon Serverless Driver\n\nHere's a complete TypeScript module for a Next.js API route that connects to Neon Postgres using the `@neondatabase/serverless` driver:\n\n```typescript\n// app/api/users/route.ts (App Router)\n// or pages/api/users.ts (Pages Router)\n\nimport { neon } from '@neondatabase/serverless';\nimport { NextRequest, NextResponse } from 'next/server';\n\n// User interface matching your database schema\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n// Response type for better type safety\ninterface UsersResponse {\n  users: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  error: string;\n  details?: string;\n}\n\n/**\n * Fetches users from Neon Postgres by email domain\n * @param domain - Email domain to filter by (e.g., 'example.com')\n * @returns Array of users matching the domain\n */\nexport async function getUsersByDomain(\n  domain: string\n): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  // Create Neon connection\n  const sql = neon<User[]>(process.env.DATABASE_URL);\n\n  try {\n    // Parameterized query to prevent SQL injection\n    // The % wildcards are part of the parameter, not concatenated\n    const users = await sql(\n      `SELECT id, email, name, created_at \n       FROM users \n       WHERE email LIKE $1\n       ORDER BY created_at DESC`,\n      [`%@${domain}`]\n    );\n\n    return users;\n  } catch (error) {\n    // Re-throw with more context\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('Unknown database error occurred');\n  }\n}\n\n// App Router (Next.js 13+) - GET handler\nexport async function GET(request: NextRequest) {\n  try {\n    // Extract domain from query parameters\n    const { searchParams } = new URL(request.url);\n    const domain = searchParams.get('domain');\n\n    // Validate required parameter\n    if (!domain) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Missing required parameter: domain' },\n        { status: 400 }\n      );\n    }\n\n    // Basic domain validation\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Invalid domain format' },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return NextResponse.json<UsersResponse>(\n      {\n        users,\n        count: users.length,\n      },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('API route error:', error);\n\n    // Handle specific error types\n    if (error instanceof Error) {\n      if (error.message.includes('DATABASE_URL')) {\n        return NextResponse.json<ErrorResponse>(\n          { error: 'Database configuration error' },\n          { status: 500 }\n        );\n      }\n\n      return NextResponse.json<ErrorResponse>(\n        {\n          error: 'Failed to fetch users',\n          details: process.env.NODE_ENV === 'development' ? error.message : undefined,\n        },\n        { status: 500 }\n      );\n    }\n\n    return NextResponse.json<ErrorResponse>(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n## Alternative: Pages Router Version\n\nIf you're using the Pages Router instead of App Router:\n\n```typescript\n// pages/api/users.ts\n\nimport { neon } from '@neondatabase/serverless';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface UsersResponse {\n  users: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  error: string;\n  details?: string;\n}\n\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  const sql = neon<User[]>(process.env.DATABASE_URL);\n\n  try {\n    const users = await sql(\n      `SELECT id, email, name, created_at \n       FROM users \n       WHERE email LIKE $1\n       ORDER BY created_at DESC`,\n      [`%@${domain}`]\n    );\n\n    return users;\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error('Unknown database error occurred');\n  }\n}\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<UsersResponse | ErrorResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { domain } = req.query;\n\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({ error: 'Missing required parameter: domain' });\n    }\n\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return res.status(400).json({ error: 'Invalid domain format' });\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return res.status(200).json({\n      users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error('API route error:', error);\n\n    if (error instanceof Error) {\n      if (error.message.includes('DATABASE_URL')) {\n        return res.status(500).json({ error: 'Database configuration error' });\n      }\n\n      return res.status(500).json({\n        error: 'Failed to fetch users',\n        details: process.env.NODE_ENV === 'development' ? error.message : undefined,\n      });\n    }\n\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}\n```\n\n## Setup Instructions\n\n### 1. Install Dependencies\n\n```bash\nnpm install @neondatabase/serverless\n```\n\n### 2. Configure Environment Variables\n\nCreate or update `.env.local`:\n\n```bash\n# Get this from your Neon project dashboard\nDATABASE_URL=\"postgresql://user:password@ep-xxx.region.aws.neon.tech/dbname?sslmode=require\"\n```\n\n### 3. Create Database Schema\n\n```sql\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email VARCHAR(255) NOT NULL UNIQUE,\n  name VARCHAR(255) NOT NULL,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Add some sample data\nINSERT INTO users (email, name) VALUES\n  ('alice@example.com', 'Alice Smith'),\n  ('bob@example.com', 'Bob Jones'),\n  ('charlie@acme.com', 'Charlie Brown');\n```\n\n### 4. Usage Examples\n\n```typescript\n// Fetch users from example.com domain\nconst response = await fetch('/api/users?domain=example.com');\nconst data = await response.json();\nconsole.log(data.users); // [{ id: 1, email: 'alice@example.com', ... }, ...]\n```\n\n## Key Features\n\n\u2705 **Type Safety**: Full TypeScript support with proper interfaces  \n\u2705 **Parameterized Queries**: SQL injection protection using `$1` placeholders  \n\u2705 **Error Handling**: Comprehensive error catching and user-friendly messages  \n\u2705 **Environment Validation**: Checks for required `DATABASE_URL`  \n\u2705 **Input Validation**: Domain format validation before querying  \n\u2705 **HTTP over WebSockets**: Uses Neon's HTTP API for serverless compatibility  \n\u2705 **Development-friendly**: Exposes error details in development mode only\n\n## Important Notes\n\n- The `@neondatabase/serverless` driver uses HTTP queries, making it ideal for serverless/edge environments\n- No connection pooling needed - each query is independent\n- Automatically handles SSL connections to Neon\n- Works in Vercel Edge Functions, Cloudflare Workers, and other edge runtimes\n\nFor more details, see the [Neon Serverless Driver documentation](https://neon.com/docs/serverless/serverless-driver.md).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2240,
            "output_tokens": 2194,
            "cached": false
          },
          "realistic": {
            "output": "I'll create a TypeScript module for a Next.js API route that connects to Neon Postgres using the serverless driver.\n\n```typescript\n// src/app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextResponse } from \"next/server\";\n\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\nexport async function getUsersByEmailDomain(\n  domain: string,\n): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Use parameterized query with LIKE pattern for email domain matching\n    const users = await sql<User[]>`\n      SELECT id, email, name, created_at \n      FROM users \n      WHERE email LIKE ${\"%\" + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users by domain: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    );\n  }\n}\n\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Domain parameter is required\" },\n        { status: 400 },\n      );\n    }\n\n    const users = await getUsersByEmailDomain(domain);\n\n    return NextResponse.json({ data: users, count: users.length });\n  } catch (error) {\n    console.error(\"API route error:\", error);\n    return NextResponse.json(\n      {\n        error:\n          error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 },\n    );\n  }\n}\n```\n\nThis module:\n\n1. **Uses the HTTP-based `neon()` function** - Ideal for serverless environments with single queries\n2. **Proper parameterization** - Uses tagged template literals to safely interpolate the domain parameter\n3. **TypeScript types** - Defines a `User` interface and types the query result\n4. **Error handling** - Catches and logs database errors, returns appropriate HTTP responses\n5. **Environment variable validation** - Checks for `DATABASE_URL` before attempting connection\n6. **Next.js App Router pattern** - Exports a `GET` handler for the API route\n\nUsage example:\n```\nGET /api/users/by-domain?domain=@example.com\n```\n\nThe query will return all users whose email ends with the specified domain.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10350,
            "output_tokens": 681,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "```typescript\n// pages/api/users/by-domain.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { neon, NeonQueryFunction } from '@neondatabase/serverless';\n\n// User interface definition\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\n// API response types\ninterface SuccessResponse {\n  success: true;\n  data: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  success: false;\n  error: string;\n  details?: string;\n}\n\ntype ApiResponse = SuccessResponse | ErrorResponse;\n\n/**\n * Fetches users by email domain from Neon Postgres database\n * @param domain - The email domain to search for (e.g., \"example.com\")\n * @returns Array of User objects matching the domain\n * @throws Error if database connection or query fails\n */\nexport async function getUsersByEmailDomain(domain: string): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  // Validate input\n  if (!domain || typeof domain !== 'string') {\n    throw new Error('Invalid domain parameter');\n  }\n\n  let sql: NeonQueryFunction<false, false>;\n\n  try {\n    // Create Neon connection\n    sql = neon(process.env.DATABASE_URL);\n\n    // Run parameterized query to prevent SQL injection\n    // Using LIKE with parameterized query for email domain matching\n    const query = `\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC\n    `;\n\n    // Execute query with parameterized domain\n    const result = await sql(query, [`%@${domain}`]);\n\n    // Type cast and return results\n    return result as User[];\n  } catch (error) {\n    // Handle connection and query errors\n    if (error instanceof Error) {\n      throw new Error(`Database error: ${error.message}`);\n    }\n    throw new Error('Unknown database error occurred');\n  }\n}\n\n/**\n * Next.js API route handler\n */\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({\n      success: false,\n      error: 'Method not allowed',\n    });\n  }\n\n  try {\n    // Extract domain from query parameters\n    const { domain } = req.query;\n\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({\n        success: false,\n        error: 'Domain parameter is required',\n        details: 'Please provide a valid email domain in the query string',\n      });\n    }\n\n    // Fetch users by domain\n    const users = await getUsersByEmailDomain(domain);\n\n    // Return successful response\n    return res.status(200).json({\n      success: true,\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    // Log error for debugging (in production, use proper logging service)\n    console.error('API Error:', error);\n\n    // Return error response\n    return res.status(500).json({\n      success: false,\n      error: 'Failed to fetch users',\n      details: error instanceof Error ? error.message : 'Unknown error',\n    });\n  }\n}\n```\n\n```typescript\n// Alternative: Standalone module version (lib/db/users.ts)\nimport { neon, NeonQueryFunction } from '@neondatabase/serverless';\n\nexport interface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\nexport interface DatabaseConfig {\n  connectionString: string;\n}\n\n/**\n * Database utility class for user operations\n */\nexport class UserRepository {\n  private sql: NeonQueryFunction<false, false>;\n\n  constructor(config: DatabaseConfig) {\n    if (!config.connectionString) {\n      throw new Error('Database connection string is required');\n    }\n    this.sql = neon(config.connectionString);\n  }\n\n  /**\n   * Fetch users by email domain\n   */\n  async getUsersByEmailDomain(domain: string): Promise<User[]> {\n    try {\n      const query = `\n        SELECT \n          id,\n          email,\n          name,\n          created_at,\n          updated_at\n        FROM users\n        WHERE email LIKE $1\n        ORDER BY created_at DESC\n      `;\n\n      const result = await this.sql(query, [`%@${domain}`]);\n      return result as User[];\n    } catch (error) {\n      throw new Error(\n        `Failed to fetch users by domain: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  /**\n   * Fetch user by exact email\n   */\n  async getUserByEmail(email: string): Promise<User | null> {\n    try {\n      const query = `\n        SELECT \n          id,\n          email,\n          name,\n          created_at,\n          updated_at\n        FROM users\n        WHERE email = $1\n        LIMIT 1\n      `;\n\n      const result = await this.sql(query, [email]);\n      return result.length > 0 ? (result[0] as User) : null;\n    } catch (error) {\n      throw new Error(\n        `Failed to fetch user by email: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n}\n\n// Factory function to create repository instance\nexport function createUserRepository(): UserRepository {\n  const connectionString = process.env.DATABASE_URL;\n  \n  if (!connectionString) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  return new UserRepository({ connectionString });\n}\n```\n\n```typescript\n// Usage example in API route (pages/api/users/search.ts)\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { createUserRepository } from '@/lib/db/users';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { domain } = req.query;\n\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({ error: 'Domain parameter required' });\n    }\n\n    const userRepo = createUserRepository();\n    const users = await userRepo.getUsersByEmailDomain(domain);\n\n    return res.status(200).json({\n      success: true,\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    });\n  }\n}\n```\n\nThis module includes:\n\n1. **Proper TypeScript types** for User interface and API responses\n2. **Neon Postgres connection** using the `@neondatabase/serverless` driver\n3. **Parameterized queries** to prevent SQL injection\n4. **Error handling** for connection and query failures\n5. **Environment variable validation**\n6. **Two implementations**: Direct API route and reusable repository class\n7. **Input validation** for domain parameter\n8. **Proper HTTP status codes** and response formatting",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 98,
            "output_tokens": 1919,
            "cached": false
          },
          "with_skill": {
            "output": "```typescript\n// app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\n/**\n * User interface matching the database schema\n */\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n}\n\n/**\n * Response type for the API\n */\ninterface ApiResponse {\n  users?: User[];\n  error?: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - The email domain to filter by (e.g., \"example.com\")\n * @returns Array of users matching the domain\n */\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  // Create Neon SQL client using HTTP queries\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Run parameterized query using tagged template literals\n    // This prevents SQL injection by safely interpolating the domain parameter\n    const users = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE ${\"%\" + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    // Re-throw with context for better error handling upstream\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error(\"Unknown database error occurred\");\n  }\n}\n\n/**\n * GET handler for Next.js API route\n * Usage: /api/users/by-domain?domain=example.com\n */\nexport async function GET(request: NextRequest): Promise<NextResponse<ApiResponse>> {\n  try {\n    // Extract domain from query parameters\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get(\"domain\");\n\n    // Validate required parameter\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Missing required parameter: domain\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate domain format (basic validation)\n    if (!/^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json(\n        { error: \"Invalid domain format\" },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users from database\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return NextResponse.json(\n      { users },\n      { \n        status: 200,\n        headers: {\n          \"Cache-Control\": \"private, max-age=60\", // Cache for 1 minute\n        }\n      }\n    );\n  } catch (error) {\n    // Log error for debugging (in production, use proper logging service)\n    console.error(\"Error fetching users by domain:\", error);\n\n    // Return error response\n    const errorMessage = error instanceof Error \n      ? error.message \n      : \"An unexpected error occurred\";\n\n    return NextResponse.json(\n      { error: errorMessage },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Alternative implementation using manual query construction\n * (if you prefer explicit parameterization over template literals)\n */\nexport async function getUsersByDomainManual(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Using .query() method with explicit parameters\n    const users = await sql.query<User>(\n      `SELECT \n        id,\n        email,\n        name,\n        created_at,\n        updated_at\n      FROM users\n      WHERE email LIKE $1\n      ORDER BY created_at DESC`,\n      [`%${domain}`]\n    );\n\n    return users;\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Database query failed: ${error.message}`);\n    }\n    throw new Error(\"Unknown database error occurred\");\n  }\n}\n```\n\n**Usage example:**\n\n```typescript\n// Example client-side fetch\nasync function fetchUsersByDomain(domain: string) {\n  const response = await fetch(`/api/users/by-domain?domain=${encodeURIComponent(domain)}`);\n  const data = await response.json();\n  \n  if (!response.ok) {\n    throw new Error(data.error || \"Failed to fetch users\");\n  }\n  \n  return data.users;\n}\n\n// Usage\nconst users = await fetchUsersByDomain(\"example.com\");\nconsole.log(users);\n```\n\n**Environment setup (.env.local):**\n\n```bash\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-1.aws.neon.tech/neondb?sslmode=require\n```\n\n**Key features:**\n\n1. \u2705 **Parameterized queries** - Uses tagged template literals to prevent SQL injection\n2. \u2705 **TypeScript types** - Strongly typed User interface and API responses\n3. \u2705 **Error handling** - Comprehensive try-catch with meaningful error messages\n4. \u2705 **Environment validation** - Checks for DATABASE_URL before connecting\n5. \u2705 **Input validation** - Validates domain parameter format\n6. \u2705 **HTTP best practices** - Proper status codes and cache headers\n7. \u2705 **Two query methods** - Template literals (recommended) and manual parameterization",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 9855,
            "output_tokens": 1439,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Next.js API Route with Neon Serverless Driver\n\nHere's a complete TypeScript module for a Next.js API route that connects to Neon Postgres using the `@neondatabase/serverless` driver:\n\n```typescript\n// app/api/users/route.ts (App Router)\n// or pages/api/users.ts (Pages Router)\n\nimport { neon } from '@neondatabase/serverless';\nimport { NextRequest, NextResponse } from 'next/server';\n\n// User interface matching your database schema\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\n// Response type for better type safety\ninterface UsersResponse {\n  users: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  error: string;\n  details?: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - Email domain to filter by (e.g., 'example.com')\n * @returns Array of users matching the domain\n */\nexport async function getUsersByDomain(\n  domain: string\n): Promise<User[]> {\n  // Validate environment variable\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  // Create Neon serverless connection\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Run parameterized query to prevent SQL injection\n    // The % wildcards are part of the LIKE pattern, not user input\n    const result = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return result;\n  } catch (error) {\n    // Log error for debugging\n    console.error('Database query error:', error);\n    \n    // Re-throw with more context\n    if (error instanceof Error) {\n      throw new Error(`Failed to fetch users: ${error.message}`);\n    }\n    throw new Error('Failed to fetch users: Unknown error');\n  }\n}\n\n// App Router (Next.js 13+) API Route Handler\nexport async function GET(request: NextRequest) {\n  try {\n    // Extract domain from query parameters\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get('domain');\n\n    // Validate input\n    if (!domain) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Missing required parameter: domain' },\n        { status: 400 }\n      );\n    }\n\n    // Basic domain validation\n    if (!/^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return NextResponse.json<ErrorResponse>(\n        { error: 'Invalid domain format' },\n        { status: 400 }\n      );\n    }\n\n    // Fetch users\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return NextResponse.json<UsersResponse>(\n      {\n        users,\n        count: users.length\n      },\n      { status: 200 }\n    );\n\n  } catch (error) {\n    console.error('API route error:', error);\n    \n    return NextResponse.json<ErrorResponse>(\n      {\n        error: 'Internal server error',\n        details: error instanceof Error ? error.message : 'Unknown error'\n      },\n      { status: 500 }\n    );\n  }\n}\n```\n\n## Alternative: Pages Router Version\n\nIf you're using the Pages Router instead of App Router:\n\n```typescript\n// pages/api/users.ts\n\nimport { neon } from '@neondatabase/serverless';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface UsersResponse {\n  users: User[];\n  count: number;\n}\n\ninterface ErrorResponse {\n  error: string;\n  details?: string;\n}\n\nexport async function getUsersByDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error('DATABASE_URL environment variable is not set');\n  }\n\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    const result = await sql<User[]>`\n      SELECT \n        id,\n        email,\n        name,\n        created_at\n      FROM users\n      WHERE email LIKE ${'%@' + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return result;\n  } catch (error) {\n    console.error('Database query error:', error);\n    \n    if (error instanceof Error) {\n      throw new Error(`Failed to fetch users: ${error.message}`);\n    }\n    throw new Error('Failed to fetch users: Unknown error');\n  }\n}\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<UsersResponse | ErrorResponse>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { domain } = req.query;\n\n    // Validate input\n    if (!domain || typeof domain !== 'string') {\n      return res.status(400).json({ \n        error: 'Missing or invalid required parameter: domain' \n      });\n    }\n\n    // Basic domain validation\n    if (!/^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\\.[a-zA-Z]{2,}$/.test(domain)) {\n      return res.status(400).json({ error: 'Invalid domain format' });\n    }\n\n    // Fetch users\n    const users = await getUsersByDomain(domain);\n\n    // Return successful response\n    return res.status(200).json({\n      users,\n      count: users.length\n    });\n\n  } catch (error) {\n    console.error('API route error:', error);\n    \n    return res.status(500).json({\n      error: 'Internal server error',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}\n```\n\n## Environment Setup\n\nCreate a `.env.local` file:\n\n```bash\nDATABASE_URL=\"postgresql://user:password@ep-example-123456.us-east-2.aws.neon.tech/neondb?sslmode=require\"\n```\n\n## Installation\n\n```bash\nnpm install @neondatabase/serverless\n```\n\n## Usage Examples\n\n### Client-side fetch (App Router):\n\n```typescript\n// app/components/UserList.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\nexport default function UserList() {\n  const [users, setUsers] = useState<User[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const fetchUsers = async (domain: string) => {\n    setLoading(true);\n    try {\n      const response = await fetch(`/api/users?domain=${encodeURIComponent(domain)}`);\n      const data = await response.json();\n      \n      if (response.ok) {\n        setUsers(data.users);\n      } else {\n        console.error('Error:', data.error);\n      }\n    } catch (error) {\n      console.error('Fetch error:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div>\n      <button onClick={() => fetchUsers('example.com')}>\n        Load Users\n      </button>\n      {loading && <p>Loading...</p>}\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>{user.name} - {user.email}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## Key Features\n\n1. **Parameterized Queries**: Uses template literals with `${}` for safe parameter binding\n2. **Type Safety**: Full TypeScript types for User interface and API responses\n3. **Error Handling**: Comprehensive try-catch with detailed error messages\n4. **Environment Validation**: Checks for DATABASE_URL before attempting connection\n5. **Input Validation**: Validates domain format to prevent invalid queries\n6. **HTTP Methods**: Properly restricts to GET requests only\n\n## Notes\n\n- The `neon()` function creates a connection that uses HTTP for queries (ideal for serverless/edge)\n- No connection pooling needed - each query is stateless\n- Works in Vercel Edge Functions, Cloudflare Workers, and other edge runtimes\n- For traditional Node.js environments with connection pooling, consider `@neondatabase/serverless` with `Pool` or use `pg` with `@neondatabase/serverless` WebSocket mode",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2240,
            "output_tokens": 2252,
            "cached": false
          },
          "realistic": {
            "output": "I'll create a TypeScript module for a Next.js API route that connects to Neon Postgres using the serverless driver.\n\n```typescript\n// src/app/api/users/by-domain/route.ts\nimport { neon } from \"@neondatabase/serverless\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\ninterface User {\n  id: number;\n  email: string;\n  name: string;\n  created_at: Date;\n}\n\ninterface GetUsersByDomainParams {\n  domain: string;\n}\n\n/**\n * Fetches users by email domain from Neon Postgres\n * @param domain - The email domain to filter by (e.g., \"example.com\")\n * @returns Array of users matching the domain\n */\nasync function getUsersByDomain(domain: string): Promise<User[]> {\n  if (!process.env.DATABASE_URL) {\n    throw new Error(\"DATABASE_URL environment variable is not set\");\n  }\n\n  const sql = neon(process.env.DATABASE_URL);\n\n  try {\n    // Use parameterized query with LIKE pattern for email domain matching\n    const users = await sql<User[]>`\n      SELECT id, email, name, created_at\n      FROM users\n      WHERE email LIKE ${\"%\" + domain}\n      ORDER BY created_at DESC\n    `;\n\n    return users;\n  } catch (error) {\n    console.error(\"Database query failed:\", error);\n    throw new Error(\n      `Failed to fetch users by domain: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    );\n  }\n}\n\n/**\n * GET /api/users/by-domain?domain=example.com\n * Returns users filtered by email domain\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams;\n    const domain = searchParams.get(\"domain\");\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: \"Domain parameter is required\" },\n        { status: 400 },\n      );\n    }\n\n    // Validate domain format (basic validation)\n    const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]\\.[a-zA-Z]{2,}$/;\n    if (!domainRegex.test(domain)) {\n      return NextResponse.json(\n        { error: \"Invalid domain format\" },\n        { status: 400 },\n      );\n    }\n\n    const users = await getUsersByDomain(domain);\n\n    return NextResponse.json({\n      data: users,\n      count: users.length,\n    });\n  } catch (error) {\n    console.error(\"API route error:\", error);\n    return NextResponse.json(\n      {\n        error:\n          error instanceof Error ? error.message : \"Internal server error\",\n      },\n      { status: 500 },\n    );\n  }\n}\n```\n\nThis module includes:\n\n1. **Proper TypeScript types**: `User` interface with all expected fields\n2. **Environment variable handling**: Checks for `DATABASE_URL` and throws if missing\n3. **Parameterized query**: Uses tagged template literals to safely interpolate the domain parameter\n4. **Error handling**: Catches and logs database errors, returns appropriate HTTP responses\n5. **Input validation**: Validates the domain parameter format\n6. **Next.js API route**: Exports `GET` handler following Next.js 13+ App Router conventions\n\nThe `getUsersByDomain` function can also be imported and reused in other parts of your application if needed.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10350,
            "output_tokens": 872,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-02",
      "task_type": "cross_language",
      "target_language": "python",
      "expected_patterns": [
        "from fastapi|import fastapi",
        "import asyncpg|from asyncpg",
        "async def",
        "await.*fetch|await.*execute",
        "create_pool|Pool",
        "@app\\.get|@router\\.get"
      ],
      "anti_patterns": [
        "@neondatabase",
        "neon\\(",
        "import.*drizzle",
        "import.*prisma",
        "const\\s+|let\\s+|var\\s+",
        "require\\("
      ],
      "pattern_sources": [
        {
          "url": "https://neon.com/docs/guides/python.md",
          "description": "Python with Neon: asyncpg connection patterns including await asyncpg.connect(), await conn.execute(), await conn.fetch(), async/await usage, asyncio.run() for async functions"
        },
        {
          "url": "https://docs.python.org/3/library/asyncio.html",
          "description": "Python asyncio documentation - source of async def syntax for asynchronous functions"
        },
        {
          "url": "https://raw.githubusercontent.com/fastapi/fastapi/master/README.md",
          "description": "FastAPI README - source of from fastapi import FastAPI, @app.get() and @router.get() decorator patterns, async def endpoint definitions"
        },
        {
          "url": "https://neon.com/docs/serverless/serverless-driver.md",
          "description": "Anti-patterns: TypeScript/JavaScript Neon serverless driver (@neondatabase/serverless, neon() function) that should not appear in Python"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# FastAPI PostgreSQL Products API with asyncpg\n\nHere's a complete implementation with connection pooling, proper async patterns, and error handling:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional, List\nfrom contextlib import asynccontextmanager\nimport asyncpg\nfrom decimal import Decimal\nimport os\n\n# ============================================================================\n# Configuration\n# ============================================================================\n\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql://user:password@localhost:5432/products_db\"\n)\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = Field(None, max_length=1000)\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(..., ge=0)\n    \n    @validator('price')\n    def validate_price(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than 0')\n        return v\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n    \n    class Config:\n        orm_mode = True\n        json_encoders = {\n            Decimal: lambda v: float(v)\n        }\n\nclass ProductListResponse(BaseModel):\n    products: List[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n# ============================================================================\n# Database Connection Pool\n# ============================================================================\n\nclass Database:\n    pool: Optional[asyncpg.Pool] = None\n\ndb = Database()\n\nasync def create_pool():\n    \"\"\"Create database connection pool\"\"\"\n    db.pool = await asyncpg.create_pool(\n        DATABASE_URL,\n        min_size=5,\n        max_size=20,\n        command_timeout=60,\n        max_queries=50000,\n        max_inactive_connection_lifetime=300,\n    )\n    print(\"\u2705 Database pool created\")\n\nasync def close_pool():\n    \"\"\"Close database connection pool\"\"\"\n    if db.pool:\n        await db.pool.close()\n        print(\"\u2705 Database pool closed\")\n\nasync def init_db():\n    \"\"\"Initialize database schema\"\"\"\n    async with db.pool.acquire() as conn:\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price NUMERIC(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create index for better query performance\n        await conn.execute(\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_products_name \n            ON products(name)\n        \"\"\")\n        \n        print(\"\u2705 Database schema initialized\")\n\n# ============================================================================\n# Lifespan Context Manager\n# ============================================================================\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifespan events\"\"\"\n    # Startup\n    await create_pool()\n    await init_db()\n    yield\n    # Shutdown\n    await close_pool()\n\n# ============================================================================\n# FastAPI Application\n# ============================================================================\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# ============================================================================\n# API Endpoints\n# ============================================================================\n\n@app.get(\"/\", tags=[\"Root\"])\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"message\": \"Products API is running\"\n    }\n\n@app.get(\n    \"/products\",\n    response_model=ProductListResponse,\n    tags=[\"Products\"],\n    summary=\"List all products with pagination\"\n)\nasync def get_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: Optional[str] = Query(None, description=\"Search by product name\")\n):\n    \"\"\"\n    Retrieve a paginated list of products.\n    \n    - **page**: Page number (starts from 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term for product name\n    \"\"\"\n    offset = (page - 1) * page_size\n    \n    async with db.pool.acquire() as conn:\n        # Build query based on search parameter\n        if search:\n            count_query = \"\"\"\n                SELECT COUNT(*) FROM products \n                WHERE name ILIKE $1\n            \"\"\"\n            select_query = \"\"\"\n                SELECT id, name, description, price, stock \n                FROM products \n                WHERE name ILIKE $1\n                ORDER BY id DESC\n                LIMIT $2 OFFSET $3\n            \"\"\"\n            search_param = f\"%{search}%\"\n            \n            total = await conn.fetchval(count_query, search_param)\n            rows = await conn.fetch(select_query, search_param, page_size, offset)\n        else:\n            count_query = \"SELECT COUNT(*) FROM products\"\n            select_query = \"\"\"\n                SELECT id, name, description, price, stock \n                FROM products \n                ORDER BY id DESC\n                LIMIT $1 OFFSET $2\n            \"\"\"\n            \n            total = await conn.fetchval(count_query)\n            rows = await conn.fetch(select_query, page_size, offset)\n        \n        # Convert rows to Product models\n        products = [\n            Product(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=row['price'],\n                stock=row['stock']\n            )\n            for row in rows\n        ]\n        \n        total_pages = (total + page_size - 1) // page_size\n        \n        return ProductListResponse(\n            products=products,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=total_pages\n        )\n\n@app.get(\n    \"/products/{product_id}\",\n    response_model=Product,\n    tags=[\"Products\"],\n    summary=\"Get a single product by ID\"\n)\nasync def get_product(product_id: int):\n    \"\"\"\n    Retrieve a specific product by its ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    async with db.pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"\"\"\n            SELECT id, name, description, price, stock \n            FROM products \n            WHERE id = $1\n            \"\"\",\n            product_id\n        )\n        \n        if not row:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock']\n        )\n\n@app.post(\n    \"/products\",\n    response_model=Product,\n    status_code=status.HTTP_201_CREATED,\n    tags=[\"Products\"],\n    summary=\"Create a new product\"\n)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, max 255 characters)\n    - **description**: Product description (optional, max 1000 characters)\n    - **price**: Product price (required, must be greater than 0)\n    - **stock**: Available stock (required, must be non-negative)\n    \"\"\"\n    async with db.pool.acquire() as conn:\n        try:\n            row = await conn.fetchrow(\n                \"\"\"\n                INSERT INTO products (name, description, price, stock)\n                VALUES ($1, $2, $3, $4)\n                RETURNING id, name, description, price, stock\n                \"\"\",\n                product.name,\n                product.description,\n                product.price,\n                product.stock\n            )\n            \n            return Product(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=row['price'],\n                stock=row['stock']\n            )\n        except asyncpg.UniqueViolationError:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=\"Product with this name already exists\"\n            )\n        except asyncpg.PostgresError as e:\n            raise HTTPException(\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                detail=f\"Database error: {str(e)}\"\n            )\n\n# ============================================================================\n# Additional Endpoints (Bonus)\n# ============================================================================\n\n@app.put(\n    \"/products/{product_id}\",\n    response_model=Product,\n    tags=[\"Products\"],\n    summary=\"Update a product\"\n)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"Update an existing product\"\"\"\n    async with db.pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"\"\"\n            UPDATE products \n            SET name = $1, description = $2, price = $3, stock = $4,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = $5\n            RETURNING id, name, description, price, stock\n            \"\"\",\n            product.name,\n            product.description,\n            product.price,\n            product.stock,\n            product_id\n        )\n        \n        if not row:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock']\n        )\n\n@app.delete(\n    \"/products/{product_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    tags=[\"Products\"],\n    summary=\"Delete a product\"\n)\nasync def delete_product(product_id: int):\n    \"\"\"Delete a product by ID\"\"\"\n    async with db.pool.acquire() as conn:\n        result = await conn.execute(\n            \"DELETE FROM products WHERE id = $1\",\n            product_id\n        )\n        \n        if result == \"DELETE 0\":\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return None\n\n# ============================================================================\n# Error Handlers\n# ============================================================================\n\n@app.exception_handler(asyncpg.PostgresError)\nasync def postgres_exception_handler(request, exc):\n    \"\"\"Handle PostgreSQL errors\"\"\"\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\n            \"detail\": \"Database error occurred\",\n            \"error\": str(exc)\n        }\n    )\n\n# ============================================================================\n# Run Application\n# ============================================================================\n\nif __name__ == \"__main__\":\n    import uvicorn\n    \n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True,\n        log_level=\"info\"\n    )\n```\n\n## Requirements File (`requirements.txt`)\n\n```txt\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\nasyncpg==0.29.0\npydantic==2.5.0\npython-dotenv==1.0.0\n```\n\n## Environment Variables (`.env`)\n\n```env\nDATABASE_URL=postgresql://user:password@localhost:5432/products_db\n```\n\n## Docker Compose Setup (`docker-compose.yml`)\n\n```yaml\nversion: '3.8'\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: products_db\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U user -d products_db\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      DATABASE_URL: postgresql://user:password@postgres:5432/products_db\n    depends_on:\n      postgres:\n        condition: service_healthy\n    volumes:\n      - .:/app\n\nvolumes:\n  postgres_data:\n```\n\n## Dockerfile\n\n```dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n## Usage Examples\n\n```bash\n# Start the services\ndocker-compose up -d\n\n# Create a product\ncurl -X POST \"http://localhost:8000/products\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# Get all products (paginated)\ncurl \"http://localhost:8000/products?page=1&page_size=10\"\n\n# Search products\ncurl \"http://localhost:8000/products?search=laptop\"\n\n# Get single product\ncurl \"http://localhost:8000/products/1\"\n\n# Update product\ncurl -X PUT \"http://localhost:8000/products/1\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-end gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete product\ncurl -X DELETE \"http://localhost:8000/products/1\"\n```\n\n## Key Features\n\n\u2705 **Connection Pooling** - Efficient database connections with asyncpg  \n\u2705 **Async/Await** - Proper async patterns throughout  \n\u2705 **Pagination** - Efficient data retrieval with offset/limit  \n\u2705 **Search** - Case-insensitive product name search  \n\u2705 **Validation** - Pydantic models with custom validators  \n\u2705 **Error Handling** - Comprehensive error responses  \n\u2705 **Type Safety** - Full type hints  \n\u2705 **Documentation** - Auto-generated OpenAPI docs at `/docs`  \n\u2705 **Health Check** - Root endpoint for monitoring  \n\u2705 **CRUD Operations** - Complete REST API implementation",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 3771,
            "cached": true
          },
          "with_skill": {
            "output": "# FastAPI + Neon Postgres with asyncpg\n\nHere's a complete FastAPI application with asyncpg connection pooling for a products REST API:\n\n## Installation\n\n```bash\npip install fastapi uvicorn asyncpg python-dotenv\n```\n\n## Project Structure\n\n```\n.\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 database.py\n\u251c\u2500\u2500 models.py\n\u2514\u2500\u2500 schemas.py\n```\n\n## 1. Environment Configuration\n\n```bash\n# .env\nDATABASE_URL=postgresql://user:password@ep-example-123456.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\nGet your connection string from the Neon Console. For connection pooling with asyncpg, use the **direct connection string** (not the pooled connection string).\n\n## 2. Database Connection Pool\n\n```python\n# database.py\nimport asyncpg\nimport os\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\n\n# Global connection pool\npool: asyncpg.Pool | None = None\n\n\nasync def create_pool():\n    \"\"\"Create database connection pool on startup.\"\"\"\n    global pool\n    pool = await asyncpg.create_pool(\n        dsn=os.getenv(\"DATABASE_URL\"),\n        min_size=2,\n        max_size=10,\n        command_timeout=60,\n        # Connection pool settings optimized for serverless\n        max_queries=50000,\n        max_inactive_connection_lifetime=300,\n    )\n    return pool\n\n\nasync def close_pool():\n    \"\"\"Close database connection pool on shutdown.\"\"\"\n    global pool\n    if pool:\n        await pool.close()\n\n\nasync def get_connection() -> AsyncGenerator[asyncpg.Connection, None]:\n    \"\"\"Get a connection from the pool.\"\"\"\n    if not pool:\n        raise RuntimeError(\"Database pool not initialized\")\n    \n    async with pool.acquire() as connection:\n        yield connection\n```\n\n## 3. Pydantic Models\n\n```python\n# schemas.py\nfrom pydantic import BaseModel, Field, ConfigDict\nfrom typing import Optional\nfrom datetime import datetime\n\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\n\nclass ProductCreate(ProductBase):\n    pass\n\n\nclass Product(ProductBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass PaginatedProducts(BaseModel):\n    items: list[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\n## 4. Database Models\n\n```python\n# models.py\nCREATE_PRODUCTS_TABLE = \"\"\"\nCREATE TABLE IF NOT EXISTS products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    description TEXT,\n    price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n    stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX IF NOT EXISTS idx_products_name ON products(name);\nCREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at DESC);\n\"\"\"\n\n# Trigger to auto-update updated_at\nCREATE_UPDATED_AT_TRIGGER = \"\"\"\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$$ language 'plpgsql';\n\nDROP TRIGGER IF EXISTS update_products_updated_at ON products;\n\nCREATE TRIGGER update_products_updated_at\n    BEFORE UPDATE ON products\n    FOR EACH ROW\n    EXECUTE FUNCTION update_updated_at_column();\n\"\"\"\n```\n\n## 5. FastAPI Application\n\n```python\n# main.py\nfrom fastapi import FastAPI, HTTPException, Depends, Query\nfrom fastapi.responses import JSONResponse\nfrom contextlib import asynccontextmanager\nimport asyncpg\nfrom typing import Annotated\nimport os\nfrom dotenv import load_dotenv\n\nfrom database import create_pool, close_pool, get_connection\nfrom schemas import Product, ProductCreate, PaginatedProducts\nfrom models import CREATE_PRODUCTS_TABLE, CREATE_UPDATED_AT_TRIGGER\n\nload_dotenv()\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage database connection pool lifecycle.\"\"\"\n    # Startup\n    pool = await create_pool()\n    \n    # Initialize database schema\n    async with pool.acquire() as conn:\n        await conn.execute(CREATE_PRODUCTS_TABLE)\n        await conn.execute(CREATE_UPDATED_AT_TRIGGER)\n    \n    yield\n    \n    # Shutdown\n    await close_pool()\n\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon Postgres\",\n    version=\"1.0.0\",\n    lifespan=lifespan,\n)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"ok\", \"message\": \"Products API is running\"}\n\n\n@app.get(\"/products\", response_model=PaginatedProducts)\nasync def list_products(\n    page: Annotated[int, Query(ge=1)] = 1,\n    page_size: Annotated[int, Query(ge=1, le=100)] = 20,\n    conn: asyncpg.Connection = Depends(get_connection),\n):\n    \"\"\"\n    List all products with pagination.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    offset = (page - 1) * page_size\n    \n    # Get total count\n    total = await conn.fetchval(\"SELECT COUNT(*) FROM products\")\n    \n    # Get paginated products\n    rows = await conn.fetch(\n        \"\"\"\n        SELECT id, name, description, price, stock, created_at, updated_at\n        FROM products\n        ORDER BY created_at DESC\n        LIMIT $1 OFFSET $2\n        \"\"\",\n        page_size,\n        offset,\n    )\n    \n    products = [Product(**dict(row)) for row in rows]\n    total_pages = (total + page_size - 1) // page_size\n    \n    return PaginatedProducts(\n        items=products,\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=total_pages,\n    )\n\n\n@app.get(\"/products/{product_id}\", response_model=Product)\nasync def get_product(\n    product_id: int,\n    conn: asyncpg.Connection = Depends(get_connection),\n):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The product ID\n    \"\"\"\n    row = await conn.fetchrow(\n        \"\"\"\n        SELECT id, name, description, price, stock, created_at, updated_at\n        FROM products\n        WHERE id = $1\n        \"\"\",\n        product_id,\n    )\n    \n    if not row:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    \n    return Product(**dict(row))\n\n\n@app.post(\"/products\", response_model=Product, status_code=201)\nasync def create_product(\n    product: ProductCreate,\n    conn: asyncpg.Connection = Depends(get_connection),\n):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (must be > 0)\n    - **stock**: Stock quantity (must be >= 0)\n    \"\"\"\n    try:\n        row = await conn.fetchrow(\n            \"\"\"\n            INSERT INTO products (name, description, price, stock)\n            VALUES ($1, $2, $3, $4)\n            RETURNING id, name, description, price, stock, created_at, updated_at\n            \"\"\",\n            product.name,\n            product.description,\n            product.price,\n            product.stock,\n        )\n        \n        return Product(**dict(row))\n    \n    except asyncpg.exceptions.UniqueViolationError:\n        raise HTTPException(status_code=409, detail=\"Product already exists\")\n    except asyncpg.exceptions.CheckViolationError as e:\n        raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n@app.delete(\"/products/{product_id}\", status_code=204)\nasync def delete_product(\n    product_id: int,\n    conn: asyncpg.Connection = Depends(get_connection),\n):\n    \"\"\"\n    Delete a product by ID.\n    \n    - **product_id**: The product ID\n    \"\"\"\n    result = await conn.execute(\n        \"DELETE FROM products WHERE id = $1\",\n        product_id,\n    )\n    \n    # Check if any row was deleted\n    if result == \"DELETE 0\":\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    \n    return None\n\n\n@app.put(\"/products/{product_id}\", response_model=Product)\nasync def update_product(\n    product_id: int,\n    product: ProductCreate,\n    conn: asyncpg.Connection = Depends(get_connection),\n):\n    \"\"\"\n    Update an existing product.\n    \n    - **product_id**: The product ID\n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (must be > 0)\n    - **stock**: Stock quantity (must be >= 0)\n    \"\"\"\n    try:\n        row = await conn.fetchrow(\n            \"\"\"\n            UPDATE products\n            SET name = $2, description = $3, price = $4, stock = $5\n            WHERE id = $1\n            RETURNING id, name, description, price, stock, created_at, updated_at\n            \"\"\",\n            product_id,\n            product.name,\n            product.description,\n            product.price,\n            product.stock,\n        )\n        \n        if not row:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        return Product(**dict(row))\n    \n    except asyncpg.exceptions.CheckViolationError as e:\n        raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n## Running the Application\n\n```bash\n# Development\nuvicorn main:app --reload\n\n# Production\nuvicorn main:app --host 0.0.0.0 --port 8000 --workers 4\n```\n\n## Testing the API\n\n```bash\n# List products (paginated)\ncurl http://localhost:8000/products?page=1&page_size=10\n\n# Get single product\ncurl http://localhost:8000/products/1\n\n# Create product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# Update product\ncurl -X PUT http://localhost:8000/products/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-performance gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete product\ncurl -X DELETE http://localhost:8000/products/1\n```\n\n## Key Features\n\n\u2705 **Connection Pooling**: asyncpg pool with configurable min/max connections  \n\u2705 **Async/Await**: Full async support throughout the application  \n\u2705 **Pagination**: Efficient pagination with total count  \n\u2705 **Error Handling**: Proper HTTP status codes and error messages  \n\u2705 **Data Validation**: Pydantic models with constraints  \n\u2705 **Auto-timestamps**: Automatic `updated_at` trigger  \n\u2705 **Dependency Injection**: Clean connection management with FastAPI dependencies  \n\u2705 **Lifecycle Management**: Pool creation/cleanup on app startup/shutdown\n\n## Connection Pool Settings\n\nThe pool configuration is optimized for typical web applications:\n\n- `min_size=2`: Minimum 2 connections always ready\n- `max_size=10`: Maximum 10 concurrent connections\n- `command_timeout=60`: 60 second query timeout\n- `max_queries=50000`: Recycle connections after 50k queries\n- `max_inactive_connection_lifetime=300`: Close idle connections after 5 minutes\n\nAdjust these based on your traffic patterns and Neon plan limits.\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive API docs:\n\n- Swagger UI: http://localhost:8000/docs\n- ReDoc: http://localhost:8000/redoc\n\n## Next Steps\n\nFor production deployments:\n\n1. **Add authentication**: Implement JWT or API key authentication\n2. **Rate limiting**: Use `slowapi` or similar middleware\n3. **Monitoring**: Add logging and metrics (Sentry, DataDog, etc.)\n4. **Caching**: Consider Redis for frequently accessed data\n5. **Database migrations**: Use Alembic for schema versioning\n\nFor more on Neon with Python, see the [SQLAlchemy guide](https://neon.com/docs/guides/sqlalchemy.md) or [Django guide](https://neon.com/docs/guides/django.md).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5516,
            "output_tokens": 3455,
            "cached": false
          },
          "skill_md_only": {
            "output": "# FastAPI with Neon Postgres using asyncpg\n\nHere's a complete implementation of a FastAPI application with asyncpg for connecting to Neon Postgres:\n\n## Complete Implementation\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List\nfrom contextlib import asynccontextmanager\nimport asyncpg\nimport os\n\n# Pydantic models for request/response validation\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\nclass ProductResponse(BaseModel):\n    id: int\n    name: str\n    description: Optional[str]\n    price: float\n    stock: int\n\n    class Config:\n        from_attributes = True\n\nclass ProductList(BaseModel):\n    products: List[ProductResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n# Database connection pool\ndb_pool: Optional[asyncpg.Pool] = None\n\nasync def get_database_pool():\n    \"\"\"Create and return database connection pool\"\"\"\n    connection_string = os.getenv(\"DATABASE_URL\")\n    \n    if not connection_string:\n        raise ValueError(\"DATABASE_URL environment variable is not set\")\n    \n    # Create connection pool with recommended settings for Neon\n    pool = await asyncpg.create_pool(\n        connection_string,\n        min_size=1,           # Minimum connections in pool\n        max_size=10,          # Maximum connections in pool\n        max_queries=50000,    # Max queries per connection before recycling\n        max_inactive_connection_lifetime=300,  # 5 minutes\n        command_timeout=60,   # Command timeout in seconds\n    )\n    \n    return pool\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifespan - setup and teardown\"\"\"\n    global db_pool\n    \n    # Startup: Create connection pool\n    db_pool = await get_database_pool()\n    \n    # Create products table if it doesn't exist\n    async with db_pool.acquire() as conn:\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create index for better query performance\n        await conn.execute(\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_products_name \n            ON products(name)\n        \"\"\")\n    \n    yield\n    \n    # Shutdown: Close connection pool\n    await db_pool.close()\n\n# Initialize FastAPI app with lifespan\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon Postgres\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# Health check endpoint\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Check if the API and database are healthy\"\"\"\n    try:\n        async with db_pool.acquire() as conn:\n            await conn.fetchval(\"SELECT 1\")\n        return {\"status\": \"healthy\", \"database\": \"connected\"}\n    except Exception as e:\n        raise HTTPException(status_code=503, detail=f\"Database unhealthy: {str(e)}\")\n\n# GET /products - List products with pagination\n@app.get(\"/products\", response_model=ProductList)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\")\n):\n    \"\"\"\n    List all products with pagination.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    offset = (page - 1) * page_size\n    \n    async with db_pool.acquire() as conn:\n        # Get total count\n        total = await conn.fetchval(\"SELECT COUNT(*) FROM products\")\n        \n        # Get paginated products\n        rows = await conn.fetch(\n            \"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            ORDER BY id\n            LIMIT $1 OFFSET $2\n            \"\"\",\n            page_size,\n            offset\n        )\n        \n        products = [\n            ProductResponse(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=float(row['price']),\n                stock=row['stock']\n            )\n            for row in rows\n        ]\n        \n        total_pages = (total + page_size - 1) // page_size\n        \n        return ProductList(\n            products=products,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=total_pages\n        )\n\n# GET /products/{id} - Get single product\n@app.get(\"/products/{product_id}\", response_model=ProductResponse)\nasync def get_product(product_id: int):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    async with db_pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            WHERE id = $1\n            \"\"\",\n            product_id\n        )\n        \n        if not row:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        return ProductResponse(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=float(row['price']),\n            stock=row['stock']\n        )\n\n# POST /products - Create new product\n@app.post(\"/products\", response_model=ProductResponse, status_code=201)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be > 0)\n    - **stock**: Stock quantity (required, must be >= 0)\n    \"\"\"\n    async with db_pool.acquire() as conn:\n        try:\n            row = await conn.fetchrow(\n                \"\"\"\n                INSERT INTO products (name, description, price, stock)\n                VALUES ($1, $2, $3, $4)\n                RETURNING id, name, description, price, stock\n                \"\"\",\n                product.name,\n                product.description,\n                product.price,\n                product.stock\n            )\n            \n            return ProductResponse(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=float(row['price']),\n                stock=row['stock']\n            )\n        except asyncpg.UniqueViolationError:\n            raise HTTPException(status_code=409, detail=\"Product already exists\")\n        except Exception as e:\n            raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n# Optional: PUT /products/{id} - Update product\n@app.put(\"/products/{product_id}\", response_model=ProductResponse)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"Update an existing product\"\"\"\n    async with db_pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"\"\"\n            UPDATE products\n            SET name = $2, description = $3, price = $4, stock = $5,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = $1\n            RETURNING id, name, description, price, stock\n            \"\"\",\n            product_id,\n            product.name,\n            product.description,\n            product.price,\n            product.stock\n        )\n        \n        if not row:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        return ProductResponse(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=float(row['price']),\n            stock=row['stock']\n        )\n\n# Optional: DELETE /products/{id} - Delete product\n@app.delete(\"/products/{product_id}\", status_code=204)\nasync def delete_product(product_id: int):\n    \"\"\"Delete a product\"\"\"\n    async with db_pool.acquire() as conn:\n        result = await conn.execute(\n            \"DELETE FROM products WHERE id = $1\",\n            product_id\n        )\n        \n        if result == \"DELETE 0\":\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n```\n\n## Requirements File\n\n```txt\n# requirements.txt\nfastapi==0.109.0\nuvicorn[standard]==0.27.0\nasyncpg==0.29.0\npydantic==2.5.3\npython-dotenv==1.0.0\n```\n\n## Environment Configuration\n\n```bash\n# .env\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n## Running the Application\n\n```bash\n# Install dependencies\npip install -r requirements.txt\n\n# Run the server\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n```\n\n## Testing the API\n\n```bash\n# Health check\ncurl http://localhost:8000/health\n\n# Create a product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# List products (with pagination)\ncurl http://localhost:8000/products?page=1&page_size=10\n\n# Get single product\ncurl http://localhost:8000/products/1\n\n# Update product\ncurl -X PUT http://localhost:8000/products/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-performance gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete product\ncurl -X DELETE http://localhost:8000/products/1\n```\n\n## Key Features\n\n1. **Connection Pooling**: Uses `asyncpg.create_pool()` with optimized settings for Neon\n2. **Async/Await**: All database operations use proper async patterns\n3. **Lifespan Management**: Pool created on startup, closed on shutdown\n4. **Pagination**: GET /products supports page and page_size parameters\n5. **Error Handling**: Proper HTTP status codes and error messages\n6. **Validation**: Pydantic models validate all input/output\n7. **Auto-docs**: FastAPI generates interactive docs at `/docs`\n\n## Neon-Specific Optimizations\n\nThe connection pool settings are optimized for Neon:\n- `min_size=1`: Minimal idle connections (Neon scales to zero)\n- `max_size=10`: Reasonable max for most applications\n- `max_inactive_connection_lifetime=300`: Recycle idle connections after 5 minutes\n- SSL mode required in connection string\n\nVisit `http://localhost:8000/docs` for interactive API documentation!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2226,
            "output_tokens": 2885,
            "cached": false
          },
          "realistic": {
            "output": "I'll create a complete FastAPI endpoint for products with asyncpg and connection pooling. Let me build this step by step.\n\nFirst, let me check the current database setup:\n\n<function_calls>\n<invoke name=\"read_file\">\n<parameter name=\"path\">src/database.py</parameter>\n</invoke>\n</function_calls>\n<parameter name=\"path\">src/database.py</parameter>\n<invoke name=\"read_file\">\n<parameter name=\"path\">pyproject.toml</parameter>\n</invoke>\n</function_calls>\n<parameter name=\"path\">pyproject.toml</parameter>\n<invoke name=\"read_file\">\n<parameter name=\"path\">src/main.py</parameter>\n</invoke>\n</function_calls>\n<parameter name=\"path\">src/main.py</parameter>\n\nNow I'll create the products implementation:\n\n<function_calls>\n<invoke name=\"write_file\">\n<parameter name=\"path\">src/models/product.py</parameter>\n<parameter name=\"content\">\"\"\"Product model for the database.\"\"\"\nfrom sqlalchemy import Column, Integer, String, Numeric, Text, DateTime\nfrom sqlalchemy.sql import func\nfrom src.models import Base\n\n\nclass Product(Base):\n    \"\"\"Product table model.\"\"\"\n    \n    __tablename__ = \"products\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(255), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    price = Column(Numeric(10, 2), nullable=False)\n    stock = Column(Integer, nullable=False, default=0)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)\n    \n    def __repr__(self):\n        return f\"<Product(id={self.id}, name='{self.name}', price={self.price})>\"\n</parameter>\n</invoke>\n</function_calls>\n<parameter name=\"path\">src/models/product.py</parameter>\n\n<function_calls>\n<invoke name=\"write_file\">\n<parameter name=\"path\">src/schemas/product.py</parameter>\n<parameter name=\"content\">\"\"\"Pydantic schemas for product API.\"\"\"\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom pydantic import BaseModel, Field, ConfigDict\n\n\nclass ProductBase(BaseModel):\n    \"\"\"Base product schema with common fields.\"\"\"\n    \n    name: str = Field(..., min_length=1, max_length=255, description=\"Product name\")\n    description: str | None = Field(None, description=\"Product description\")\n    price: Decimal = Field(..., gt=0, decimal_places=2, description=\"Product price\")\n    stock: int = Field(default=0, ge=0, description=\"Stock quantity\")\n\n\nclass ProductCreate(ProductBase):\n    \"\"\"Schema for creating a new product.\"\"\"\n    pass\n\n\nclass ProductUpdate(BaseModel):\n    \"\"\"Schema for updating a product (all fields optional).\"\"\"\n    \n    name: str | None = Field(None, min_length=1, max_length=255)\n    description: str | None = None\n    price: Decimal | None = Field(None, gt=0, decimal_places=2)\n    stock: int | None = Field(None, ge=0)\n\n\nclass ProductResponse(ProductBase):\n    \"\"\"Schema for product response.\"\"\"\n    \n    model_config = ConfigDict(from_attributes=True)\n    \n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n\nclass ProductListResponse(BaseModel):\n    \"\"\"Schema for paginated product list response.\"\"\"\n    \n    items: list[ProductResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n</parameter>\n</invoke>\n</function_calls>\n<parameter name=\"path\">src/schemas/product.py</parameter>\n\n<function_calls>\n<invoke name=\"write_file\">\n<parameter name=\"path\">src/services/product.py</parameter>\n<parameter name=\"content\">\"\"\"Product service with business logic.\"\"\"\nimport logging\nfrom sqlalchemy import select, func\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.models.product import Product\nfrom src.schemas.product import ProductCreate, ProductUpdate\nfrom src.services.base import BaseService\n\nlogger = logging.getLogger(__name__)\n\n\nclass ProductService(BaseService[Product]):\n    \"\"\"Service for product operations.\"\"\"\n    \n    def __init__(self, session: AsyncSession):\n        super().__init__(session)\n    \n    async def get_product(self, product_id: int) -> Product | None:\n        \"\"\"Get a single product by ID.\"\"\"\n        return await self.get_by_id(Product, product_id)\n    \n    async def list_products(\n        self, \n        page: int = 1, \n        page_size: int = 10,\n        search: str | None = None\n    ) -> tuple[list[Product], int]:\n        \"\"\"\n        List products with pagination and optional search.\n        \n        Returns:\n            Tuple of (products list, total count)\n        \"\"\"\n        # Build base query\n        query = select(Product)\n        \n        # Add search filter if provided\n        if search:\n            search_pattern = f\"%{search}%\"\n            query = query.where(\n                (Product.name.ilike(search_pattern)) | \n                (Product.description.ilike(search_pattern))\n            )\n        \n        # Get total count\n        count_query = select(func.count()).select_from(query.subquery())\n        total_result = await self.session.execute(count_query)\n        total = total_result.scalar_one()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        query = query.offset(offset).limit(page_size).order_by(Product.created_at.desc())\n        \n        # Execute query\n        result = await self.session.execute(query)\n        products = list(result.scalars().all())\n        \n        logger.info(\n            \"Listed products: page=%d, page_size=%d, total=%d, search=%s\",\n            page, page_size, total, search\n        )\n        \n        return products, total\n    \n    async def create_product(self, product_data: ProductCreate) -> Product:\n        \"\"\"Create a new product.\"\"\"\n        product = Product(**product_data.model_dump())\n        return await self.create(product)\n    \n    async def update_product(\n        self, \n        product_id: int, \n        product_data: ProductUpdate\n    ) -> Product | None:\n        \"\"\"Update an existing product.\"\"\"\n        product = await self.get_product(product_id)\n        if not product:\n            return None\n        \n        # Update only provided fields\n        update_data = product_data.model_dump(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(product, field, value)\n        \n        await self.session.flush()\n        logger.info(\"Updated product id=%d\", product_id)\n        \n        return product\n    \n    async def delete_product(self, product_id: int) -> bool:\n        \"\"\"Delete a product.\"\"\"\n        product = await self.get_product(product_id)\n        if not product:\n            return False\n        \n        await self.session.delete(product)\n        await self.session.flush()\n        logger.info(\"Deleted product id=%d\", product_id)\n        \n        return True\n</parameter>\n</invoke>\n</function_calls>\n<parameter name=\"path\">src/services/product.py</parameter>\n\n<function_calls>\n<invoke name=\"write_file\">\n<parameter name=\"path\">src/routers/products.py</parameter>\n<parameter name=\"content\">\"\"\"Product API endpoints.\"\"\"\nimport logging\nimport math\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.database import get_db\nfrom src.schemas.product import (\n    ProductCreate,\n    ProductResponse,\n    ProductListResponse,\n    ProductUpdate,\n)\nfrom src.services.product import ProductService\n\nlogger = logging.getLogger(__name__)\nrouter = APIRouter(prefix=\"/products\", tags=[\"products\"])\n\n\ndef get_product_service(session: AsyncSession = Depends(get_db)) -> ProductService:\n    \"\"\"Dependency to get product service.\"\"\"\n    return ProductService(session)\n\n\n@router.get(\"\", response_model=ProductListResponse)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: str | None = Query(None, description=\"Search in name and description\"),\n    service: ProductService = Depends(get_product_service),\n):\n    \"\"\"\n    List products with pagination and optional search.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term for name/description\n    \"\"\"\n    products, total = await service.list_products(\n        page=page,\n        page_size=page_size,\n        search=search,\n    )\n    \n    total_pages = math.ceil(total / page_size) if total > 0 else 0\n    \n    return ProductListResponse(\n        items=products,\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=total_pages,\n    )\n\n\n@router.get(\"/{product_id}\", response_model=ProductResponse)\nasync def get_product(\n    product_id: int,\n    service: ProductService = Depends(get_product_service),\n):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The product ID\n    \"\"\"\n    product = await service.get_product(product_id)\n    if not product:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {product_id} not found\",\n        )\n    return product\n\n\n@router.post(\"\", response_model=ProductResponse, status_code=status.HTTP_201_CREATED)\nasync def create_product(\n    product_data: ProductCreate,\n    service: ProductService = Depends(get_product_service),\n):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be > 0)\n    - **stock**: Stock quantity (optional, defaults to 0)\n    \"\"\"\n    product = await service.create_product(product_data)\n    return product\n\n\n@router.patch(\"/{product_id}\", response_model=ProductResponse)\nasync def update_product(\n    product_id: int,\n    product_data: ProductUpdate,\n    service: ProductService = Depends(get_product_service),\n):\n    \"\"\"\n    Update an existing product (partial update).\n    \n    - **product_id**: The product ID\n    - All fields are optional - only provided fields will be updated\n    \"\"\"\n    product = await service.update_product(product_id, product_data)\n    if not product:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {product_id} not found\",\n        )\n    return product\n\n\n@router.delete(\"/{product_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_product(\n    product_id: int,\n    service: ProductService = Depends(get_product_service),\n):\n    \"\"\"\n    Delete a product.\n    \n    - **product_id**: The product ID\n    \"\"\"\n    deleted = await service.delete_product(product_id)\n    if not deleted:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {product_id} not found\",\n        )\n</parameter>\n</invoke>\n</function_calls>\n<parameter name=\"path\">src/routers/products.py</parameter>\n\nNow let me update the main.py to include the products router:\n\n<function_calls>\n<invoke name=\"read_file\">\n<parameter name=\"path\">src/main.py</parameter>\n</invoke>\n</function_calls>\n<parameter name=\"path\">src/main.py</parameter>\n\n<function_calls>\n<invoke name=\"write_file\">\n<parameter name=\"path\">src/main.py</parameter>\n<parameter name=\"content\">\"\"\"FastAPI application entrypoint.\"\"\"\nimport logging\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom src.database import engine, Base\nfrom src.routers import products\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan events.\"\"\"\n    # Startup\n    logger.info(\"Starting application...\")\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    logger.info(\"Database tables created\")\n    \n    yield\n    \n    # Shutdown\n    logger.info(\"Shutting down application...\")\n    await engine.dispose()\n    logger.info(\"Database connections closed\")\n\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan,\n)\n\n# Include routers\napp.include_router(products.router)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"ok\", \"message\": \"Products API is running\"}\n\n\n@app.get(\"/health\")\nasync def health():\n    \"\"\"Detailed health check.\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"database\": \"connected\",\n    }\n</parameter>\n</invoke>\n</function_calls>\n<parameter name=\"path\">src/main.py</parameter>\n\nNow let me create the database configuration with asyncpg:\n\n<function_calls>\n<invoke name=\"write_file\">\n<parameter name=\"path\">src/database.py</parameter>\n<parameter name=\"content\">\"\"\"Database configuration and session management.\"\"\"\nimport os\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker\nfrom sqlalchemy.pool import NullPool\n\n# Get database URL from environment\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql+asyncpg://user:password@localhost:5432/products_db\"\n)\n\n# Create async engine with connection pooling\n# For asyncpg, use postgresql+asyncpg:// scheme\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=True,  # Log SQL queries (disable in production)\n    pool_size=10,  # Maximum number of connections in the pool\n    max_overflow=20,  # Maximum overflow connections\n    pool_pre_ping=True,  # Verify connections before using them\n    pool_recycle=3600,  # Recycle connections after 1 hour\n    # Use NullPool for serverless environments (uncomment if needed)\n    # poolclass=NullPool,\n)\n\n# Create async session factory\nAsyncSessionLocal = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False,  # Don't expire objects after commit\n    autocommit=False,\n    autoflush=False,\n)\n\n\nasync def get_db() -> Async",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6042,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# FastAPI PostgreSQL Products API with asyncpg\n\nHere's a complete implementation with connection pooling, proper async patterns, and error handling:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query, Depends\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional, List\nfrom contextlib import asynccontextmanager\nimport asyncpg\nfrom asyncpg.pool import Pool\nimport os\nfrom decimal import Decimal\n\n# Configuration\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql://user:password@localhost:5432/products_db\"\n)\n\n# Global connection pool\ndb_pool: Optional[Pool] = None\n\n\n# Pydantic Models\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = Field(None, max_length=1000)\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(..., ge=0)\n\n    @validator('price')\n    def validate_price(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than 0')\n        return round(v, 2)\n\n\nclass ProductCreate(ProductBase):\n    pass\n\n\nclass Product(ProductBase):\n    id: int\n    created_at: str\n\n    class Config:\n        from_attributes = True\n\n\nclass ProductList(BaseModel):\n    products: List[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n\n# Database connection pool management\nasync def init_db_pool():\n    \"\"\"Initialize the database connection pool\"\"\"\n    global db_pool\n    db_pool = await asyncpg.create_pool(\n        DATABASE_URL,\n        min_size=5,\n        max_size=20,\n        command_timeout=60,\n        max_queries=50000,\n        max_inactive_connection_lifetime=300,\n    )\n    print(\"Database pool created successfully\")\n\n\nasync def close_db_pool():\n    \"\"\"Close the database connection pool\"\"\"\n    global db_pool\n    if db_pool:\n        await db_pool.close()\n        print(\"Database pool closed\")\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Lifespan context manager for startup and shutdown events\"\"\"\n    # Startup\n    await init_db_pool()\n    await create_products_table()\n    yield\n    # Shutdown\n    await close_db_pool()\n\n\n# Initialize FastAPI app with lifespan\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n\n# Dependency to get database connection\nasync def get_db_connection():\n    \"\"\"Dependency that provides a database connection from the pool\"\"\"\n    if not db_pool:\n        raise HTTPException(status_code=500, detail=\"Database pool not initialized\")\n    \n    async with db_pool.acquire() as connection:\n        yield connection\n\n\n# Database initialization\nasync def create_products_table():\n    \"\"\"Create the products table if it doesn't exist\"\"\"\n    async with db_pool.acquire() as conn:\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price NUMERIC(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create index for better query performance\n        await conn.execute(\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_products_name \n            ON products(name)\n        \"\"\")\n        \n        print(\"Products table created/verified successfully\")\n\n\n# API Endpoints\n\n@app.get(\"/\", tags=[\"Root\"])\nasync def root():\n    \"\"\"Root endpoint\"\"\"\n    return {\n        \"message\": \"Products API\",\n        \"endpoints\": {\n            \"list\": \"GET /products\",\n            \"get\": \"GET /products/{id}\",\n            \"create\": \"POST /products\"\n        }\n    }\n\n\n@app.get(\"/products\", response_model=ProductList, tags=[\"Products\"])\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: Optional[str] = Query(None, description=\"Search by product name\"),\n    conn: asyncpg.Connection = Depends(get_db_connection)\n):\n    \"\"\"\n    Get a paginated list of products\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term for product name\n    \"\"\"\n    try:\n        offset = (page - 1) * page_size\n        \n        # Build query based on search parameter\n        if search:\n            count_query = \"\"\"\n                SELECT COUNT(*) FROM products \n                WHERE name ILIKE $1\n            \"\"\"\n            select_query = \"\"\"\n                SELECT id, name, description, price, stock, \n                       created_at::text as created_at\n                FROM products\n                WHERE name ILIKE $1\n                ORDER BY created_at DESC\n                LIMIT $2 OFFSET $3\n            \"\"\"\n            search_param = f\"%{search}%\"\n            total = await conn.fetchval(count_query, search_param)\n            rows = await conn.fetch(select_query, search_param, page_size, offset)\n        else:\n            count_query = \"SELECT COUNT(*) FROM products\"\n            select_query = \"\"\"\n                SELECT id, name, description, price, stock, \n                       created_at::text as created_at\n                FROM products\n                ORDER BY created_at DESC\n                LIMIT $1 OFFSET $2\n            \"\"\"\n            total = await conn.fetchval(count_query)\n            rows = await conn.fetch(select_query, page_size, offset)\n        \n        # Convert rows to Product models\n        products = [\n            Product(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=row['price'],\n                stock=row['stock'],\n                created_at=row['created_at']\n            )\n            for row in rows\n        ]\n        \n        total_pages = (total + page_size - 1) // page_size\n        \n        return ProductList(\n            products=products,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=total_pages\n        )\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n@app.get(\"/products/{product_id}\", response_model=Product, tags=[\"Products\"])\nasync def get_product(\n    product_id: int,\n    conn: asyncpg.Connection = Depends(get_db_connection)\n):\n    \"\"\"\n    Get a single product by ID\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    try:\n        query = \"\"\"\n            SELECT id, name, description, price, stock, \n                   created_at::text as created_at\n            FROM products\n            WHERE id = $1\n        \"\"\"\n        \n        row = await conn.fetchrow(query, product_id)\n        \n        if not row:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock'],\n            created_at=row['created_at']\n        )\n    \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n@app.post(\"/products\", response_model=Product, status_code=201, tags=[\"Products\"])\nasync def create_product(\n    product: ProductCreate,\n    conn: asyncpg.Connection = Depends(get_db_connection)\n):\n    \"\"\"\n    Create a new product\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional, max 1000 characters)\n    - **price**: Product price (required, must be > 0)\n    - **stock**: Stock quantity (required, must be >= 0)\n    \"\"\"\n    try:\n        query = \"\"\"\n            INSERT INTO products (name, description, price, stock)\n            VALUES ($1, $2, $3, $4)\n            RETURNING id, name, description, price, stock, \n                      created_at::text as created_at\n        \"\"\"\n        \n        row = await conn.fetchrow(\n            query,\n            product.name,\n            product.description,\n            product.price,\n            product.stock\n        )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock'],\n            created_at=row['created_at']\n        )\n    \n    except asyncpg.UniqueViolationError:\n        raise HTTPException(\n            status_code=400,\n            detail=\"A product with this name already exists\"\n        )\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n# Health check endpoint\n@app.get(\"/health\", tags=[\"Health\"])\nasync def health_check(conn: asyncpg.Connection = Depends(get_db_connection)):\n    \"\"\"Check if the API and database are healthy\"\"\"\n    try:\n        # Simple query to check database connectivity\n        await conn.fetchval(\"SELECT 1\")\n        return {\n            \"status\": \"healthy\",\n            \"database\": \"connected\"\n        }\n    except Exception as e:\n        raise HTTPException(\n            status_code=503,\n            detail=f\"Database connection failed: {str(e)}\"\n        )\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True\n    )\n```\n\n## Requirements File (`requirements.txt`)\n\n```txt\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\nasyncpg==0.29.0\npydantic==2.5.0\npython-dotenv==1.0.0\n```\n\n## Environment Configuration (`.env`)\n\n```env\nDATABASE_URL=postgresql://user:password@localhost:5432/products_db\n```\n\n## Docker Compose for PostgreSQL (`docker-compose.yml`)\n\n```yaml\nversion: '3.8'\n\nservices:\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: products_db\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U user -d products_db\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\nvolumes:\n  postgres_data:\n```\n\n## Usage Examples\n\n### Start the PostgreSQL database:\n```bash\ndocker-compose up -d\n```\n\n### Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n### Run the application:\n```bash\npython main.py\n# or\nuvicorn main:app --reload\n```\n\n### Test the API:\n\n```bash\n# Create a product\ncurl -X POST \"http://localhost:8000/products\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# Get all products (paginated)\ncurl \"http://localhost:8000/products?page=1&page_size=10\"\n\n# Search products\ncurl \"http://localhost:8000/products?search=Laptop\"\n\n# Get single product\ncurl \"http://localhost:8000/products/1\"\n\n# Health check\ncurl \"http://localhost:8000/health\"\n```\n\n## Key Features:\n\n1. **Connection Pooling**: Uses asyncpg's connection pool for efficient database connections\n2. **Async/Await**: Proper async patterns throughout\n3. **Pagination**: Built-in pagination with configurable page size\n4. **Search**: Optional search functionality\n5. **Validation**: Pydantic models for request/response validation\n6. **Error Handling**: Comprehensive error handling with appropriate HTTP status codes\n7. **Health Check**: Endpoint to verify API and database health\n8. **Type Safety**: Full type hints for better IDE support\n9. **Documentation**: Auto-generated API docs at `/docs`\n\nAccess the interactive API documentation at `http://localhost:8000/docs`!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 3244,
            "cached": true
          },
          "with_skill": {
            "output": "# FastAPI Products API with Neon Postgres\n\nHere's a complete implementation using FastAPI with asyncpg and proper connection pooling for Neon Postgres.\n\n## Installation\n\n```bash\npip install fastapi uvicorn asyncpg python-dotenv\n```\n\n## Project Structure\n\n```\nproject/\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 database.py\n\u251c\u2500\u2500 models.py\n\u2514\u2500\u2500 schemas.py\n```\n\n## Environment Configuration\n\n```bash\n# .env\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\nGet your connection string from the Neon Console. For connection pooling with asyncpg, use the **pooled connection string** (port 5432) from your Neon project dashboard.\n\n## Database Connection Pool\n\n```python\n# database.py\nimport asyncpg\nimport os\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\n\nclass Database:\n    def __init__(self):\n        self.pool: asyncpg.Pool | None = None\n    \n    async def connect(self):\n        \"\"\"Create connection pool on startup\"\"\"\n        self.pool = await asyncpg.create_pool(\n            dsn=os.getenv(\"DATABASE_URL\"),\n            min_size=2,\n            max_size=10,\n            command_timeout=60,\n            # Recommended settings for Neon\n            server_settings={\n                'application_name': 'fastapi_products_api'\n            }\n        )\n    \n    async def disconnect(self):\n        \"\"\"Close connection pool on shutdown\"\"\"\n        if self.pool:\n            await self.pool.close()\n    \n    async def execute(self, query: str, *args):\n        \"\"\"Execute a query that doesn't return results\"\"\"\n        async with self.pool.acquire() as connection:\n            return await connection.execute(query, *args)\n    \n    async def fetch(self, query: str, *args):\n        \"\"\"Fetch multiple rows\"\"\"\n        async with self.pool.acquire() as connection:\n            return await connection.fetch(query, *args)\n    \n    async def fetchrow(self, query: str, *args):\n        \"\"\"Fetch a single row\"\"\"\n        async with self.pool.acquire() as connection:\n            return await connection.fetchrow(query, *args)\n    \n    async def fetchval(self, query: str, *args):\n        \"\"\"Fetch a single value\"\"\"\n        async with self.pool.acquire() as connection:\n            return await connection.fetchval(query, *args)\n\n# Global database instance\ndb = Database()\n```\n\n## Pydantic Models\n\n```python\n# schemas.py\nfrom pydantic import BaseModel, Field, ConfigDict\nfrom typing import Optional\nfrom decimal import Decimal\nfrom datetime import datetime\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(..., ge=0)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n    \n    model_config = ConfigDict(from_attributes=True)\n\nclass ProductList(BaseModel):\n    products: list[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\n## FastAPI Application\n\n```python\n# main.py\nfrom fastapi import FastAPI, HTTPException, Query\nfrom fastapi.responses import JSONResponse\nfrom contextlib import asynccontextmanager\nfrom typing import Annotated\nimport os\nfrom dotenv import load_dotenv\n\nfrom database import db\nfrom schemas import Product, ProductCreate, ProductList\n\nload_dotenv()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage database connection lifecycle\"\"\"\n    # Startup\n    await db.connect()\n    await initialize_database()\n    yield\n    # Shutdown\n    await db.disconnect()\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon Postgres\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\nasync def initialize_database():\n    \"\"\"Create products table if it doesn't exist\"\"\"\n    create_table_query = \"\"\"\n    CREATE TABLE IF NOT EXISTS products (\n        id SERIAL PRIMARY KEY,\n        name VARCHAR(255) NOT NULL,\n        description TEXT,\n        price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n        stock INTEGER NOT NULL CHECK (stock >= 0),\n        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n    );\n    \n    CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);\n    \"\"\"\n    await db.execute(create_table_query)\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\"status\": \"healthy\", \"message\": \"Products API is running\"}\n\n@app.get(\"/products\", response_model=ProductList)\nasync def list_products(\n    page: Annotated[int, Query(ge=1)] = 1,\n    page_size: Annotated[int, Query(ge=1, le=100)] = 10\n):\n    \"\"\"\n    List products with pagination\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    offset = (page - 1) * page_size\n    \n    # Get total count\n    count_query = \"SELECT COUNT(*) FROM products\"\n    total = await db.fetchval(count_query)\n    \n    # Get paginated products\n    products_query = \"\"\"\n    SELECT id, name, description, price, stock, created_at, updated_at\n    FROM products\n    ORDER BY created_at DESC\n    LIMIT $1 OFFSET $2\n    \"\"\"\n    rows = await db.fetch(products_query, page_size, offset)\n    \n    products = [\n        Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock'],\n            created_at=row['created_at'],\n            updated_at=row['updated_at']\n        )\n        for row in rows\n    ]\n    \n    total_pages = (total + page_size - 1) // page_size\n    \n    return ProductList(\n        products=products,\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=total_pages\n    )\n\n@app.get(\"/products/{product_id}\", response_model=Product)\nasync def get_product(product_id: int):\n    \"\"\"\n    Get a single product by ID\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    query = \"\"\"\n    SELECT id, name, description, price, stock, created_at, updated_at\n    FROM products\n    WHERE id = $1\n    \"\"\"\n    row = await db.fetchrow(query, product_id)\n    \n    if not row:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    \n    return Product(\n        id=row['id'],\n        name=row['name'],\n        description=row['description'],\n        price=row['price'],\n        stock=row['stock'],\n        created_at=row['created_at'],\n        updated_at=row['updated_at']\n    )\n\n@app.post(\"/products\", response_model=Product, status_code=201)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product\n    \n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be > 0)\n    - **stock**: Stock quantity (required, must be >= 0)\n    \"\"\"\n    query = \"\"\"\n    INSERT INTO products (name, description, price, stock)\n    VALUES ($1, $2, $3, $4)\n    RETURNING id, name, description, price, stock, created_at, updated_at\n    \"\"\"\n    \n    try:\n        row = await db.fetchrow(\n            query,\n            product.name,\n            product.description,\n            product.price,\n            product.stock\n        )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=row['price'],\n            stock=row['stock'],\n            created_at=row['created_at'],\n            updated_at=row['updated_at']\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Failed to create product: {str(e)}\"\n        )\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request, exc):\n    \"\"\"Global exception handler for unexpected errors\"\"\"\n    return JSONResponse(\n        status_code=500,\n        content={\"detail\": \"Internal server error\"}\n    )\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n## Running the Application\n\n```bash\n# Development\nuvicorn main:app --reload\n\n# Production\nuvicorn main:app --host 0.0.0.0 --port 8000 --workers 4\n```\n\n## Testing the API\n\n```bash\n# Health check\ncurl http://localhost:8000/\n\n# Create a product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# List products (first page)\ncurl http://localhost:8000/products?page=1&page_size=10\n\n# Get specific product\ncurl http://localhost:8000/products/1\n```\n\n## Key Features\n\n### Connection Pooling\n- **Min connections**: 2 (always ready)\n- **Max connections**: 10 (scales with load)\n- **Automatic cleanup**: Pool closes on shutdown\n- **Connection reuse**: Efficient resource management\n\n### Async/Await Patterns\n- All database operations are async\n- Non-blocking I/O for high concurrency\n- Proper connection acquisition/release with context managers\n\n### Best Practices\n- \u2705 Parameterized queries (prevents SQL injection)\n- \u2705 Proper error handling with HTTP status codes\n- \u2705 Input validation with Pydantic\n- \u2705 Pagination for list endpoints\n- \u2705 Database initialization on startup\n- \u2705 Connection lifecycle management\n\n## Neon-Specific Optimizations\n\n1. **Use pooled connection string** (port 5432) for connection pooling\n2. **Set `application_name`** for better monitoring in Neon Console\n3. **Configure timeouts** to handle Neon's scale-to-zero gracefully\n4. **Use indexes** for frequently queried columns\n\n## Additional Resources\n\n- [Neon Python Guide](https://neon.com/docs/guides/python.md)\n- [FastAPI Documentation](https://fastapi.tiangolo.com/)\n- [asyncpg Documentation](https://magicstack.github.io/asyncpg/)\n\nThis implementation provides a production-ready REST API with proper async patterns, connection pooling, and Neon Postgres integration.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5516,
            "output_tokens": 2842,
            "cached": false
          },
          "skill_md_only": {
            "output": "# FastAPI with Neon Postgres using asyncpg\n\nHere's a complete implementation of a FastAPI application with asyncpg for connecting to Neon Postgres:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List\nimport asyncpg\nfrom contextlib import asynccontextmanager\nimport os\n\n# Pydantic models\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n\n# Database connection pool\ndb_pool: Optional[asyncpg.Pool] = None\n\nasync def get_database_pool():\n    \"\"\"Create and return database connection pool\"\"\"\n    connection_string = os.getenv(\"DATABASE_URL\")\n    \n    if not connection_string:\n        raise ValueError(\"DATABASE_URL environment variable is not set\")\n    \n    # Create connection pool with recommended settings for Neon\n    pool = await asyncpg.create_pool(\n        connection_string,\n        min_size=1,\n        max_size=10,\n        command_timeout=60,\n        # Neon-specific: Use prepared statements for better performance\n        server_settings={\n            'jit': 'off',  # Disable JIT for faster cold starts\n        }\n    )\n    \n    return pool\n\nasync def init_db(pool: asyncpg.Pool):\n    \"\"\"Initialize database schema\"\"\"\n    async with pool.acquire() as conn:\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create index for better query performance\n        await conn.execute(\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_products_name \n            ON products(name)\n        \"\"\")\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifecycle\"\"\"\n    global db_pool\n    \n    # Startup: Create connection pool\n    db_pool = await get_database_pool()\n    await init_db(db_pool)\n    print(\"\u2705 Database connection pool created\")\n    \n    yield\n    \n    # Shutdown: Close connection pool\n    if db_pool:\n        await db_pool.close()\n        print(\"\u2705 Database connection pool closed\")\n\n# Initialize FastAPI app\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon Postgres\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# API Endpoints\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"message\": \"Products API is running\",\n        \"database\": \"connected\" if db_pool else \"disconnected\"\n    }\n\n@app.get(\"/products\", response_model=List[Product])\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\")\n):\n    \"\"\"\n    List products with pagination\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    if not db_pool:\n        raise HTTPException(status_code=503, detail=\"Database connection not available\")\n    \n    offset = (page - 1) * page_size\n    \n    async with db_pool.acquire() as conn:\n        # Get total count\n        total = await conn.fetchval(\"SELECT COUNT(*) FROM products\")\n        \n        # Get paginated results\n        rows = await conn.fetch(\n            \"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            ORDER BY id\n            LIMIT $1 OFFSET $2\n            \"\"\",\n            page_size,\n            offset\n        )\n    \n    products = [\n        Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=float(row['price']),\n            stock=row['stock']\n        )\n        for row in rows\n    ]\n    \n    return products\n\n@app.get(\"/products/{product_id}\", response_model=Product)\nasync def get_product(product_id: int):\n    \"\"\"\n    Get a single product by ID\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    if not db_pool:\n        raise HTTPException(status_code=503, detail=\"Database connection not available\")\n    \n    async with db_pool.acquire() as conn:\n        row = await conn.fetchrow(\n            \"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            WHERE id = $1\n            \"\"\",\n            product_id\n        )\n    \n    if not row:\n        raise HTTPException(status_code=404, detail=f\"Product {product_id} not found\")\n    \n    return Product(\n        id=row['id'],\n        name=row['name'],\n        description=row['description'],\n        price=float(row['price']),\n        stock=row['stock']\n    )\n\n@app.post(\"/products\", response_model=Product, status_code=201)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **stock**: Stock quantity (required, must be non-negative)\n    \"\"\"\n    if not db_pool:\n        raise HTTPException(status_code=503, detail=\"Database connection not available\")\n    \n    async with db_pool.acquire() as conn:\n        try:\n            row = await conn.fetchrow(\n                \"\"\"\n                INSERT INTO products (name, description, price, stock)\n                VALUES ($1, $2, $3, $4)\n                RETURNING id, name, description, price, stock\n                \"\"\",\n                product.name,\n                product.description,\n                product.price,\n                product.stock\n            )\n        except asyncpg.UniqueViolationError:\n            raise HTTPException(status_code=409, detail=\"Product already exists\")\n        except asyncpg.CheckViolationError as e:\n            raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n    \n    return Product(\n        id=row['id'],\n        name=row['name'],\n        description=row['description'],\n        price=float(row['price']),\n        stock=row['stock']\n    )\n\n@app.put(\"/products/{product_id}\", response_model=Product)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"\n    Update an existing product\n    \n    - **product_id**: The ID of the product to update\n    - **name**: Updated product name\n    - **description**: Updated product description\n    - **price**: Updated product price\n    - **stock**: Updated stock quantity\n    \"\"\"\n    if not db_pool:\n        raise HTTPException(status_code=503, detail=\"Database connection not available\")\n    \n    async with db_pool.acquire() as conn:\n        try:\n            row = await conn.fetchrow(\n                \"\"\"\n                UPDATE products\n                SET name = $2, description = $3, price = $4, stock = $5,\n                    updated_at = CURRENT_TIMESTAMP\n                WHERE id = $1\n                RETURNING id, name, description, price, stock\n                \"\"\",\n                product_id,\n                product.name,\n                product.description,\n                product.price,\n                product.stock\n            )\n        except asyncpg.CheckViolationError as e:\n            raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n    \n    if not row:\n        raise HTTPException(status_code=404, detail=f\"Product {product_id} not found\")\n    \n    return Product(\n        id=row['id'],\n        name=row['name'],\n        description=row['description'],\n        price=float(row['price']),\n        stock=row['stock']\n    )\n\n@app.delete(\"/products/{product_id}\", status_code=204)\nasync def delete_product(product_id: int):\n    \"\"\"\n    Delete a product\n    \n    - **product_id**: The ID of the product to delete\n    \"\"\"\n    if not db_pool:\n        raise HTTPException(status_code=503, detail=\"Database connection not available\")\n    \n    async with db_pool.acquire() as conn:\n        result = await conn.execute(\n            \"DELETE FROM products WHERE id = $1\",\n            product_id\n        )\n    \n    if result == \"DELETE 0\":\n        raise HTTPException(status_code=404, detail=f\"Product {product_id} not found\")\n    \n    return None\n```\n\n## Requirements File\n\nCreate a `requirements.txt`:\n\n```txt\nfastapi==0.109.0\nuvicorn[standard]==0.27.0\nasyncpg==0.29.0\npydantic==2.5.3\npython-dotenv==1.0.0\n```\n\n## Environment Configuration\n\nCreate a `.env` file:\n\n```bash\n# Get your connection string from Neon Console\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n## Running the Application\n\n```bash\n# Install dependencies\npip install -r requirements.txt\n\n# Run the server\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n```\n\n## Testing the API\n\n```bash\n# Health check\ncurl http://localhost:8000/\n\n# Create a product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# List products (with pagination)\ncurl http://localhost:8000/products?page=1&page_size=10\n\n# Get single product\ncurl http://localhost:8000/products/1\n\n# Update product\ncurl -X PUT http://localhost:8000/products/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-performance gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete product\ncurl -X DELETE http://localhost:8000/products/1\n```\n\n## Key Features\n\n1. **Connection Pooling**: Uses `asyncpg.create_pool()` with optimal settings for Neon\n2. **Async/Await**: All database operations use proper async patterns\n3. **Lifecycle Management**: Pool created on startup, closed on shutdown\n4. **Pagination**: GET /products supports page and page_size parameters\n5. **Error Handling**: Proper HTTP status codes and error messages\n6. **Data Validation**: Pydantic models validate input/output\n7. **CRUD Operations**: Complete Create, Read, Update, Delete functionality\n\n## Neon-Specific Optimizations\n\n- **JIT disabled**: Faster cold starts on serverless\n- **Connection pooling**: Reuses connections efficiently\n- **SSL mode**: Required for Neon connections\n- **Prepared statements**: asyncpg automatically uses them for better performance\n\n## Interactive API Documentation\n\nOnce running, visit:\n- Swagger UI: http://localhost:8000/docs\n- ReDoc: http://localhost:8000/redoc\n\nThis provides a complete, production-ready FastAPI application with asyncpg and Neon Postgres!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2226,
            "output_tokens": 3009,
            "cached": false
          },
          "realistic": {
            "output": "I'll create a complete implementation with proper async patterns, connection pooling, and REST endpoints for the products table.\n\nFirst, let me check the current database setup:\n\n```python\n# src/database.py\n\"\"\"Database configuration and session management.\"\"\"\nimport os\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker\nfrom sqlalchemy.orm import declarative_base\n\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"postgresql+asyncpg://user:password@localhost/dbname\")\n\n# Create async engine with connection pooling\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=True,  # Set to False in production\n    pool_size=10,\n    max_overflow=20,\n    pool_pre_ping=True,\n    pool_recycle=3600,\n)\n\n# Create async session factory\nAsyncSessionLocal = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\nBase = declarative_base()\n\n\nasync def get_db() -> AsyncSession:\n    \"\"\"Dependency for getting database sessions.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n```\n\nNow the Product model:\n\n```python\n# src/models/product.py\n\"\"\"Product model definition.\"\"\"\nfrom datetime import datetime\nfrom sqlalchemy import Column, Integer, String, Numeric, DateTime, Text\nfrom src.database import Base\n\n\nclass Product(Base):\n    __tablename__ = \"products\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(255), nullable=False, index=True)\n    description = Column(Text, nullable=True)\n    price = Column(Numeric(10, 2), nullable=False)\n    sku = Column(String(100), unique=True, nullable=False, index=True)\n    stock_quantity = Column(Integer, default=0, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)\n\n    def __repr__(self):\n        return f\"<Product(id={self.id}, name='{self.name}', sku='{self.sku}')>\"\n```\n\nPydantic schemas for request/response validation:\n\n```python\n# src/schemas/product.py\n\"\"\"Pydantic schemas for product endpoints.\"\"\"\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom pydantic import BaseModel, Field, ConfigDict\n\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: str | None = None\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    sku: str = Field(..., min_length=1, max_length=100)\n    stock_quantity: int = Field(default=0, ge=0)\n\n\nclass ProductCreate(ProductBase):\n    pass\n\n\nclass ProductResponse(ProductBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass ProductListResponse(BaseModel):\n    items: list[ProductResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\nProduct service layer:\n\n```python\n# src/services/product_service.py\n\"\"\"Business logic for product operations.\"\"\"\nimport logging\nfrom sqlalchemy import select, func\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.models.product import Product\nfrom src.schemas.product import ProductCreate\n\nlogger = logging.getLogger(__name__)\n\n\nclass ProductService:\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def get_products(\n        self, \n        page: int = 1, \n        page_size: int = 20,\n        search: str | None = None\n    ) -> tuple[list[Product], int]:\n        \"\"\"Get paginated list of products with optional search.\"\"\"\n        offset = (page - 1) * page_size\n        \n        # Build base query\n        query = select(Product)\n        count_query = select(func.count(Product.id))\n        \n        # Add search filter if provided\n        if search:\n            search_filter = Product.name.ilike(f\"%{search}%\")\n            query = query.where(search_filter)\n            count_query = count_query.where(search_filter)\n        \n        # Order by created_at descending\n        query = query.order_by(Product.created_at.desc())\n        \n        # Apply pagination\n        query = query.offset(offset).limit(page_size)\n        \n        # Execute queries\n        result = await self.session.execute(query)\n        products = result.scalars().all()\n        \n        count_result = await self.session.execute(count_query)\n        total = count_result.scalar_one()\n        \n        logger.info(f\"Retrieved {len(products)} products (page {page}, total {total})\")\n        return list(products), total\n\n    async def get_product_by_id(self, product_id: int) -> Product | None:\n        \"\"\"Get a single product by ID.\"\"\"\n        result = await self.session.get(Product, product_id)\n        if result is None:\n            logger.warning(f\"Product with id={product_id} not found\")\n        return result\n\n    async def get_product_by_sku(self, sku: str) -> Product | None:\n        \"\"\"Get a product by SKU.\"\"\"\n        query = select(Product).where(Product.sku == sku)\n        result = await self.session.execute(query)\n        return result.scalar_one_or_none()\n\n    async def create_product(self, product_data: ProductCreate) -> Product:\n        \"\"\"Create a new product.\"\"\"\n        # Check if SKU already exists\n        existing = await self.get_product_by_sku(product_data.sku)\n        if existing:\n            raise ValueError(f\"Product with SKU '{product_data.sku}' already exists\")\n        \n        product = Product(**product_data.model_dump())\n        self.session.add(product)\n        await self.session.flush()\n        await self.session.refresh(product)\n        \n        logger.info(f\"Created product id={product.id}, sku={product.sku}\")\n        return product\n```\n\nFastAPI router with endpoints:\n\n```python\n# src/routers/products.py\n\"\"\"Product API endpoints.\"\"\"\nimport logging\nimport math\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.database import get_db\nfrom src.schemas.product import ProductCreate, ProductResponse, ProductListResponse\nfrom src.services.product_service import ProductService\n\nlogger = logging.getLogger(__name__)\nrouter = APIRouter(prefix=\"/products\", tags=[\"products\"])\n\n\n@router.get(\"\", response_model=ProductListResponse)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(20, ge=1, le=100, description=\"Items per page\"),\n    search: str | None = Query(None, description=\"Search by product name\"),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"\n    Get paginated list of products.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term to filter by product name\n    \"\"\"\n    service = ProductService(db)\n    products, total = await service.get_products(page, page_size, search)\n    \n    total_pages = math.ceil(total / page_size) if total > 0 else 0\n    \n    return ProductListResponse(\n        items=[ProductResponse.model_validate(p) for p in products],\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=total_pages,\n    )\n\n\n@router.get(\"/{product_id}\", response_model=ProductResponse)\nasync def get_product(\n    product_id: int,\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    service = ProductService(db)\n    product = await service.get_product_by_id(product_id)\n    \n    if product is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {product_id} not found\"\n        )\n    \n    return ProductResponse.model_validate(product)\n\n\n@router.post(\"\", response_model=ProductResponse, status_code=status.HTTP_201_CREATED)\nasync def create_product(\n    product_data: ProductCreate,\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **sku**: Stock Keeping Unit (required, must be unique)\n    - **stock_quantity**: Available stock (default: 0)\n    \"\"\"\n    service = ProductService(db)\n    \n    try:\n        product = await service.create_product(product_data)\n        return ProductResponse.model_validate(product)\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e)\n        )\n    except Exception as e:\n        logger.error(f\"Error creating product: {e}\", exc_info=True)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create product\"\n        )\n```\n\nUpdate main.py to include the router:\n\n```python\n# src/main.py\n\"\"\"FastAPI application entrypoint.\"\"\"\nimport logging\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom src.database import engine, Base\nfrom src.routers import products\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan events.\"\"\"\n    # Startup\n    logger.info(\"Starting application...\")\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    logger.info(\"Database tables created\")\n    \n    yield\n    \n    # Shutdown\n    logger.info(\"Shutting down application...\")\n    await engine.dispose()\n    logger.info(\"Database connections closed\")\n\n\napp = FastAPI(\n    title=\"Product API\",\n    description=\"REST API for managing products\",\n    version=\"1.0.0\",\n    lifespan=lifespan,\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Include routers\napp.include_router(products.router)\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"healthy\"}\n```\n\nUpdate dependencies in pyproject.toml:\n\n```toml\n[tool.poetry.dependencies]\npython = \"^3.12\"\nfastapi = \"^0.115.0\"\nuvicorn = {extras = [\"standard\"], version = \"^0.32.0\"}\nsqlalchemy = \"^2.0.36\"\nasyncpg = \"^0.30.0\"\npydantic = \"^2.10.0\"\npydantic-settings = \"^2.6.0\"\n```\n\nExample .env file:\n\n```bash\n# .env\nDATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/products_db\n```\n\nRun the application:\n\n```bash\n# Install dependencies\npoetry install\n\n# Run migrations (create tables)\npoetry run python -c \"from src.database import engine, Base; import asyncio; asyncio.run(engine.begin().__aenter__().run_sync(Base.metadata.create_all))\"\n\n# Start the server\npoetry run uvicorn src.main:app --reload --host 0.0.0.0 --port 8000\n```\n\nThe implementation includes:\n\n\u2705 **Async/await patterns** throughout\n\u2705 **Connection pooling** with configurable pool size\n\u2705 **Proper session management** with dependency injection\n\u2705 **Pagination** with page and page_size parameters\n\u2705 **Search functionality** for filtering products\n\u2705 **Error handling** with appropriate HTTP status codes\n\u2705 **Pydantic validation** for request/response\n\u2705 **Service layer** separating business logic from routes\n\u2705 **Logging** for debugging and monitoring\n\u2705 **Health check** endpoint\n\nTest the endpoints:\n- `GET http://localhost:8000/products?page=1&page_size=20`\n- `GET http://localhost:8000/products/1`\n- `POST http://localhost:8000/products` with JSON body\n- `GET http://localhost:8000/docs` for interactive API documentation",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6042,
            "output_tokens": 3333,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# FastAPI PostgreSQL Products API with asyncpg\n\nHere's a complete implementation with connection pooling, proper async patterns, and error handling:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional, List\nfrom contextlib import asynccontextmanager\nimport asyncpg\nfrom decimal import Decimal\nimport os\n\n# ============================================================================\n# Configuration\n# ============================================================================\n\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql://user:password@localhost:5432/products_db\"\n)\n\n# ============================================================================\n# Pydantic Models\n# ============================================================================\n\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = Field(None, max_length=1000)\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    stock: int = Field(..., ge=0)\n    \n    @validator('price')\n    def validate_price(cls, v):\n        if v <= 0:\n            raise ValueError('Price must be greater than 0')\n        return round(v, 2)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n    created_at: str\n    \n    class Config:\n        orm_mode = True\n        json_encoders = {\n            Decimal: lambda v: float(v)\n        }\n\nclass ProductListResponse(BaseModel):\n    products: List[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n# ============================================================================\n# Database Connection Pool\n# ============================================================================\n\nclass Database:\n    pool: Optional[asyncpg.Pool] = None\n    \n    @classmethod\n    async def connect(cls):\n        \"\"\"Create database connection pool\"\"\"\n        try:\n            cls.pool = await asyncpg.create_pool(\n                DATABASE_URL,\n                min_size=5,\n                max_size=20,\n                command_timeout=60,\n                max_queries=50000,\n                max_inactive_connection_lifetime=300\n            )\n            print(\"\u2705 Database connection pool created successfully\")\n        except Exception as e:\n            print(f\"\u274c Failed to create database pool: {e}\")\n            raise\n    \n    @classmethod\n    async def disconnect(cls):\n        \"\"\"Close database connection pool\"\"\"\n        if cls.pool:\n            await cls.pool.close()\n            print(\"\u2705 Database connection pool closed\")\n    \n    @classmethod\n    async def initialize_schema(cls):\n        \"\"\"Create products table if it doesn't exist\"\"\"\n        async with cls.pool.acquire() as connection:\n            await connection.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS products (\n                    id SERIAL PRIMARY KEY,\n                    name VARCHAR(255) NOT NULL,\n                    description TEXT,\n                    price NUMERIC(10, 2) NOT NULL CHECK (price > 0),\n                    stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                );\n                \n                CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);\n                CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at DESC);\n            \"\"\")\n            print(\"\u2705 Database schema initialized\")\n\n# ============================================================================\n# FastAPI Application with Lifespan\n# ============================================================================\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifespan - startup and shutdown\"\"\"\n    # Startup\n    await Database.connect()\n    await Database.initialize_schema()\n    yield\n    # Shutdown\n    await Database.disconnect()\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# ============================================================================\n# Helper Functions\n# ============================================================================\n\ndef record_to_product(record: asyncpg.Record) -> Product:\n    \"\"\"Convert database record to Product model\"\"\"\n    return Product(\n        id=record['id'],\n        name=record['name'],\n        description=record['description'],\n        price=record['price'],\n        stock=record['stock'],\n        created_at=record['created_at'].isoformat()\n    )\n\n# ============================================================================\n# API Endpoints\n# ============================================================================\n\n@app.get(\"/\", tags=[\"Health\"])\nasync def root():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"service\": \"Products API\",\n        \"version\": \"1.0.0\"\n    }\n\n@app.get(\n    \"/products\",\n    response_model=ProductListResponse,\n    tags=[\"Products\"],\n    summary=\"List all products with pagination\"\n)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: Optional[str] = Query(None, description=\"Search by product name\")\n):\n    \"\"\"\n    Retrieve a paginated list of products.\n    \n    - **page**: Page number (starts from 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term to filter by product name\n    \"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            # Calculate offset\n            offset = (page - 1) * page_size\n            \n            # Build query based on search parameter\n            if search:\n                count_query = \"\"\"\n                    SELECT COUNT(*) FROM products \n                    WHERE name ILIKE $1\n                \"\"\"\n                select_query = \"\"\"\n                    SELECT * FROM products \n                    WHERE name ILIKE $1\n                    ORDER BY created_at DESC\n                    LIMIT $2 OFFSET $3\n                \"\"\"\n                search_pattern = f\"%{search}%\"\n                \n                total = await connection.fetchval(count_query, search_pattern)\n                records = await connection.fetch(\n                    select_query, \n                    search_pattern, \n                    page_size, \n                    offset\n                )\n            else:\n                count_query = \"SELECT COUNT(*) FROM products\"\n                select_query = \"\"\"\n                    SELECT * FROM products \n                    ORDER BY created_at DESC\n                    LIMIT $1 OFFSET $2\n                \"\"\"\n                \n                total = await connection.fetchval(count_query)\n                records = await connection.fetch(select_query, page_size, offset)\n            \n            # Convert records to Product models\n            products = [record_to_product(record) for record in records]\n            \n            # Calculate total pages\n            total_pages = (total + page_size - 1) // page_size\n            \n            return ProductListResponse(\n                products=products,\n                total=total,\n                page=page,\n                page_size=page_size,\n                total_pages=total_pages\n            )\n            \n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n@app.get(\n    \"/products/{product_id}\",\n    response_model=Product,\n    tags=[\"Products\"],\n    summary=\"Get a single product by ID\"\n)\nasync def get_product(product_id: int):\n    \"\"\"\n    Retrieve a specific product by its ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            record = await connection.fetchrow(\n                \"SELECT * FROM products WHERE id = $1\",\n                product_id\n            )\n            \n            if not record:\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=f\"Product with id {product_id} not found\"\n                )\n            \n            return record_to_product(record)\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n@app.post(\n    \"/products\",\n    response_model=Product,\n    status_code=status.HTTP_201_CREATED,\n    tags=[\"Products\"],\n    summary=\"Create a new product\"\n)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional, max 1000 characters)\n    - **price**: Product price (required, must be greater than 0)\n    - **stock**: Stock quantity (required, must be non-negative)\n    \"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            # Check if product with same name already exists\n            existing = await connection.fetchval(\n                \"SELECT id FROM products WHERE name = $1\",\n                product.name\n            )\n            \n            if existing:\n                raise HTTPException(\n                    status_code=status.HTTP_409_CONFLICT,\n                    detail=f\"Product with name '{product.name}' already exists\"\n                )\n            \n            # Insert new product\n            record = await connection.fetchrow(\n                \"\"\"\n                INSERT INTO products (name, description, price, stock)\n                VALUES ($1, $2, $3, $4)\n                RETURNING *\n                \"\"\",\n                product.name,\n                product.description,\n                product.price,\n                product.stock\n            )\n            \n            return record_to_product(record)\n            \n    except HTTPException:\n        raise\n    except asyncpg.exceptions.CheckViolationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=f\"Validation error: {str(e)}\"\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n# ============================================================================\n# Additional Endpoints (Bonus)\n# ============================================================================\n\n@app.put(\n    \"/products/{product_id}\",\n    response_model=Product,\n    tags=[\"Products\"],\n    summary=\"Update an existing product\"\n)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"Update an existing product by ID\"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            # Check if product exists\n            exists = await connection.fetchval(\n                \"SELECT id FROM products WHERE id = $1\",\n                product_id\n            )\n            \n            if not exists:\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=f\"Product with id {product_id} not found\"\n                )\n            \n            # Update product\n            record = await connection.fetchrow(\n                \"\"\"\n                UPDATE products \n                SET name = $1, description = $2, price = $3, stock = $4\n                WHERE id = $5\n                RETURNING *\n                \"\"\",\n                product.name,\n                product.description,\n                product.price,\n                product.stock,\n                product_id\n            )\n            \n            return record_to_product(record)\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n@app.delete(\n    \"/products/{product_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    tags=[\"Products\"],\n    summary=\"Delete a product\"\n)\nasync def delete_product(product_id: int):\n    \"\"\"Delete a product by ID\"\"\"\n    try:\n        async with Database.pool.acquire() as connection:\n            result = await connection.execute(\n                \"DELETE FROM products WHERE id = $1\",\n                product_id\n            )\n            \n            # Check if any row was deleted\n            if result == \"DELETE 0\":\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=f\"Product with id {product_id} not found\"\n                )\n            \n            return None\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Database error: {str(e)}\"\n        )\n\n# ============================================================================\n# Run Application\n# ============================================================================\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=True,\n        log_level=\"info\"\n    )\n```\n\n## Requirements File (`requirements.txt`)\n\n```txt\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\nasyncpg==0.29.0\npydantic==2.5.0\npython-dotenv==1.0.0\n```\n\n## Environment Configuration (`.env`)\n\n```env\nDATABASE_URL=postgresql://user:password@localhost:5432/products_db\n```\n\n## Docker Compose for PostgreSQL (`docker-compose.yml`)\n\n```yaml\nversion: '3.8'\n\nservices:\n  postgres:\n    image: postgres:16-alpine\n    container_name: products_db\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: products_db\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U user -d products_db\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\nvolumes:\n  postgres_data:\n```\n\n## Usage Examples\n\n### Start the database:\n```bash\ndocker-compose up -d\n```\n\n### Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n### Run the application:\n```bash\npython main.py\n# Or with uvicorn directly:\nuvicorn main:app --reload\n```\n\n### Test the API:\n\n```bash\n# Create a product\ncurl -X POST \"http://localhost:8000/products\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# List products with pagination\ncurl \"http://localhost:8000/products?page=1&page_size=10\"\n\n# Search products\ncurl \"http://localhost:8000/products?search=Laptop\"\n\n# Get single product\ncurl \"http://localhost:8000/products/1\"\n\n# Update product\ncurl -X PUT \"http://localhost:8000/products/1\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-end gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete product\ncurl -X DELETE \"http://localhost:8000/products/1\"\n```\n\n## Key Features\n\n\u2705 **Connection Pooling** - Efficient database connection management  \n\u2705 **Async/Await** - Full async support with asyncpg  \n\u2705 **Pagination** - Efficient data retrieval with offset/limit  \n\u2705 **Search** - Filter products by name  \n\u2705 **Validation** - Pydantic models with custom validators  \n\u2705 **Error Handling** - Comprehensive error responses  \n\u2705 **Auto Documentation** - Swagger UI at `/docs`  \n\u2705 **Type Safety** - Full type hints throughout  \n\u2705 **CRUD Operations** - Complete REST API implementation\n\nVisit `http://localhost:8000/docs` for interactive API documentation!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 84,
            "output_tokens": 4001,
            "cached": true
          },
          "with_skill": {
            "output": "# FastAPI Products API with Neon Postgres\n\nHere's a complete FastAPI application with asyncpg connection pooling for a products REST API:\n\n## Installation\n\n```bash\npip install fastapi uvicorn asyncpg python-dotenv\n```\n\n## Project Structure\n\n```\nproject/\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 database.py\n\u251c\u2500\u2500 models.py\n\u2514\u2500\u2500 schemas.py\n```\n\n## 1. Environment Configuration (.env)\n\n```bash\n# Get your connection string from Neon Console\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n## 2. Database Connection Pool (database.py)\n\n```python\nimport asyncpg\nimport os\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Global connection pool\npool: asyncpg.Pool | None = None\n\n\nasync def create_pool() -> asyncpg.Pool:\n    \"\"\"Create and return a connection pool.\"\"\"\n    return await asyncpg.create_pool(\n        dsn=os.getenv(\"DATABASE_URL\"),\n        min_size=2,  # Minimum connections in pool\n        max_size=10,  # Maximum connections in pool\n        command_timeout=60,\n        max_queries=50000,  # Recycle connection after 50k queries\n        max_inactive_connection_lifetime=300,  # Close idle connections after 5 min\n    )\n\n\nasync def get_pool() -> asyncpg.Pool:\n    \"\"\"Get the global connection pool.\"\"\"\n    global pool\n    if pool is None:\n        pool = await create_pool()\n    return pool\n\n\nasync def close_pool():\n    \"\"\"Close the connection pool.\"\"\"\n    global pool\n    if pool is not None:\n        await pool.close()\n        pool = None\n\n\nasync def get_connection() -> AsyncGenerator[asyncpg.Connection, None]:\n    \"\"\"Dependency to get a database connection from the pool.\"\"\"\n    pool = await get_pool()\n    async with pool.acquire() as connection:\n        yield connection\n```\n\n## 3. Pydantic Models (schemas.py)\n\n```python\nfrom pydantic import BaseModel, Field, ConfigDict\nfrom typing import Optional\nfrom datetime import datetime\n\n\nclass ProductBase(BaseModel):\n    \"\"\"Base product schema with common fields.\"\"\"\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = Field(None, max_length=1000)\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\n\nclass ProductCreate(ProductBase):\n    \"\"\"Schema for creating a new product.\"\"\"\n    pass\n\n\nclass Product(ProductBase):\n    \"\"\"Schema for product responses (includes database fields).\"\"\"\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass ProductList(BaseModel):\n    \"\"\"Schema for paginated product list response.\"\"\"\n    products: list[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\n## 4. Database Models (models.py)\n\n```python\nfrom typing import Optional\nfrom datetime import datetime\n\n\nclass ProductModel:\n    \"\"\"Product database model with CRUD operations.\"\"\"\n\n    @staticmethod\n    async def create_table(conn) -> None:\n        \"\"\"Create the products table if it doesn't exist.\"\"\"\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n            );\n            \n            CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);\n            CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at DESC);\n        \"\"\")\n\n    @staticmethod\n    async def get_all(\n        conn,\n        page: int = 1,\n        page_size: int = 10,\n        search: Optional[str] = None\n    ) -> tuple[list[dict], int]:\n        \"\"\"\n        Get paginated list of products.\n        Returns (products, total_count).\n        \"\"\"\n        offset = (page - 1) * page_size\n        \n        # Build query with optional search\n        where_clause = \"\"\n        params = [page_size, offset]\n        \n        if search:\n            where_clause = \"WHERE name ILIKE $3 OR description ILIKE $3\"\n            params.append(f\"%{search}%\")\n        \n        # Get products\n        query = f\"\"\"\n            SELECT id, name, description, price, stock, created_at, updated_at\n            FROM products\n            {where_clause}\n            ORDER BY created_at DESC\n            LIMIT $1 OFFSET $2\n        \"\"\"\n        rows = await conn.fetch(query, *params)\n        \n        # Get total count\n        count_query = f\"SELECT COUNT(*) FROM products {where_clause}\"\n        count_params = [f\"%{search}%\"] if search else []\n        total = await conn.fetchval(count_query, *count_params)\n        \n        return [dict(row) for row in rows], total\n\n    @staticmethod\n    async def get_by_id(conn, product_id: int) -> Optional[dict]:\n        \"\"\"Get a single product by ID.\"\"\"\n        row = await conn.fetchrow(\n            \"\"\"\n            SELECT id, name, description, price, stock, created_at, updated_at\n            FROM products\n            WHERE id = $1\n            \"\"\",\n            product_id\n        )\n        return dict(row) if row else None\n\n    @staticmethod\n    async def create(conn, product_data: dict) -> dict:\n        \"\"\"Create a new product.\"\"\"\n        row = await conn.fetchrow(\n            \"\"\"\n            INSERT INTO products (name, description, price, stock)\n            VALUES ($1, $2, $3, $4)\n            RETURNING id, name, description, price, stock, created_at, updated_at\n            \"\"\",\n            product_data[\"name\"],\n            product_data.get(\"description\"),\n            product_data[\"price\"],\n            product_data[\"stock\"]\n        )\n        return dict(row)\n\n    @staticmethod\n    async def update(conn, product_id: int, product_data: dict) -> Optional[dict]:\n        \"\"\"Update an existing product.\"\"\"\n        row = await conn.fetchrow(\n            \"\"\"\n            UPDATE products\n            SET name = $2,\n                description = $3,\n                price = $4,\n                stock = $5,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = $1\n            RETURNING id, name, description, price, stock, created_at, updated_at\n            \"\"\",\n            product_id,\n            product_data[\"name\"],\n            product_data.get(\"description\"),\n            product_data[\"price\"],\n            product_data[\"stock\"]\n        )\n        return dict(row) if row else None\n\n    @staticmethod\n    async def delete(conn, product_id: int) -> bool:\n        \"\"\"Delete a product by ID.\"\"\"\n        result = await conn.execute(\n            \"DELETE FROM products WHERE id = $1\",\n            product_id\n        )\n        return result == \"DELETE 1\"\n```\n\n## 5. FastAPI Application (main.py)\n\n```python\nfrom fastapi import FastAPI, Depends, HTTPException, Query\nfrom fastapi.responses import JSONResponse\nfrom contextlib import asynccontextmanager\nimport asyncpg\nimport math\n\nfrom database import get_connection, get_pool, close_pool\nfrom schemas import Product, ProductCreate, ProductList\nfrom models import ProductModel\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage application lifecycle: startup and shutdown.\"\"\"\n    # Startup: Create connection pool and initialize database\n    pool = await get_pool()\n    async with pool.acquire() as conn:\n        await ProductModel.create_table(conn)\n    print(\"\u2713 Database connection pool created\")\n    print(\"\u2713 Products table initialized\")\n    \n    yield\n    \n    # Shutdown: Close connection pool\n    await close_pool()\n    print(\"\u2713 Database connection pool closed\")\n\n\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon Postgres\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"message\": \"Products API is running\",\n        \"database\": \"connected\"\n    }\n\n\n@app.get(\"/products\", response_model=ProductList)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    search: str = Query(None, description=\"Search in name and description\"),\n    conn: asyncpg.Connection = Depends(get_connection)\n):\n    \"\"\"\n    Get paginated list of products.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    - **search**: Optional search term for name/description\n    \"\"\"\n    try:\n        products, total = await ProductModel.get_all(conn, page, page_size, search)\n        total_pages = math.ceil(total / page_size)\n        \n        return ProductList(\n            products=products,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=total_pages\n        )\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n@app.get(\"/products/{product_id}\", response_model=Product)\nasync def get_product(\n    product_id: int,\n    conn: asyncpg.Connection = Depends(get_connection)\n):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    try:\n        product = await ProductModel.get_by_id(conn, product_id)\n        \n        if not product:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        return product\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n@app.post(\"/products\", response_model=Product, status_code=201)\nasync def create_product(\n    product: ProductCreate,\n    conn: asyncpg.Connection = Depends(get_connection)\n):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional, max 1000 characters)\n    - **price**: Product price (required, must be positive)\n    - **stock**: Stock quantity (required, must be non-negative)\n    \"\"\"\n    try:\n        new_product = await ProductModel.create(conn, product.model_dump())\n        return new_product\n    except asyncpg.UniqueViolationError:\n        raise HTTPException(status_code=409, detail=\"Product already exists\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n@app.put(\"/products/{product_id}\", response_model=Product)\nasync def update_product(\n    product_id: int,\n    product: ProductCreate,\n    conn: asyncpg.Connection = Depends(get_connection)\n):\n    \"\"\"\n    Update an existing product.\n    \n    - **product_id**: The ID of the product to update\n    - **name**: Updated product name\n    - **description**: Updated product description\n    - **price**: Updated product price\n    - **stock**: Updated stock quantity\n    \"\"\"\n    try:\n        updated_product = await ProductModel.update(\n            conn, product_id, product.model_dump()\n        )\n        \n        if not updated_product:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        return updated_product\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\n@app.delete(\"/products/{product_id}\", status_code=204)\nasync def delete_product(\n    product_id: int,\n    conn: asyncpg.Connection = Depends(get_connection)\n):\n    \"\"\"\n    Delete a product by ID.\n    \n    - **product_id**: The ID of the product to delete\n    \"\"\"\n    try:\n        deleted = await ProductModel.delete(conn, product_id)\n        \n        if not deleted:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        return None\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n## Running the Application\n\n```bash\n# Start the server\nuvicorn main:app --reload\n\n# Or run directly\npython main.py\n```\n\n## Testing the API\n\n```bash\n# Health check\ncurl http://localhost:8000/\n\n# Create a product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# List products (with pagination)\ncurl \"http://localhost:8000/products?page=1&page_size=10\"\n\n# Search products\ncurl \"http://localhost:8000/products?search=laptop\"\n\n# Get single product\ncurl http://localhost:8000/products/1\n\n# Update product\ncurl -X PUT http://localhost:8000/products/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-performance gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete product\ncurl -X DELETE http://localhost:8000/products/1\n```\n\n## Key Features\n\n\u2705 **Connection Pooling**: Efficient connection reuse with configurable pool size  \n\u2705 **Async/Await**: Fully asynchronous for high concurrency  \n\u2705 **Pagination**: Built-in pagination with configurable page size  \n\u2705 **Search**: Full-text search across name and description  \n\u2705 **Validation**: Pydantic models for request/response validation  \n\u2705 **Error Handling**: Proper HTTP status codes and error messages  \n\u2705 **Lifecycle Management**: Automatic pool creation/cleanup  \n\u2705 **Type Safety**: Full type hints throughout  \n\u2705 **Auto Documentation**: Interactive API docs at `/docs`\n\n## Interactive API Documentation\n\nFastAPI automatically generates interactive documentation:\n\n- **Swagger UI**: http://localhost:8000/docs\n- **ReDoc**: http://localhost:8000/redoc\n\n## Production Considerations\n\nFor production deployments:\n\n1. **Environment Variables**: Use proper secrets management\n2. **Connection Pool Tuning**: Adjust `min_size`/`max_size` based on load\n3. **Error Logging**: Add structured logging (e.g., `structlog`)\n4. **Rate Limiting**: Add rate limiting middleware\n5. **Authentication**: Implement JWT or OAuth2\n6. **CORS**: Configure CORS for frontend access\n7. **Monitoring**: Add health checks and metrics\n\nFor more details on Neon connection best practices, see the [Python guide](https://neon.com/docs/guides/python.md).",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 5516,
            "output_tokens": 3965,
            "cached": false
          },
          "skill_md_only": {
            "output": "# FastAPI + Neon PostgreSQL with asyncpg\n\nHere's a complete implementation of a FastAPI REST API for a products table using asyncpg with Neon:\n\n## Complete Implementation\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List\nfrom contextlib import asynccontextmanager\nimport asyncpg\nimport os\n\n# Pydantic models\nclass ProductBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=255)\n    description: Optional[str] = None\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass Product(ProductBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n\nclass ProductList(BaseModel):\n    products: List[Product]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n# Database connection pool\npool: Optional[asyncpg.Pool] = None\n\nasync def get_pool() -> asyncpg.Pool:\n    \"\"\"Get the database connection pool.\"\"\"\n    if pool is None:\n        raise RuntimeError(\"Database pool not initialized\")\n    return pool\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Manage database connection pool lifecycle.\"\"\"\n    global pool\n    \n    # Get connection string from environment\n    database_url = os.getenv(\"DATABASE_URL\")\n    if not database_url:\n        raise ValueError(\"DATABASE_URL environment variable not set\")\n    \n    # Create connection pool\n    pool = await asyncpg.create_pool(\n        database_url,\n        min_size=2,\n        max_size=10,\n        command_timeout=60,\n        # For Neon, you may want to adjust these timeouts\n        timeout=30,\n        max_inactive_connection_lifetime=300\n    )\n    \n    # Initialize database schema\n    async with pool.acquire() as conn:\n        await conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS products (\n                id SERIAL PRIMARY KEY,\n                name VARCHAR(255) NOT NULL,\n                description TEXT,\n                price DECIMAL(10, 2) NOT NULL CHECK (price > 0),\n                stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create index for better query performance\n        await conn.execute(\"\"\"\n            CREATE INDEX IF NOT EXISTS idx_products_name \n            ON products(name)\n        \"\"\")\n    \n    yield\n    \n    # Close pool on shutdown\n    await pool.close()\n\n# Initialize FastAPI app\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with Neon PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"ok\", \"message\": \"Products API is running\"}\n\n@app.get(\"/products\", response_model=ProductList)\nasync def list_products(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    page_size: int = Query(10, ge=1, le=100, description=\"Items per page\")\n):\n    \"\"\"\n    List all products with pagination.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    pool = await get_pool()\n    offset = (page - 1) * page_size\n    \n    async with pool.acquire() as conn:\n        # Get total count\n        total = await conn.fetchval(\"SELECT COUNT(*) FROM products\")\n        \n        # Get paginated products\n        rows = await conn.fetch(\"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            ORDER BY id\n            LIMIT $1 OFFSET $2\n        \"\"\", page_size, offset)\n        \n        products = [\n            Product(\n                id=row['id'],\n                name=row['name'],\n                description=row['description'],\n                price=float(row['price']),\n                stock=row['stock']\n            )\n            for row in rows\n        ]\n        \n        total_pages = (total + page_size - 1) // page_size\n        \n        return ProductList(\n            products=products,\n            total=total,\n            page=page,\n            page_size=page_size,\n            total_pages=total_pages\n        )\n\n@app.get(\"/products/{product_id}\", response_model=Product)\nasync def get_product(product_id: int):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    pool = await get_pool()\n    \n    async with pool.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            SELECT id, name, description, price, stock\n            FROM products\n            WHERE id = $1\n        \"\"\", product_id)\n        \n        if row is None:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=float(row['price']),\n            stock=row['stock']\n        )\n\n@app.post(\"/products\", response_model=Product, status_code=201)\nasync def create_product(product: ProductCreate):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required, 1-255 characters)\n    - **description**: Product description (optional)\n    - **price**: Product price (required, must be positive)\n    - **stock**: Stock quantity (required, must be non-negative)\n    \"\"\"\n    pool = await get_pool()\n    \n    async with pool.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            INSERT INTO products (name, description, price, stock)\n            VALUES ($1, $2, $3, $4)\n            RETURNING id, name, description, price, stock\n        \"\"\", product.name, product.description, product.price, product.stock)\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=float(row['price']),\n            stock=row['stock']\n        )\n\n@app.put(\"/products/{product_id}\", response_model=Product)\nasync def update_product(product_id: int, product: ProductCreate):\n    \"\"\"\n    Update an existing product.\n    \n    - **product_id**: The ID of the product to update\n    - **name**: Updated product name\n    - **description**: Updated product description\n    - **price**: Updated product price\n    - **stock**: Updated stock quantity\n    \"\"\"\n    pool = await get_pool()\n    \n    async with pool.acquire() as conn:\n        row = await conn.fetchrow(\"\"\"\n            UPDATE products\n            SET name = $2, description = $3, price = $4, stock = $5,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = $1\n            RETURNING id, name, description, price, stock\n        \"\"\", product_id, product.name, product.description, product.price, product.stock)\n        \n        if row is None:\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return Product(\n            id=row['id'],\n            name=row['name'],\n            description=row['description'],\n            price=float(row['price']),\n            stock=row['stock']\n        )\n\n@app.delete(\"/products/{product_id}\", status_code=204)\nasync def delete_product(product_id: int):\n    \"\"\"\n    Delete a product by ID.\n    \n    - **product_id**: The ID of the product to delete\n    \"\"\"\n    pool = await get_pool()\n    \n    async with pool.acquire() as conn:\n        result = await conn.execute(\"\"\"\n            DELETE FROM products WHERE id = $1\n        \"\"\", product_id)\n        \n        if result == \"DELETE 0\":\n            raise HTTPException(\n                status_code=404,\n                detail=f\"Product with id {product_id} not found\"\n            )\n        \n        return None\n```\n\n## Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nfastapi==0.109.0\nuvicorn[standard]==0.27.0\nasyncpg==0.29.0\npydantic==2.5.3\npython-dotenv==1.0.0\n```\n\n## Environment Setup\n\nCreate a `.env` file with your Neon connection string:\n\n```bash\n# Get your connection string from Neon Console\nDATABASE_URL=postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/neondb?sslmode=require\n```\n\n## Running the Application\n\n```bash\n# Install dependencies\npip install -r requirements.txt\n\n# Run the server\nuvicorn main:app --reload --host 0.0.0.0 --port 8000\n```\n\n## Testing the API\n\n```bash\n# Health check\ncurl http://localhost:8000/\n\n# Create a product\ncurl -X POST http://localhost:8000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"description\": \"High-performance laptop\",\n    \"price\": 999.99,\n    \"stock\": 50\n  }'\n\n# List products (with pagination)\ncurl http://localhost:8000/products?page=1&page_size=10\n\n# Get a specific product\ncurl http://localhost:8000/products/1\n\n# Update a product\ncurl -X PUT http://localhost:8000/products/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Gaming Laptop\",\n    \"description\": \"High-performance gaming laptop\",\n    \"price\": 1299.99,\n    \"stock\": 30\n  }'\n\n# Delete a product\ncurl -X DELETE http://localhost:8000/products/1\n```\n\n## Key Features\n\n### 1. **Connection Pooling**\n- Pool initialized in `lifespan` context manager\n- Min 2, max 10 connections\n- Automatic connection management\n- Proper cleanup on shutdown\n\n### 2. **Async/Await Patterns**\n- All database operations use `async`/`await`\n- Connection acquired from pool for each request\n- Non-blocking I/O for better performance\n\n### 3. **Pagination**\n- Query parameters for `page` and `page_size`\n- Returns total count and page metadata\n- Efficient LIMIT/OFFSET queries\n\n### 4. **Error Handling**\n- 404 for missing resources\n- Validation via Pydantic models\n- Proper HTTP status codes\n\n### 5. **Database Schema**\n- Auto-creates table on startup\n- Constraints for data integrity\n- Indexes for performance\n- Timestamps for audit trail\n\n## Neon-Specific Optimizations\n\nFor Neon, consider these adjustments:\n\n```python\n# Optimized pool settings for Neon\npool = await asyncpg.create_pool(\n    database_url,\n    min_size=1,  # Lower min for scale-to-zero\n    max_size=5,  # Adjust based on your plan\n    command_timeout=60,\n    timeout=30,\n    max_inactive_connection_lifetime=300,\n    # Enable statement cache\n    statement_cache_size=100\n)\n```\n\n## Production Considerations\n\n1. **Environment Variables**: Use proper secrets management\n2. **Logging**: Add structured logging for debugging\n3. **Monitoring**: Track connection pool metrics\n4. **Rate Limiting**: Add rate limiting middleware\n5. **CORS**: Configure CORS for frontend access\n6. **Authentication**: Add JWT or API key authentication\n7. **Database Migrations**: Use Alembic for schema changes\n\nThis implementation provides a solid foundation for a production-ready FastAPI application with Neon PostgreSQL!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2226,
            "output_tokens": 2994,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a complete FastAPI endpoint for products with asyncpg connection pooling. Let me set this up:\n\n```python\n# src/database.py\n\"\"\"Database connection and session management.\"\"\"\nimport os\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\n\nfrom sqlalchemy.ext.asyncio import (\n    AsyncSession,\n    async_sessionmaker,\n    create_async_engine,\n)\nfrom sqlalchemy.orm import declarative_base\n\n# Get database URL from environment\nDATABASE_URL = os.getenv(\n    \"DATABASE_URL\",\n    \"postgresql+asyncpg://user:password@localhost:5432/dbname\"\n)\n\n# Create async engine with connection pooling\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=True,  # Set to False in production\n    pool_size=10,\n    max_overflow=20,\n    pool_pre_ping=True,  # Verify connections before using\n    pool_recycle=3600,  # Recycle connections after 1 hour\n)\n\n# Create async session factory\nasync_session_maker = async_sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\nBase = declarative_base()\n\n\nasync def get_db() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Dependency for getting async database sessions.\"\"\"\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\n\n@asynccontextmanager\nasync def lifespan_context():\n    \"\"\"Context manager for application lifespan (startup/shutdown).\"\"\"\n    # Startup: Create tables if needed\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    \n    yield\n    \n    # Shutdown: Dispose of connection pool\n    await engine.dispose()\n```\n\n```python\n# src/models/product.py\n\"\"\"Product database model.\"\"\"\nfrom datetime import datetime\nfrom sqlalchemy import String, Numeric, DateTime, Text\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom src.database import Base\n\n\nclass Product(Base):\n    __tablename__ = \"products\"\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)\n    name: Mapped[str] = mapped_column(String(255), nullable=False, index=True)\n    description: Mapped[str | None] = mapped_column(Text, nullable=True)\n    price: Mapped[float] = mapped_column(Numeric(10, 2), nullable=False)\n    stock: Mapped[int] = mapped_column(default=0, nullable=False)\n    created_at: Mapped[datetime] = mapped_column(\n        DateTime, default=datetime.utcnow, nullable=False\n    )\n    updated_at: Mapped[datetime] = mapped_column(\n        DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False\n    )\n\n    def __repr__(self) -> str:\n        return f\"<Product(id={self.id}, name='{self.name}', price={self.price})>\"\n```\n\n```python\n# src/schemas/product.py\n\"\"\"Pydantic schemas for product API.\"\"\"\nfrom datetime import datetime\nfrom pydantic import BaseModel, Field, ConfigDict\n\n\nclass ProductBase(BaseModel):\n    \"\"\"Base product schema with common fields.\"\"\"\n    name: str = Field(..., min_length=1, max_length=255)\n    description: str | None = None\n    price: float = Field(..., gt=0, description=\"Price must be greater than 0\")\n    stock: int = Field(default=0, ge=0, description=\"Stock must be non-negative\")\n\n\nclass ProductCreate(ProductBase):\n    \"\"\"Schema for creating a new product.\"\"\"\n    pass\n\n\nclass ProductUpdate(BaseModel):\n    \"\"\"Schema for updating a product (all fields optional).\"\"\"\n    name: str | None = Field(None, min_length=1, max_length=255)\n    description: str | None = None\n    price: float | None = Field(None, gt=0)\n    stock: int | None = Field(None, ge=0)\n\n\nclass ProductResponse(ProductBase):\n    \"\"\"Schema for product responses.\"\"\"\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass ProductListResponse(BaseModel):\n    \"\"\"Schema for paginated product list.\"\"\"\n    items: list[ProductResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n```\n\n```python\n# src/services/product_service.py\n\"\"\"Business logic for product operations.\"\"\"\nimport logging\nfrom sqlalchemy import select, func\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom src.models.product import Product\nfrom src.schemas.product import ProductCreate, ProductUpdate\n\nlogger = logging.getLogger(__name__)\n\n\nclass ProductService:\n    \"\"\"Service for managing products.\"\"\"\n\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def get_products(\n        self, page: int = 1, page_size: int = 10\n    ) -> tuple[list[Product], int]:\n        \"\"\"\n        Get paginated list of products.\n        \n        Returns:\n            Tuple of (products list, total count)\n        \"\"\"\n        # Get total count\n        count_query = select(func.count()).select_from(Product)\n        total_result = await self.session.execute(count_query)\n        total = total_result.scalar_one()\n\n        # Get paginated products\n        offset = (page - 1) * page_size\n        query = (\n            select(Product)\n            .order_by(Product.created_at.desc())\n            .offset(offset)\n            .limit(page_size)\n        )\n        result = await self.session.execute(query)\n        products = list(result.scalars().all())\n\n        logger.info(\n            \"Retrieved %d products (page %d, page_size %d, total %d)\",\n            len(products), page, page_size, total\n        )\n        return products, total\n\n    async def get_product_by_id(self, product_id: int) -> Product | None:\n        \"\"\"Get a single product by ID.\"\"\"\n        result = await self.session.get(Product, product_id)\n        if result is None:\n            logger.warning(\"Product with id=%d not found\", product_id)\n        return result\n\n    async def create_product(self, product_data: ProductCreate) -> Product:\n        \"\"\"Create a new product.\"\"\"\n        product = Product(**product_data.model_dump())\n        self.session.add(product)\n        await self.session.flush()\n        await self.session.refresh(product)\n        \n        logger.info(\"Created product id=%d, name='%s'\", product.id, product.name)\n        return product\n\n    async def update_product(\n        self, product_id: int, product_data: ProductUpdate\n    ) -> Product | None:\n        \"\"\"Update an existing product.\"\"\"\n        product = await self.get_product_by_id(product_id)\n        if product is None:\n            return None\n\n        # Update only provided fields\n        update_data = product_data.model_dump(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(product, field, value)\n\n        await self.session.flush()\n        await self.session.refresh(product)\n        \n        logger.info(\"Updated product id=%d\", product_id)\n        return product\n\n    async def delete_product(self, product_id: int) -> bool:\n        \"\"\"Delete a product.\"\"\"\n        product = await self.get_product_by_id(product_id)\n        if product is None:\n            return False\n\n        await self.session.delete(product)\n        await self.session.flush()\n        \n        logger.info(\"Deleted product id=%d\", product_id)\n        return True\n```\n\n```python\n# src/routers/products.py\n\"\"\"Product API endpoints.\"\"\"\nimport logging\nfrom typing import Annotated\nfrom fastapi import APIRouter, Depends, HTTPException, Query, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.database import get_db\nfrom src.schemas.product import (\n    ProductCreate,\n    ProductResponse,\n    ProductListResponse,\n    ProductUpdate,\n)\nfrom src.services.product_service import ProductService\n\nlogger = logging.getLogger(__name__)\nrouter = APIRouter(prefix=\"/products\", tags=[\"products\"])\n\n\ndef get_product_service(\n    session: Annotated[AsyncSession, Depends(get_db)]\n) -> ProductService:\n    \"\"\"Dependency for getting product service.\"\"\"\n    return ProductService(session)\n\n\n@router.get(\"\", response_model=ProductListResponse)\nasync def list_products(\n    service: Annotated[ProductService, Depends(get_product_service)],\n    page: Annotated[int, Query(ge=1, description=\"Page number\")] = 1,\n    page_size: Annotated[int, Query(ge=1, le=100, description=\"Items per page\")] = 10,\n):\n    \"\"\"\n    Get paginated list of products.\n    \n    - **page**: Page number (starts at 1)\n    - **page_size**: Number of items per page (max 100)\n    \"\"\"\n    products, total = await service.get_products(page=page, page_size=page_size)\n    \n    total_pages = (total + page_size - 1) // page_size  # Ceiling division\n    \n    return ProductListResponse(\n        items=[ProductResponse.model_validate(p) for p in products],\n        total=total,\n        page=page,\n        page_size=page_size,\n        total_pages=total_pages,\n    )\n\n\n@router.get(\"/{product_id}\", response_model=ProductResponse)\nasync def get_product(\n    product_id: int,\n    service: Annotated[ProductService, Depends(get_product_service)],\n):\n    \"\"\"\n    Get a single product by ID.\n    \n    - **product_id**: The ID of the product to retrieve\n    \"\"\"\n    product = await service.get_product_by_id(product_id)\n    if product is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {product_id} not found\",\n        )\n    \n    return ProductResponse.model_validate(product)\n\n\n@router.post(\"\", response_model=ProductResponse, status_code=status.HTTP_201_CREATED)\nasync def create_product(\n    product_data: ProductCreate,\n    service: Annotated[ProductService, Depends(get_product_service)],\n):\n    \"\"\"\n    Create a new product.\n    \n    - **name**: Product name (required)\n    - **description**: Product description (optional)\n    - **price**: Product price (must be > 0)\n    - **stock**: Initial stock quantity (default: 0)\n    \"\"\"\n    product = await service.create_product(product_data)\n    return ProductResponse.model_validate(product)\n\n\n@router.put(\"/{product_id}\", response_model=ProductResponse)\nasync def update_product(\n    product_id: int,\n    product_data: ProductUpdate,\n    service: Annotated[ProductService, Depends(get_product_service)],\n):\n    \"\"\"\n    Update an existing product.\n    \n    All fields are optional - only provided fields will be updated.\n    \"\"\"\n    product = await service.update_product(product_id, product_data)\n    if product is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {product_id} not found\",\n        )\n    \n    return ProductResponse.model_validate(product)\n\n\n@router.delete(\"/{product_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_product(\n    product_id: int,\n    service: Annotated[ProductService, Depends(get_product_service)],\n):\n    \"\"\"\n    Delete a product.\n    \n    - **product_id**: The ID of the product to delete\n    \"\"\"\n    deleted = await service.delete_product(product_id)\n    if not deleted:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {product_id} not found\",\n        )\n```\n\n```python\n# src/main.py\n\"\"\"FastAPI application entrypoint.\"\"\"\nimport logging\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\nfrom src.database import lifespan_context\nfrom src.routers import products\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogger = logging.getLogger(__name__)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan manager.\"\"\"\n    logger.info(\"Starting application...\")\n    async with lifespan_context():\n        yield\n    logger.info(\"Shutting down application...\")\n\n\n# Create FastAPI app\napp = FastAPI(\n    title=\"Products API\",\n    description=\"REST API for managing products with PostgreSQL\",\n    version=\"1.0.0\",\n    lifespan=lifespan,\n)\n\n# Add CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # Configure appropriately for production\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Include routers\napp.include_router(products.router)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\"status\": \"ok\", \"message\": \"Products API is running\"}\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Detailed health check.\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"database\": \"connected\",\n    }\n```\n\n```toml\n# Add to pyproject.toml dependencies\n[tool.poetry.dependencies]\npython = \"^3.12\"\nfastapi = \"^0.109.0\"\nuvicorn = {extras = [\"standard\"], version = \"^0.27.0\"}\nsqlalchemy = {extras = [\"asyncio\"], version = \"^2.0.25\"}\nasyncpg = \"^0.29.0\"\npydantic = \"^2.5.0\"\npydantic-settings = \"^2.1.0\"\n```\n\n```bash\n# .env.example\nDATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/products_db\n```\n\nNow install dependencies and run:\n\n```bash\npoetry add fastapi uvicorn[standard] sqlalchemy[asyncio] asyncpg pydantic pydantic-settings\npoetry run uvicorn src.main:app --reload\n```\n\n**Key features implemented:**\n\n1. **Connection pooling** with asyncpg via SQLAlchemy's async engine\n2. **Proper async/await** patterns throughout\n3. **Pagination** with total count and page metadata\n4. **Full CRUD operations** (GET list, GET single, POST, PUT, DELETE)\n5. **Service layer** for business logic separation\n6. **Pydantic schemas** for validation and serialization\n7. **Dependency injection** for database sessions\n8. **Proper error handling** with HTTP status codes\n9. **Logging** for debugging and monitoring\n10. **Lifespan management** for startup/shutdown\n\nThe API will be available at `http://localhost:8000` with automatic docs at `/docs`.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6042,
            "output_tokens": 3885,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-03",
      "task_type": "similar_syntax",
      "target_language": "javascript",
      "expected_patterns": [
        "require.*pg|import.*pg|Pool",
        "new Pool\\(",
        "pool\\.query|client\\.query",
        "pool\\.connect",
        "max:|connectionTimeoutMillis|idleTimeoutMillis",
        "SIGTERM|process\\.on"
      ],
      "anti_patterns": [
        "@neondatabase/serverless",
        "neon\\(",
        "import.*neon",
        "drizzle\\(",
        "neonConfig",
        "import asyncpg|from asyncpg"
      ],
      "pattern_sources": [
        {
          "url": "https://neon.com/docs/guides/node.md",
          "description": "Node.js with Neon: node-postgres (pg) usage including const { Pool } = require('pg'), new Pool() with config, pool.connect(), client.query(), client.release(), proper connection handling with try-finally"
        },
        {
          "url": "https://node-postgres.com/apis/pool",
          "description": "node-postgres Pool API: max pool size, connectionTimeoutMillis, idleTimeoutMillis configuration options"
        },
        {
          "url": "https://nodejs.org/api/process.html#process_signal_events",
          "description": "Node.js process signal events - source of process.on('SIGTERM') pattern for graceful shutdown handling"
        },
        {
          "url": "https://neon.com/docs/serverless/serverless-driver.md",
          "description": "Anti-patterns: Neon serverless driver (@neondatabase/serverless, neon(), neonConfig) that should not appear when using standard pg library"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# PostgreSQL Connection Pooling Middleware for Express.js\n\nHere's a comprehensive implementation of a PostgreSQL connection pooling middleware with health checks and graceful shutdown:\n\n```javascript\n// db-pool-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool middleware\n * @param {Object} config - Pool configuration options\n * @returns {Object} - Middleware function and pool instance\n */\nfunction createDbPoolMiddleware(config = {}) {\n  // Default configuration\n  const poolConfig = {\n    host: config.host || process.env.DB_HOST || 'localhost',\n    port: config.port || process.env.DB_PORT || 5432,\n    database: config.database || process.env.DB_NAME || 'mydb',\n    user: config.user || process.env.DB_USER || 'postgres',\n    password: config.password || process.env.DB_PASSWORD || '',\n    \n    // Pool configuration\n    max: config.max || 20, // Maximum number of clients in the pool\n    min: config.min || 4, // Minimum number of clients in the pool\n    idleTimeoutMillis: config.idleTimeoutMillis || 30000, // 30 seconds\n    connectionTimeoutMillis: config.connectionTimeoutMillis || 10000, // 10 seconds\n    \n    // Additional options\n    allowExitOnIdle: config.allowExitOnIdle || false,\n    statement_timeout: config.statementTimeout || 30000, // Query timeout\n  };\n\n  // Create the pool instance\n  const pool = new Pool(poolConfig);\n\n  // Pool event handlers\n  pool.on('connect', (client) => {\n    console.log('New client connected to the database pool');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n    // Don't exit the process, let the pool handle it\n  });\n\n  /**\n   * Middleware function to attach pool to request object\n   */\n  const middleware = (req, res, next) => {\n    req.db = pool;\n    \n    // Add helper method for executing queries\n    req.dbQuery = async (text, params) => {\n      const start = Date.now();\n      try {\n        const result = await pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: result.rowCount });\n        return result;\n      } catch (error) {\n        console.error('Database query error', { text, error: error.message });\n        throw error;\n      }\n    };\n\n    // Add helper method for transactions\n    req.dbTransaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    };\n\n    next();\n  };\n\n  /**\n   * Health check endpoint handler\n   */\n  const healthCheck = async (req, res) => {\n    const healthStatus = {\n      status: 'unknown',\n      timestamp: new Date().toISOString(),\n      pool: {\n        total: pool.totalCount,\n        idle: pool.idleCount,\n        waiting: pool.waitingCount,\n      },\n      database: {\n        connected: false,\n        responseTime: null,\n      },\n    };\n\n    try {\n      const start = Date.now();\n      \n      // Test database connection with a simple query\n      const result = await pool.query('SELECT NOW() as current_time, version() as version');\n      \n      const responseTime = Date.now() - start;\n      \n      healthStatus.status = 'healthy';\n      healthStatus.database.connected = true;\n      healthStatus.database.responseTime = `${responseTime}ms`;\n      healthStatus.database.serverTime = result.rows[0].current_time;\n      healthStatus.database.version = result.rows[0].version.split(',')[0]; // Shortened version\n\n      res.status(200).json(healthStatus);\n    } catch (error) {\n      healthStatus.status = 'unhealthy';\n      healthStatus.error = error.message;\n      \n      console.error('Database health check failed:', error);\n      res.status(503).json(healthStatus);\n    }\n  };\n\n  /**\n   * Graceful shutdown handler\n   */\n  const gracefulShutdown = async (signal) => {\n    console.log(`\\n${signal} received. Starting graceful shutdown...`);\n    \n    try {\n      // Stop accepting new connections\n      console.log('Closing database pool...');\n      \n      // Wait for active queries to complete (with timeout)\n      const shutdownTimeout = setTimeout(() => {\n        console.warn('Shutdown timeout reached, forcing pool closure');\n      }, 10000); // 10 second timeout\n\n      await pool.end();\n      \n      clearTimeout(shutdownTimeout);\n      console.log('Database pool closed successfully');\n      \n      process.exit(0);\n    } catch (error) {\n      console.error('Error during graceful shutdown:', error);\n      process.exit(1);\n    }\n  };\n\n  // Register shutdown handlers\n  process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n  process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n  // Handle uncaught exceptions\n  process.on('uncaughtException', (error) => {\n    console.error('Uncaught Exception:', error);\n    gracefulShutdown('uncaughtException');\n  });\n\n  return {\n    middleware,\n    healthCheck,\n    pool,\n    gracefulShutdown,\n  };\n}\n\nmodule.exports = createDbPoolMiddleware;\n```\n\n## Usage Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst createDbPoolMiddleware = require('./db-pool-middleware');\n\nconst app = express();\n\n// Create database pool middleware with custom configuration\nconst dbPool = createDbPoolMiddleware({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'dbuser',\n  password: 'dbpassword',\n  max: 25, // Maximum pool size\n  min: 5, // Minimum pool size\n  idleTimeoutMillis: 30000, // 30 seconds\n  connectionTimeoutMillis: 10000, // 10 seconds\n  statementTimeout: 30000, // 30 seconds query timeout\n});\n\n// Apply middleware globally\napp.use(dbPool.middleware);\n\n// Register health check endpoint\napp.get('/db/health', dbPool.healthCheck);\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.dbQuery('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Database error' });\n  }\n});\n\n// Example route using transactions\napp.post('/transfer', async (req, res) => {\n  try {\n    const { fromAccount, toAccount, amount } = req.body;\n    \n    const result = await req.dbTransaction(async (client) => {\n      // Deduct from source account\n      await client.query(\n        'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n        [amount, fromAccount]\n      );\n      \n      // Add to destination account\n      await client.query(\n        'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n        [amount, toAccount]\n      );\n      \n      return { success: true };\n    });\n    \n    res.json(result);\n  } catch (error) {\n    console.error('Transfer error:', error);\n    res.status(500).json({ error: 'Transaction failed' });\n  }\n});\n\n// Example route with direct pool access\napp.get('/stats', async (req, res) => {\n  const client = await req.db.connect();\n  \n  try {\n    const result = await client.query(`\n      SELECT \n        COUNT(*) as total_users,\n        COUNT(CASE WHEN created_at > NOW() - INTERVAL '24 hours' THEN 1 END) as new_users_today\n      FROM users\n    `);\n    \n    res.json(result.rows[0]);\n  } catch (error) {\n    console.error('Stats error:', error);\n    res.status(500).json({ error: 'Failed to fetch stats' });\n  } finally {\n    client.release(); // Always release the client back to the pool\n  }\n});\n\nconst PORT = process.env.PORT || 3000;\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n\n// Graceful shutdown for the HTTP server\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing HTTP server...');\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n});\n```\n\n## Advanced Usage with Environment Variables\n\n```javascript\n// config/database.js\nrequire('dotenv').config();\n\nmodule.exports = {\n  host: process.env.DB_HOST || 'localhost',\n  port: parseInt(process.env.DB_PORT || '5432'),\n  database: process.env.DB_NAME || 'myapp',\n  user: process.env.DB_USER || 'postgres',\n  password: process.env.DB_PASSWORD || '',\n  \n  // Pool settings\n  max: parseInt(process.env.DB_POOL_MAX || '20'),\n  min: parseInt(process.env.DB_POOL_MIN || '4'),\n  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000'),\n  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || '10000'),\n  statementTimeout: parseInt(process.env.DB_STATEMENT_TIMEOUT || '30000'),\n};\n\n// app.js\nconst express = require('express');\nconst createDbPoolMiddleware = require('./db-pool-middleware');\nconst dbConfig = require('./config/database');\n\nconst app = express();\nconst dbPool = createDbPoolMiddleware(dbConfig);\n\napp.use(dbPool.middleware);\napp.get('/db/health', dbPool.healthCheck);\n\n// ... rest of your routes\n```\n\n## .env Example\n\n```env\n# Database Configuration\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=dbuser\nDB_PASSWORD=secretpassword\n\n# Pool Configuration\nDB_POOL_MAX=25\nDB_POOL_MIN=5\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_STATEMENT_TIMEOUT=30000\n```\n\n## Testing the Health Check\n\n```bash\n# Check database health\ncurl http://localhost:3000/db/health\n\n# Expected response:\n{\n  \"status\": \"healthy\",\n  \"timestamp\": \"2024-01-15T10:30:00.000Z\",\n  \"pool\": {\n    \"total\": 5,\n    \"idle\": 4,\n    \"waiting\": 0\n  },\n  \"database\": {\n    \"connected\": true,\n    \"responseTime\": \"15ms\",\n    \"serverTime\": \"2024-01-15T10:30:00.000Z\",\n    \"version\": \"PostgreSQL 14.5\"\n  }\n}\n```\n\n## Key Features\n\n1. **Connection Pooling**: Efficient reuse of database connections\n2. **Health Checks**: Monitor database connectivity and pool status\n3. **Graceful Shutdown**: Properly closes connections on SIGTERM/SIGINT\n4. **Helper Methods**: Convenient `dbQuery` and `dbTransaction` methods\n5. **Error Handling**: Comprehensive error logging and handling\n6. **Configurable**: Flexible configuration for different environments\n7. **Transaction Support**: Built-in transaction helper with automatic rollback\n8. **Pool Monitoring**: Real-time pool statistics in health check\n\nThis implementation provides a production-ready database connection pooling solution for Express.js applications!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 92,
            "output_tokens": 3111,
            "cached": true
          },
          "with_skill": {
            "output": "# Express.js PostgreSQL Connection Pooling Middleware\n\nHere's a complete implementation with connection pooling, health checks, and graceful shutdown:\n\n```javascript\n// db/pool.js\nimport { Pool } from 'pg';\n\n/**\n * Create and configure PostgreSQL connection pool\n * @returns {Pool} Configured pg Pool instance\n */\nexport function createPool() {\n  const pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    \n    // Pool configuration\n    max: parseInt(process.env.DB_POOL_MAX || '20', 10), // Maximum pool size\n    idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000', 10), // 30 seconds\n    connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || '10000', 10), // 10 seconds\n    \n    // Additional recommended settings\n    allowExitOnIdle: false, // Keep pool alive even when idle\n    statement_timeout: parseInt(process.env.DB_STATEMENT_TIMEOUT || '30000', 10), // Query timeout\n  });\n\n  // Error handling for idle clients\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n    // Don't exit the process - let the pool handle reconnection\n  });\n\n  // Connection event logging (optional, useful for debugging)\n  pool.on('connect', (client) => {\n    console.log('New client connected to database');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  return pool;\n}\n\n/**\n * Gracefully shutdown the pool\n * @param {Pool} pool - The pool instance to shutdown\n */\nexport async function shutdownPool(pool) {\n  console.log('Shutting down database pool...');\n  \n  try {\n    // Wait for all clients to finish their work\n    await pool.end();\n    console.log('Database pool shut down successfully');\n  } catch (err) {\n    console.error('Error during pool shutdown:', err);\n    throw err;\n  }\n}\n\n/**\n * Test database connection\n * @param {Pool} pool - The pool instance to test\n * @returns {Promise<Object>} Connection status and metrics\n */\nexport async function testConnection(pool) {\n  const start = Date.now();\n  \n  try {\n    const client = await pool.connect();\n    \n    try {\n      // Simple query to test connection\n      const result = await client.query('SELECT NOW() as current_time, version() as pg_version');\n      const duration = Date.now() - start;\n      \n      return {\n        status: 'healthy',\n        responseTime: duration,\n        timestamp: result.rows[0].current_time,\n        postgresVersion: result.rows[0].pg_version,\n        poolStats: {\n          total: pool.totalCount,\n          idle: pool.idleCount,\n          waiting: pool.waitingCount,\n        },\n      };\n    } finally {\n      client.release();\n    }\n  } catch (err) {\n    const duration = Date.now() - start;\n    \n    return {\n      status: 'unhealthy',\n      responseTime: duration,\n      error: err.message,\n      poolStats: {\n        total: pool.totalCount,\n        idle: pool.idleCount,\n        waiting: pool.waitingCount,\n      },\n    };\n  }\n}\n```\n\n```javascript\n// middleware/database.js\nimport { createPool, shutdownPool, testConnection } from '../db/pool.js';\n\n// Create a single shared pool instance\nlet pool = null;\n\n/**\n * Initialize the database pool\n * Should be called once during app startup\n */\nexport function initializePool() {\n  if (pool) {\n    console.warn('Pool already initialized');\n    return pool;\n  }\n  \n  pool = createPool();\n  console.log('Database pool initialized');\n  return pool;\n}\n\n/**\n * Get the current pool instance\n * @returns {Pool} The shared pool instance\n */\nexport function getPool() {\n  if (!pool) {\n    throw new Error('Pool not initialized. Call initializePool() first.');\n  }\n  return pool;\n}\n\n/**\n * Express middleware to attach database pool to request\n * @param {Request} req - Express request object\n * @param {Response} res - Express response object\n * @param {Function} next - Express next function\n */\nexport function databaseMiddleware(req, res, next) {\n  if (!pool) {\n    return res.status(503).json({\n      error: 'Database pool not initialized',\n    });\n  }\n  \n  // Attach pool to request object\n  req.db = pool;\n  \n  // Helper method for executing queries\n  req.query = async (text, params) => {\n    const start = Date.now();\n    try {\n      const result = await pool.query(text, params);\n      const duration = Date.now() - start;\n      \n      // Log slow queries (optional)\n      if (duration > 1000) {\n        console.warn(`Slow query detected (${duration}ms):`, text);\n      }\n      \n      return result;\n    } catch (err) {\n      console.error('Query error:', err.message);\n      throw err;\n    }\n  };\n  \n  // Helper method for transactions\n  req.transaction = async (callback) => {\n    const client = await pool.connect();\n    \n    try {\n      await client.query('BEGIN');\n      const result = await callback(client);\n      await client.query('COMMIT');\n      return result;\n    } catch (err) {\n      await client.query('ROLLBACK');\n      throw err;\n    } finally {\n      client.release();\n    }\n  };\n  \n  next();\n}\n\n/**\n * Health check endpoint handler\n * @param {Request} req - Express request object\n * @param {Response} res - Express response object\n */\nexport async function healthCheckHandler(req, res) {\n  try {\n    const health = await testConnection(pool);\n    \n    const statusCode = health.status === 'healthy' ? 200 : 503;\n    \n    res.status(statusCode).json({\n      service: 'database',\n      ...health,\n    });\n  } catch (err) {\n    res.status(503).json({\n      service: 'database',\n      status: 'unhealthy',\n      error: err.message,\n    });\n  }\n}\n\n/**\n * Setup graceful shutdown handlers\n * @param {Pool} poolInstance - The pool to shutdown\n */\nexport function setupGracefulShutdown(poolInstance = pool) {\n  const signals = ['SIGTERM', 'SIGINT'];\n  \n  signals.forEach((signal) => {\n    process.on(signal, async () => {\n      console.log(`\\nReceived ${signal}, starting graceful shutdown...`);\n      \n      try {\n        await shutdownPool(poolInstance);\n        console.log('Graceful shutdown completed');\n        process.exit(0);\n      } catch (err) {\n        console.error('Error during graceful shutdown:', err);\n        process.exit(1);\n      }\n    });\n  });\n  \n  // Handle uncaught exceptions\n  process.on('uncaughtException', async (err) => {\n    console.error('Uncaught exception:', err);\n    try {\n      await shutdownPool(poolInstance);\n    } catch (shutdownErr) {\n      console.error('Error during emergency shutdown:', shutdownErr);\n    }\n    process.exit(1);\n  });\n}\n```\n\n```javascript\n// app.js\nimport express from 'express';\nimport {\n  initializePool,\n  databaseMiddleware,\n  healthCheckHandler,\n  setupGracefulShutdown,\n} from './middleware/database.js';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(express.json());\n\n// Initialize database pool\nconst pool = initializePool();\n\n// Setup graceful shutdown\nsetupGracefulShutdown(pool);\n\n// Health check endpoint (before database middleware to avoid dependency)\napp.get('/db/health', healthCheckHandler);\n\n// Apply database middleware to all routes\napp.use(databaseMiddleware);\n\n// Example routes using the database\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT id, name, email FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (err) {\n    console.error('Error fetching users:', err);\n    res.status(500).json({ error: 'Failed to fetch users' });\n  }\n});\n\napp.get('/users/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const result = await req.query(\n      'SELECT id, name, email, created_at FROM users WHERE id = $1',\n      [id]\n    );\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(result.rows[0]);\n  } catch (err) {\n    console.error('Error fetching user:', err);\n    res.status(500).json({ error: 'Failed to fetch user' });\n  }\n});\n\napp.post('/users', async (req, res) => {\n  try {\n    const { name, email } = req.body;\n    \n    // Using transaction helper\n    const user = await req.transaction(async (client) => {\n      // Insert user\n      const userResult = await client.query(\n        'INSERT INTO users(name, email) VALUES($1, $2) RETURNING *',\n        [name, email]\n      );\n      \n      // Create profile in same transaction\n      await client.query(\n        'INSERT INTO profiles(user_id, bio) VALUES($1, $2)',\n        [userResult.rows[0].id, 'New user']\n      );\n      \n      return userResult.rows[0];\n    });\n    \n    res.status(201).json(user);\n  } catch (err) {\n    console.error('Error creating user:', err);\n    res.status(500).json({ error: 'Failed to create user' });\n  }\n});\n\n// Error handling middleware\napp.use((err, req, res, next) => {\n  console.error('Unhandled error:', err);\n  res.status(500).json({\n    error: 'Internal server error',\n    message: process.env.NODE_ENV === 'development' ? err.message : undefined,\n  });\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n\n// Graceful shutdown for HTTP server\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing HTTP server...');\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n});\n```\n\n```bash\n# .env.example\nDATABASE_URL=postgresql://user:password@localhost:5432/mydb\n\n# Pool configuration\nDB_POOL_MAX=20\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_STATEMENT_TIMEOUT=30000\n\n# Server configuration\nPORT=3000\nNODE_ENV=development\n```\n\n```json\n// package.json\n{\n  \"name\": \"express-pg-pooling\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.3\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.1\"\n  }\n}\n```\n\n## Key Features\n\n### 1. **Shared Pool Instance**\n- Single pool created at startup\n- Attached to `req.db` for all routes\n- Prevents connection exhaustion\n\n### 2. **Configuration Options**\n- `max`: Maximum pool size (default: 20)\n- `idleTimeoutMillis`: Close idle connections after 30s\n- `connectionTimeoutMillis`: Timeout for acquiring connections (10s)\n- `statement_timeout`: Query execution timeout (30s)\n\n### 3. **Health Check Endpoint**\n- Tests actual database connectivity\n- Returns pool statistics\n- Includes response time metrics\n\n### 4. **Graceful Shutdown**\n- Handles SIGTERM/SIGINT signals\n- Waits for active queries to complete\n- Closes all connections cleanly\n\n### 5. **Helper Methods**\n- `req.query()`: Simple query execution with logging\n- `req.transaction()`: Automatic transaction management\n\n### 6. **Error Handling**\n- Pool-level error listeners\n- Query error logging\n- Slow query detection\n\n## Usage Example\n\n```bash\n# Install dependencies\nnpm install\n\n# Set environment variables\ncp .env.example .env\n\n# Start server\nnpm start\n\n# Test health check\ncurl http://localhost:3000/db/health\n\n# Test endpoints\ncurl http://localhost:3000/users\ncurl http://localhost:3000/users/1\n```\n\nThis implementation follows Neon's best practices for connection pooling in long-running servers and provides a production-ready foundation for Express.js applications.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10304,
            "output_tokens": 3374,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Express.js PostgreSQL Connection Pooling Middleware\n\nHere's a complete implementation of an Express.js middleware with PostgreSQL connection pooling using `pg`:\n\n```javascript\n// db-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured pg Pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection settings\n    connectionString: process.env.DATABASE_URL,\n    \n    // Pool size configuration\n    max: config.max || parseInt(process.env.DB_POOL_MAX) || 20,\n    min: config.min || parseInt(process.env.DB_POOL_MIN) || 2,\n    \n    // Timeout configuration\n    idleTimeoutMillis: config.idleTimeoutMillis || \n                       parseInt(process.env.DB_IDLE_TIMEOUT) || 30000,\n    connectionTimeoutMillis: config.connectionTimeoutMillis || \n                            parseInt(process.env.DB_CONNECTION_TIMEOUT) || 10000,\n    \n    // Query timeout\n    query_timeout: config.queryTimeout || \n                   parseInt(process.env.DB_QUERY_TIMEOUT) || 30000,\n    \n    // Statement timeout (PostgreSQL-level)\n    statement_timeout: config.statementTimeout || \n                       parseInt(process.env.DB_STATEMENT_TIMEOUT) || 30000,\n    \n    // SSL configuration (important for Neon and other cloud providers)\n    ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false,\n    \n    // Application name for connection tracking\n    application_name: config.applicationName || \n                      process.env.APP_NAME || \n                      'express-app',\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Pool error handler - catches errors on idle clients\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n  });\n\n  // Pool connect event - useful for monitoring\n  pool.on('connect', (client) => {\n    console.log('New client connected to the pool');\n  });\n\n  // Pool acquire event - useful for monitoring\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  // Pool remove event - useful for monitoring\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  return pool;\n}\n\n/**\n * Express middleware that attaches the database pool to the request object\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express middleware function\n */\nfunction dbMiddleware(pool) {\n  return (req, res, next) => {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Add helper method for executing queries\n    req.query = async (text, params) => {\n      const start = Date.now();\n      try {\n        const result = await pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: result.rowCount });\n        return result;\n      } catch (error) {\n        console.error('Query error', { text, error: error.message });\n        throw error;\n      }\n    };\n    \n    // Add helper method for transactions\n    req.transaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    };\n    \n    next();\n  };\n}\n\n/**\n * Creates a health check endpoint handler\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express route handler\n */\nfunction createHealthCheckHandler(pool) {\n  return async (req, res) => {\n    const healthCheck = {\n      status: 'unknown',\n      timestamp: new Date().toISOString(),\n      database: {\n        connected: false,\n        latency: null,\n        pool: {\n          total: pool.totalCount,\n          idle: pool.idleCount,\n          waiting: pool.waitingCount,\n        },\n      },\n    };\n\n    try {\n      const start = Date.now();\n      \n      // Test connection with a simple query\n      const result = await pool.query('SELECT NOW() as current_time, version() as version');\n      \n      const latency = Date.now() - start;\n      \n      healthCheck.status = 'healthy';\n      healthCheck.database.connected = true;\n      healthCheck.database.latency = `${latency}ms`;\n      healthCheck.database.serverTime = result.rows[0].current_time;\n      healthCheck.database.version = result.rows[0].version;\n      \n      res.status(200).json(healthCheck);\n    } catch (error) {\n      healthCheck.status = 'unhealthy';\n      healthCheck.database.error = error.message;\n      \n      console.error('Health check failed:', error);\n      res.status(503).json(healthCheck);\n    }\n  };\n}\n\n/**\n * Sets up graceful shutdown handlers for the pool\n * @param {Pool} pool - PostgreSQL connection pool\n * @param {Object} server - HTTP server instance (optional)\n */\nfunction setupGracefulShutdown(pool, server = null) {\n  const shutdown = async (signal) => {\n    console.log(`\\n${signal} received. Starting graceful shutdown...`);\n    \n    try {\n      // Stop accepting new connections if server is provided\n      if (server) {\n        server.close(() => {\n          console.log('HTTP server closed');\n        });\n      }\n      \n      // Close the database pool\n      await pool.end();\n      console.log('Database pool closed');\n      \n      process.exit(0);\n    } catch (error) {\n      console.error('Error during shutdown:', error);\n      process.exit(1);\n    }\n  };\n\n  // Handle different shutdown signals\n  process.on('SIGTERM', () => shutdown('SIGTERM'));\n  process.on('SIGINT', () => shutdown('SIGINT'));\n  \n  // Handle uncaught errors\n  process.on('uncaughtException', (error) => {\n    console.error('Uncaught Exception:', error);\n    shutdown('UNCAUGHT_EXCEPTION');\n  });\n  \n  process.on('unhandledRejection', (reason, promise) => {\n    console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n    shutdown('UNHANDLED_REJECTION');\n  });\n}\n\nmodule.exports = {\n  createPool,\n  dbMiddleware,\n  createHealthCheckHandler,\n  setupGracefulShutdown,\n};\n```\n\n## Usage Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst {\n  createPool,\n  dbMiddleware,\n  createHealthCheckHandler,\n  setupGracefulShutdown,\n} = require('./db-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Create the database pool\nconst pool = createPool({\n  max: 20,                      // Maximum pool size\n  min: 2,                       // Minimum pool size\n  idleTimeoutMillis: 30000,     // 30 seconds\n  connectionTimeoutMillis: 10000, // 10 seconds\n  queryTimeout: 30000,          // 30 seconds\n  applicationName: 'my-express-app',\n});\n\n// Apply database middleware to all routes\napp.use(dbMiddleware(pool));\n\n// Health check endpoint\napp.get('/db/health', createHealthCheckHandler(pool));\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Failed to fetch users' });\n  }\n});\n\n// Example route using transactions\napp.post('/transfer', async (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  \n  try {\n    const result = await req.transaction(async (client) => {\n      // Debit from account\n      await client.query(\n        'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n        [amount, fromAccount]\n      );\n      \n      // Credit to account\n      await client.query(\n        'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n        [amount, toAccount]\n      );\n      \n      return { success: true };\n    });\n    \n    res.json(result);\n  } catch (error) {\n    console.error('Transfer failed:', error);\n    res.status(500).json({ error: 'Transfer failed' });\n  }\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n\n// Setup graceful shutdown\nsetupGracefulShutdown(pool, server);\n```\n\n## Environment Variables\n\nCreate a `.env` file:\n\n```bash\n# Database connection\nDATABASE_URL=postgresql://user:password@localhost:5432/mydb\n\n# Pool configuration\nDB_POOL_MAX=20\nDB_POOL_MIN=2\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_QUERY_TIMEOUT=30000\nDB_STATEMENT_TIMEOUT=30000\n\n# SSL (set to 'true' for cloud providers like Neon)\nDB_SSL=true\n\n# Application name\nAPP_NAME=my-express-app\n\n# Server\nPORT=3000\n```\n\n## Using with Neon\n\nFor Neon Serverless Postgres, update your configuration:\n\n```javascript\n// neon-config.js\nconst { createPool } = require('./db-middleware');\n\n// Neon connection string format\nconst pool = createPool({\n  connectionString: process.env.DATABASE_URL, // From Neon console\n  max: 10,  // Lower for serverless environments\n  min: 0,   // Allow scaling to zero\n  idleTimeoutMillis: 10000, // Shorter timeout for serverless\n  ssl: { rejectUnauthorized: false }, // Required for Neon\n});\n\nmodule.exports = pool;\n```\n\n## Advanced Features\n\n### Connection Pooling with Read Replicas\n\n```javascript\n// read-replica-pool.js\nconst { Pool } = require('pg');\n\nfunction createReadReplicaPool() {\n  const writePool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    max: 10,\n  });\n\n  const readPool = new Pool({\n    connectionString: process.env.DATABASE_READ_REPLICA_URL,\n    max: 20, // More connections for read operations\n  });\n\n  return {\n    write: writePool,\n    read: readPool,\n    \n    async query(text, params, { preferRead = false } = {}) {\n      const pool = preferRead ? readPool : writePool;\n      return pool.query(text, params);\n    },\n    \n    async end() {\n      await Promise.all([writePool.end(), readPool.end()]);\n    },\n  };\n}\n```\n\n### Monitoring Middleware\n\n```javascript\n// monitoring-middleware.js\nfunction createMonitoringMiddleware(pool) {\n  return (req, res, next) => {\n    const originalQuery = req.query;\n    \n    req.query = async (text, params) => {\n      const start = Date.now();\n      const queryId = Math.random().toString(36).substring(7);\n      \n      console.log(`[${queryId}] Query started:`, text);\n      \n      try {\n        const result = await originalQuery(text, params);\n        const duration = Date.now() - start;\n        \n        console.log(`[${queryId}] Query completed:`, {\n          duration: `${duration}ms`,\n          rows: result.rowCount,\n          poolStats: {\n            total: pool.totalCount,\n            idle: pool.idleCount,\n            waiting: pool.waitingCount,\n          },\n        });\n        \n        return result;\n      } catch (error) {\n        const duration = Date.now() - start;\n        console.error(`[${queryId}] Query failed:`, {\n          duration: `${duration}ms`,\n          error: error.message,\n        });\n        throw error;\n      }\n    };\n    \n    next();\n  };\n}\n```\n\n## Key Features\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Helpers**: `req.query()` and `req.transaction()` for easy database access\n3. **Health Check**: `/db/health` endpoint with connection testing and pool stats\n4. **Graceful Shutdown**: Handles SIGTERM, SIGINT, and uncaught errors\n5. **Comprehensive Configuration**: Pool size, timeouts, SSL, and monitoring\n6. **Error Handling**: Pool-level and query-level error handling\n7. **Transaction Support**: Built-in transaction helper with automatic rollback\n8. **Monitoring**: Query logging with duration and pool statistics\n\nThis implementation is production-ready and works seamlessly with Neon Serverless Postgres!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2234,
            "output_tokens": 3366,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive PostgreSQL connection pooling middleware for your Express.js application.\n\n```javascript\n// src/middleware/db.js\nimport pg from \"pg\";\nconst { Pool } = pg;\n\n// Create a shared pool instance\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  max: parseInt(process.env.DB_POOL_MAX || \"20\", 10), // Maximum pool size\n  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || \"30000\", 10), // 30 seconds\n  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || \"10000\", 10), // 10 seconds\n  allowExitOnIdle: false, // Keep pool alive even when idle\n});\n\n// Pool error handler - log unexpected errors on idle clients\npool.on(\"error\", (err, client) => {\n  console.error(\"Unexpected error on idle client\", err);\n});\n\n// Pool connection event - useful for debugging\npool.on(\"connect\", (client) => {\n  console.log(\"New client connected to database\");\n});\n\n// Pool removal event - useful for debugging\npool.on(\"remove\", (client) => {\n  console.log(\"Client removed from pool\");\n});\n\n/**\n * Middleware to attach database pool to request object\n */\nexport function attachDbPool(req, res, next) {\n  req.db = pool;\n  next();\n}\n\n/**\n * Health check endpoint handler\n * Tests database connectivity and returns pool statistics\n */\nexport async function dbHealthCheck(req, res) {\n  const startTime = Date.now();\n  \n  try {\n    // Test connection with a simple query\n    const result = await pool.query(\"SELECT NOW() as current_time, version() as pg_version\");\n    const responseTime = Date.now() - startTime;\n    \n    // Get pool statistics\n    const poolStats = {\n      totalCount: pool.totalCount,\n      idleCount: pool.idleCount,\n      waitingCount: pool.waitingCount,\n    };\n    \n    res.status(200).json({\n      status: \"healthy\",\n      database: \"postgresql\",\n      responseTime: `${responseTime}ms`,\n      timestamp: result.rows[0].current_time,\n      version: result.rows[0].pg_version,\n      pool: poolStats,\n    });\n  } catch (error) {\n    const responseTime = Date.now() - startTime;\n    \n    console.error(\"Database health check failed:\", error);\n    \n    res.status(503).json({\n      status: \"unhealthy\",\n      database: \"postgresql\",\n      responseTime: `${responseTime}ms`,\n      error: error.message,\n      pool: {\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount,\n      },\n    });\n  }\n}\n\n/**\n * Graceful shutdown handler\n * Closes all pool connections before process exit\n */\nexport async function gracefulShutdown(signal) {\n  console.log(`\\n${signal} received. Closing database pool...`);\n  \n  try {\n    await pool.end();\n    console.log(\"Database pool closed successfully\");\n    process.exit(0);\n  } catch (error) {\n    console.error(\"Error closing database pool:\", error);\n    process.exit(1);\n  }\n}\n\n// Register shutdown handlers\nprocess.on(\"SIGTERM\", () => gracefulShutdown(\"SIGTERM\"));\nprocess.on(\"SIGINT\", () => gracefulShutdown(\"SIGINT\"));\n\n// Export pool for direct access if needed\nexport { pool };\n```\n\nNow let's create an example route that uses the database pool:\n\n```javascript\n// src/routes/users.js\nimport express from \"express\";\n\nconst router = express.Router();\n\n// Example: Get all users\nrouter.get(\"/\", async (req, res) => {\n  try {\n    const result = await req.db.query(\n      \"SELECT id, name, email, created_at FROM users ORDER BY created_at DESC\"\n    );\n    \n    res.json({\n      users: result.rows,\n      count: result.rowCount,\n    });\n  } catch (error) {\n    console.error(\"Error fetching users:\", error);\n    res.status(500).json({ error: \"Failed to fetch users\" });\n  }\n});\n\n// Example: Get user by ID with parameterized query\nrouter.get(\"/:id\", async (req, res) => {\n  try {\n    const result = await req.db.query(\n      \"SELECT id, name, email, created_at FROM users WHERE id = $1\",\n      [req.params.id]\n    );\n    \n    if (result.rowCount === 0) {\n      return res.status(404).json({ error: \"User not found\" });\n    }\n    \n    res.json(result.rows[0]);\n  } catch (error) {\n    console.error(\"Error fetching user:\", error);\n    res.status(500).json({ error: \"Failed to fetch user\" });\n  }\n});\n\n// Example: Create user with transaction\nrouter.post(\"/\", async (req, res) => {\n  const client = await req.db.connect();\n  \n  try {\n    await client.query(\"BEGIN\");\n    \n    const userResult = await client.query(\n      \"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email, created_at\",\n      [req.body.name, req.body.email]\n    );\n    \n    // Example: Insert related data in same transaction\n    await client.query(\n      \"INSERT INTO user_profiles (user_id, bio) VALUES ($1, $2)\",\n      [userResult.rows[0].id, req.body.bio || \"\"]\n    );\n    \n    await client.query(\"COMMIT\");\n    \n    res.status(201).json(userResult.rows[0]);\n  } catch (error) {\n    await client.query(\"ROLLBACK\");\n    console.error(\"Error creating user:\", error);\n    res.status(500).json({ error: \"Failed to create user\" });\n  } finally {\n    client.release(); // Always release client back to pool\n  }\n});\n\nexport default router;\n```\n\nNow update your main app file to use the middleware:\n\n```javascript\n// src/app.js\nimport express from \"express\";\nimport { attachDbPool, dbHealthCheck } from \"./middleware/db.js\";\nimport usersRouter from \"./routes/users.js\";\n\nconst app = express();\n\napp.use(express.json());\n\n// Attach database pool to all requests\napp.use(attachDbPool);\n\n// Health check endpoint\napp.get(\"/db/health\", dbHealthCheck);\n\n// Your routes\napp.use(\"/api/users\", usersRouter);\n\nexport default app;\n```\n\nCreate an environment variables template:\n\n```bash\n# .env.example\nDATABASE_URL=postgresql://username:password@localhost:5432/dbname\n\n# Database Pool Configuration\nDB_POOL_MAX=20                # Maximum number of clients in the pool\nDB_IDLE_TIMEOUT=30000         # Close idle clients after 30 seconds\nDB_CONNECTION_TIMEOUT=10000   # Timeout when acquiring a connection (10 seconds)\n\n# JWT (your existing config)\nJWT_SECRET=your-secret-key\n```\n\nFinally, here's a test file for the middleware:\n\n```javascript\n// src/middleware/__tests__/db.test.js\nimport { jest } from \"@jest/globals\";\nimport { attachDbPool, dbHealthCheck } from \"../db.js\";\n\ndescribe(\"Database Middleware\", () => {\n  describe(\"attachDbPool\", () => {\n    it(\"should attach pool to request object\", () => {\n      const req = {};\n      const res = {};\n      const next = jest.fn();\n\n      attachDbPool(req, res, next);\n\n      expect(req.db).toBeDefined();\n      expect(req.db.query).toBeDefined();\n      expect(next).toHaveBeenCalled();\n    });\n  });\n\n  describe(\"dbHealthCheck\", () => {\n    it(\"should return healthy status on successful connection\", async () => {\n      const req = {};\n      const res = {\n        status: jest.fn().mockReturnThis(),\n        json: jest.fn(),\n      };\n\n      await dbHealthCheck(req, res);\n\n      expect(res.status).toHaveBeenCalledWith(expect.any(Number));\n      expect(res.json).toHaveBeenCalledWith(\n        expect.objectContaining({\n          status: expect.any(String),\n          database: \"postgresql\",\n        })\n      );\n    });\n  });\n});\n```\n\n## Key Features:\n\n1. **Shared Pool Instance** - Single pool reused across all requests\n2. **Request Attachment** - Pool available via `req.db` in all routes\n3. **Health Check** - `/db/health` endpoint with connection test and pool stats\n4. **Graceful Shutdown** - Handles SIGTERM/SIGINT to close connections cleanly\n5. **Configurable** - Max pool size, idle timeout, connection timeout via env vars\n6. **Error Handling** - Pool-level error handler for unexpected issues\n7. **Transaction Support** - Example shows how to use `client.connect()` for transactions\n8. **Parameterized Queries** - Safe query examples with `$1`, `$2` placeholders\n\nThe middleware is production-ready and follows Node.js best practices for connection pooling!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10770,
            "output_tokens": 2305,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# PostgreSQL Connection Pooling Middleware for Express.js\n\nHere's a comprehensive implementation of a PostgreSQL connection pooling middleware with health checks and graceful shutdown:\n\n```javascript\n// db-pool-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured PostgreSQL pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection settings\n    host: config.host || process.env.DB_HOST || 'localhost',\n    port: config.port || process.env.DB_PORT || 5432,\n    database: config.database || process.env.DB_NAME || 'mydb',\n    user: config.user || process.env.DB_USER || 'postgres',\n    password: config.password || process.env.DB_PASSWORD || '',\n    \n    // Pool settings\n    max: config.max || parseInt(process.env.DB_POOL_MAX) || 20, // Maximum pool size\n    min: config.min || parseInt(process.env.DB_POOL_MIN) || 2, // Minimum pool size\n    idleTimeoutMillis: config.idleTimeoutMillis || \n                       parseInt(process.env.DB_IDLE_TIMEOUT) || 30000, // 30 seconds\n    connectionTimeoutMillis: config.connectionTimeoutMillis || \n                            parseInt(process.env.DB_CONNECTION_TIMEOUT) || 10000, // 10 seconds\n    \n    // Additional settings\n    allowExitOnIdle: config.allowExitOnIdle || false,\n    statement_timeout: config.statementTimeout || 30000, // Query timeout\n    query_timeout: config.queryTimeout || 30000,\n    \n    // SSL configuration (optional)\n    ssl: config.ssl || (process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false),\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Event handlers for pool monitoring\n  pool.on('connect', (client) => {\n    console.log('New client connected to the pool');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n    // Don't exit the process, just log the error\n  });\n\n  return pool;\n}\n\n/**\n * Middleware factory that creates and attaches pool to request object\n * @param {Object} config - Pool configuration options\n * @returns {Function} Express middleware function\n */\nfunction createPoolMiddleware(config = {}) {\n  const pool = createPool(config);\n  \n  // Store pool instance for access outside middleware\n  createPoolMiddleware.pool = pool;\n\n  return function poolMiddleware(req, res, next) {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Add helper method for executing queries\n    req.query = async (text, params) => {\n      const start = Date.now();\n      try {\n        const result = await pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: result.rowCount });\n        return result;\n      } catch (error) {\n        console.error('Query error', { text, error: error.message });\n        throw error;\n      }\n    };\n\n    // Add helper method for transactions\n    req.transaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    };\n\n    next();\n  };\n}\n\n/**\n * Health check middleware for database connection\n * @param {Pool} pool - PostgreSQL pool instance\n * @returns {Function} Express route handler\n */\nfunction createHealthCheckHandler(pool) {\n  return async (req, res) => {\n    const healthCheck = {\n      status: 'unhealthy',\n      timestamp: new Date().toISOString(),\n      database: {\n        connected: false,\n        responseTime: null,\n        poolStats: null,\n      },\n    };\n\n    try {\n      const start = Date.now();\n      \n      // Test connection with a simple query\n      const result = await pool.query('SELECT NOW() as current_time, version() as version');\n      const responseTime = Date.now() - start;\n\n      // Get pool statistics\n      const poolStats = {\n        total: pool.totalCount,\n        idle: pool.idleCount,\n        waiting: pool.waitingCount,\n      };\n\n      healthCheck.status = 'healthy';\n      healthCheck.database.connected = true;\n      healthCheck.database.responseTime = `${responseTime}ms`;\n      healthCheck.database.poolStats = poolStats;\n      healthCheck.database.serverTime = result.rows[0].current_time;\n      healthCheck.database.version = result.rows[0].version.split(',')[0]; // Shortened version\n\n      res.status(200).json(healthCheck);\n    } catch (error) {\n      healthCheck.error = error.message;\n      healthCheck.database.error = error.message;\n      \n      console.error('Health check failed:', error);\n      res.status(503).json(healthCheck);\n    }\n  };\n}\n\n/**\n * Graceful shutdown handler for the pool\n * @param {Pool} pool - PostgreSQL pool instance\n * @param {Object} options - Shutdown options\n */\nasync function gracefulShutdown(pool, options = {}) {\n  const timeout = options.timeout || 10000; // 10 seconds default\n  \n  console.log('Initiating graceful shutdown of database pool...');\n  \n  try {\n    // Set a timeout for the shutdown process\n    const shutdownPromise = pool.end();\n    const timeoutPromise = new Promise((_, reject) => \n      setTimeout(() => reject(new Error('Shutdown timeout')), timeout)\n    );\n\n    await Promise.race([shutdownPromise, timeoutPromise]);\n    console.log('Database pool closed successfully');\n  } catch (error) {\n    console.error('Error during pool shutdown:', error);\n    // Force close if graceful shutdown fails\n    await pool.end();\n  }\n}\n\n/**\n * Setup signal handlers for graceful shutdown\n * @param {Pool} pool - PostgreSQL pool instance\n * @param {Object} options - Shutdown options\n */\nfunction setupGracefulShutdown(pool, options = {}) {\n  const signals = ['SIGTERM', 'SIGINT'];\n  \n  signals.forEach((signal) => {\n    process.on(signal, async () => {\n      console.log(`Received ${signal}, starting graceful shutdown...`);\n      \n      try {\n        await gracefulShutdown(pool, options);\n        process.exit(0);\n      } catch (error) {\n        console.error('Graceful shutdown failed:', error);\n        process.exit(1);\n      }\n    });\n  });\n\n  // Handle uncaught exceptions\n  process.on('uncaughtException', async (error) => {\n    console.error('Uncaught Exception:', error);\n    await gracefulShutdown(pool, { timeout: 5000 });\n    process.exit(1);\n  });\n\n  // Handle unhandled promise rejections\n  process.on('unhandledRejection', async (reason, promise) => {\n    console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n    await gracefulShutdown(pool, { timeout: 5000 });\n    process.exit(1);\n  });\n}\n\nmodule.exports = {\n  createPool,\n  createPoolMiddleware,\n  createHealthCheckHandler,\n  gracefulShutdown,\n  setupGracefulShutdown,\n};\n```\n\n```javascript\n// app.js - Example usage\nconst express = require('express');\nconst {\n  createPoolMiddleware,\n  createHealthCheckHandler,\n  setupGracefulShutdown,\n} = require('./db-pool-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Database configuration\nconst dbConfig = {\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  max: 20,                      // Maximum pool size\n  min: 2,                       // Minimum pool size\n  idleTimeoutMillis: 30000,     // 30 seconds\n  connectionTimeoutMillis: 10000, // 10 seconds\n};\n\n// Create and apply pool middleware\nconst poolMiddleware = createPoolMiddleware(dbConfig);\napp.use(poolMiddleware);\n\n// Setup health check endpoint\napp.get('/db/health', createHealthCheckHandler(poolMiddleware.pool));\n\n// Setup graceful shutdown\nsetupGracefulShutdown(poolMiddleware.pool, { timeout: 10000 });\n\n// Example routes using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/users/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const result = await req.query('SELECT * FROM users WHERE id = $1', [id]);\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(result.rows[0]);\n  } catch (error) {\n    console.error('Error fetching user:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Example transaction route\napp.post('/transfer', async (req, res) => {\n  try {\n    const { fromAccount, toAccount, amount } = req.body;\n    \n    const result = await req.transaction(async (client) => {\n      // Deduct from sender\n      await client.query(\n        'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n        [amount, fromAccount]\n      );\n      \n      // Add to receiver\n      await client.query(\n        'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n        [amount, toAccount]\n      );\n      \n      return { success: true };\n    });\n    \n    res.json(result);\n  } catch (error) {\n    console.error('Transaction error:', error);\n    res.status(500).json({ error: 'Transaction failed' });\n  }\n});\n\n// Pool statistics endpoint\napp.get('/db/stats', (req, res) => {\n  const pool = poolMiddleware.pool;\n  res.json({\n    totalConnections: pool.totalCount,\n    idleConnections: pool.idleCount,\n    waitingRequests: pool.waitingCount,\n  });\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n\n// Graceful server shutdown\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing HTTP server...');\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n});\n```\n\n```javascript\n// .env.example - Environment variables configuration\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=postgres\nDB_PASSWORD=your_password\nDB_POOL_MAX=20\nDB_POOL_MIN=2\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_SSL=false\nPORT=3000\n```\n\n```javascript\n// package.json\n{\n  \"name\": \"express-pg-pool-middleware\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Express.js middleware with PostgreSQL connection pooling\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\",\n    \"test\": \"jest\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.0\",\n    \"dotenv\": \"^16.0.3\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.22\"\n  }\n}\n```\n\n```javascript\n// advanced-usage.js - Advanced patterns and examples\nconst express = require('express');\nconst {\n  createPoolMiddleware,\n  createHealthCheckHandler,\n  setupGracefulShutdown,\n} = require('./db-pool-middleware');\n\nconst app = express();\n\n// Create pool middleware with advanced configuration\nconst poolMiddleware = createPoolMiddleware({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  max: 20,\n  min: 2,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 10000,\n  statementTimeout: 30000,\n  ssl: false,\n});\n\napp.use(express.json());\napp.use(poolMiddleware);\n\n// Health check with custom logic\napp.get('/db/health', createHealthCheckHandler(poolMiddleware.pool));\n\n// Advanced query with prepared statements\napp.get('/api/search', async (req, res) => {\n  try {\n    const { query, limit = 10, offset = 0 } = req.query;\n    \n    const result = await req.query(\n      `SELECT * FROM products \n       WHERE name ILIKE $1 \n       ORDER BY created_at DESC \n       LIMIT $2 OFFSET $3`,\n      [`%${query}%`, limit, offset]\n    );\n    \n    res.json({\n      data: result.rows,\n      count: result.rowCount,\n      limit: parseInt(limit),\n      offset: parseInt(offset),\n    });\n  } catch (error) {\n    console.error('Search error:', error);\n    res.status(500).json({ error: 'Search failed' });\n  }\n});\n\n// Batch operations with transaction\napp.post('/api/batch-insert', async (req, res) => {\n  try {\n    const { items } = req.body;\n    \n    const result = await req.transaction(async (client) => {\n      const insertedIds = [];\n      \n      for (const item of items) {\n        const result = await client.query(\n          'INSERT INTO items (name, description) VALUES ($1, $2) RETURNING id',\n          [item.name, item.description]\n        );\n        insertedIds.push(result.rows[0].id);\n      }\n      \n      return insertedIds;\n    });\n    \n    res.json({ success: true, ids: result });\n  } catch (error) {\n    console.error('Batch insert error:', error);\n    res.status(500).json({ error: 'Batch insert failed' });\n  }\n});\n\n// Connection pool monitoring\napp.get('/api/pool/monitor', (req, res) => {\n  const pool = poolMiddleware.pool;\n  \n  res.json({\n    timestamp: new Date().toISOString(),\n    pool: {\n      total: pool.totalCount,\n      idle: pool.idleCount,\n      waiting: pool.waitingCount,\n      maxSize: pool.options.max,\n      minSize: pool.options.min,\n    },\n    configuration: {\n      idleTimeout: pool.options.idleTimeoutMillis,\n      connectionTimeout: pool.options.connectionTimeoutMillis,\n    },\n  });\n});\n\nsetupGracefulShutdown(poolMiddleware.pool);\n\nconst server = app.listen(3000, () => {\n  console.log('Advanced server running on port 3",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 92,
            "output_tokens": 4096,
            "cached": true
          },
          "with_skill": {
            "output": "# Express.js PostgreSQL Connection Pooling Middleware\n\nHere's a complete implementation with connection pooling, health checks, and graceful shutdown:\n\n```javascript\n// middleware/database.js\nimport { Pool } from 'pg';\n\n// Pool configuration\nconst poolConfig = {\n  connectionString: process.env.DATABASE_URL,\n  max: parseInt(process.env.DB_POOL_MAX || '20', 10), // Maximum pool size\n  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000', 10), // 30 seconds\n  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || '10000', 10), // 10 seconds\n  allowExitOnIdle: false, // Keep pool alive even with no active clients\n};\n\n// Create shared pool instance\nconst pool = new Pool(poolConfig);\n\n// Pool error handler - catches errors on idle clients\npool.on('error', (err, client) => {\n  console.error('Unexpected error on idle client', err);\n  // Don't exit the process - let the pool handle reconnection\n});\n\n// Pool connect event - useful for monitoring\npool.on('connect', (client) => {\n  console.log('New client connected to database');\n});\n\n// Pool remove event - client removed from pool\npool.on('remove', (client) => {\n  console.log('Client removed from pool');\n});\n\n/**\n * Database middleware - attaches pool to request object\n * @param {Request} req - Express request object\n * @param {Response} res - Express response object\n * @param {Function} next - Express next middleware function\n */\nexport const databaseMiddleware = (req, res, next) => {\n  req.db = pool;\n  next();\n};\n\n/**\n * Health check endpoint handler\n * Tests database connectivity and returns pool statistics\n */\nexport const healthCheckHandler = async (req, res) => {\n  const startTime = Date.now();\n  \n  try {\n    // Test connection with simple query\n    const result = await pool.query('SELECT NOW() as current_time, version() as pg_version');\n    const responseTime = Date.now() - startTime;\n    \n    // Get pool statistics\n    const poolStats = {\n      totalCount: pool.totalCount,\n      idleCount: pool.idleCount,\n      waitingCount: pool.waitingCount,\n    };\n    \n    res.status(200).json({\n      status: 'healthy',\n      database: {\n        connected: true,\n        responseTime: `${responseTime}ms`,\n        currentTime: result.rows[0].current_time,\n        version: result.rows[0].pg_version,\n      },\n      pool: poolStats,\n      config: {\n        maxConnections: poolConfig.max,\n        idleTimeout: `${poolConfig.idleTimeoutMillis}ms`,\n        connectionTimeout: `${poolConfig.connectionTimeoutMillis}ms`,\n      },\n    });\n  } catch (error) {\n    const responseTime = Date.now() - startTime;\n    \n    console.error('Database health check failed:', error);\n    \n    res.status(503).json({\n      status: 'unhealthy',\n      database: {\n        connected: false,\n        responseTime: `${responseTime}ms`,\n        error: error.message,\n      },\n      pool: {\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount,\n      },\n    });\n  }\n};\n\n/**\n * Graceful shutdown handler\n * Closes all pool connections and exits process\n */\nexport const gracefulShutdown = async () => {\n  console.log('Received shutdown signal, closing database connections...');\n  \n  try {\n    // End the pool - waits for all clients to be released\n    await pool.end();\n    console.log('Database pool closed successfully');\n    process.exit(0);\n  } catch (error) {\n    console.error('Error during pool shutdown:', error);\n    process.exit(1);\n  }\n};\n\n// Export pool for direct access if needed\nexport { pool };\n```\n\n```javascript\n// app.js\nimport express from 'express';\nimport { databaseMiddleware, healthCheckHandler, gracefulShutdown } from './middleware/database.js';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Apply database middleware globally\napp.use(databaseMiddleware);\n\n// Health check endpoint\napp.get('/db/health', healthCheckHandler);\n\n// Example route using the database pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.db.query('SELECT id, name, email FROM users LIMIT 10');\n    res.json({\n      success: true,\n      count: result.rowCount,\n      users: result.rows,\n    });\n  } catch (error) {\n    console.error('Database query error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch users',\n    });\n  }\n});\n\n// Example route with parameterized query\napp.get('/users/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const result = await req.db.query(\n      'SELECT id, name, email, created_at FROM users WHERE id = $1',\n      [id]\n    );\n    \n    if (result.rowCount === 0) {\n      return res.status(404).json({\n        success: false,\n        error: 'User not found',\n      });\n    }\n    \n    res.json({\n      success: true,\n      user: result.rows[0],\n    });\n  } catch (error) {\n    console.error('Database query error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch user',\n    });\n  }\n});\n\n// Example route with transaction\napp.post('/users', async (req, res) => {\n  const client = await req.db.connect();\n  \n  try {\n    await client.query('BEGIN');\n    \n    const { name, email } = req.body;\n    \n    // Insert user\n    const userResult = await client.query(\n      'INSERT INTO users(name, email) VALUES($1, $2) RETURNING id',\n      [name, email]\n    );\n    const userId = userResult.rows[0].id;\n    \n    // Insert user profile\n    await client.query(\n      'INSERT INTO profiles(user_id, bio) VALUES($1, $2)',\n      [userId, 'New user']\n    );\n    \n    await client.query('COMMIT');\n    \n    res.status(201).json({\n      success: true,\n      userId,\n    });\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('Transaction error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to create user',\n    });\n  } finally {\n    client.release(); // Always release the client back to the pool\n  }\n});\n\n// Start server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n\n// Graceful shutdown handlers\nprocess.on('SIGTERM', async () => {\n  console.log('SIGTERM received');\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n  await gracefulShutdown();\n});\n\nprocess.on('SIGINT', async () => {\n  console.log('SIGINT received');\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n  await gracefulShutdown();\n});\n\n// Handle uncaught errors\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n  gracefulShutdown();\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  gracefulShutdown();\n});\n```\n\n```bash\n# .env\nDATABASE_URL=postgresql://username:password@host:5432/database\nDB_POOL_MAX=20\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nPORT=3000\n```\n\n```json\n// package.json\n{\n  \"name\": \"express-pg-pooling\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.3\",\n    \"dotenv\": \"^16.3.1\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.1\"\n  }\n}\n```\n\n## Key Features\n\n### 1. **Shared Pool Instance**\n- Single pool created at module load\n- Attached to `req.db` for easy access\n- Reused across all requests\n\n### 2. **Pool Configuration**\n- **max**: Maximum number of clients (default: 20)\n- **idleTimeoutMillis**: How long idle clients stay in pool (default: 30s)\n- **connectionTimeoutMillis**: Max time to wait for connection (default: 10s)\n\n### 3. **Health Check Endpoint**\nReturns comprehensive status:\n```json\n{\n  \"status\": \"healthy\",\n  \"database\": {\n    \"connected\": true,\n    \"responseTime\": \"15ms\",\n    \"currentTime\": \"2024-01-15T10:30:00.000Z\",\n    \"version\": \"PostgreSQL 16.1\"\n  },\n  \"pool\": {\n    \"totalCount\": 5,\n    \"idleCount\": 3,\n    \"waitingCount\": 0\n  }\n}\n```\n\n### 4. **Graceful Shutdown**\n- Listens for SIGTERM/SIGINT signals\n- Closes HTTP server first\n- Waits for all clients to be released\n- Ends pool cleanly\n\n### 5. **Error Handling**\n- Pool-level error handler for idle clients\n- Query-level try/catch blocks\n- Transaction rollback on errors\n- Always releases clients back to pool\n\n## Usage Examples\n\n```javascript\n// Simple query\napp.get('/posts', async (req, res) => {\n  const { rows } = await req.db.query('SELECT * FROM posts');\n  res.json(rows);\n});\n\n// Parameterized query\napp.get('/posts/:id', async (req, res) => {\n  const { rows } = await req.db.query(\n    'SELECT * FROM posts WHERE id = $1',\n    [req.params.id]\n  );\n  res.json(rows[0]);\n});\n\n// Transaction\napp.post('/transfer', async (req, res) => {\n  const client = await req.db.connect();\n  try {\n    await client.query('BEGIN');\n    await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [100, 1]);\n    await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [100, 2]);\n    await client.query('COMMIT');\n    res.json({ success: true });\n  } catch (e) {\n    await client.query('ROLLBACK');\n    throw e;\n  } finally {\n    client.release();\n  }\n});\n```\n\nThis implementation provides production-ready connection pooling with monitoring, health checks, and graceful shutdown handling.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10304,
            "output_tokens": 2900,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Express.js PostgreSQL Connection Pooling Middleware\n\nHere's a complete implementation of a connection pooling middleware for Express.js using the `pg` library:\n\n```javascript\n// db-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured pg Pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection string (supports Neon connection strings)\n    connectionString: config.connectionString || process.env.DATABASE_URL,\n    \n    // Pool configuration\n    max: config.max || parseInt(process.env.DB_POOL_MAX || '20', 10), // Maximum pool size\n    idleTimeoutMillis: config.idleTimeoutMillis || parseInt(process.env.DB_IDLE_TIMEOUT || '30000', 10), // 30 seconds\n    connectionTimeoutMillis: config.connectionTimeoutMillis || parseInt(process.env.DB_CONNECTION_TIMEOUT || '10000', 10), // 10 seconds\n    \n    // Additional recommended settings\n    allowExitOnIdle: config.allowExitOnIdle !== undefined ? config.allowExitOnIdle : false,\n    \n    // SSL configuration (important for Neon and other cloud providers)\n    ssl: config.ssl !== undefined ? config.ssl : {\n      rejectUnauthorized: false // Set to true in production with proper certificates\n    },\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Error handling for the pool\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n  });\n\n  // Optional: Log pool events for monitoring\n  pool.on('connect', (client) => {\n    console.log('New client connected to the pool');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  return pool;\n}\n\n/**\n * Express middleware that attaches the database pool to the request object\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express middleware function\n */\nfunction dbMiddleware(pool) {\n  return (req, res, next) => {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Helper method to get a client from the pool\n    req.getDbClient = async () => {\n      try {\n        const client = await pool.connect();\n        return client;\n      } catch (error) {\n        console.error('Error acquiring client from pool:', error);\n        throw error;\n      }\n    };\n\n    // Helper method for simple queries\n    req.query = async (text, params) => {\n      try {\n        const result = await pool.query(text, params);\n        return result;\n      } catch (error) {\n        console.error('Database query error:', error);\n        throw error;\n      }\n    };\n\n    // Helper method for transactions\n    req.transaction = async (callback) => {\n      const client = await pool.connect();\n      try {\n        await client.query('BEGIN');\n        const result = await callback(client);\n        await client.query('COMMIT');\n        return result;\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    };\n\n    next();\n  };\n}\n\n/**\n * Health check endpoint handler\n * Tests database connectivity and returns pool statistics\n */\nasync function healthCheckHandler(req, res) {\n  const startTime = Date.now();\n  \n  try {\n    // Test database connection with a simple query\n    const result = await req.db.query('SELECT NOW() as current_time, version() as pg_version');\n    const responseTime = Date.now() - startTime;\n\n    // Get pool statistics\n    const poolStats = {\n      totalCount: req.db.totalCount,\n      idleCount: req.db.idleCount,\n      waitingCount: req.db.waitingCount,\n    };\n\n    res.status(200).json({\n      status: 'healthy',\n      database: {\n        connected: true,\n        currentTime: result.rows[0].current_time,\n        version: result.rows[0].pg_version,\n        responseTime: `${responseTime}ms`,\n      },\n      pool: poolStats,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('Health check failed:', error);\n    \n    res.status(503).json({\n      status: 'unhealthy',\n      database: {\n        connected: false,\n        error: error.message,\n      },\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Gracefully shuts down the connection pool\n * @param {Pool} pool - PostgreSQL connection pool\n * @param {number} timeout - Maximum time to wait for shutdown (ms)\n */\nasync function gracefulShutdown(pool, timeout = 10000) {\n  console.log('Shutting down database connection pool...');\n  \n  const shutdownPromise = pool.end();\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => reject(new Error('Pool shutdown timeout')), timeout);\n  });\n\n  try {\n    await Promise.race([shutdownPromise, timeoutPromise]);\n    console.log('Database pool closed successfully');\n  } catch (error) {\n    console.error('Error during pool shutdown:', error);\n    // Force exit if graceful shutdown fails\n    process.exit(1);\n  }\n}\n\n/**\n * Sets up signal handlers for graceful shutdown\n * @param {Pool} pool - PostgreSQL connection pool\n */\nfunction setupGracefulShutdown(pool) {\n  const signals = ['SIGTERM', 'SIGINT'];\n  \n  signals.forEach((signal) => {\n    process.on(signal, async () => {\n      console.log(`Received ${signal}, starting graceful shutdown...`);\n      \n      try {\n        await gracefulShutdown(pool);\n        process.exit(0);\n      } catch (error) {\n        console.error('Graceful shutdown failed:', error);\n        process.exit(1);\n      }\n    });\n  });\n\n  // Handle uncaught exceptions\n  process.on('uncaughtException', async (error) => {\n    console.error('Uncaught exception:', error);\n    await gracefulShutdown(pool);\n    process.exit(1);\n  });\n\n  // Handle unhandled promise rejections\n  process.on('unhandledRejection', async (reason, promise) => {\n    console.error('Unhandled rejection at:', promise, 'reason:', reason);\n    await gracefulShutdown(pool);\n    process.exit(1);\n  });\n}\n\nmodule.exports = {\n  createPool,\n  dbMiddleware,\n  healthCheckHandler,\n  gracefulShutdown,\n  setupGracefulShutdown,\n};\n```\n\n## Usage Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst {\n  createPool,\n  dbMiddleware,\n  healthCheckHandler,\n  setupGracefulShutdown,\n} = require('./db-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Create the connection pool\nconst pool = createPool({\n  connectionString: process.env.DATABASE_URL,\n  max: 20,                      // Maximum 20 connections\n  idleTimeoutMillis: 30000,     // Close idle clients after 30 seconds\n  connectionTimeoutMillis: 10000, // Timeout after 10 seconds\n});\n\n// Apply the database middleware globally\napp.use(dbMiddleware(pool));\n\n// Health check endpoint\napp.get('/db/health', healthCheckHandler);\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Database error' });\n  }\n});\n\n// Example route using a transaction\napp.post('/users', async (req, res) => {\n  try {\n    const result = await req.transaction(async (client) => {\n      const userResult = await client.query(\n        'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',\n        [req.body.name, req.body.email]\n      );\n      \n      await client.query(\n        'INSERT INTO audit_log (action, user_id) VALUES ($1, $2)',\n        ['user_created', userResult.rows[0].id]\n      );\n      \n      return userResult.rows[0];\n    });\n    \n    res.status(201).json(result);\n  } catch (error) {\n    console.error('Error creating user:', error);\n    res.status(500).json({ error: 'Database error' });\n  }\n});\n\n// Example route using a dedicated client\napp.get('/complex-query', async (req, res) => {\n  const client = await req.getDbClient();\n  \n  try {\n    await client.query('BEGIN');\n    \n    const result1 = await client.query('SELECT * FROM table1');\n    const result2 = await client.query('SELECT * FROM table2 WHERE id = $1', [result1.rows[0].id]);\n    \n    await client.query('COMMIT');\n    \n    res.json({ result1: result1.rows, result2: result2.rows });\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('Complex query error:', error);\n    res.status(500).json({ error: 'Database error' });\n  } finally {\n    client.release(); // Always release the client back to the pool\n  }\n});\n\n// Setup graceful shutdown handlers\nsetupGracefulShutdown(pool);\n\n// Start the server\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n\n// Graceful shutdown for the HTTP server\nprocess.on('SIGTERM', () => {\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n});\n```\n\n## Environment Variables (.env)\n\n```bash\n# Database connection\nDATABASE_URL=postgresql://user:password@host:5432/database\n\n# Pool configuration\nDB_POOL_MAX=20\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\n\n# Server configuration\nPORT=3000\nNODE_ENV=production\n```\n\n## Package.json Dependencies\n\n```json\n{\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.3\",\n    \"dotenv\": \"^16.3.1\"\n  }\n}\n```\n\n## Key Features\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Helpers**: Convenient methods (`req.query`, `req.transaction`, `req.getDbClient`)\n3. **Health Check**: `/db/health` endpoint with connection testing and pool statistics\n4. **Graceful Shutdown**: Proper cleanup on SIGTERM/SIGINT signals\n5. **Error Handling**: Comprehensive error handling and logging\n6. **Transaction Support**: Built-in transaction helper with automatic rollback\n7. **Pool Monitoring**: Event listeners for debugging and monitoring\n8. **Configurable**: Environment variables for all pool settings\n\n## Best Practices Implemented\n\n- Connection pooling prevents connection exhaustion\n- Proper client release to avoid pool leaks\n- Transaction rollback on errors\n- SSL support for secure connections (important for Neon)\n- Graceful shutdown with timeout\n- Health check for monitoring and load balancers\n- Error event handlers to prevent crashes\n\nThis middleware is production-ready and works seamlessly with Neon's serverless Postgres!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2234,
            "output_tokens": 2984,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive PostgreSQL connection pooling middleware for your Express.js application.\n\n```javascript\n// src/middleware/db.js\nimport pg from \"pg\";\nconst { Pool } = pg;\n\n// Create a shared pool instance\nlet pool = null;\n\n/**\n * Initialize the PostgreSQL connection pool\n * @returns {Pool} The initialized pool instance\n */\nexport function initializePool() {\n  if (pool) {\n    return pool;\n  }\n\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    // Maximum number of clients in the pool\n    max: parseInt(process.env.DB_POOL_MAX || \"20\", 10),\n    // Number of milliseconds a client must sit idle before being removed\n    idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || \"30000\", 10),\n    // Number of milliseconds to wait before timing out when connecting\n    connectionTimeoutMillis: parseInt(\n      process.env.DB_CONNECTION_TIMEOUT || \"10000\",\n      10\n    ),\n    // Maximum number of queued requests when pool is full\n    maxUses: parseInt(process.env.DB_MAX_USES || \"7500\", 10),\n    // Allow the pool to return clients with errors\n    allowExitOnIdle: false,\n  });\n\n  // Handle pool errors\n  pool.on(\"error\", (err, client) => {\n    console.error(\"Unexpected error on idle PostgreSQL client\", err);\n  });\n\n  // Log pool events in development\n  if (process.env.NODE_ENV === \"development\") {\n    pool.on(\"connect\", (client) => {\n      console.log(\"New client connected to PostgreSQL pool\");\n    });\n\n    pool.on(\"acquire\", (client) => {\n      console.log(\"Client acquired from pool\");\n    });\n\n    pool.on(\"remove\", (client) => {\n      console.log(\"Client removed from pool\");\n    });\n  }\n\n  console.log(\"PostgreSQL connection pool initialized\");\n  return pool;\n}\n\n/**\n * Middleware to attach database pool to request object\n */\nexport function attachPool(req, res, next) {\n  if (!pool) {\n    pool = initializePool();\n  }\n  req.db = pool;\n  next();\n}\n\n/**\n * Health check endpoint handler\n * Tests database connectivity and returns pool statistics\n */\nexport async function healthCheck(req, res) {\n  const startTime = Date.now();\n\n  try {\n    // Test the connection with a simple query\n    const client = await pool.connect();\n    try {\n      const result = await client.query(\"SELECT NOW() as current_time\");\n      const responseTime = Date.now() - startTime;\n\n      // Get pool statistics\n      const poolStats = {\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount,\n      };\n\n      res.status(200).json({\n        status: \"healthy\",\n        database: \"postgresql\",\n        responseTime: `${responseTime}ms`,\n        timestamp: result.rows[0].current_time,\n        pool: poolStats,\n      });\n    } finally {\n      client.release();\n    }\n  } catch (error) {\n    const responseTime = Date.now() - startTime;\n\n    console.error(\"Database health check failed:\", error);\n\n    res.status(503).json({\n      status: \"unhealthy\",\n      database: \"postgresql\",\n      responseTime: `${responseTime}ms`,\n      error: error.message,\n      pool: pool\n        ? {\n            totalCount: pool.totalCount,\n            idleCount: pool.idleCount,\n            waitingCount: pool.waitingCount,\n          }\n        : null,\n    });\n  }\n}\n\n/**\n * Gracefully shut down the connection pool\n */\nexport async function closePool() {\n  if (pool) {\n    console.log(\"Closing PostgreSQL connection pool...\");\n    try {\n      await pool.end();\n      console.log(\"PostgreSQL connection pool closed successfully\");\n      pool = null;\n    } catch (error) {\n      console.error(\"Error closing PostgreSQL pool:\", error);\n      throw error;\n    }\n  }\n}\n\n/**\n * Setup graceful shutdown handlers\n */\nexport function setupGracefulShutdown() {\n  const shutdown = async (signal) => {\n    console.log(`\\n${signal} received, starting graceful shutdown...`);\n\n    try {\n      await closePool();\n      console.log(\"Graceful shutdown completed\");\n      process.exit(0);\n    } catch (error) {\n      console.error(\"Error during graceful shutdown:\", error);\n      process.exit(1);\n    }\n  };\n\n  // Handle termination signals\n  process.on(\"SIGTERM\", () => shutdown(\"SIGTERM\"));\n  process.on(\"SIGINT\", () => shutdown(\"SIGINT\"));\n\n  // Handle uncaught errors\n  process.on(\"uncaughtException\", async (error) => {\n    console.error(\"Uncaught Exception:\", error);\n    await closePool();\n    process.exit(1);\n  });\n\n  process.on(\"unhandledRejection\", async (reason, promise) => {\n    console.error(\"Unhandled Rejection at:\", promise, \"reason:\", reason);\n    await closePool();\n    process.exit(1);\n  });\n}\n\n/**\n * Get the current pool instance\n * @returns {Pool|null} The pool instance or null if not initialized\n */\nexport function getPool() {\n  return pool;\n}\n```\n\nNow let's create an example of how to use this middleware in your Express app:\n\n```javascript\n// src/app.js (or wherever you initialize your Express app)\nimport express from \"express\";\nimport {\n  attachPool,\n  healthCheck,\n  initializePool,\n  setupGracefulShutdown,\n} from \"./middleware/db.js\";\n\nconst app = express();\n\n// Initialize the pool when the app starts\ninitializePool();\n\n// Setup graceful shutdown handlers\nsetupGracefulShutdown();\n\n// Attach pool to all requests\napp.use(attachPool);\n\n// Health check endpoint\napp.get(\"/db/health\", healthCheck);\n\n// Example route using the pool\napp.get(\"/users\", async (req, res) => {\n  try {\n    const result = await req.db.query(\"SELECT * FROM users LIMIT 10\");\n    res.json(result.rows);\n  } catch (error) {\n    console.error(\"Database query error:\", error);\n    res.status(500).json({ error: \"Database query failed\" });\n  }\n});\n\nexport default app;\n```\n\nAnd here's an example `.env` configuration file:\n\n```bash\n# .env\nDATABASE_URL=postgresql://username:password@localhost:5432/dbname\n\n# Pool Configuration\nDB_POOL_MAX=20\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_MAX_USES=7500\n\n# JWT Secret (existing)\nJWT_SECRET=your-secret-key\n\nNODE_ENV=development\n```\n\nFinally, here's a test file for the middleware:\n\n```javascript\n// src/middleware/__tests__/db.test.js\nimport { jest } from \"@jest/globals\";\nimport {\n  initializePool,\n  attachPool,\n  healthCheck,\n  closePool,\n  getPool,\n} from \"../db.js\";\n\n// Mock pg\njest.unstable_mockModule(\"pg\", () => ({\n  Pool: jest.fn().mockImplementation(() => ({\n    connect: jest.fn().mockResolvedValue({\n      query: jest.fn().mockResolvedValue({\n        rows: [{ current_time: new Date().toISOString() }],\n      }),\n      release: jest.fn(),\n    }),\n    query: jest.fn(),\n    end: jest.fn().mockResolvedValue(undefined),\n    on: jest.fn(),\n    totalCount: 5,\n    idleCount: 3,\n    waitingCount: 0,\n  })),\n}));\n\ndescribe(\"Database Middleware\", () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  afterEach(async () => {\n    await closePool();\n  });\n\n  describe(\"initializePool\", () => {\n    it(\"should create a pool instance\", () => {\n      const pool = initializePool();\n      expect(pool).toBeDefined();\n      expect(pool.connect).toBeDefined();\n    });\n\n    it(\"should return the same pool instance on subsequent calls\", () => {\n      const pool1 = initializePool();\n      const pool2 = initializePool();\n      expect(pool1).toBe(pool2);\n    });\n  });\n\n  describe(\"attachPool\", () => {\n    it(\"should attach pool to request object\", () => {\n      const req = {};\n      const res = {};\n      const next = jest.fn();\n\n      attachPool(req, res, next);\n\n      expect(req.db).toBeDefined();\n      expect(next).toHaveBeenCalled();\n    });\n  });\n\n  describe(\"healthCheck\", () => {\n    it(\"should return healthy status on successful connection\", async () => {\n      initializePool();\n\n      const req = {};\n      const res = {\n        status: jest.fn().mockReturnThis(),\n        json: jest.fn(),\n      };\n\n      await healthCheck(req, res);\n\n      expect(res.status).toHaveBeenCalledWith(200);\n      expect(res.json).toHaveBeenCalledWith(\n        expect.objectContaining({\n          status: \"healthy\",\n          database: \"postgresql\",\n        })\n      );\n    });\n  });\n\n  describe(\"closePool\", () => {\n    it(\"should close the pool gracefully\", async () => {\n      const pool = initializePool();\n      await closePool();\n      expect(pool.end).toHaveBeenCalled();\n    });\n  });\n\n  describe(\"getPool\", () => {\n    it(\"should return the current pool instance\", () => {\n      initializePool();\n      const pool = getPool();\n      expect(pool).toBeDefined();\n    });\n\n    it(\"should return null if pool is not initialized\", async () => {\n      await closePool();\n      const pool = getPool();\n      expect(pool).toBeNull();\n    });\n  });\n});\n```\n\n## Key Features:\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Attachment**: Pool available via `req.db` in all routes\n3. **Health Check**: `/db/health` endpoint with connection testing and pool statistics\n4. **Graceful Shutdown**: Handles SIGTERM, SIGINT, and uncaught errors\n5. **Configurable**: All pool settings via environment variables\n6. **Error Handling**: Comprehensive error logging and handling\n7. **Development Logging**: Optional verbose logging in development mode\n8. **Pool Statistics**: Real-time monitoring of pool state\n\nThe middleware is production-ready and follows Express.js best practices!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10770,
            "output_tokens": 2679,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "```javascript\n// db-pool-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Database Connection Pool Middleware for Express.js\n * Implements PostgreSQL connection pooling with health checks and graceful shutdown\n */\n\nclass DatabasePoolMiddleware {\n  constructor(config = {}) {\n    // Pool configuration with defaults\n    this.poolConfig = {\n      host: config.host || process.env.DB_HOST || 'localhost',\n      port: config.port || process.env.DB_PORT || 5432,\n      database: config.database || process.env.DB_NAME || 'mydb',\n      user: config.user || process.env.DB_USER || 'postgres',\n      password: config.password || process.env.DB_PASSWORD || '',\n      \n      // Pool-specific settings\n      max: config.max || 20, // Maximum number of clients in the pool\n      min: config.min || 5, // Minimum number of clients in the pool\n      idleTimeoutMillis: config.idleTimeoutMillis || 30000, // 30 seconds\n      connectionTimeoutMillis: config.connectionTimeoutMillis || 10000, // 10 seconds\n      \n      // Additional settings\n      allowExitOnIdle: config.allowExitOnIdle || false,\n      statement_timeout: config.statementTimeout || 30000, // Query timeout\n    };\n\n    // Create the pool instance\n    this.pool = new Pool(this.poolConfig);\n\n    // Pool event handlers\n    this.setupPoolEventHandlers();\n\n    // Setup graceful shutdown\n    this.setupGracefulShutdown();\n\n    // Track pool statistics\n    this.stats = {\n      totalConnections: 0,\n      activeConnections: 0,\n      idleConnections: 0,\n      waitingRequests: 0,\n      errors: 0,\n    };\n  }\n\n  /**\n   * Setup event handlers for the pool\n   */\n  setupPoolEventHandlers() {\n    // Client connection event\n    this.pool.on('connect', (client) => {\n      this.stats.totalConnections++;\n      console.log(`[DB Pool] New client connected. Total connections: ${this.pool.totalCount}`);\n    });\n\n    // Client acquisition event\n    this.pool.on('acquire', (client) => {\n      this.stats.activeConnections = this.pool.totalCount - this.pool.idleCount;\n      console.log(`[DB Pool] Client acquired. Active: ${this.stats.activeConnections}, Idle: ${this.pool.idleCount}`);\n    });\n\n    // Client release event\n    this.pool.on('release', (err, client) => {\n      if (err) {\n        console.error('[DB Pool] Error releasing client:', err);\n      }\n      this.stats.idleConnections = this.pool.idleCount;\n    });\n\n    // Error event\n    this.pool.on('error', (err, client) => {\n      this.stats.errors++;\n      console.error('[DB Pool] Unexpected error on idle client:', err);\n    });\n\n    // Remove event (client removed from pool)\n    this.pool.on('remove', (client) => {\n      console.log(`[DB Pool] Client removed. Total connections: ${this.pool.totalCount}`);\n    });\n  }\n\n  /**\n   * Setup graceful shutdown handlers\n   */\n  setupGracefulShutdown() {\n    const gracefulShutdown = async (signal) => {\n      console.log(`\\n[DB Pool] ${signal} received. Starting graceful shutdown...`);\n      \n      try {\n        // Wait for active queries to complete (with timeout)\n        const shutdownTimeout = setTimeout(() => {\n          console.warn('[DB Pool] Shutdown timeout reached, forcing pool closure');\n        }, 10000);\n\n        await this.pool.end();\n        clearTimeout(shutdownTimeout);\n        \n        console.log('[DB Pool] All connections closed successfully');\n        process.exit(0);\n      } catch (err) {\n        console.error('[DB Pool] Error during shutdown:', err);\n        process.exit(1);\n      }\n    };\n\n    // Handle different termination signals\n    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n    process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n    \n    // Handle uncaught exceptions\n    process.on('uncaughtException', (err) => {\n      console.error('[DB Pool] Uncaught exception:', err);\n      gracefulShutdown('UNCAUGHT_EXCEPTION');\n    });\n  }\n\n  /**\n   * Middleware function to attach pool to request object\n   */\n  middleware() {\n    return (req, res, next) => {\n      // Attach pool instance to request\n      req.db = this.pool;\n      \n      // Attach helper methods\n      req.dbQuery = async (text, params) => {\n        const start = Date.now();\n        try {\n          const result = await this.pool.query(text, params);\n          const duration = Date.now() - start;\n          console.log(`[DB Query] Executed query in ${duration}ms`);\n          return result;\n        } catch (err) {\n          console.error('[DB Query] Error:', err);\n          throw err;\n        }\n      };\n\n      // Attach transaction helper\n      req.dbTransaction = async (callback) => {\n        const client = await this.pool.connect();\n        try {\n          await client.query('BEGIN');\n          const result = await callback(client);\n          await client.query('COMMIT');\n          return result;\n        } catch (err) {\n          await client.query('ROLLBACK');\n          throw err;\n        } finally {\n          client.release();\n        }\n      };\n\n      next();\n    };\n  }\n\n  /**\n   * Health check endpoint handler\n   */\n  healthCheckHandler() {\n    return async (req, res) => {\n      const healthCheck = {\n        status: 'unknown',\n        timestamp: new Date().toISOString(),\n        pool: {\n          total: this.pool.totalCount,\n          idle: this.pool.idleCount,\n          waiting: this.pool.waitingCount,\n        },\n        stats: this.stats,\n        config: {\n          max: this.poolConfig.max,\n          min: this.poolConfig.min,\n          idleTimeout: this.poolConfig.idleTimeoutMillis,\n          connectionTimeout: this.poolConfig.connectionTimeoutMillis,\n        },\n      };\n\n      try {\n        // Test database connectivity\n        const start = Date.now();\n        const result = await this.pool.query('SELECT NOW() as current_time, version() as version');\n        const responseTime = Date.now() - start;\n\n        healthCheck.status = 'healthy';\n        healthCheck.database = {\n          connected: true,\n          responseTime: `${responseTime}ms`,\n          currentTime: result.rows[0].current_time,\n          version: result.rows[0].version.split(',')[0], // Simplified version\n        };\n\n        res.status(200).json(healthCheck);\n      } catch (err) {\n        healthCheck.status = 'unhealthy';\n        healthCheck.error = {\n          message: err.message,\n          code: err.code,\n        };\n\n        console.error('[DB Health Check] Failed:', err);\n        res.status(503).json(healthCheck);\n      }\n    };\n  }\n\n  /**\n   * Get pool statistics\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      pool: {\n        total: this.pool.totalCount,\n        idle: this.pool.idleCount,\n        waiting: this.pool.waitingCount,\n      },\n    };\n  }\n\n  /**\n   * Manual pool shutdown (for testing or manual cleanup)\n   */\n  async shutdown() {\n    console.log('[DB Pool] Manual shutdown initiated');\n    await this.pool.end();\n  }\n}\n\n/**\n * Factory function to create and configure the middleware\n */\nfunction createDatabasePoolMiddleware(config) {\n  return new DatabasePoolMiddleware(config);\n}\n\nmodule.exports = {\n  DatabasePoolMiddleware,\n  createDatabasePoolMiddleware,\n};\n\n// Example usage file: app.js\n/*\nconst express = require('express');\nconst { createDatabasePoolMiddleware } = require('./db-pool-middleware');\n\nconst app = express();\n\n// Create database pool middleware\nconst dbPool = createDatabasePoolMiddleware({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  max: 20,\n  min: 5,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 10000,\n});\n\n// Apply middleware globally\napp.use(dbPool.middleware());\n\n// Register health check endpoint\napp.get('/db/health', dbPool.healthCheckHandler());\n\n// Example route using the pool\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.dbQuery('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Example route using transactions\napp.post('/transfer', async (req, res) => {\n  try {\n    const result = await req.dbTransaction(async (client) => {\n      await client.query('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [100, 1]);\n      await client.query('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [100, 2]);\n      return { success: true };\n    });\n    res.json(result);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Pool statistics endpoint\napp.get('/db/stats', (req, res) => {\n  res.json(dbPool.getStats());\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n*/\n\n// Example .env file\n/*\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=postgres\nDB_PASSWORD=your_password\n*/\n```\n\nThis comprehensive implementation includes:\n\n## Key Features:\n\n1. **Connection Pooling**: Configurable pool with max/min connections, idle timeout, and connection timeout\n2. **Request Integration**: Attaches pool and helper methods to Express request object\n3. **Health Check Endpoint**: `/db/health` tests connectivity and returns pool statistics\n4. **Graceful Shutdown**: Handles SIGTERM, SIGINT, and uncaught exceptions\n5. **Event Monitoring**: Tracks pool events and maintains statistics\n6. **Transaction Support**: Helper method for database transactions\n7. **Query Helper**: Simplified query execution with timing\n8. **Error Handling**: Comprehensive error logging and handling\n\n## Usage:\n\n```javascript\n// Initialize with custom config\nconst dbPool = createDatabasePoolMiddleware({\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 10000\n});\n\n// Apply middleware\napp.use(dbPool.middleware());\n\n// Register health check\napp.get('/db/health', dbPool.healthCheckHandler());\n```\n\nThe middleware provides production-ready database connection pooling with monitoring, health checks, and graceful shutdown capabilities.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 92,
            "output_tokens": 2825,
            "cached": true
          },
          "with_skill": {
            "output": "# Express.js PostgreSQL Connection Pooling Middleware\n\nHere's a complete implementation of a production-ready connection pooling middleware for Express.js with Neon Postgres:\n\n```javascript\n// middleware/database.js\nimport { Pool } from 'pg';\n\n// Configuration with sensible defaults\nconst poolConfig = {\n  connectionString: process.env.DATABASE_URL,\n  \n  // Pool size configuration\n  max: parseInt(process.env.DB_POOL_MAX || '20', 10), // Maximum pool size\n  min: parseInt(process.env.DB_POOL_MIN || '2', 10),  // Minimum pool size\n  \n  // Timeout configuration\n  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000', 10), // 30 seconds\n  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || '10000', 10), // 10 seconds\n  \n  // Query timeout\n  query_timeout: parseInt(process.env.DB_QUERY_TIMEOUT || '30000', 10), // 30 seconds\n  \n  // Statement timeout (server-side)\n  statement_timeout: parseInt(process.env.DB_STATEMENT_TIMEOUT || '30000', 10), // 30 seconds\n  \n  // Allow graceful exit\n  allowExitOnIdle: true,\n};\n\n// Create the shared pool instance\nconst pool = new Pool(poolConfig);\n\n// Pool error handler - catches errors on idle clients\npool.on('error', (err, client) => {\n  console.error('Unexpected error on idle client', err);\n  // Don't exit the process - let the pool handle reconnection\n});\n\n// Pool connection event (useful for debugging)\npool.on('connect', (client) => {\n  console.log('New client connected to database');\n});\n\n// Pool removal event (useful for debugging)\npool.on('remove', (client) => {\n  console.log('Client removed from pool');\n});\n\n/**\n * Middleware to attach database pool to request object\n * Usage: app.use(databaseMiddleware);\n */\nexport function databaseMiddleware(req, res, next) {\n  // Attach the pool to the request object\n  req.db = pool;\n  \n  // Add a helper method for acquiring a client with automatic release\n  req.getDbClient = async () => {\n    const client = await pool.connect();\n    const release = client.release.bind(client);\n    \n    // Override release to add error handling\n    client.release = (err) => {\n      if (err) {\n        console.error('Error releasing client', err);\n      }\n      release();\n    };\n    \n    return client;\n  };\n  \n  next();\n}\n\n/**\n * Health check endpoint handler\n * Usage: app.get('/db/health', healthCheckHandler);\n */\nexport async function healthCheckHandler(req, res) {\n  const startTime = Date.now();\n  let client;\n  \n  try {\n    // Attempt to acquire a client from the pool\n    client = await pool.connect();\n    \n    // Test the connection with a simple query\n    const result = await client.query('SELECT NOW() as current_time, version() as pg_version');\n    \n    const responseTime = Date.now() - startTime;\n    \n    // Get pool statistics\n    const poolStats = {\n      totalCount: pool.totalCount,\n      idleCount: pool.idleCount,\n      waitingCount: pool.waitingCount,\n    };\n    \n    res.status(200).json({\n      status: 'healthy',\n      database: {\n        connected: true,\n        currentTime: result.rows[0].current_time,\n        version: result.rows[0].pg_version,\n        responseTime: `${responseTime}ms`,\n      },\n      pool: poolStats,\n      config: {\n        maxConnections: poolConfig.max,\n        minConnections: poolConfig.min,\n        idleTimeout: `${poolConfig.idleTimeoutMillis}ms`,\n        connectionTimeout: `${poolConfig.connectionTimeoutMillis}ms`,\n      },\n    });\n  } catch (error) {\n    console.error('Database health check failed:', error);\n    \n    res.status(503).json({\n      status: 'unhealthy',\n      database: {\n        connected: false,\n        error: error.message,\n        code: error.code,\n      },\n      pool: {\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount,\n      },\n    });\n  } finally {\n    // Always release the client back to the pool\n    if (client) {\n      client.release();\n    }\n  }\n}\n\n/**\n * Graceful shutdown handler\n * Call this in your shutdown logic\n */\nexport async function gracefulShutdown(signal = 'SIGTERM') {\n  console.log(`${signal} received. Starting graceful shutdown...`);\n  \n  try {\n    // Wait for all clients to finish their work and close connections\n    await pool.end();\n    console.log('Database pool has been closed successfully');\n    return true;\n  } catch (error) {\n    console.error('Error during database pool shutdown:', error);\n    throw error;\n  }\n}\n\n/**\n * Setup graceful shutdown handlers\n * Call this once during app initialization\n */\nexport function setupShutdownHandlers() {\n  // Handle SIGTERM (e.g., from Docker, Kubernetes)\n  process.on('SIGTERM', async () => {\n    try {\n      await gracefulShutdown('SIGTERM');\n      process.exit(0);\n    } catch (error) {\n      process.exit(1);\n    }\n  });\n  \n  // Handle SIGINT (e.g., Ctrl+C)\n  process.on('SIGINT', async () => {\n    try {\n      await gracefulShutdown('SIGINT');\n      process.exit(0);\n    } catch (error) {\n      process.exit(1);\n    }\n  });\n  \n  // Handle uncaught exceptions\n  process.on('uncaughtException', async (error) => {\n    console.error('Uncaught Exception:', error);\n    try {\n      await gracefulShutdown('uncaughtException');\n      process.exit(1);\n    } catch (shutdownError) {\n      process.exit(1);\n    }\n  });\n  \n  // Handle unhandled promise rejections\n  process.on('unhandledRejection', async (reason, promise) => {\n    console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n    try {\n      await gracefulShutdown('unhandledRejection');\n      process.exit(1);\n    } catch (shutdownError) {\n      process.exit(1);\n    }\n  });\n}\n\n// Export the pool for direct access if needed\nexport { pool };\n```\n\n## Usage Example\n\n```javascript\n// app.js\nimport express from 'express';\nimport {\n  databaseMiddleware,\n  healthCheckHandler,\n  setupShutdownHandlers,\n} from './middleware/database.js';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Setup graceful shutdown handlers\nsetupShutdownHandlers();\n\n// Apply database middleware globally\napp.use(databaseMiddleware);\n\n// Health check endpoint\napp.get('/db/health', healthCheckHandler);\n\n// Example route using the pool directly\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.db.query('SELECT id, name, email FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Database query failed' });\n  }\n});\n\n// Example route using a client with transaction\napp.post('/users', async (req, res) => {\n  const client = await req.getDbClient();\n  \n  try {\n    await client.query('BEGIN');\n    \n    const { name, email } = req.body;\n    const userResult = await client.query(\n      'INSERT INTO users(name, email) VALUES($1, $2) RETURNING id',\n      [name, email]\n    );\n    \n    const userId = userResult.rows[0].id;\n    \n    await client.query(\n      'INSERT INTO profiles(user_id, bio) VALUES($1, $2)',\n      [userId, 'New user profile']\n    );\n    \n    await client.query('COMMIT');\n    \n    res.status(201).json({ id: userId, name, email });\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('Transaction error:', error);\n    res.status(500).json({ error: 'Failed to create user' });\n  } finally {\n    client.release();\n  }\n});\n\n// Example route with parameterized query\napp.get('/users/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const result = await req.db.query(\n      'SELECT id, name, email, created_at FROM users WHERE id = $1',\n      [id]\n    );\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(result.rows[0]);\n  } catch (error) {\n    console.error('Error fetching user:', error);\n    res.status(500).json({ error: 'Database query failed' });\n  }\n});\n\nconst server = app.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n\n// Graceful shutdown for the HTTP server\nprocess.on('SIGTERM', () => {\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n});\n```\n\n## Environment Variables\n\nCreate a `.env` file:\n\n```bash\n# Required\nDATABASE_URL=postgresql://user:password@host.neon.tech/dbname\n\n# Optional - Pool Configuration\nDB_POOL_MAX=20                # Maximum number of clients in the pool\nDB_POOL_MIN=2                 # Minimum number of clients in the pool\nDB_IDLE_TIMEOUT=30000         # How long a client can be idle before being closed (ms)\nDB_CONNECTION_TIMEOUT=10000   # How long to wait for a connection (ms)\nDB_QUERY_TIMEOUT=30000        # Client-side query timeout (ms)\nDB_STATEMENT_TIMEOUT=30000    # Server-side statement timeout (ms)\n\n# Server\nPORT=3000\n```\n\n## Advanced Usage: Connection Pool Monitoring\n\n```javascript\n// middleware/poolMonitor.js\nimport { pool } from './database.js';\n\n/**\n * Middleware to log pool statistics on each request\n * Useful for debugging connection issues\n */\nexport function poolMonitorMiddleware(req, res, next) {\n  const stats = {\n    total: pool.totalCount,\n    idle: pool.idleCount,\n    waiting: pool.waitingCount,\n  };\n  \n  console.log(`[Pool Stats] Total: ${stats.total}, Idle: ${stats.idle}, Waiting: ${stats.waiting}`);\n  \n  // Attach to request for access in route handlers\n  req.poolStats = stats;\n  \n  next();\n}\n\n/**\n * Endpoint to get detailed pool statistics\n */\nexport function poolStatsHandler(req, res) {\n  res.json({\n    pool: {\n      totalCount: pool.totalCount,\n      idleCount: pool.idleCount,\n      waitingCount: pool.waitingCount,\n    },\n    config: {\n      max: pool.options.max,\n      min: pool.options.min,\n      idleTimeoutMillis: pool.options.idleTimeoutMillis,\n      connectionTimeoutMillis: pool.options.connectionTimeoutMillis,\n    },\n  });\n}\n```\n\n## Testing the Health Check\n\n```bash\n# Test the health check endpoint\ncurl http://localhost:3000/db/health\n\n# Expected response:\n{\n  \"status\": \"healthy\",\n  \"database\": {\n    \"connected\": true,\n    \"currentTime\": \"2024-01-15T10:30:00.000Z\",\n    \"version\": \"PostgreSQL 16.0 on x86_64-pc-linux-gnu...\",\n    \"responseTime\": \"45ms\"\n  },\n  \"pool\": {\n    \"totalCount\": 2,\n    \"idleCount\": 2,\n    \"waitingCount\": 0\n  },\n  \"config\": {\n    \"maxConnections\": 20,\n    \"minConnections\": 2,\n    \"idleTimeout\": \"30000ms\",\n    \"connectionTimeout\": \"10000ms\"\n  }\n}\n```\n\n## Key Features\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Attachment**: Pool accessible via `req.db` in all routes\n3. **Helper Method**: `req.getDbClient()` for transaction support with automatic error handling\n4. **Health Check**: Comprehensive endpoint testing connection and returning pool stats\n5. **Graceful Shutdown**: Proper cleanup on SIGTERM, SIGINT, and uncaught errors\n6. **Error Handling**: Pool-level error handlers and per-query error handling\n7. **Configuration**: Environment-based configuration for all timeouts and limits\n8. **Monitoring**: Pool statistics available for debugging\n\nThis implementation follows Neon's best practices for long-running servers with connection pooling.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10304,
            "output_tokens": 3348,
            "cached": false
          },
          "skill_md_only": {
            "output": "# PostgreSQL Connection Pooling Middleware for Express.js\n\nHere's a complete implementation of an Express.js middleware with PostgreSQL connection pooling using the `pg` library:\n\n```javascript\n// db-pool-middleware.js\nconst { Pool } = require('pg');\n\n/**\n * Creates and configures a PostgreSQL connection pool\n * @param {Object} config - Pool configuration options\n * @returns {Pool} Configured pg Pool instance\n */\nfunction createPool(config = {}) {\n  const poolConfig = {\n    // Connection settings\n    connectionString: config.connectionString || process.env.DATABASE_URL,\n    \n    // Pool size configuration\n    max: config.max || parseInt(process.env.DB_POOL_MAX) || 20,\n    min: config.min || parseInt(process.env.DB_POOL_MIN) || 2,\n    \n    // Timeout configuration (in milliseconds)\n    idleTimeoutMillis: config.idleTimeoutMillis || \n                       parseInt(process.env.DB_IDLE_TIMEOUT) || 30000,\n    connectionTimeoutMillis: config.connectionTimeoutMillis || \n                            parseInt(process.env.DB_CONNECTION_TIMEOUT) || 10000,\n    \n    // Query timeout\n    query_timeout: config.queryTimeout || \n                   parseInt(process.env.DB_QUERY_TIMEOUT) || 30000,\n    \n    // Statement timeout (PostgreSQL server-side)\n    statement_timeout: config.statementTimeout || \n                       parseInt(process.env.DB_STATEMENT_TIMEOUT) || 30000,\n    \n    // SSL configuration for production (Neon requires SSL)\n    ssl: config.ssl !== undefined ? config.ssl : \n         (process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false),\n    \n    // Application name for connection tracking\n    application_name: config.applicationName || \n                      process.env.APP_NAME || \n                      'express-app',\n  };\n\n  const pool = new Pool(poolConfig);\n\n  // Pool event handlers for monitoring\n  pool.on('connect', (client) => {\n    console.log('New client connected to the pool');\n  });\n\n  pool.on('acquire', (client) => {\n    console.log('Client acquired from pool');\n  });\n\n  pool.on('remove', (client) => {\n    console.log('Client removed from pool');\n  });\n\n  pool.on('error', (err, client) => {\n    console.error('Unexpected error on idle client', err);\n    // Don't exit the process, let the pool handle it\n  });\n\n  return pool;\n}\n\n/**\n * Express middleware that attaches the database pool to the request object\n * @param {Pool} pool - PostgreSQL connection pool\n * @returns {Function} Express middleware function\n */\nfunction dbPoolMiddleware(pool) {\n  return (req, res, next) => {\n    // Attach pool to request object\n    req.db = pool;\n    \n    // Helper method to get a client from the pool\n    req.getDbClient = async () => {\n      try {\n        const client = await pool.connect();\n        \n        // Wrap the release method to ensure it's called\n        const originalRelease = client.release.bind(client);\n        client.release = () => {\n          console.log('Client released back to pool');\n          originalRelease();\n        };\n        \n        return client;\n      } catch (error) {\n        console.error('Error acquiring client from pool:', error);\n        throw error;\n      }\n    };\n    \n    // Helper method for simple queries\n    req.query = async (text, params) => {\n      const start = Date.now();\n      try {\n        const result = await pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: result.rowCount });\n        return result;\n      } catch (error) {\n        console.error('Query error:', error);\n        throw error;\n      }\n    };\n    \n    next();\n  };\n}\n\n/**\n * Health check endpoint handler\n * Tests database connectivity and returns pool statistics\n */\nasync function healthCheckHandler(req, res) {\n  const startTime = Date.now();\n  \n  try {\n    // Test database connection with a simple query\n    const result = await req.db.query('SELECT NOW() as current_time, version() as pg_version');\n    \n    const responseTime = Date.now() - startTime;\n    \n    // Get pool statistics\n    const poolStats = {\n      totalCount: req.db.totalCount,\n      idleCount: req.db.idleCount,\n      waitingCount: req.db.waitingCount,\n    };\n    \n    res.status(200).json({\n      status: 'healthy',\n      database: {\n        connected: true,\n        currentTime: result.rows[0].current_time,\n        version: result.rows[0].pg_version,\n        responseTime: `${responseTime}ms`,\n      },\n      pool: poolStats,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('Health check failed:', error);\n    \n    res.status(503).json({\n      status: 'unhealthy',\n      database: {\n        connected: false,\n        error: error.message,\n      },\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n/**\n * Graceful shutdown handler\n * Closes all connections in the pool\n */\nasync function gracefulShutdown(pool, signal) {\n  console.log(`\\n${signal} received. Starting graceful shutdown...`);\n  \n  try {\n    // Stop accepting new connections\n    console.log('Closing database connection pool...');\n    \n    // End the pool (waits for all clients to be released)\n    await pool.end();\n    \n    console.log('Database pool closed successfully');\n    process.exit(0);\n  } catch (error) {\n    console.error('Error during graceful shutdown:', error);\n    process.exit(1);\n  }\n}\n\n/**\n * Initialize database pool and middleware\n * @param {Object} app - Express application instance\n * @param {Object} config - Pool configuration options\n * @returns {Pool} The created pool instance\n */\nfunction initializeDatabase(app, config = {}) {\n  // Create the pool\n  const pool = createPool(config);\n  \n  // Apply middleware to all routes\n  app.use(dbPoolMiddleware(pool));\n  \n  // Add health check endpoint\n  app.get('/db/health', healthCheckHandler);\n  \n  // Setup graceful shutdown handlers\n  process.on('SIGTERM', () => gracefulShutdown(pool, 'SIGTERM'));\n  process.on('SIGINT', () => gracefulShutdown(pool, 'SIGINT'));\n  \n  // Test initial connection\n  pool.query('SELECT NOW()')\n    .then(() => {\n      console.log('Database pool initialized successfully');\n      console.log(`Pool configuration: max=${pool.options.max}, idle_timeout=${pool.options.idleTimeoutMillis}ms`);\n    })\n    .catch((error) => {\n      console.error('Failed to initialize database pool:', error);\n      process.exit(1);\n    });\n  \n  return pool;\n}\n\nmodule.exports = {\n  createPool,\n  dbPoolMiddleware,\n  healthCheckHandler,\n  gracefulShutdown,\n  initializeDatabase,\n};\n```\n\n## Usage Example\n\n```javascript\n// app.js\nconst express = require('express');\nconst { initializeDatabase } = require('./db-pool-middleware');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Initialize database with custom configuration\nconst pool = initializeDatabase(app, {\n  max: 25,                      // Maximum pool size\n  min: 5,                       // Minimum pool size\n  idleTimeoutMillis: 60000,     // 60 seconds\n  connectionTimeoutMillis: 5000, // 5 seconds\n  queryTimeout: 30000,          // 30 seconds\n});\n\n// Example route using the pool directly\napp.get('/users', async (req, res) => {\n  try {\n    const result = await req.query('SELECT * FROM users LIMIT 10');\n    res.json(result.rows);\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Database error' });\n  }\n});\n\n// Example route using a dedicated client (for transactions)\napp.post('/users', async (req, res) => {\n  const client = await req.getDbClient();\n  \n  try {\n    await client.query('BEGIN');\n    \n    const insertResult = await client.query(\n      'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',\n      [req.body.name, req.body.email]\n    );\n    \n    await client.query('COMMIT');\n    \n    res.status(201).json(insertResult.rows[0]);\n  } catch (error) {\n    await client.query('ROLLBACK');\n    console.error('Transaction error:', error);\n    res.status(500).json({ error: 'Transaction failed' });\n  } finally {\n    client.release();\n  }\n});\n\n// Example route with error handling\napp.get('/stats', async (req, res) => {\n  try {\n    const result = await req.query(`\n      SELECT \n        COUNT(*) as total_users,\n        COUNT(CASE WHEN created_at > NOW() - INTERVAL '24 hours' THEN 1 END) as new_users_24h\n      FROM users\n    `);\n    \n    res.json(result.rows[0]);\n  } catch (error) {\n    console.error('Error fetching stats:', error);\n    res.status(500).json({ error: 'Failed to fetch statistics' });\n  }\n});\n\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n  console.log(`Health check available at http://localhost:${PORT}/db/health`);\n});\n```\n\n## Environment Variables\n\nCreate a `.env` file:\n\n```bash\n# Database connection\nDATABASE_URL=postgresql://user:password@host:5432/database\n\n# For Neon (example)\n# DATABASE_URL=postgresql://user:password@ep-cool-name-123456.us-east-2.aws.neon.tech/neondb?sslmode=require\n\n# Pool configuration\nDB_POOL_MAX=20\nDB_POOL_MIN=2\nDB_IDLE_TIMEOUT=30000\nDB_CONNECTION_TIMEOUT=10000\nDB_QUERY_TIMEOUT=30000\nDB_STATEMENT_TIMEOUT=30000\n\n# Application\nNODE_ENV=production\nAPP_NAME=my-express-app\nPORT=3000\n```\n\n## Package.json\n\n```json\n{\n  \"name\": \"express-pg-pool\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Express.js with PostgreSQL connection pooling\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"dev\": \"nodemon app.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"pg\": \"^8.11.3\",\n    \"dotenv\": \"^16.3.1\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.1\"\n  }\n}\n```\n\n## Testing the Health Check\n\n```bash\n# Check database health\ncurl http://localhost:3000/db/health\n\n# Expected response:\n{\n  \"status\": \"healthy\",\n  \"database\": {\n    \"connected\": true,\n    \"currentTime\": \"2024-01-15T10:30:45.123Z\",\n    \"version\": \"PostgreSQL 16.0 on x86_64-pc-linux-gnu...\",\n    \"responseTime\": \"15ms\"\n  },\n  \"pool\": {\n    \"totalCount\": 5,\n    \"idleCount\": 4,\n    \"waitingCount\": 0\n  },\n  \"timestamp\": \"2024-01-15T10:30:45.123Z\"\n}\n```\n\n## Key Features\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Request Attachment**: Pool accessible via `req.db`\n3. **Helper Methods**: \n   - `req.query()` for simple queries\n   - `req.getDbClient()` for transactions\n4. **Health Check**: `/db/health` endpoint with pool statistics\n5. **Graceful Shutdown**: Handles SIGTERM/SIGINT properly\n6. **Configurable**: All timeouts and pool sizes configurable\n7. **Error Handling**: Comprehensive error logging\n8. **Monitoring**: Pool event handlers for debugging\n\n## Best Practices for Neon\n\nWhen using with Neon Serverless Postgres:\n\n1. **Use Connection Pooling**: Neon recommends pooled connections for serverless\n2. **SSL Required**: Always use SSL in production (`sslmode=require`)\n3. **Reasonable Pool Size**: Start with 10-20 connections\n4. **Monitor Connections**: Use the health check to track pool usage\n5. **Handle Timeouts**: Set appropriate query and connection timeouts\n\nFor more information on Neon connection pooling, see: https://neon.com/docs/connect/connection-pooling.md",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2234,
            "output_tokens": 3329,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive PostgreSQL connection pooling middleware for your Express.js application.\n\n```javascript\n// src/middleware/db.js\nimport pg from 'pg';\nconst { Pool } = pg;\n\n// Create a shared pool instance\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  max: parseInt(process.env.DB_POOL_MAX || '20', 10), // Maximum pool size\n  idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000', 10), // 30 seconds\n  connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || '10000', 10), // 10 seconds\n  allowExitOnIdle: false, // Keep pool alive even when idle\n});\n\n// Pool error handler - log unexpected errors on idle clients\npool.on('error', (err, client) => {\n  console.error('Unexpected error on idle PostgreSQL client', err);\n});\n\n// Pool connection event - useful for debugging\npool.on('connect', (client) => {\n  console.log('New PostgreSQL client connected to pool');\n});\n\n// Pool removal event - useful for debugging\npool.on('remove', (client) => {\n  console.log('PostgreSQL client removed from pool');\n});\n\n/**\n * Middleware to attach database pool to request object\n */\nexport function attachDb(req, res, next) {\n  req.db = pool;\n  next();\n}\n\n/**\n * Health check endpoint handler\n * Tests database connectivity and returns pool statistics\n */\nexport async function dbHealthCheck(req, res) {\n  const startTime = Date.now();\n  \n  try {\n    // Test connection with a simple query\n    const result = await pool.query('SELECT NOW() as current_time, version() as pg_version');\n    const responseTime = Date.now() - startTime;\n    \n    // Get pool statistics\n    const poolStats = {\n      totalCount: pool.totalCount,\n      idleCount: pool.idleCount,\n      waitingCount: pool.waitingCount,\n    };\n    \n    res.status(200).json({\n      status: 'healthy',\n      database: 'postgresql',\n      responseTime: `${responseTime}ms`,\n      timestamp: result.rows[0].current_time,\n      version: result.rows[0].pg_version,\n      pool: poolStats,\n    });\n  } catch (error) {\n    const responseTime = Date.now() - startTime;\n    \n    console.error('Database health check failed:', error);\n    \n    res.status(503).json({\n      status: 'unhealthy',\n      database: 'postgresql',\n      responseTime: `${responseTime}ms`,\n      error: error.message,\n      pool: {\n        totalCount: pool.totalCount,\n        idleCount: pool.idleCount,\n        waitingCount: pool.waitingCount,\n      },\n    });\n  }\n}\n\n/**\n * Graceful shutdown handler\n * Closes all connections in the pool\n */\nexport async function closePool() {\n  console.log('Closing PostgreSQL connection pool...');\n  \n  try {\n    await pool.end();\n    console.log('PostgreSQL connection pool closed successfully');\n  } catch (error) {\n    console.error('Error closing PostgreSQL connection pool:', error);\n    throw error;\n  }\n}\n\n// Register graceful shutdown handlers\nprocess.on('SIGTERM', async () => {\n  console.log('SIGTERM received, initiating graceful shutdown');\n  try {\n    await closePool();\n    process.exit(0);\n  } catch (error) {\n    console.error('Error during graceful shutdown:', error);\n    process.exit(1);\n  }\n});\n\nprocess.on('SIGINT', async () => {\n  console.log('SIGINT received, initiating graceful shutdown');\n  try {\n    await closePool();\n    process.exit(0);\n  } catch (error) {\n    console.error('Error during graceful shutdown:', error);\n    process.exit(1);\n  }\n});\n\n// Export pool for direct access if needed\nexport { pool };\n```\n\nNow let's create an example of how to use this middleware in your Express app:\n\n```javascript\n// src/app.js (or wherever you initialize Express)\nimport express from 'express';\nimport { attachDb, dbHealthCheck } from './middleware/db.js';\n\nconst app = express();\n\n// Attach database pool to all requests\napp.use(attachDb);\n\n// Health check endpoint\napp.get('/db/health', dbHealthCheck);\n\n// Example route using the database\napp.get('/users/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Use the pool attached to the request\n    const result = await req.db.query(\n      'SELECT id, email, name FROM users WHERE id = $1',\n      [id]\n    );\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(result.rows[0]);\n  } catch (error) {\n    console.error('Database query error:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\nexport default app;\n```\n\nAnd here's an `.env.example` file with the configuration options:\n\n```bash\n# .env.example\n\n# PostgreSQL connection string\nDATABASE_URL=postgresql://username:password@localhost:5432/dbname\n\n# Pool configuration\nDB_POOL_MAX=20                # Maximum number of clients in the pool\nDB_IDLE_TIMEOUT=30000         # How long a client can be idle before being closed (ms)\nDB_CONNECTION_TIMEOUT=10000   # How long to wait when connecting a new client (ms)\n\n# JWT secret (existing)\nJWT_SECRET=your-secret-key\n```\n\nFinally, here's a utility module for common database operations with proper error handling:\n\n```javascript\n// src/utils/db-helpers.js\nimport { pool } from '../middleware/db.js';\n\n/**\n * Execute a query with automatic client management\n */\nexport async function query(text, params) {\n  const start = Date.now();\n  try {\n    const result = await pool.query(text, params);\n    const duration = Date.now() - start;\n    console.log('Executed query', { text, duration, rows: result.rowCount });\n    return result;\n  } catch (error) {\n    console.error('Query error', { text, error: error.message });\n    throw error;\n  }\n}\n\n/**\n * Execute a transaction with automatic rollback on error\n */\nexport async function transaction(callback) {\n  const client = await pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n    const result = await callback(client);\n    await client.query('COMMIT');\n    return result;\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get a client from the pool for manual management\n * Remember to call client.release() when done!\n */\nexport async function getClient() {\n  return await pool.connect();\n}\n```\n\nExample usage of the transaction helper:\n\n```javascript\n// src/routes/orders.js\nimport express from 'express';\nimport { transaction } from '../utils/db-helpers.js';\n\nconst router = express.Router();\n\nrouter.post('/orders', async (req, res) => {\n  try {\n    const { userId, items } = req.body;\n    \n    const order = await transaction(async (client) => {\n      // Insert order\n      const orderResult = await client.query(\n        'INSERT INTO orders (user_id, total) VALUES ($1, $2) RETURNING id',\n        [userId, 0]\n      );\n      const orderId = orderResult.rows[0].id;\n      \n      // Insert order items and calculate total\n      let total = 0;\n      for (const item of items) {\n        await client.query(\n          'INSERT INTO order_items (order_id, product_id, quantity, price) VALUES ($1, $2, $3, $4)',\n          [orderId, item.productId, item.quantity, item.price]\n        );\n        total += item.price * item.quantity;\n      }\n      \n      // Update order total\n      await client.query(\n        'UPDATE orders SET total = $1 WHERE id = $2',\n        [total, orderId]\n      );\n      \n      return { orderId, total };\n    });\n    \n    res.status(201).json(order);\n  } catch (error) {\n    console.error('Order creation failed:', error);\n    res.status(500).json({ error: 'Failed to create order' });\n  }\n});\n\nexport default router;\n```\n\n**Key Features:**\n\n1. **Shared Pool Instance**: Single pool shared across all requests\n2. **Configuration**: Environment variables for max pool size, timeouts\n3. **Health Check**: `/db/health` endpoint with connection test and pool stats\n4. **Graceful Shutdown**: Handles SIGTERM/SIGINT to close connections properly\n5. **Error Handling**: Pool-level error handler for unexpected issues\n6. **Request Attachment**: Pool available as `req.db` in all routes\n7. **Helper Utilities**: Transaction support and query helpers\n8. **Logging**: Connection events and query execution tracking\n\nThe middleware is production-ready and follows best practices for connection pooling in Node.js applications.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 10770,
            "output_tokens": 2338,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-04",
      "task_type": "grounded",
      "target_language": "typescript",
      "expected_patterns": [
        "import.*drizzle-orm|from.*drizzle",
        "pgTable|serial|varchar|timestamp",
        "relations\\(|one\\(|many\\(",
        "eq\\(|and\\(",
        "export\\s+const",
        "InferSelectModel|InferInsertModel|typeof"
      ],
      "anti_patterns": [
        "import.*prisma|@prisma",
        "neon_api|NeonAPI",
        "from neon_api",
        "import psycopg",
        "class.*Model.*:",
        "def\\s+"
      ],
      "pattern_sources": [
        {
          "url": "https://neon.com/docs/guides/drizzle.md",
          "description": "Drizzle ORM with Neon: import from drizzle-orm, schema definition with pgTable/serial/text/timestamp, db.insert().values(), db.select().from(), connection setup with drizzle(neon()) or drizzle(new Pool())"
        },
        {
          "url": "https://orm.drizzle.team/docs/column-types/pg",
          "description": "Drizzle ORM PostgreSQL column types: pgTable, serial, varchar, timestamp schema definition patterns"
        },
        {
          "url": "https://orm.drizzle.team/docs/rqb",
          "description": "Drizzle ORM relational queries: relations(), one(), many() relationship patterns, eq() filter operator"
        },
        {
          "url": "https://orm.drizzle.team/docs/operators",
          "description": "Drizzle ORM query operators - source of and() operator for combining multiple filter conditions in WHERE clauses"
        },
        {
          "url": "https://orm.drizzle.team/docs/goodies#type-api",
          "description": "Drizzle ORM type helpers: InferSelectModel, InferInsertModel, typeof for TypeScript type inference"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "```typescript\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { \n  pgTable, \n  serial, \n  varchar, \n  integer, \n  timestamp,\n  unique\n} from 'drizzle-orm/pg-core';\nimport { relations, eq, sql } from 'drizzle-orm';\nimport { InferSelectModel, InferInsertModel } from 'drizzle-orm';\nimport { Pool } from 'pg';\n\n// ============================================\n// Schema Definitions\n// ============================================\n\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// ============================================\n// Relations\n// ============================================\n\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// ============================================\n// Types\n// ============================================\n\nexport type Organization = InferSelectModel<typeof organizations>;\nexport type NewOrganization = InferInsertModel<typeof organizations>;\n\nexport type Member = InferSelectModel<typeof members>;\nexport type NewMember = InferInsertModel<typeof members>;\n\nexport type OrganizationWithMemberCount = Organization & {\n  memberCount: number;\n};\n\n// ============================================\n// Database Setup\n// ============================================\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle(pool);\n\n// ============================================\n// Query Functions\n// ============================================\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List all members with organization details\n */\nexport async function listOrgMembersWithDetails(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n      organization: {\n        id: organizations.id,\n        name: organizations.name,\n        slug: organizations.slug,\n      },\n    })\n    .from(members)\n    .innerJoin(organizations, eq(members.orgId, organizations.id))\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a member to an organization\n */\nexport async function addMember(data: {\n  orgId: number;\n  email: string;\n  role?: string;\n}) {\n  const [newMember] = await db\n    .insert(members)\n    .values({\n      orgId: data.orgId,\n      email: data.email,\n      role: data.role || 'member',\n    })\n    .returning();\n  \n  return newMember;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(\n  orgId: number\n): Promise<OrganizationWithMemberCount | undefined> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as integer)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0];\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(\n  slug: string\n): Promise<OrganizationWithMemberCount | undefined> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as integer)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0];\n}\n\n/**\n * Remove a member from an organization\n */\nexport async function removeMember(memberId: number) {\n  const [deleted] = await db\n    .delete(members)\n    .where(eq(members.id, memberId))\n    .returning();\n  \n  return deleted;\n}\n\n/**\n * Update member role\n */\nexport async function updateMemberRole(memberId: number, role: string) {\n  const [updated] = await db\n    .update(members)\n    .set({ role })\n    .where(eq(members.id, memberId))\n    .returning();\n  \n  return updated;\n}\n\n/**\n * Check if member exists in organization\n */\nexport async function memberExists(orgId: number, email: string): Promise<boolean> {\n  const result = await db\n    .select({ id: members.id })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .where(eq(members.email, email))\n    .limit(1);\n  \n  return result.length > 0;\n}\n\n// ============================================\n// Usage Examples\n// ============================================\n\n/*\n// List all members of an organization\nconst orgMembers = await listOrgMembers(1);\n\n// Add a new member\nconst newMember = await addMember({\n  orgId: 1,\n  email: 'user@example.com',\n  role: 'admin'\n});\n\n// Get organization with member count\nconst orgDetails = await getOrgWithMemberCount(1);\nconsole.log(`${orgDetails?.name} has ${orgDetails?.memberCount} members`);\n\n// Get organization by slug\nconst org = await getOrgBySlugWithMemberCount('acme-corp');\n\n// Update member role\nawait updateMemberRole(1, 'admin');\n\n// Remove a member\nawait removeMember(1);\n\n// Check if member exists\nconst exists = await memberExists(1, 'user@example.com');\n*/\n```\n\nThis code provides:\n\n1. **Complete schema definition** with proper types, constraints, and relations\n2. **Type safety** using Drizzle's inference utilities\n3. **All requested query functions** plus additional useful ones\n4. **Proper foreign key relationships** with cascade delete\n5. **Unique constraint** on org_id + email combination\n6. **Aggregation query** for member count using SQL template\n7. **Returning clauses** for insert/update/delete operations\n8. **Usage examples** in comments\n\nThe schema is fully typed and provides excellent TypeScript autocomplete support!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 202,
            "output_tokens": 1961,
            "cached": true
          },
          "with_skill": {
            "output": "# Drizzle ORM Schema and Query Functions\n\nHere's a complete implementation with schema definitions, relations, and typed query functions:\n\n## Schema Definition\n\n```typescript\n// src/schema.ts\nimport {\n  pgTable,\n  serial,\n  varchar,\n  timestamp,\n  integer,\n  unique,\n} from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\n// Organizations table\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable(\n  \"members\",\n  {\n    id: serial(\"id\").primaryKey(),\n    orgId: integer(\"org_id\")\n      .notNull()\n      .references(() => organizations.id, { onDelete: \"cascade\" }),\n    email: varchar(\"email\", { length: 255 }).notNull(),\n    role: varchar(\"role\", { length: 50 }).default(\"member\").notNull(),\n    joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n  },\n  (table) => ({\n    // Composite unique constraint\n    uniqueOrgEmail: unique().on(table.orgId, table.email),\n  }),\n);\n\n// Relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## Database Connection Setup\n\n```typescript\n// src/db.ts\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { Pool } from \"pg\";\nimport * as schema from \"./schema\";\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle({ client: pool, schema });\n```\n\n## Query Functions\n\n```typescript\n// src/queries.ts\nimport { eq, sql, count } from \"drizzle-orm\";\nimport { db } from \"./db\";\nimport { organizations, members, type NewMember, type Member } from \"./schema\";\n\n/**\n * List all members of an organization by org ID\n */\nexport async function listOrgMembers(orgId: number): Promise<Member[]> {\n  return db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List all members of an organization by slug\n */\nexport async function listOrgMembersBySlug(\n  slug: string,\n): Promise<Member[] | null> {\n  const org = await db\n    .select({ id: organizations.id })\n    .from(organizations)\n    .where(eq(organizations.slug, slug))\n    .limit(1);\n\n  if (org.length === 0) return null;\n\n  return listOrgMembers(org[0].id);\n}\n\n/**\n * Add a member to an organization\n * Returns the created member or null if org doesn't exist\n */\nexport async function addMember(\n  orgId: number,\n  email: string,\n  role: string = \"member\",\n): Promise<Member | null> {\n  try {\n    // Verify organization exists\n    const org = await db\n      .select({ id: organizations.id })\n      .from(organizations)\n      .where(eq(organizations.id, orgId))\n      .limit(1);\n\n    if (org.length === 0) return null;\n\n    const [newMember] = await db\n      .insert(members)\n      .values({\n        orgId,\n        email,\n        role,\n      })\n      .returning();\n\n    return newMember;\n  } catch (error: any) {\n    // Handle unique constraint violation\n    if (error.code === \"23505\") {\n      throw new Error(`Member with email ${email} already exists in this organization`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(slug: string) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get organization with all members (using relations)\n */\nexport async function getOrgWithMembers(orgId: number) {\n  return db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n## Usage Examples\n\n```typescript\n// src/example-usage.ts\nimport {\n  listOrgMembers,\n  addMember,\n  getOrgWithMemberCount,\n  getOrgBySlugWithMemberCount,\n  getOrgWithMembers,\n} from \"./queries\";\n\nasync function examples() {\n  // List all members of organization with ID 1\n  const members = await listOrgMembers(1);\n  console.log(\"Members:\", members);\n\n  // Add a new member\n  try {\n    const newMember = await addMember(1, \"user@example.com\", \"admin\");\n    console.log(\"New member:\", newMember);\n  } catch (error) {\n    console.error(\"Failed to add member:\", error);\n  }\n\n  // Get org details with member count\n  const orgDetails = await getOrgWithMemberCount(1);\n  console.log(\"Organization:\", orgDetails);\n  // Output: { id: 1, name: \"...\", slug: \"...\", createdAt: ..., memberCount: 5 }\n\n  // Get org by slug with member count\n  const orgBySlug = await getOrgBySlugWithMemberCount(\"acme-corp\");\n  console.log(\"Organization by slug:\", orgBySlug);\n\n  // Get org with all members using relations\n  const orgWithMembers = await getOrgWithMembers(1);\n  console.log(\"Organization with members:\", orgWithMembers);\n  // Output: { id: 1, name: \"...\", members: [...] }\n}\n```\n\n## Batch Operations\n\n```typescript\n// src/batch-operations.ts\nimport { db } from \"./db\";\nimport { members, type NewMember } from \"./schema\";\n\n/**\n * Batch insert multiple members\n */\nexport async function batchAddMembers(\n  newMembers: NewMember[],\n): Promise<Member[]> {\n  return db.insert(members).values(newMembers).returning();\n}\n\n/**\n * Example: Add multiple members to an organization\n */\nasync function addMultipleMembers() {\n  const newMembers = [\n    { orgId: 1, email: \"user1@example.com\", role: \"member\" },\n    { orgId: 1, email: \"user2@example.com\", role: \"admin\" },\n    { orgId: 1, email: \"user3@example.com\", role: \"member\" },\n  ];\n\n  const inserted = await batchAddMembers(newMembers);\n  console.log(`Inserted ${inserted.length} members`);\n}\n```\n\n## Drizzle Config\n\n```typescript\n// drizzle.config.ts\nimport { config } from \"dotenv\";\nimport { defineConfig } from \"drizzle-kit\";\n\nconfig({ path: \".env.local\" });\n\nexport default defineConfig({\n  schema: \"./src/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n## Key Features\n\n1. **Type Safety**: Full TypeScript inference for all queries\n2. **Relations**: Defined for easy joins and nested queries\n3. **Composite Unique Constraint**: Enforces unique (org_id, email) pairs\n4. **Error Handling**: Catches unique constraint violations\n5. **Flexible Queries**: Multiple ways to query (by ID, slug, with relations)\n6. **Batch Operations**: Efficient bulk inserts\n7. **Null Safety**: Returns `null` when records don't exist\n\nThis implementation follows Drizzle best practices and provides a solid foundation for working with your organization/member schema.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6223,
            "output_tokens": 2409,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Drizzle ORM Schema and Queries for Organizations & Members\n\nHere's a complete Drizzle ORM implementation with schema definitions, relations, and typed query functions.\n\n## 1. Schema Definition\n\n```typescript\n// db/schema.ts\nimport { pgTable, serial, varchar, timestamp, integer, unique } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\n// Organizations table\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).notNull().default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  // Composite unique constraint\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// Define relations for type-safe joins\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type exports\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## 2. Database Connection Setup\n\n```typescript\n// db/index.ts\nimport { neon } from '@neondatabase/serverless';\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport * as schema from './schema';\n\n// Get connection string from environment\nconst sql = neon(process.env.DATABASE_URL!);\n\n// Create Drizzle instance with schema\nexport const db = drizzle(sql, { schema });\n```\n\n## 3. Query Functions\n\n```typescript\n// db/queries.ts\nimport { eq, sql, count } from 'drizzle-orm';\nimport { db } from './index';\nimport { organizations, members, type NewMember, type Member } from './schema';\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number): Promise<Member[]> {\n  return db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n * Returns the created member or throws on duplicate email\n */\nexport async function addMember(\n  data: Omit<NewMember, 'id' | 'joinedAt'>\n): Promise<Member> {\n  const [newMember] = await db\n    .insert(members)\n    .values(data)\n    .returning();\n  \n  return newMember;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Alternative: Get org with member count using subquery\n */\nexport async function getOrgWithMemberCountAlt(orgId: number) {\n  const org = await db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        columns: { id: true },\n      },\n    },\n  });\n\n  if (!org) return null;\n\n  return {\n    ...org,\n    memberCount: org.members.length,\n    members: undefined, // Remove members array from response\n  };\n}\n```\n\n## 4. Usage Examples\n\n```typescript\n// examples/usage.ts\nimport { listOrgMembers, addMember, getOrgWithMemberCount } from './db/queries';\n\nasync function examples() {\n  // List all members of organization with ID 1\n  const members = await listOrgMembers(1);\n  console.log('Members:', members);\n\n  // Add a new member\n  try {\n    const newMember = await addMember({\n      orgId: 1,\n      email: 'user@example.com',\n      role: 'admin',\n    });\n    console.log('Added member:', newMember);\n  } catch (error) {\n    // Handle duplicate email error\n    console.error('Failed to add member:', error);\n  }\n\n  // Get org details with member count\n  const orgDetails = await getOrgWithMemberCount(1);\n  console.log('Organization:', orgDetails);\n  // Output: { id: 1, name: '...', slug: '...', createdAt: ..., memberCount: 5 }\n}\n```\n\n## 5. Additional Helper Queries\n\n```typescript\n// db/queries.ts (continued)\n\n/**\n * Get organization by slug\n */\nexport async function getOrgBySlug(slug: string) {\n  return db.query.organizations.findFirst({\n    where: eq(organizations.slug, slug),\n  });\n}\n\n/**\n * Get member with organization details\n */\nexport async function getMemberWithOrg(memberId: number) {\n  return db.query.members.findFirst({\n    where: eq(members.id, memberId),\n    with: {\n      organization: true,\n    },\n  });\n}\n\n/**\n * Update member role\n */\nexport async function updateMemberRole(memberId: number, role: string) {\n  const [updated] = await db\n    .update(members)\n    .set({ role })\n    .where(eq(members.id, memberId))\n    .returning();\n  \n  return updated;\n}\n\n/**\n * Remove member from organization\n */\nexport async function removeMember(memberId: number) {\n  await db\n    .delete(members)\n    .where(eq(members.id, memberId));\n}\n```\n\n## 6. Environment Setup\n\n```bash\n# .env\nDATABASE_URL=postgresql://user:password@host/database\n```\n\n## 7. Package Dependencies\n\n```json\n{\n  \"dependencies\": {\n    \"@neondatabase/serverless\": \"^0.10.4\",\n    \"drizzle-orm\": \"^0.36.4\"\n  },\n  \"devDependencies\": {\n    \"drizzle-kit\": \"^0.28.1\"\n  }\n}\n```\n\n## Key Features\n\n\u2705 **Type Safety**: Full TypeScript inference for queries and results  \n\u2705 **Relations**: Defined for type-safe joins using `db.query` API  \n\u2705 **Composite Unique**: Proper `UNIQUE(org_id, email)` constraint  \n\u2705 **Cascade Delete**: Foreign key with `onDelete: 'cascade'`  \n\u2705 **Default Values**: `defaultNow()` for timestamps, `default('member')` for role  \n\u2705 **Returning Clause**: Get inserted/updated records immediately  \n\n## Notes\n\n- The schema uses `neon-http` driver for serverless/edge compatibility\n- All queries are fully typed - TypeScript will catch errors at compile time\n- The `unique()` constraint properly implements the composite unique key\n- Relations enable the relational query API (`db.query.*`) for cleaner joins\n- Error handling for duplicate emails should catch Postgres unique constraint violations\n\nFor more Drizzle ORM patterns with Neon, see: https://neon.com/docs/guides/drizzle.md",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2344,
            "output_tokens": 2074,
            "cached": false
          },
          "realistic": {
            "output": "I'll create a complete Drizzle ORM setup for your schema with typed query functions.\n\nFirst, let me check if Drizzle is already installed:\n\n```typescript\n// package.json dependencies check\n```\n\nNow I'll create the schema and query functions:\n\n```typescript\n// src/db/schema.ts\nimport { pgTable, serial, varchar, integer, timestamp } from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable(\"members\", {\n  id: serial(\"id\").primaryKey(),\n  orgId: integer(\"org_id\")\n    .notNull()\n    .references(() => organizations.id, { onDelete: \"cascade\" }),\n  email: varchar(\"email\", { length: 255 }).notNull(),\n  role: varchar(\"role\", { length: 50 }).notNull().default(\"member\"),\n  joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n});\n\n// Define relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n```typescript\n// src/db/index.ts\nimport { drizzle } from \"drizzle-orm/neon-http\";\nimport { neon } from \"@neondatabase/serverless\";\nimport * as schema from \"./schema\";\n\nconst sql = neon(process.env.DATABASE_URL!);\nexport const db = drizzle(sql, { schema });\n```\n\n```typescript\n// src/db/queries.ts\nimport { db } from \"./index\";\nimport { organizations, members, type Member, type NewMember } from \"./schema\";\nimport { eq, sql, count } from \"drizzle-orm\";\n\n/**\n * Get all members of an organization by org ID\n */\nexport async function getOrgMembers(orgId: number): Promise<Member[]> {\n  return db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Get all members of an organization by slug\n */\nexport async function getOrgMembersBySlug(slug: string): Promise<Member[]> {\n  return db\n    .select({\n      id: members.id,\n      orgId: members.orgId,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .innerJoin(organizations, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n */\nexport async function addMember(\n  newMember: NewMember,\n): Promise<Member> {\n  const [member] = await db\n    .insert(members)\n    .values(newMember)\n    .returning();\n  \n  return member;\n}\n\n/**\n * Add a member by organization slug\n */\nexport async function addMemberBySlug(\n  slug: string,\n  email: string,\n  role: string = \"member\",\n): Promise<Member | null> {\n  const [org] = await db\n    .select({ id: organizations.id })\n    .from(organizations)\n    .where(eq(organizations.slug, slug))\n    .limit(1);\n\n  if (!org) {\n    return null;\n  }\n\n  return addMember({\n    orgId: org.id,\n    email,\n    role,\n  });\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const [result] = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result;\n}\n\n/**\n * Get organization details with member count by slug\n */\nexport async function getOrgWithMemberCountBySlug(slug: string) {\n  const [result] = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result;\n}\n\n/**\n * Get organization with all members (using relations)\n */\nexport async function getOrgWithMembers(orgId: number) {\n  return db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n```typescript\n// drizzle.config.ts\nimport { config } from \"dotenv\";\nimport { defineConfig } from \"drizzle-kit\";\n\nconfig({ path: \".env.local\" });\n\nexport default defineConfig({\n  schema: \"./src/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n```bash\n# Install dependencies (if not already installed)\npnpm add drizzle-orm @neondatabase/serverless\npnpm add -D drizzle-kit dotenv\n\n# Generate migrations from schema\npnpm drizzle-kit generate\n\n# Apply migrations\npnpm drizzle-kit migrate\n```\n\n**Key Features:**\n\n1. **Type-safe schema** with proper Postgres types matching your SQL\n2. **Relations defined** for easy querying with joins\n3. **Multiple query variants** - by ID and by slug\n4. **Proper error handling** - returns `null` when org not found\n5. **Aggregate queries** - member count using Drizzle's `count()`\n6. **Relational queries** - using Drizzle's query API for nested data\n\n**Usage example:**\n\n```typescript\n// In an API route or server action\nimport { getOrgWithMemberCount, addMemberBySlug } from \"@/db/queries\";\n\n// Get org details\nconst org = await getOrgWithMemberCount(1);\nconsole.log(`${org.name} has ${org.memberCount} members`);\n\n// Add a member\nconst newMember = await addMemberBySlug(\"acme-corp\", \"user@example.com\", \"admin\");\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6718,
            "output_tokens": 1892,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "```typescript\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { \n  pgTable, \n  serial, \n  varchar, \n  integer, \n  timestamp,\n  unique\n} from 'drizzle-orm/pg-core';\nimport { relations, eq, sql } from 'drizzle-orm';\nimport { InferSelectModel, InferInsertModel } from 'drizzle-orm';\nimport { Pool } from 'pg';\n\n// ============================================\n// Schema Definitions\n// ============================================\n\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  // Composite unique constraint\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// ============================================\n// Relations\n// ============================================\n\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// ============================================\n// Types\n// ============================================\n\nexport type Organization = InferSelectModel<typeof organizations>;\nexport type NewOrganization = InferInsertModel<typeof organizations>;\n\nexport type Member = InferSelectModel<typeof members>;\nexport type NewMember = InferInsertModel<typeof members>;\n\nexport type OrganizationWithMemberCount = Organization & {\n  memberCount: number;\n};\n\n// ============================================\n// Database Setup\n// ============================================\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle(pool);\n\n// ============================================\n// Query Functions\n// ============================================\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  const result = await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n  \n  return result;\n}\n\n/**\n * List all members with organization details (using relations)\n */\nexport async function listOrgMembersWithDetails(orgId: number) {\n  const result = await db.query.members.findMany({\n    where: eq(members.orgId, orgId),\n    with: {\n      organization: true,\n    },\n    orderBy: (members, { asc }) => [asc(members.joinedAt)],\n  });\n  \n  return result;\n}\n\n/**\n * Add a new member to an organization\n */\nexport async function addMember(\n  orgId: number, \n  email: string, \n  role: string = 'member'\n): Promise<Member> {\n  const result = await db\n    .insert(members)\n    .values({\n      orgId,\n      email,\n      role,\n    })\n    .returning();\n  \n  return result[0];\n}\n\n/**\n * Add multiple members at once\n */\nexport async function addMembers(\n  newMembers: NewMember[]\n): Promise<Member[]> {\n  const result = await db\n    .insert(members)\n    .values(newMembers)\n    .returning();\n  \n  return result;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(\n  orgId: number\n): Promise<OrganizationWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n  \n  return result[0] || null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(\n  slug: string\n): Promise<OrganizationWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n  \n  return result[0] || null;\n}\n\n/**\n * Get all organizations with their member counts\n */\nexport async function getAllOrgsWithMemberCount(): Promise<OrganizationWithMemberCount[]> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .groupBy(organizations.id)\n    .orderBy(organizations.name);\n  \n  return result;\n}\n\n/**\n * Remove a member from an organization\n */\nexport async function removeMember(memberId: number): Promise<void> {\n  await db\n    .delete(members)\n    .where(eq(members.id, memberId));\n}\n\n/**\n * Update member role\n */\nexport async function updateMemberRole(\n  memberId: number, \n  newRole: string\n): Promise<Member> {\n  const result = await db\n    .update(members)\n    .set({ role: newRole })\n    .where(eq(members.id, memberId))\n    .returning();\n  \n  return result[0];\n}\n\n// ============================================\n// Usage Examples\n// ============================================\n\n/*\n// Example 1: List all members of an organization\nconst orgMembers = await listOrgMembers(1);\nconsole.log(orgMembers);\n\n// Example 2: Add a new member\nconst newMember = await addMember(1, 'user@example.com', 'admin');\nconsole.log(newMember);\n\n// Example 3: Get organization with member count\nconst orgDetails = await getOrgWithMemberCount(1);\nconsole.log(orgDetails);\n// Output: { id: 1, name: 'Acme Corp', slug: 'acme', createdAt: ..., memberCount: 5 }\n\n// Example 4: Get organization by slug\nconst org = await getOrgBySlugWithMemberCount('acme');\nconsole.log(org);\n\n// Example 5: Add multiple members\nconst bulkMembers = await addMembers([\n  { orgId: 1, email: 'user1@example.com', role: 'member' },\n  { orgId: 1, email: 'user2@example.com', role: 'admin' },\n]);\n\n// Example 6: Update member role\nconst updatedMember = await updateMemberRole(1, 'admin');\n*/\n```\n\nThis code provides:\n\n1. **Complete schema definitions** with proper types and constraints\n2. **Relations** for easy querying with joins\n3. **Type safety** using TypeScript inference\n4. **Query functions** for common operations:\n   - Listing members\n   - Adding members (single and bulk)\n   - Getting org details with member count\n   - Updating and removing members\n5. **Flexible queries** using both the query builder and relational query API\n\nThe schema properly handles the CASCADE delete and composite unique constraint from your SQL definition.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 202,
            "output_tokens": 2143,
            "cached": true
          },
          "with_skill": {
            "output": "# Drizzle ORM Schema and Query Functions\n\nHere's a complete implementation with schema definitions, relations, and typed query functions:\n\n## 1. Schema Definition\n\n```typescript\n// src/schema.ts\nimport { pgTable, serial, varchar, integer, timestamp } from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\n// Organizations table\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow().notNull(),\n});\n\n// Members table\nexport const members = pgTable(\"members\", {\n  id: serial(\"id\").primaryKey(),\n  orgId: integer(\"org_id\")\n    .notNull()\n    .references(() => organizations.id, { onDelete: \"cascade\" }),\n  email: varchar(\"email\", { length: 255 }).notNull(),\n  role: varchar(\"role\", { length: 50 }).default(\"member\").notNull(),\n  joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow().notNull(),\n});\n\n// Relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## 2. Database Connection\n\n```typescript\n// src/db.ts\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { Pool } from \"pg\";\nimport * as schema from \"./schema\";\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle({ client: pool, schema });\n```\n\n## 3. Query Functions\n\n```typescript\n// src/queries.ts\nimport { eq, sql, count } from \"drizzle-orm\";\nimport { db } from \"./db\";\nimport { organizations, members, type NewMember, type Member } from \"./schema\";\n\n/**\n * List all members of an organization by org ID\n */\nexport async function listOrgMembers(orgId: number): Promise<Member[]> {\n  return db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List all members of an organization by slug\n */\nexport async function listOrgMembersBySlug(slug: string): Promise<Member[]> {\n  const org = await db\n    .select({ id: organizations.id })\n    .from(organizations)\n    .where(eq(organizations.slug, slug))\n    .limit(1);\n\n  if (org.length === 0) {\n    throw new Error(`Organization with slug \"${slug}\" not found`);\n  }\n\n  return listOrgMembers(org[0].id);\n}\n\n/**\n * Add a new member to an organization\n * Returns the created member or throws on duplicate email\n */\nexport async function addMember(\n  orgId: number,\n  email: string,\n  role: string = \"member\"\n): Promise<Member> {\n  try {\n    const [newMember] = await db\n      .insert(members)\n      .values({\n        orgId,\n        email,\n        role,\n      })\n      .returning();\n\n    return newMember;\n  } catch (error: any) {\n    // Handle unique constraint violation (duplicate email in org)\n    if (error.code === \"23505\") {\n      throw new Error(`Member with email \"${email}\" already exists in this organization`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  if (result.length === 0) {\n    throw new Error(`Organization with ID ${orgId} not found`);\n  }\n\n  return result[0];\n}\n\n/**\n * Get organization details with member count by slug\n */\nexport async function getOrgWithMemberCountBySlug(slug: string) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  if (result.length === 0) {\n    throw new Error(`Organization with slug \"${slug}\" not found`);\n  }\n\n  return result[0];\n}\n\n/**\n * Get organization with all members (using relations)\n */\nexport async function getOrgWithMembers(orgId: number) {\n  const result = await db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n\n  if (!result) {\n    throw new Error(`Organization with ID ${orgId} not found`);\n  }\n\n  return result;\n}\n```\n\n## 4. Usage Examples\n\n```typescript\n// examples.ts\nimport {\n  listOrgMembers,\n  listOrgMembersBySlug,\n  addMember,\n  getOrgWithMemberCount,\n  getOrgWithMemberCountBySlug,\n  getOrgWithMembers,\n} from \"./queries\";\n\nasync function examples() {\n  // List all members of org with ID 1\n  const members = await listOrgMembers(1);\n  console.log(\"Members:\", members);\n\n  // List members by organization slug\n  const membersBySlug = await listOrgMembersBySlug(\"acme-corp\");\n  console.log(\"Members by slug:\", membersBySlug);\n\n  // Add a new member\n  try {\n    const newMember = await addMember(1, \"john@example.com\", \"admin\");\n    console.log(\"New member:\", newMember);\n  } catch (error) {\n    console.error(\"Failed to add member:\", error);\n  }\n\n  // Get org details with member count\n  const orgDetails = await getOrgWithMemberCount(1);\n  console.log(\"Organization:\", orgDetails);\n  // Output: { id: 1, name: \"...\", slug: \"...\", createdAt: ..., memberCount: 5 }\n\n  // Get org by slug with member count\n  const orgBySlug = await getOrgWithMemberCountBySlug(\"acme-corp\");\n  console.log(\"Organization by slug:\", orgBySlug);\n\n  // Get org with all members using relations\n  const orgWithMembers = await getOrgWithMembers(1);\n  console.log(\"Org with members:\", orgWithMembers);\n  // Output: { id: 1, name: \"...\", members: [...] }\n}\n```\n\n## 5. Advanced Query: Batch Operations\n\n```typescript\n// src/queries.ts (additional functions)\n\n/**\n * Add multiple members in a single transaction\n */\nexport async function addMembersBatch(\n  orgId: number,\n  memberData: Array<{ email: string; role?: string }>\n): Promise<Member[]> {\n  return db.transaction(async (tx) => {\n    const newMembers: Member[] = [];\n\n    for (const data of memberData) {\n      const [member] = await tx\n        .insert(members)\n        .values({\n          orgId,\n          email: data.email,\n          role: data.role || \"member\",\n        })\n        .returning();\n\n      newMembers.push(member);\n    }\n\n    return newMembers;\n  });\n}\n\n/**\n * Get organizations with member counts (paginated)\n */\nexport async function listOrgsWithMemberCounts(\n  limit: number = 10,\n  offset: number = 0\n) {\n  return db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .groupBy(organizations.id)\n    .orderBy(organizations.createdAt)\n    .limit(limit)\n    .offset(offset);\n}\n```\n\n## Key Features\n\n1. **Type Safety**: Full TypeScript inference for all queries\n2. **Relations**: Defined bidirectional relations between tables\n3. **Error Handling**: Proper handling of unique constraint violations\n4. **Flexible Queries**: Support for both ID and slug-based lookups\n5. **Aggregations**: Member count using SQL `COUNT()`\n6. **Transactions**: Batch operations with rollback support\n7. **Ordering**: Consistent ordering by `joinedAt` timestamp\n\nThis implementation follows Drizzle ORM best practices and provides a solid foundation for working with the organization/member schema.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6223,
            "output_tokens": 2460,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Drizzle ORM Schema and Query Functions\n\nHere's a complete implementation with Drizzle ORM for your schema, including typed query functions.\n\n## 1. Schema Definition\n\n```typescript\n// db/schema.ts\nimport { pgTable, serial, varchar, integer, timestamp, unique } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\n// Organizations table\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).notNull().default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  // Composite unique constraint\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// Define relations for type-safe joins\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type exports\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## 2. Database Connection Setup\n\n```typescript\n// db/index.ts\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport { neon } from '@neondatabase/serverless';\nimport * as schema from './schema';\n\n// Get connection string from environment\nconst sql = neon(process.env.DATABASE_URL!);\n\n// Create Drizzle instance with schema for relational queries\nexport const db = drizzle(sql, { schema });\n```\n\n## 3. Query Functions\n\n```typescript\n// db/queries.ts\nimport { eq, sql, count } from 'drizzle-orm';\nimport { db } from './index';\nimport { organizations, members, type NewMember, type Member, type Organization } from './schema';\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number): Promise<Member[]> {\n  return await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n * Returns the created member or throws on constraint violation\n */\nexport async function addMember(data: NewMember): Promise<Member> {\n  const [member] = await db\n    .insert(members)\n    .values(data)\n    .returning();\n  \n  return member;\n}\n\n/**\n * Get organization details with member count\n */\nexport interface OrgWithMemberCount extends Organization {\n  memberCount: number;\n}\n\nexport async function getOrgWithMemberCount(orgId: number): Promise<OrgWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Alternative: Get org with member count by slug\n */\nexport async function getOrgBySlugWithMemberCount(slug: string): Promise<OrgWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Bonus: Get org with all members using relational queries\n */\nexport async function getOrgWithMembers(orgId: number) {\n  return await db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n## 4. Usage Examples\n\n```typescript\n// examples/usage.ts\nimport { addMember, listOrgMembers, getOrgWithMemberCount, getOrgWithMembers } from './db/queries';\n\nasync function examples() {\n  // Add a new member\n  const newMember = await addMember({\n    orgId: 1,\n    email: 'user@example.com',\n    role: 'admin',\n  });\n  console.log('Created member:', newMember);\n\n  // List all members of an org\n  const members = await listOrgMembers(1);\n  console.log('Org members:', members);\n\n  // Get org details with member count\n  const orgWithCount = await getOrgWithMemberCount(1);\n  console.log('Org with count:', orgWithCount);\n  // Output: { id: 1, name: '...', slug: '...', createdAt: ..., memberCount: 5 }\n\n  // Get org with all member details (relational query)\n  const orgWithMembers = await getOrgWithMembers(1);\n  console.log('Org with members:', orgWithMembers);\n  // Output: { id: 1, name: '...', members: [...] }\n}\n```\n\n## 5. Package Dependencies\n\n```json\n{\n  \"dependencies\": {\n    \"@neondatabase/serverless\": \"^0.10.4\",\n    \"drizzle-orm\": \"^0.36.4\"\n  },\n  \"devDependencies\": {\n    \"drizzle-kit\": \"^0.28.1\"\n  }\n}\n```\n\n## 6. Drizzle Configuration\n\n```typescript\n// drizzle.config.ts\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  schema: './db/schema.ts',\n  out: './drizzle',\n  dialect: 'postgresql',\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n## Key Features\n\n\u2705 **Type Safety**: Full TypeScript types inferred from schema  \n\u2705 **Relations**: Defined for type-safe joins and relational queries  \n\u2705 **Constraints**: Composite unique constraint on `(org_id, email)`  \n\u2705 **Cascading Deletes**: Handled via `onDelete: 'cascade'`  \n\u2705 **Default Values**: `role` and timestamps with defaults  \n\u2705 **Query Builders**: Both SQL-like and relational query APIs  \n\u2705 **Neon Integration**: Uses `@neondatabase/serverless` with `drizzle-orm/neon-http`\n\n## Error Handling Example\n\n```typescript\nasync function addMemberSafely(data: NewMember) {\n  try {\n    return await addMember(data);\n  } catch (error: any) {\n    if (error.code === '23505') { // Unique constraint violation\n      throw new Error(`Member ${data.email} already exists in this organization`);\n    }\n    throw error;\n  }\n}\n```\n\nThis implementation provides a fully typed, production-ready setup for your schema with Drizzle ORM and Neon Serverless Postgres.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2344,
            "output_tokens": 2090,
            "cached": false
          },
          "realistic": {
            "output": "I'll create a complete Drizzle ORM setup for your schema with typed query functions.\n\nFirst, let me check if Drizzle is already installed:\n\n```typescript\n// package.json dependencies check\n```\n\nNow I'll create the schema and query functions:\n\n```typescript\n// src/db/schema.ts\nimport { pgTable, serial, varchar, integer, timestamp } from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable(\"members\", {\n  id: serial(\"id\").primaryKey(),\n  orgId: integer(\"org_id\")\n    .notNull()\n    .references(() => organizations.id, { onDelete: \"cascade\" }),\n  email: varchar(\"email\", { length: 255 }).notNull(),\n  role: varchar(\"role\", { length: 50 }).notNull().default(\"member\"),\n  joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n});\n\n// Define relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n```typescript\n// src/db/index.ts\nimport { drizzle } from \"drizzle-orm/neon-http\";\nimport { neon } from \"@neondatabase/serverless\";\nimport * as schema from \"./schema\";\n\nconst sql = neon(process.env.DATABASE_URL!);\nexport const db = drizzle(sql, { schema });\n```\n\n```typescript\n// src/db/queries.ts\nimport { db } from \"./index\";\nimport { organizations, members, type Member, type NewMember } from \"./schema\";\nimport { eq, sql, count } from \"drizzle-orm\";\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number): Promise<Member[]> {\n  return db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n */\nexport async function addMember(\n  data: NewMember\n): Promise<Member> {\n  const [member] = await db\n    .insert(members)\n    .values(data)\n    .returning();\n  \n  return member;\n}\n\n/**\n * Get organization details with member count\n */\nexport interface OrgWithMemberCount {\n  id: number;\n  name: string;\n  slug: string;\n  createdAt: Date | null;\n  memberCount: number;\n}\n\nexport async function getOrgWithMemberCount(\n  orgId: number\n): Promise<OrgWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(\n  slug: string\n): Promise<OrgWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get member by email within an organization\n */\nexport async function getMemberByEmail(\n  orgId: number,\n  email: string\n): Promise<Member | null> {\n  const [member] = await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .where(eq(members.email, email))\n    .limit(1);\n\n  return member ?? null;\n}\n\n/**\n * Update member role\n */\nexport async function updateMemberRole(\n  memberId: number,\n  role: string\n): Promise<Member> {\n  const [updated] = await db\n    .update(members)\n    .set({ role })\n    .where(eq(members.id, memberId))\n    .returning();\n\n  return updated;\n}\n\n/**\n * Remove member from organization\n */\nexport async function removeMember(memberId: number): Promise<void> {\n  await db.delete(members).where(eq(members.id, memberId));\n}\n```\n\n```typescript\n// drizzle.config.ts\nimport { defineConfig } from \"drizzle-kit\";\nimport { config } from \"dotenv\";\n\nconfig({ path: \".env.local\" });\n\nexport default defineConfig({\n  schema: \"./src/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n```typescript\n// Example usage in an API route: src/app/api/orgs/[orgId]/members/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { listOrgMembers, addMember } from \"@/db/queries\";\nimport { z } from \"zod\";\n\nconst addMemberSchema = z.object({\n  email: z.string().email(),\n  role: z.enum([\"admin\", \"member\"]).default(\"member\"),\n});\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: { orgId: string } }\n) {\n  try {\n    const orgId = parseInt(params.orgId);\n    if (isNaN(orgId)) {\n      return NextResponse.json({ error: \"Invalid org ID\" }, { status: 400 });\n    }\n\n    const members = await listOrgMembers(orgId);\n    return NextResponse.json({ data: members });\n  } catch (error) {\n    console.error(\"Failed to fetch members:\", error);\n    return NextResponse.json(\n      { error: \"Failed to fetch members\" },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { orgId: string } }\n) {\n  try {\n    const orgId = parseInt(params.orgId);\n    if (isNaN(orgId)) {\n      return NextResponse.json({ error: \"Invalid org ID\" }, { status: 400 });\n    }\n\n    const body = await request.json();\n    const validated = addMemberSchema.parse(body);\n\n    const member = await addMember({\n      orgId,\n      email: validated.email,\n      role: validated.role,\n    });\n\n    return NextResponse.json({ data: member }, { status: 201 });\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { error: \"Invalid request data\", details: error.errors },\n        { status: 400 }\n      );\n    }\n    console.error(\"Failed to add member:\", error);\n    return NextResponse.json(\n      { error: \"Failed to add member\" },\n      { status: 500 }\n    );\n  }\n}\n```\n\nTo set this up, you'll need to install the dependencies:\n\n```bash\npnpm add drizzle-orm @neondatabase/serverless\npnpm add -D drizzle-kit dotenv\n```\n\nThen generate and run migrations:\n\n```bash\n# Generate migration files from schema\npnpm drizzle-kit generate\n\n# Apply migrations to database\npnpm drizzle-kit migrate\n```\n\nThe code includes:\n- \u2705 Proper Drizzle schema with relations\n- \u2705 Type-safe query functions\n- \u2705 All three requested operations (list members, add member, get org with count)\n- \u2705 Bonus functions for common operations\n- \u2705 Example API route showing usage\n- \u2705 Proper error handling and validation",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6718,
            "output_tokens": 2258,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "```typescript\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { \n  pgTable, \n  serial, \n  varchar, \n  integer, \n  timestamp,\n  unique\n} from 'drizzle-orm/pg-core';\nimport { relations, eq, sql } from 'drizzle-orm';\nimport { InferSelectModel, InferInsertModel } from 'drizzle-orm';\nimport { Pool } from 'pg';\n\n// ============================================\n// Schema Definitions\n// ============================================\n\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// ============================================\n// Relations\n// ============================================\n\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// ============================================\n// Types\n// ============================================\n\nexport type Organization = InferSelectModel<typeof organizations>;\nexport type NewOrganization = InferInsertModel<typeof organizations>;\n\nexport type Member = InferSelectModel<typeof members>;\nexport type NewMember = InferInsertModel<typeof members>;\n\nexport type OrganizationWithMemberCount = Organization & {\n  memberCount: number;\n};\n\n// ============================================\n// Database Setup\n// ============================================\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle(pool);\n\n// ============================================\n// Query Functions\n// ============================================\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List all members with organization details\n */\nexport async function listOrgMembersWithDetails(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n      organization: {\n        id: organizations.id,\n        name: organizations.name,\n        slug: organizations.slug,\n      },\n    })\n    .from(members)\n    .innerJoin(organizations, eq(members.orgId, organizations.id))\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a member to an organization\n */\nexport async function addMember(\n  orgId: number, \n  email: string, \n  role: string = 'member'\n) {\n  const [newMember] = await db\n    .insert(members)\n    .values({\n      orgId,\n      email,\n      role,\n    })\n    .returning();\n  \n  return newMember;\n}\n\n/**\n * Add a member with error handling for duplicates\n */\nexport async function addMemberSafe(\n  orgId: number, \n  email: string, \n  role: string = 'member'\n): Promise<{ success: boolean; member?: Member; error?: string }> {\n  try {\n    const member = await addMember(orgId, email, role);\n    return { success: true, member };\n  } catch (error: any) {\n    if (error.code === '23505') { // Unique violation\n      return { \n        success: false, \n        error: 'Member with this email already exists in the organization' \n      };\n    }\n    throw error;\n  }\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(\n  orgId: number\n): Promise<OrganizationWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(\n  slug: string\n): Promise<OrganizationWithMemberCount | null> {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Get all organizations with their member counts\n */\nexport async function getAllOrgsWithMemberCount(): Promise<OrganizationWithMemberCount[]> {\n  return await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: sql<number>`cast(count(${members.id}) as int)`,\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .groupBy(organizations.id)\n    .orderBy(organizations.name);\n}\n\n// ============================================\n// Usage Examples\n// ============================================\n\n/*\n// List members\nconst members = await listOrgMembers(1);\n\n// Add a member\nconst newMember = await addMember(1, 'user@example.com', 'admin');\n\n// Add member with safety\nconst result = await addMemberSafe(1, 'user@example.com');\nif (result.success) {\n  console.log('Member added:', result.member);\n} else {\n  console.error('Error:', result.error);\n}\n\n// Get org with member count\nconst org = await getOrgWithMemberCount(1);\nconsole.log(`${org?.name} has ${org?.memberCount} members`);\n\n// Get org by slug\nconst orgBySlug = await getOrgBySlugWithMemberCount('acme-corp');\n*/\n```\n\nThis code provides:\n\n1. **Proper schema definitions** with all constraints (foreign keys, unique constraints, defaults)\n2. **Relations** for easy joins between tables\n3. **Type safety** with inferred types for select and insert operations\n4. **Query functions** for:\n   - Listing organization members\n   - Adding members (with safe variant for duplicate handling)\n   - Getting organization details with member counts\n   - Multiple lookup methods (by ID and slug)\n5. **Proper SQL aggregation** using Drizzle's `sql` template for counting members\n6. **Usage examples** in comments",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 202,
            "output_tokens": 2016,
            "cached": true
          },
          "with_skill": {
            "output": "# Drizzle ORM Schema and Query Functions\n\nBased on the provided SQL schema, here's a complete Drizzle ORM implementation with typed schema definitions and query functions.\n\n## Schema Definition\n\n```typescript\n// src/schema.ts\nimport { pgTable, serial, varchar, integer, timestamp } from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\n// Organizations table\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\n// Members table\nexport const members = pgTable(\"members\", {\n  id: serial(\"id\").primaryKey(),\n  orgId: integer(\"org_id\")\n    .notNull()\n    .references(() => organizations.id, { onDelete: \"cascade\" }),\n  email: varchar(\"email\", { length: 255 }).notNull(),\n  role: varchar(\"role\", { length: 50 }).default(\"member\").notNull(),\n  joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n});\n\n// Define relations\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## Database Connection\n\n```typescript\n// src/db.ts\nimport { drizzle } from \"drizzle-orm/neon-http\";\nimport { neon } from \"@neondatabase/serverless\";\nimport * as schema from \"./schema\";\n\nconst sql = neon(process.env.DATABASE_URL!);\nexport const db = drizzle(sql, { schema });\n```\n\n## Query Functions\n\n```typescript\n// src/queries.ts\nimport { db } from \"./db\";\nimport { organizations, members, type Member, type NewMember } from \"./schema\";\nimport { eq, sql, count } from \"drizzle-orm\";\n\n/**\n * List all members of an organization by org ID\n */\nexport async function listOrgMembers(orgId: number): Promise<Member[]> {\n  return db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * List all members of an organization by slug\n */\nexport async function listOrgMembersBySlug(slug: string): Promise<Member[]> {\n  return db\n    .select({\n      id: members.id,\n      orgId: members.orgId,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .innerJoin(organizations, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n * Returns the created member or null if org doesn't exist\n */\nexport async function addMember(\n  orgId: number,\n  email: string,\n  role: string = \"member\"\n): Promise<Member | null> {\n  try {\n    const [newMember] = await db\n      .insert(members)\n      .values({\n        orgId,\n        email,\n        role,\n      })\n      .returning();\n\n    return newMember;\n  } catch (error: any) {\n    // Handle unique constraint violation\n    if (error.code === \"23505\") {\n      throw new Error(`Member with email ${email} already exists in this organization`);\n    }\n    // Handle foreign key violation\n    if (error.code === \"23503\") {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Get organization details with member count by slug\n */\nexport async function getOrgWithMemberCountBySlug(slug: string) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Get organization with all members (using relations)\n */\nexport async function getOrgWithMembers(orgId: number) {\n  return db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n## Usage Examples\n\n```typescript\n// src/examples.ts\nimport {\n  listOrgMembers,\n  listOrgMembersBySlug,\n  addMember,\n  getOrgWithMemberCount,\n  getOrgWithMemberCountBySlug,\n  getOrgWithMembers,\n} from \"./queries\";\n\nasync function examples() {\n  // List all members of organization with ID 1\n  const members = await listOrgMembers(1);\n  console.log(\"Members:\", members);\n\n  // List members by organization slug\n  const membersBySlug = await listOrgMembersBySlug(\"acme-corp\");\n  console.log(\"Members by slug:\", membersBySlug);\n\n  // Add a new member\n  try {\n    const newMember = await addMember(1, \"john@example.com\", \"admin\");\n    if (newMember) {\n      console.log(\"Added member:\", newMember);\n    } else {\n      console.log(\"Organization not found\");\n    }\n  } catch (error) {\n    console.error(\"Failed to add member:\", error);\n  }\n\n  // Get org details with member count\n  const orgDetails = await getOrgWithMemberCount(1);\n  console.log(\"Organization:\", orgDetails);\n  // Output: { id: 1, name: \"...\", slug: \"...\", createdAt: ..., memberCount: 5 }\n\n  // Get org by slug with member count\n  const orgBySlug = await getOrgWithMemberCountBySlug(\"acme-corp\");\n  console.log(\"Organization by slug:\", orgBySlug);\n\n  // Get org with all members using relations\n  const orgWithMembers = await getOrgWithMembers(1);\n  console.log(\"Organization with members:\", orgWithMembers);\n  // Output: { id: 1, name: \"...\", members: [...] }\n}\n```\n\n## Batch Operations\n\n```typescript\n// src/batch-operations.ts\nimport { db } from \"./db\";\nimport { members, type NewMember } from \"./schema\";\n\n/**\n * Batch insert multiple members\n */\nexport async function batchAddMembers(newMembers: NewMember[]): Promise<Member[]> {\n  return db.insert(members).values(newMembers).returning();\n}\n\n/**\n * Example usage\n */\nasync function batchExample() {\n  const newMembers = [\n    { orgId: 1, email: \"alice@example.com\", role: \"member\" },\n    { orgId: 1, email: \"bob@example.com\", role: \"admin\" },\n    { orgId: 1, email: \"charlie@example.com\", role: \"member\" },\n  ];\n\n  const inserted = await batchAddMembers(newMembers);\n  console.log(`Inserted ${inserted.length} members`);\n}\n```\n\n## Key Features\n\n1. **Type Safety**: Full TypeScript inference for queries and results\n2. **Relations**: Defined relationships between organizations and members\n3. **Error Handling**: Handles unique constraint and foreign key violations\n4. **Flexible Queries**: Support for querying by ID or slug\n5. **Aggregations**: Member count using SQL `COUNT()`\n6. **Batch Operations**: Efficient bulk inserts\n7. **Ordering**: Results ordered by `joinedAt` timestamp\n\nThis implementation follows Drizzle ORM best practices and provides a solid foundation for working with your organization/member schema in a type-safe manner.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6223,
            "output_tokens": 2300,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Drizzle ORM Schema and Query Functions\n\nHere's a complete implementation with Drizzle ORM for your schema, including typed queries:\n\n## 1. Schema Definition\n\n```typescript\n// db/schema.ts\nimport { pgTable, serial, varchar, integer, timestamp } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n\nexport const organizations = pgTable('organizations', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  slug: varchar('slug', { length: 100 }).notNull().unique(),\n  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable('members', {\n  id: serial('id').primaryKey(),\n  orgId: integer('org_id')\n    .notNull()\n    .references(() => organizations.id, { onDelete: 'cascade' }),\n  email: varchar('email', { length: 255 }).notNull(),\n  role: varchar('role', { length: 50 }).default('member'),\n  joinedAt: timestamp('joined_at', { withTimezone: true }).defaultNow(),\n}, (table) => ({\n  // Composite unique constraint\n  uniqueOrgEmail: unique().on(table.orgId, table.email),\n}));\n\n// Define relations for easier joins\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type exports\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n## 2. Database Connection\n\n```typescript\n// db/index.ts\nimport { drizzle } from 'drizzle-orm/neon-http';\nimport { neon } from '@neondatabase/serverless';\nimport * as schema from './schema';\n\n// Get connection string from environment\nconst sql = neon(process.env.DATABASE_URL!);\n\n// Create Drizzle instance with schema for relational queries\nexport const db = drizzle(sql, { schema });\n```\n\n## 3. Query Functions\n\n```typescript\n// db/queries.ts\nimport { eq, sql, count } from 'drizzle-orm';\nimport { db } from './index';\nimport { organizations, members, type NewMember } from './schema';\n\n/**\n * List all members of an organization\n */\nexport async function listOrgMembers(orgId: number) {\n  return await db\n    .select({\n      id: members.id,\n      email: members.email,\n      role: members.role,\n      joinedAt: members.joinedAt,\n    })\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n */\nexport async function addMember(data: {\n  orgId: number;\n  email: string;\n  role?: string;\n}) {\n  const [newMember] = await db\n    .insert(members)\n    .values({\n      orgId: data.orgId,\n      email: data.email,\n      role: data.role || 'member',\n    })\n    .returning();\n  \n  return newMember;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(members.orgId, organizations.id))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] || null;\n}\n\n/**\n * Alternative: Get org with member count using subquery\n */\nexport async function getOrgWithMemberCountAlt(orgId: number) {\n  const org = await db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        columns: { id: true },\n      },\n    },\n  });\n\n  if (!org) return null;\n\n  return {\n    ...org,\n    memberCount: org.members.length,\n    members: undefined, // Remove members array from result\n  };\n}\n\n/**\n * Bonus: Get org by slug with full member details\n */\nexport async function getOrgBySlugWithMembers(slug: string) {\n  return await db.query.organizations.findFirst({\n    where: eq(organizations.slug, slug),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n```\n\n## 4. Usage Examples\n\n```typescript\n// Example usage in your application\nimport { \n  listOrgMembers, \n  addMember, \n  getOrgWithMemberCount \n} from './db/queries';\n\n// List members\nconst members = await listOrgMembers(1);\nconsole.log('Members:', members);\n\n// Add a new member\nconst newMember = await addMember({\n  orgId: 1,\n  email: 'user@example.com',\n  role: 'admin',\n});\nconsole.log('New member:', newMember);\n\n// Get org with member count\nconst orgDetails = await getOrgWithMemberCount(1);\nconsole.log('Organization:', orgDetails);\n// Output: { id: 1, name: '...', slug: '...', createdAt: ..., memberCount: 5 }\n```\n\n## 5. Package Dependencies\n\n```json\n{\n  \"dependencies\": {\n    \"@neondatabase/serverless\": \"^0.10.4\",\n    \"drizzle-orm\": \"^0.36.4\"\n  },\n  \"devDependencies\": {\n    \"drizzle-kit\": \"^0.28.1\"\n  }\n}\n```\n\n## 6. Drizzle Configuration\n\n```typescript\n// drizzle.config.ts\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  schema: './db/schema.ts',\n  out: './drizzle',\n  dialect: 'postgresql',\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n## Key Features\n\n1. **Type Safety**: Full TypeScript types inferred from schema\n2. **Relations**: Defined for easy relational queries\n3. **Composite Unique**: Enforces `(org_id, email)` uniqueness\n4. **Cascade Delete**: Members deleted when org is deleted\n5. **Default Values**: Handled at schema level\n6. **Query Builders**: Multiple approaches (select builder vs relational queries)\n\n## Running Migrations\n\n```bash\n# Generate migration from schema\nnpx drizzle-kit generate\n\n# Push schema directly to database (development)\nnpx drizzle-kit push\n\n# Run migrations (production)\nnpx drizzle-kit migrate\n```\n\nThis implementation provides a fully-typed, production-ready setup for your database schema with Drizzle ORM and Neon Postgres!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2344,
            "output_tokens": 1879,
            "cached": false
          },
          "realistic": {
            "output": "I'll create a complete Drizzle ORM setup for your schema with typed query functions.\n\nFirst, let me check if Drizzle is already installed:\n\n```bash\ncat package.json | grep drizzle\n```\n\nNow I'll create the schema definition and query functions:\n\n```typescript\n// src/lib/db/schema.ts\nimport { pgTable, serial, varchar, integer, timestamp } from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm\";\n\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: varchar(\"name\", { length: 255 }).notNull(),\n  slug: varchar(\"slug\", { length: 100 }).notNull().unique(),\n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n\nexport const members = pgTable(\"members\", {\n  id: serial(\"id\").primaryKey(),\n  orgId: integer(\"org_id\")\n    .notNull()\n    .references(() => organizations.id, { onDelete: \"cascade\" }),\n  email: varchar(\"email\", { length: 255 }).notNull(),\n  role: varchar(\"role\", { length: 50 }).notNull().default(\"member\"),\n  joinedAt: timestamp(\"joined_at\", { withTimezone: true }).defaultNow(),\n});\n\n// Define relations for easier querying\nexport const organizationsRelations = relations(organizations, ({ many }) => ({\n  members: many(members),\n}));\n\nexport const membersRelations = relations(members, ({ one }) => ({\n  organization: one(organizations, {\n    fields: [members.orgId],\n    references: [organizations.id],\n  }),\n}));\n\n// Type inference\nexport type Organization = typeof organizations.$inferSelect;\nexport type NewOrganization = typeof organizations.$inferInsert;\nexport type Member = typeof members.$inferSelect;\nexport type NewMember = typeof members.$inferInsert;\n```\n\n```typescript\n// src/lib/db/index.ts\nimport { drizzle } from \"drizzle-orm/neon-http\";\nimport { neon } from \"@neondatabase/serverless\";\nimport * as schema from \"./schema\";\n\nconst sql = neon(process.env.DATABASE_URL!);\nexport const db = drizzle(sql, { schema });\n```\n\n```typescript\n// src/lib/db/queries.ts\nimport { db } from \"./index\";\nimport { organizations, members, type Member, type NewMember } from \"./schema\";\nimport { eq, sql, count } from \"drizzle-orm\";\n\n/**\n * List all members of an organization\n */\nexport async function getOrgMembers(orgId: number): Promise<Member[]> {\n  return db\n    .select()\n    .from(members)\n    .where(eq(members.orgId, orgId))\n    .orderBy(members.joinedAt);\n}\n\n/**\n * Add a new member to an organization\n */\nexport async function addMember(\n  orgId: number,\n  email: string,\n  role: string = \"member\"\n): Promise<Member> {\n  const [newMember] = await db\n    .insert(members)\n    .values({\n      orgId,\n      email,\n      role,\n    })\n    .returning();\n\n  return newMember;\n}\n\n/**\n * Get organization details with member count\n */\nexport async function getOrgWithMemberCount(orgId: number) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.id, orgId))\n    .groupBy(organizations.id);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get organization by slug with member count\n */\nexport async function getOrgBySlugWithMemberCount(slug: string) {\n  const result = await db\n    .select({\n      id: organizations.id,\n      name: organizations.name,\n      slug: organizations.slug,\n      createdAt: organizations.createdAt,\n      memberCount: count(members.id),\n    })\n    .from(organizations)\n    .leftJoin(members, eq(organizations.id, members.orgId))\n    .where(eq(organizations.slug, slug))\n    .groupBy(organizations.id);\n\n  return result[0] ?? null;\n}\n\n/**\n * Get organization with all members (using relations)\n */\nexport async function getOrgWithMembers(orgId: number) {\n  return db.query.organizations.findFirst({\n    where: eq(organizations.id, orgId),\n    with: {\n      members: {\n        orderBy: (members, { asc }) => [asc(members.joinedAt)],\n      },\n    },\n  });\n}\n\n/**\n * Remove a member from an organization\n */\nexport async function removeMember(memberId: number): Promise<void> {\n  await db.delete(members).where(eq(members.id, memberId));\n}\n\n/**\n * Update member role\n */\nexport async function updateMemberRole(\n  memberId: number,\n  newRole: string\n): Promise<Member> {\n  const [updated] = await db\n    .update(members)\n    .set({ role: newRole })\n    .where(eq(members.id, memberId))\n    .returning();\n\n  return updated;\n}\n```\n\n```typescript\n// drizzle.config.ts\nimport { config } from \"dotenv\";\nimport { defineConfig } from \"drizzle-kit\";\n\nconfig({ path: \".env.local\" });\n\nexport default defineConfig({\n  schema: \"./src/lib/db/schema.ts\",\n  out: \"./drizzle\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\nTo install the required dependencies:\n\n```bash\npnpm add drizzle-orm @neondatabase/serverless\npnpm add -D drizzle-kit dotenv\n```\n\nTo generate and run migrations:\n\n```bash\n# Generate migration from schema\npnpm drizzle-kit generate\n\n# Apply migrations to database\npnpm drizzle-kit migrate\n```\n\nExample usage in an API route:\n\n```typescript\n// src/app/api/orgs/[orgId]/members/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { getOrgMembers, addMember } from \"@/lib/db/queries\";\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: { orgId: string } }\n) {\n  try {\n    const members = await getOrgMembers(parseInt(params.orgId));\n    return NextResponse.json({ data: members });\n  } catch (error) {\n    return NextResponse.json(\n      { error: \"Failed to fetch members\" },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { orgId: string } }\n) {\n  try {\n    const { email, role } = await request.json();\n    const member = await addMember(parseInt(params.orgId), email, role);\n    return NextResponse.json({ data: member }, { status: 201 });\n  } catch (error) {\n    return NextResponse.json(\n      { error: \"Failed to add member\" },\n      { status: 500 }\n    );\n  }\n}\n```\n\nThe schema includes:\n- \u2705 Proper type inference with `$inferSelect` and `$inferInsert`\n- \u2705 Relations for easier querying with `db.query`\n- \u2705 Typed query functions with proper return types\n- \u2705 Composite unique constraint on `(org_id, email)`\n- \u2705 Cascade delete behavior\n- \u2705 Default values and timestamps",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 6718,
            "output_tokens": 1984,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "neon-postgres-05",
      "task_type": "adjacent_domain",
      "target_language": "typescript",
      "expected_patterns": [
        "import.*ioredis|import.*Redis",
        "class Cache|export class Cache",
        "<T>|generic",
        "JSON\\.parse|JSON\\.stringify",
        "get\\(|set\\(",
        "async\\s+"
      ],
      "anti_patterns": [
        "@neondatabase",
        "neon\\(",
        "DATABASE_URL",
        "postgres|pg\\b|sql`",
        "drizzle|prisma",
        "SELECT|INSERT|CREATE TABLE"
      ],
      "pattern_sources": [
        {
          "url": "https://github.com/redis/ioredis#readme",
          "description": "ioredis docs - source of import Redis/ioredis, get/set/del commands, and connection patterns"
        },
        {
          "url": "https://redis.io/docs/latest/commands/",
          "description": "Redis commands reference - source of key-value operations, TTL, and pattern-based key scanning"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/2/classes.html",
          "description": "TypeScript classes - source of class keyword and export class patterns for defining Cache class"
        },
        {
          "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
          "description": "TypeScript generics - source of <T> generic type parameter syntax for type-safe get/set methods"
        },
        {
          "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
          "description": "JSON object documentation - source of JSON.parse() and JSON.stringify() for serialization/deserialization"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Redis Caching Layer Utility Module\n\n```typescript\n// cache.ts\nimport Redis, { Redis as RedisClient, RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig extends RedisOptions {\n  keyPrefix?: string;\n  defaultTTL?: number;\n  enableLogging?: boolean;\n}\n\n/**\n * Serialized cache entry with metadata\n */\ninterface CacheEntry<T> {\n  value: T;\n  timestamp: number;\n  type: string;\n}\n\n/**\n * Custom error class for cache-related errors\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Generic caching layer using Redis with TypeScript support\n */\nexport class Cache {\n  private client: RedisClient;\n  private readonly config: Required<Pick<CacheConfig, 'keyPrefix' | 'defaultTTL' | 'enableLogging'>>;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      keyPrefix: config.keyPrefix || 'cache:',\n      defaultTTL: config.defaultTTL || 3600, // 1 hour default\n      enableLogging: config.enableLogging ?? true,\n    };\n\n    // Initialize Redis client with configuration\n    this.client = new Redis({\n      host: config.host || 'localhost',\n      port: config.port || 6379,\n      password: config.password,\n      db: config.db || 0,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection (attempt ${times}) in ${delay}ms`);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      enableReadyCheck: true,\n      lazyConnect: true,\n      ...config,\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup Redis client event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client connected and ready');\n    });\n\n    this.client.on('error', (error: Error) => {\n      this.isConnected = false;\n      this.log(`Redis client error: ${error.message}`, 'error');\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Ensure Redis connection is established\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    this.connectionPromise = this.client.connect().then(() => {\n      this.connectionPromise = null;\n    });\n\n    return this.connectionPromise;\n  }\n\n  /**\n   * Generate full key with prefix\n   */\n  private getFullKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    const entry: CacheEntry<T> = {\n      value,\n      timestamp: Date.now(),\n      type: typeof value,\n    };\n    return JSON.stringify(entry);\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(data: string): T {\n    try {\n      const entry: CacheEntry<T> = JSON.parse(data);\n      return entry.value;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to deserialize cache entry',\n        'deserialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Log messages if logging is enabled\n   */\n  private log(message: string, level: 'info' | 'error' = 'info'): void {\n    if (this.config.enableLogging) {\n      const timestamp = new Date().toISOString();\n      const prefix = `[Cache ${timestamp}]`;\n      \n      if (level === 'error') {\n        console.error(`${prefix} ${message}`);\n      } else {\n        console.log(`${prefix} ${message}`);\n      }\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.getFullKey(key);\n      const data = await this.client.get(fullKey);\n\n      if (data === null) {\n        this.log(`Cache miss: ${key}`);\n        return null;\n      }\n\n      this.log(`Cache hit: ${key}`);\n      return this.deserialize<T>(data);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get key \"${key}\"`,\n        'get',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n        this.log(`Set key \"${key}\" with TTL ${ttl}s`);\n      } else {\n        await this.client.set(fullKey, serialized);\n        this.log(`Set key \"${key}\" without TTL`);\n      }\n    } catch (error) {\n      throw new CacheError(\n        `Failed to set key \"${key}\"`,\n        'set',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key to delete\n   * @returns Number of keys deleted (0 or 1)\n   */\n  async delete(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.del(fullKey);\n      \n      this.log(`Deleted key \"${key}\" (${result} keys removed)`);\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to delete key \"${key}\"`,\n        'delete',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullPattern = this.getFullKey(pattern);\n      let cursor = '0';\n      let deletedCount = 0;\n      const batchSize = 100;\n\n      do {\n        // Use SCAN to iterate through keys matching the pattern\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          batchSize\n        );\n\n        cursor = nextCursor;\n\n        if (keys.length > 0) {\n          // Delete keys in pipeline for better performance\n          const pipeline = this.client.pipeline();\n          keys.forEach((key) => pipeline.del(key));\n          const results = await pipeline.exec();\n          \n          // Count successful deletions\n          deletedCount += results?.filter(([err, result]) => !err && result === 1).length || 0;\n        }\n      } while (cursor !== '0');\n\n      this.log(`Invalidated pattern \"${pattern}\" (${deletedCount} keys removed)`);\n      return deletedCount;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to invalidate pattern \"${pattern}\"`,\n        'invalidatePattern',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns True if key exists, false otherwise\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.exists(fullKey);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key \"${key}\"`,\n        'exists',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key \"${key}\"`,\n        'getTTL',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set expiration time for an existing key\n   * @param key - Cache key\n   * @param ttlSeconds - Time to live in seconds\n   * @returns True if TTL was set, false if key doesn't exist\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.expire(fullKey, ttlSeconds);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to set expiration for key \"${key}\"`,\n        'expire',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get multiple values at once\n   * @param keys - Array of cache keys\n   * @returns Map of keys to values (null for missing keys)\n   */\n  async mget<T>(keys: string[]): Promise<Map<string, T | null>> {\n    try {\n      await this.ensureConnection();\n\n      const fullKeys = keys.map((key) => this.getFullKey(key));\n      const values = await this.client.mget(...fullKeys);\n      \n      const result = new Map<string, T | null>();\n      keys.forEach((key, index) => {\n        const value = values[index];\n        result.set(key, value ? this.deserialize<T>(value) : null);\n      });\n\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to get multiple keys',\n        'mget',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set multiple values at once\n   * @param entries - Map of keys to values\n   * @param ttlSeconds - Optional TTL for all entries\n   */\n  async mset<T>(\n    entries: Map<string, T>,\n    ttlSeconds?: number\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      const pipeline = this.client.pipeline();\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      entries.forEach((value, key) => {\n        const fullKey = this.getFullKey(key);\n        const serialized = this.serialize(value);\n\n        if (ttl > 0) {\n          pipeline.setex(fullKey, ttl, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      });\n\n      await pipeline.exec();\n      this.log(`Set ${entries.size} keys in batch`);\n    } catch (error) {\n      throw new CacheError(\n        'Failed to set multiple keys',\n        'mset',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern('*');\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Object with cache statistics\n   */\n  async getStats(): Promise<{\n    connected: boolean;\n    keyCount: number;\n    memoryUsed: string;\n    uptime: number;\n  }> {\n    try {\n      await this.ensureConnection();\n\n      const info = await this.client.info('stats');\n      const memory = await this.client.info('memory');\n      const server = await this.client.info('server');\n      \n      // Count keys with our prefix\n      const pattern = this.getFullKey('*');\n      let keyCount = 0;\n      let cursor = '0';\n\n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          pattern,\n          'COUNT',\n          1000\n        );\n        cursor = nextCursor;\n        keyCount += keys.length;\n      } while (cursor !== '0');\n\n      // Parse memory usage\n      const memoryMatch = memory.match(/used_memory_human:([^\\r\\n]+)/);\n      const memoryUsed = memoryMatch ? memoryMatch[1] : 'unknown';\n\n      // Parse uptime\n      const uptimeMatch = server.match(/uptime_in_seconds:(\\d+)/);\n      const uptime = uptimeMatch ? parseInt(uptimeMatch[1], 10) : 0;\n\n      return {\n        connected: this.isConnected,\n        keyCount,\n        memoryUsed,\n        uptime,\n      };\n    } catch (error) {\n      throw new CacheError(\n        'Failed to get cache statistics',\n        'getStats',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Close the Redis connection\n   */\n  async disconnect(): Promise<void> {\n    try {\n      await this.client.quit();\n      this.isConnected = false;\n      this.log('Redis client disconnected');\n    } catch (error) {\n      throw new CacheError(\n        'Failed to disconnect',\n        'disconnect',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get the underlying Redis client (for advanced operations)\n   */\n  getClient(): RedisClient {\n    return this.client;\n  }\n\n  /**\n   * Check if cache is connected\n   */\n  isReady(): boolean {\n    return this.isConnected;\n  }\n}\n\n// Export a singleton instance factory\nlet defaultInstance: Cache | null = null;\n\nexport function getDefaultCache(config?: CacheConfig): Cache {\n  if (!defaultInstance) {\n    defaultInstance = new Cache(config);\n  }\n  return defaultInstance;\n}\n\nexport default Cache;\n```\n\n```typescript\n// cache.test.ts\nimport { Cache, CacheError, CacheConfig } from './cache';\n\n/**\n * Example usage and tests\n */\n\n// Example 1: Basic usage\nasync function basicUsageExample() {\n  const cache = new Cache({\n    host: 'localhost',\n    port: 6379,\n    keyPrefix: 'myapp:',\n    defaultTTL: 300, // 5 minutes\n  });",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 94,
            "output_tokens": 4096,
            "cached": true
          },
          "with_skill": {
            "output": "# Redis Cache Utility Module\n\nI'll create a comprehensive TypeScript caching layer with Redis using `ioredis`, including proper error handling, generics, and pattern-based invalidation.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions } from \"ioredis\";\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig {\n  /**\n   * Redis connection options (ioredis format)\n   */\n  redis?: RedisOptions;\n  /**\n   * Connection string (alternative to redis options)\n   * Format: redis://[:password@]host[:port][/db-number]\n   */\n  connectionString?: string;\n  /**\n   * Default TTL in seconds for cached items (optional)\n   */\n  defaultTTL?: number;\n  /**\n   * Prefix for all cache keys (helps with namespacing)\n   */\n  keyPrefix?: string;\n  /**\n   * Enable automatic reconnection on connection failures\n   */\n  enableOfflineQueue?: boolean;\n  /**\n   * Maximum number of retry attempts\n   */\n  maxRetriesPerRequest?: number;\n}\n\n/**\n * Error thrown when cache operations fail\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error,\n  ) {\n    super(message);\n    this.name = \"CacheError\";\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Generic Redis-based caching layer with TypeScript support\n */\nexport class Cache {\n  private client: Redis;\n  private readonly keyPrefix: string;\n  private readonly defaultTTL?: number;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.keyPrefix = config.keyPrefix || \"cache:\";\n    this.defaultTTL = config.defaultTTL;\n\n    // Initialize Redis client\n    if (config.connectionString) {\n      this.client = new Redis(config.connectionString, {\n        enableOfflineQueue: config.enableOfflineQueue ?? true,\n        maxRetriesPerRequest: config.maxRetriesPerRequest ?? 3,\n        lazyConnect: true,\n        ...config.redis,\n      });\n    } else {\n      this.client = new Redis({\n        enableOfflineQueue: config.enableOfflineQueue ?? true,\n        maxRetriesPerRequest: config.maxRetriesPerRequest ?? 3,\n        lazyConnect: true,\n        ...config.redis,\n      });\n    }\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup Redis event handlers for connection management\n   */\n  private setupEventHandlers(): void {\n    this.client.on(\"connect\", () => {\n      this.isConnected = true;\n      console.log(\"Redis cache connected\");\n    });\n\n    this.client.on(\"ready\", () => {\n      this.isConnected = true;\n      console.log(\"Redis cache ready\");\n    });\n\n    this.client.on(\"error\", (error) => {\n      console.error(\"Redis cache error:\", error);\n      this.isConnected = false;\n    });\n\n    this.client.on(\"close\", () => {\n      this.isConnected = false;\n      console.log(\"Redis cache connection closed\");\n    });\n\n    this.client.on(\"reconnecting\", () => {\n      console.log(\"Redis cache reconnecting...\");\n    });\n  }\n\n  /**\n   * Ensure the Redis client is connected\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    // Prevent multiple simultaneous connection attempts\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    this.connectionPromise = this.client\n      .connect()\n      .then(() => {\n        this.isConnected = true;\n        this.connectionPromise = null;\n      })\n      .catch((error) => {\n        this.connectionPromise = null;\n        throw new CacheError(\n          \"Failed to connect to Redis\",\n          \"connect\",\n          error as Error,\n        );\n      });\n\n    return this.connectionPromise;\n  }\n\n  /**\n   * Generate a prefixed cache key\n   */\n  private getPrefixedKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize a value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify(value);\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to serialize value\",\n        \"serialize\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Deserialize a JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      return JSON.parse(value) as T;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to deserialize value\",\n        \"deserialize\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get a cached value by key\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const value = await this.client.get(prefixedKey);\n\n      if (value === null) {\n        return null;\n      }\n\n      return this.deserialize<T>(value);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get cache key: ${key}`,\n        \"get\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set a cached value with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses defaultTTL if not provided)\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number,\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const serializedValue = this.serialize(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      if (ttl !== undefined && ttl > 0) {\n        await this.client.setex(prefixedKey, ttl, serializedValue);\n      } else {\n        await this.client.set(prefixedKey, serializedValue);\n      }\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set cache key: ${key}`,\n        \"set\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Delete a cached value by key\n   * @param key - Cache key\n   * @returns True if the key was deleted, false if it didn't exist\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.del(prefixedKey);\n\n      return result > 0;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to delete cache key: ${key}`,\n        \"delete\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:123:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedPattern = this.getPrefixedKey(pattern);\n      const keys: string[] = [];\n\n      // Use SCAN for safe iteration over large keysets\n      const stream = this.client.scanStream({\n        match: prefixedPattern,\n        count: 100,\n      });\n\n      // Collect all matching keys\n      await new Promise<void>((resolve, reject) => {\n        stream.on(\"data\", (resultKeys: string[]) => {\n          keys.push(...resultKeys);\n        });\n\n        stream.on(\"end\", () => {\n          resolve();\n        });\n\n        stream.on(\"error\", (error) => {\n          reject(error);\n        });\n      });\n\n      // Delete keys in batches using pipeline for efficiency\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      const pipeline = this.client.pipeline();\n      keys.forEach((key) => {\n        pipeline.del(key);\n      });\n\n      const results = await pipeline.exec();\n\n      // Count successful deletions\n      return results?.filter(([err, result]) => !err && result === 1).length ?? 0;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        \"invalidatePattern\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in the cache\n   * @param key - Cache key\n   * @returns True if the key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.exists(prefixedKey);\n\n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        \"exists\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get the TTL (time to live) of a key in seconds\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      return await this.client.ttl(prefixedKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        \"getTTL\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Update the TTL of an existing key\n   * @param key - Cache key\n   * @param ttlSeconds - New TTL in seconds\n   * @returns True if TTL was updated\n   */\n  async updateTTL(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.expire(prefixedKey, ttlSeconds);\n\n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to update TTL for key: ${key}`,\n        \"updateTTL\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get multiple values at once\n   * @param keys - Array of cache keys\n   * @returns Map of key to value (null for missing keys)\n   */\n  async getMany<T>(keys: string[]): Promise<Map<string, T | null>> {\n    try {\n      await this.ensureConnection();\n\n      if (keys.length === 0) {\n        return new Map();\n      }\n\n      const prefixedKeys = keys.map((key) => this.getPrefixedKey(key));\n      const values = await this.client.mget(...prefixedKeys);\n\n      const result = new Map<string, T | null>();\n      keys.forEach((key, index) => {\n        const value = values[index];\n        result.set(key, value ? this.deserialize<T>(value) : null);\n      });\n\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to get multiple cache keys\",\n        \"getMany\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set multiple values at once\n   * @param entries - Array of [key, value, ttl?] tuples\n   */\n  async setMany<T>(\n    entries: Array<[string, T, number?]>,\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      if (entries.length === 0) {\n        return;\n      }\n\n      const pipeline = this.client.pipeline();\n\n      entries.forEach(([key, value, ttl]) => {\n        const prefixedKey = this.getPrefixedKey(key);\n        const serializedValue = this.serialize(value);\n        const effectiveTTL = ttl ?? this.defaultTTL;\n\n        if (effectiveTTL !== undefined && effectiveTTL > 0) {\n          pipeline.setex(prefixedKey, effectiveTTL, serializedValue);\n        } else {\n          pipeline.set(prefixedKey, serializedValue);\n        }\n      });\n\n      await pipeline.exec();\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to set multiple cache keys\",\n        \"setMany\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern(\"*\");\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Object with cache stats\n   */\n  async getStats(): Promise<{\n    totalKeys: number;\n    memoryUsed: string;\n    connected: boolean;\n  }> {\n    try {\n      await this.ensureConnection();\n\n      const pattern = this.getPrefixedKey(\"*\");\n      let totalKeys = 0;\n\n      const stream = this.client.scanStream({\n        match: pattern,\n        count: 100,\n      });\n\n      await new Promise<void>((resolve, reject) => {\n        stream.on(\"data\", (keys: string[]) => {\n          totalKeys += keys.length;\n        });\n\n        stream.on(\"end\", () => {\n          resolve();\n        });\n\n        stream.on(\"error\", (error) => {\n          reject(error);\n        });\n      });\n\n      const info = await this.client.info(\"memory\");\n      const memoryMatch = info.match(/used_memory_human:(.+)/);\n      const memoryUsed = memoryMatch ? memoryMatch[1].trim() : \"unknown\";\n\n      return {\n        totalKeys,\n        memoryUsed,\n        connected: this.isConnected,\n      };\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to get cache stats\",\n        \"getStats\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    try {\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to disconnect from Redis\",\n        \"disconnect\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Check if the cache is connected\n   */\n  isReady(): boolean {\n    return this.isConnected;\n  }\n}\n\n/**\n * Create a cache instance with the given configuration\n */\nexport function createCache(config?: CacheConfig): Cache {\n  return new Cache(config);\n}\n```\n\nNow let's create comprehensive examples and tests:\n\n```typescript\n// cache.example.ts\nimport { Cache, CacheError, createCache } from \"./cache\";\n\n// Example 1: Basic usage\nasync function basicUsage() {\n  const cache = createCache({\n    connectionString: process.env.REDIS_URL || \"redis://localhost:6379\",\n    keyPrefix: \"myapp:\",\n    defaultTTL: 3600, // 1 hour\n  });\n\n  try {\n    // Set a value\n    await cache.set(\"",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8258,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Redis Caching Layer with TypeScript\n\nI'll create a comprehensive caching utility module with proper TypeScript generics, error handling, and Redis integration.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig {\n  /** Redis connection options */\n  redis?: RedisOptions;\n  /** Default TTL in seconds (optional) */\n  defaultTTL?: number;\n  /** Key prefix for all cache entries */\n  keyPrefix?: string;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n/**\n * Cache operation result\n */\nexport interface CacheResult<T> {\n  success: boolean;\n  data?: T;\n  error?: Error;\n}\n\n/**\n * Custom error types for cache operations\n */\nexport class CacheError extends Error {\n  constructor(message: string, public readonly operation: string, public readonly cause?: Error) {\n    super(message);\n    this.name = 'CacheError';\n  }\n}\n\nexport class CacheConnectionError extends CacheError {\n  constructor(message: string, cause?: Error) {\n    super(message, 'connection', cause);\n    this.name = 'CacheConnectionError';\n  }\n}\n\nexport class CacheSerializationError extends CacheError {\n  constructor(message: string, cause?: Error) {\n    super(message, 'serialization', cause);\n    this.name = 'CacheSerializationError';\n  }\n}\n\n/**\n * Generic caching layer using Redis with ioredis\n */\nexport class Cache {\n  private client: Redis;\n  private readonly config: Required<CacheConfig>;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      redis: config.redis || {},\n      defaultTTL: config.defaultTTL || 3600, // 1 hour default\n      keyPrefix: config.keyPrefix || 'cache:',\n      debug: config.debug || false,\n    };\n\n    // Initialize Redis client with retry strategy\n    this.client = new Redis({\n      ...this.config.redis,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection (attempt ${times}), delay: ${delay}ms`);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n    });\n\n    this.setupEventHandlers();\n    this.connectionPromise = this.waitForConnection();\n  }\n\n  /**\n   * Setup Redis event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client connected and ready');\n    });\n\n    this.client.on('error', (error: Error) => {\n      this.isConnected = false;\n      this.log(`Redis client error: ${error.message}`, 'error');\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Wait for Redis connection to be ready\n   */\n  private async waitForConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new CacheConnectionError('Connection timeout after 10 seconds'));\n      }, 10000);\n\n      this.client.once('ready', () => {\n        clearTimeout(timeout);\n        resolve();\n      });\n\n      this.client.once('error', (error: Error) => {\n        clearTimeout(timeout);\n        reject(new CacheConnectionError('Failed to connect to Redis', error));\n      });\n    });\n  }\n\n  /**\n   * Ensure connection is ready before operations\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n    } else {\n      throw new CacheConnectionError('Redis client is not connected');\n    }\n  }\n\n  /**\n   * Build full cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify({\n        data: value,\n        timestamp: Date.now(),\n      });\n    } catch (error) {\n      throw new CacheSerializationError(\n        `Failed to serialize value for caching`,\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const parsed = JSON.parse(value);\n      return parsed.data as T;\n    } catch (error) {\n      throw new CacheSerializationError(\n        `Failed to deserialize cached value`,\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Log messages if debug is enabled\n   */\n  private log(message: string, level: 'info' | 'error' = 'info'): void {\n    if (this.config.debug) {\n      const timestamp = new Date().toISOString();\n      const prefix = `[Cache ${timestamp}]`;\n      if (level === 'error') {\n        console.error(`${prefix} ${message}`);\n      } else {\n        console.log(`${prefix} ${message}`);\n      }\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      this.log(`GET ${fullKey}`);\n      \n      const value = await this.client.get(fullKey);\n      \n      if (value === null) {\n        this.log(`Cache miss: ${fullKey}`);\n        return null;\n      }\n      \n      this.log(`Cache hit: ${fullKey}`);\n      return this.deserialize<T>(value);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get value for key: ${key}`,\n        'get',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses default if not provided)\n   */\n  async set<T>(key: string, value: T, ttlSeconds?: number): Promise<void> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n      \n      this.log(`SET ${fullKey} (TTL: ${ttl}s)`);\n      \n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n      } else {\n        await this.client.set(fullKey, serialized);\n      }\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set value for key: ${key}`,\n        'set',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Delete a value from cache\n   * @param key - Cache key\n   * @returns Number of keys deleted (0 or 1)\n   */\n  async delete(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      this.log(`DELETE ${fullKey}`);\n      \n      const result = await this.client.del(fullKey);\n      this.log(`Deleted ${result} key(s)`);\n      \n      return result;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        'delete',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:123:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n      \n      const fullPattern = this.buildKey(pattern);\n      this.log(`INVALIDATE PATTERN ${fullPattern}`);\n      \n      // Use SCAN to find matching keys (safer than KEYS for production)\n      const keys: string[] = [];\n      let cursor = '0';\n      \n      do {\n        const [nextCursor, matchedKeys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100\n        );\n        cursor = nextCursor;\n        keys.push(...matchedKeys);\n      } while (cursor !== '0');\n      \n      if (keys.length === 0) {\n        this.log(`No keys found matching pattern: ${fullPattern}`);\n        return 0;\n      }\n      \n      // Delete in batches using pipeline for better performance\n      const pipeline = this.client.pipeline();\n      keys.forEach(key => pipeline.del(key));\n      await pipeline.exec();\n      \n      this.log(`Invalidated ${keys.length} key(s) matching pattern: ${fullPattern}`);\n      return keys.length;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        'invalidatePattern',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns True if key exists, false otherwise\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        'exists',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async ttl(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n      \n      const fullKey = this.buildKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        'ttl',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get or set pattern: retrieve from cache or compute and cache\n   * @param key - Cache key\n   * @param factory - Function to compute value if not in cache\n   * @param ttlSeconds - TTL for cached value\n   * @returns The cached or computed value\n   */\n  async getOrSet<T>(\n    key: string,\n    factory: () => Promise<T>,\n    ttlSeconds?: number\n  ): Promise<T> {\n    try {\n      // Try to get from cache first\n      const cached = await this.get<T>(key);\n      if (cached !== null) {\n        return cached;\n      }\n      \n      // Compute value\n      this.log(`Computing value for key: ${key}`);\n      const value = await factory();\n      \n      // Cache the computed value\n      await this.set(key, value, ttlSeconds);\n      \n      return value;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get or set value for key: ${key}`,\n        'getOrSet',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * WARNING: Use with caution in production\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern('*');\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Object with cache statistics\n   */\n  async stats(): Promise<{\n    connected: boolean;\n    keyCount: number;\n    memoryUsed: string;\n  }> {\n    try {\n      await this.ensureConnection();\n      \n      const info = await this.client.info('memory');\n      const memoryMatch = info.match(/used_memory_human:(.+)/);\n      const memoryUsed = memoryMatch ? memoryMatch[1].trim() : 'unknown';\n      \n      // Count keys with our prefix\n      let keyCount = 0;\n      let cursor = '0';\n      \n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          `${this.config.keyPrefix}*`,\n          'COUNT',\n          100\n        );\n        cursor = nextCursor;\n        keyCount += keys.length;\n      } while (cursor !== '0');\n      \n      return {\n        connected: this.isConnected,\n        keyCount,\n        memoryUsed,\n      };\n    } catch (error) {\n      throw new CacheError(\n        'Failed to get cache statistics',\n        'stats',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    this.log('Disconnecting from Redis...');\n    await this.client.quit();\n    this.isConnected = false;\n  }\n\n  /**\n   * Get the underlying Redis client (for advanced operations)\n   */\n  getClient(): Redis {\n    return this.client;\n  }\n}\n\n/**\n * Create a singleton cache instance\n */\nlet cacheInstance: Cache | null = null;\n\nexport function createCache(config?: CacheConfig): Cache {\n  if (!cacheInstance) {\n    cacheInstance = new Cache(config);\n  }\n  return cacheInstance;\n}\n\nexport function getCache(): Cache {\n  if (!cacheInstance) {\n    throw new Error('Cache not initialized. Call createCache() first.');\n  }\n  return cacheInstance;\n}\n```\n\nNow let's create usage examples and tests:\n\n```typescript\n// examples/basic-usage.ts\nimport { Cache } from '../cache';\n\nasync function basicUsageExample() {\n  // Initialize cache with custom configuration\n  const cache = new Cache({\n    redis: {\n      host: 'localhost',\n      port: 6379,\n      // password: 'your-password', // if needed\n    },\n    defaultTTL: 300, // 5 minutes\n    keyPrefix: 'myapp:',\n    debug: true,\n  });\n\n  try {\n    // Set a value\n    await cache.set('user:123', { id: 123, name: 'John Doe', email: 'john@example.com' });\n    console.log('User cached');\n\n    // Get a value\n    const user = await cache.get<{ id: number; name: string; email: string }>('user:123');\n    console.log('Retrieved user:', user);\n\n    // Set with custom TTL (10 seconds)\n    await cache.set('temp:data', { value: 'temporary' }, 10);\n\n    // Check if key exists\n    const",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2236,
            "output_tokens": 4096,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive Redis caching utility module with proper TypeScript generics and error handling.\n\n```typescript\n// src/lib/cache.ts\nimport Redis, { RedisOptions } from \"ioredis\";\n\ninterface CacheOptions {\n  redis?: RedisOptions;\n  keyPrefix?: string;\n  defaultTTL?: number;\n}\n\ninterface CacheResult<T> {\n  data: T | null;\n  error?: string;\n}\n\nexport class Cache {\n  private client: Redis;\n  private keyPrefix: string;\n  private defaultTTL: number;\n  private isConnected: boolean = false;\n\n  constructor(options: CacheOptions = {}) {\n    this.keyPrefix = options.keyPrefix ?? \"cache:\";\n    this.defaultTTL = options.defaultTTL ?? 3600; // 1 hour default\n\n    const redisOptions: RedisOptions = {\n      host: process.env.REDIS_HOST ?? \"localhost\",\n      port: parseInt(process.env.REDIS_PORT ?? \"6379\", 10),\n      password: process.env.REDIS_PASSWORD,\n      db: parseInt(process.env.REDIS_DB ?? \"0\", 10),\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      enableReadyCheck: true,\n      ...options.redis,\n    };\n\n    this.client = new Redis(redisOptions);\n\n    this.client.on(\"connect\", () => {\n      this.isConnected = true;\n      console.log(\"Redis client connected\");\n    });\n\n    this.client.on(\"error\", (err) => {\n      this.isConnected = false;\n      console.error(\"Redis client error:\", err);\n    });\n\n    this.client.on(\"close\", () => {\n      this.isConnected = false;\n      console.log(\"Redis client connection closed\");\n    });\n  }\n\n  /**\n   * Get a value from cache\n   */\n  async get<T>(key: string): Promise<CacheResult<T>> {\n    if (!this.isConnected) {\n      return {\n        data: null,\n        error: \"Redis client not connected\",\n      };\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const value = await this.client.get(prefixedKey);\n\n      if (value === null) {\n        return { data: null };\n      }\n\n      const parsed = JSON.parse(value) as T;\n      return { data: parsed };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      console.error(`Cache get error for key \"${key}\":`, errorMessage);\n      return {\n        data: null,\n        error: errorMessage,\n      };\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number,\n  ): Promise<{ success: boolean; error?: string }> {\n    if (!this.isConnected) {\n      return {\n        success: false,\n        error: \"Redis client not connected\",\n      };\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const serialized = JSON.stringify(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      if (ttl > 0) {\n        await this.client.setex(prefixedKey, ttl, serialized);\n      } else {\n        await this.client.set(prefixedKey, serialized);\n      }\n\n      return { success: true };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      console.error(`Cache set error for key \"${key}\":`, errorMessage);\n      return {\n        success: false,\n        error: errorMessage,\n      };\n    }\n  }\n\n  /**\n   * Delete a specific key from cache\n   */\n  async delete(key: string): Promise<{ success: boolean; error?: string }> {\n    if (!this.isConnected) {\n      return {\n        success: false,\n        error: \"Redis client not connected\",\n      };\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      await this.client.del(prefixedKey);\n      return { success: true };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      console.error(`Cache delete error for key \"${key}\":`, errorMessage);\n      return {\n        success: false,\n        error: errorMessage,\n      };\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * Pattern examples: \"user:*\", \"*:session\", \"cache:product:*\"\n   */\n  async invalidatePattern(\n    pattern: string,\n  ): Promise<{ success: boolean; deletedCount: number; error?: string }> {\n    if (!this.isConnected) {\n      return {\n        success: false,\n        deletedCount: 0,\n        error: \"Redis client not connected\",\n      };\n    }\n\n    try {\n      const prefixedPattern = this.getPrefixedKey(pattern);\n      const keys = await this.scanKeys(prefixedPattern);\n\n      if (keys.length === 0) {\n        return { success: true, deletedCount: 0 };\n      }\n\n      // Delete in batches using pipeline for better performance\n      const pipeline = this.client.pipeline();\n      keys.forEach((key) => pipeline.del(key));\n      await pipeline.exec();\n\n      return { success: true, deletedCount: keys.length };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      console.error(\n        `Cache invalidatePattern error for pattern \"${pattern}\":`,\n        errorMessage,\n      );\n      return {\n        success: false,\n        deletedCount: 0,\n        error: errorMessage,\n      };\n    }\n  }\n\n  /**\n   * Get or set pattern: fetch from cache, or compute and cache if missing\n   */\n  async getOrSet<T>(\n    key: string,\n    fetchFn: () => Promise<T>,\n    ttlSeconds?: number,\n  ): Promise<CacheResult<T>> {\n    const cached = await this.get<T>(key);\n\n    if (cached.data !== null) {\n      return cached;\n    }\n\n    try {\n      const data = await fetchFn();\n      await this.set(key, data, ttlSeconds);\n      return { data };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : \"Unknown error\";\n      return {\n        data: null,\n        error: errorMessage,\n      };\n    }\n  }\n\n  /**\n   * Check if a key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    if (!this.isConnected) {\n      return false;\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.exists(prefixedKey);\n      return result === 1;\n    } catch (error) {\n      console.error(`Cache exists error for key \"${key}\":`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Get TTL for a key (in seconds)\n   */\n  async getTTL(key: string): Promise<number | null> {\n    if (!this.isConnected) {\n      return null;\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const ttl = await this.client.ttl(prefixedKey);\n      return ttl >= 0 ? ttl : null;\n    } catch (error) {\n      console.error(`Cache getTTL error for key \"${key}\":`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Scan for keys matching a pattern (handles cursor-based iteration)\n   */\n  private async scanKeys(pattern: string): Promise<string[]> {\n    const keys: string[] = [];\n    let cursor = \"0\";\n\n    do {\n      const [nextCursor, foundKeys] = await this.client.scan(\n        cursor,\n        \"MATCH\",\n        pattern,\n        \"COUNT\",\n        100,\n      );\n      cursor = nextCursor;\n      keys.push(...foundKeys);\n    } while (cursor !== \"0\");\n\n    return keys;\n  }\n\n  /**\n   * Add prefix to key\n   */\n  private getPrefixedKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Close the Redis connection\n   */\n  async disconnect(): Promise<void> {\n    await this.client.quit();\n    this.isConnected = false;\n  }\n\n  /**\n   * Check connection status\n   */\n  get connected(): boolean {\n    return this.isConnected;\n  }\n\n  /**\n   * Flush all keys with the configured prefix\n   */\n  async flush(): Promise<{ success: boolean; error?: string }> {\n    return this.invalidatePattern(\"*\");\n  }\n}\n\n// Singleton instance for convenience\nlet cacheInstance: Cache | null = null;\n\nexport function getCache(options?: CacheOptions): Cache {\n  if (!cacheInstance) {\n    cacheInstance = new Cache(options);\n  }\n  return cacheInstance;\n}\n\nexport function resetCache(): void {\n  if (cacheInstance) {\n    cacheInstance.disconnect();\n    cacheInstance = null;\n  }\n}\n```\n\nNow let me create a comprehensive test file:\n\n```typescript\n// src/lib/cache.test.ts\nimport { describe, it, expect, beforeEach, afterEach, vi } from \"vitest\";\nimport { Cache } from \"./cache\";\n\n// Mock ioredis\nvi.mock(\"ioredis\", () => {\n  const mockRedis = vi.fn(() => ({\n    get: vi.fn(),\n    set: vi.fn(),\n    setex: vi.fn(),\n    del: vi.fn(),\n    exists: vi.fn(),\n    ttl: vi.fn(),\n    scan: vi.fn(),\n    pipeline: vi.fn(() => ({\n      del: vi.fn(),\n      exec: vi.fn(),\n    })),\n    quit: vi.fn(),\n    on: vi.fn(),\n  }));\n\n  return { default: mockRedis };\n});\n\ndescribe(\"Cache\", () => {\n  let cache: Cache;\n\n  beforeEach(() => {\n    cache = new Cache({ keyPrefix: \"test:\" });\n    // Simulate connection\n    (cache as any).isConnected = true;\n  });\n\n  afterEach(async () => {\n    await cache.disconnect();\n  });\n\n  describe(\"get\", () => {\n    it(\"should return null for non-existent key\", async () => {\n      const mockClient = (cache as any).client;\n      mockClient.get.mockResolvedValue(null);\n\n      const result = await cache.get(\"nonexistent\");\n\n      expect(result.data).toBeNull();\n      expect(result.error).toBeUndefined();\n    });\n\n    it(\"should return parsed data for existing key\", async () => {\n      const mockClient = (cache as any).client;\n      const testData = { id: 1, name: \"Test\" };\n      mockClient.get.mockResolvedValue(JSON.stringify(testData));\n\n      const result = await cache.get<typeof testData>(\"test-key\");\n\n      expect(result.data).toEqual(testData);\n      expect(result.error).toBeUndefined();\n    });\n\n    it(\"should handle JSON parse errors\", async () => {\n      const mockClient = (cache as any).client;\n      mockClient.get.mockResolvedValue(\"invalid json\");\n\n      const result = await cache.get(\"test-key\");\n\n      expect(result.data).toBeNull();\n      expect(result.error).toBeDefined();\n    });\n\n    it(\"should return error when not connected\", async () => {\n      (cache as any).isConnected = false;\n\n      const result = await cache.get(\"test-key\");\n\n      expect(result.data).toBeNull();\n      expect(result.error).toBe(\"Redis client not connected\");\n    });\n  });\n\n  describe(\"set\", () => {\n    it(\"should set value with TTL\", async () => {\n      const mockClient = (cache as any).client;\n      mockClient.setex.mockResolvedValue(\"OK\");\n\n      const result = await cache.set(\"test-key\", { data: \"test\" }, 300);\n\n      expect(result.success).toBe(true);\n      expect(mockClient.setex).toHaveBeenCalledWith(\n        \"test:test-key\",\n        300,\n        JSON.stringify({ data: \"test\" }),\n      );\n    });\n\n    it(\"should set value without TTL when ttl is 0\", async () => {\n      const mockClient = (cache as any).client;\n      mockClient.set.mockResolvedValue(\"OK\");\n\n      const result = await cache.set(\"test-key\", { data: \"test\" }, 0);\n\n      expect(result.success).toBe(true);\n      expect(mockClient.set).toHaveBeenCalled();\n    });\n\n    it(\"should return error when not connected\", async () => {\n      (cache as any).isConnected = false;\n\n      const result = await cache.set(\"test-key\", { data: \"test\" });\n\n      expect(result.success).toBe(false);\n      expect(result.error).toBe(\"Redis client not connected\");\n    });\n  });\n\n  describe(\"delete\", () => {\n    it(\"should delete a key\", async () => {\n      const mockClient = (cache as any).client;\n      mockClient.del.mockResolvedValue(1);\n\n      const result = await cache.delete(\"test-key\");\n\n      expect(result.success).toBe(true);\n      expect(mockClient.del).toHaveBeenCalledWith(\"test:test-key\");\n    });\n  });\n\n  describe(\"invalidatePattern\", () => {\n    it(\"should delete all keys matching pattern\", async () => {\n      const mockClient = (cache as any).client;\n      mockClient.scan.mockResolvedValue([\n        \"0\",\n        [\"test:user:1\", \"test:user:2\"],\n      ]);\n\n      const mockPipeline = {\n        del: vi.fn(),\n        exec: vi.fn().mockResolvedValue([]),\n      };\n      mockClient.pipeline.mockReturnValue(mockPipeline);\n\n      const result = await cache.invalidatePattern(\"user:*\");\n\n      expect(result.success).toBe(true);\n      expect(result.deletedCount).toBe(2);\n      expect(mockPipeline.del).toHaveBeenCalledTimes(2);\n    });\n\n    it(\"should handle empty pattern match\", async () => {\n      const mockClient = (cache as any).client;\n      mockClient.scan.mockResolvedValue([\"0\", []]);\n\n      const result = await cache.invalidatePattern(\"nonexistent:*\");\n\n      expect(result.success).toBe(true);\n      expect(result.deletedCount).toBe(0);\n    });\n  });\n\n  describe(\"getOrSet\", () => {\n    it(\"should return cached value if exists\", async () => {\n      const mockClient = (cache as any).client;\n      const cachedData = { id: 1, name: \"Cached\" };\n      mockClient.get.mockResolvedValue(JSON.stringify(cachedData));\n\n      const fetchFn = vi.fn();\n      const result = await cache.getOrSet(\"test-key\", fetchFn);\n\n      expect(result.data).toEqual(cachedData);\n      expect(fetchFn).not.toHaveBeenCalled();\n    });\n\n    it(\"should fetch and cache if not exists\", async () => {\n      const mockClient = (cache as any).client;\n      mockClient.get.mockResolvedValue(null);\n      mockClient.setex.mockResolvedValue(\"OK\");\n\n      const fetchedData = { id: 1, name: \"Fetched\" };\n      const fetchFn = vi.fn().mockResolvedValue(fetchedData);\n\n      const result = await cache.getOrSet(\"test-key\", fetchFn, 300);\n\n      expect",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8753,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Redis Caching Layer Utility Module\n\n```typescript\n// cache.ts\nimport Redis, { Redis as RedisClient, RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig extends RedisOptions {\n  keyPrefix?: string;\n  defaultTTL?: number;\n  enableLogging?: boolean;\n}\n\n/**\n * Custom error class for cache-related errors\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Serialized cache value wrapper\n */\ninterface CacheValue<T> {\n  data: T;\n  timestamp: number;\n  type: string;\n}\n\n/**\n * Generic Redis caching layer with TypeScript support\n */\nexport class Cache {\n  private client: RedisClient;\n  private keyPrefix: string;\n  private defaultTTL: number;\n  private enableLogging: boolean;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.keyPrefix = config.keyPrefix || 'cache:';\n    this.defaultTTL = config.defaultTTL || 3600; // 1 hour default\n    this.enableLogging = config.enableLogging ?? false;\n\n    // Initialize Redis client with default configuration\n    const redisConfig: RedisOptions = {\n      host: config.host || 'localhost',\n      port: config.port || 6379,\n      password: config.password,\n      db: config.db || 0,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection... Attempt ${times}`);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      enableReadyCheck: true,\n      ...config,\n    };\n\n    this.client = new Redis(redisConfig);\n\n    // Set up event handlers\n    this.setupEventHandlers();\n\n    // Initialize connection\n    this.connectionPromise = this.initialize();\n  }\n\n  /**\n   * Set up Redis client event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client connected and ready');\n    });\n\n    this.client.on('error', (error: Error) => {\n      this.isConnected = false;\n      this.log(`Redis client error: ${error.message}`, 'error');\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Initialize the cache connection\n   */\n  private async initialize(): Promise<void> {\n    try {\n      await this.client.ping();\n      this.isConnected = true;\n      this.log('Cache initialized successfully');\n    } catch (error) {\n      this.isConnected = false;\n      throw new CacheError(\n        'Failed to initialize cache connection',\n        'initialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Ensure the client is connected before operations\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n    }\n\n    if (!this.isConnected) {\n      throw new CacheError(\n        'Redis client is not connected',\n        'ensureConnection'\n      );\n    }\n  }\n\n  /**\n   * Generate a prefixed cache key\n   */\n  private getPrefixedKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value for storage\n   */\n  private serialize<T>(value: T): string {\n    try {\n      const cacheValue: CacheValue<T> = {\n        data: value,\n        timestamp: Date.now(),\n        type: typeof value,\n      };\n      return JSON.stringify(cacheValue);\n    } catch (error) {\n      throw new CacheError(\n        'Failed to serialize cache value',\n        'serialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Deserialize value from storage\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const cacheValue: CacheValue<T> = JSON.parse(value);\n      return cacheValue.data;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to deserialize cache value',\n        'deserialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Log messages if logging is enabled\n   */\n  private log(message: string, level: 'info' | 'error' = 'info'): void {\n    if (this.enableLogging) {\n      const timestamp = new Date().toISOString();\n      const prefix = `[Cache ${timestamp}]`;\n      \n      if (level === 'error') {\n        console.error(`${prefix} ${message}`);\n      } else {\n        console.log(`${prefix} ${message}`);\n      }\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n      \n      const prefixedKey = this.getPrefixedKey(key);\n      const value = await this.client.get(prefixedKey);\n\n      if (value === null) {\n        this.log(`Cache miss: ${key}`);\n        return null;\n      }\n\n      this.log(`Cache hit: ${key}`);\n      return this.deserialize<T>(value);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get value for key: ${key}`,\n        'get',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const serializedValue = this.serialize(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      if (ttl > 0) {\n        await this.client.setex(prefixedKey, ttl, serializedValue);\n      } else {\n        await this.client.set(prefixedKey, serializedValue);\n      }\n\n      this.log(`Cache set: ${key} (TTL: ${ttl}s)`);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set value for key: ${key}`,\n        'set',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Delete a value from cache\n   * @param key - Cache key\n   * @returns True if the key was deleted, false if it didn't exist\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.del(prefixedKey);\n\n      const deleted = result > 0;\n      this.log(`Cache delete: ${key} (deleted: ${deleted})`);\n      \n      return deleted;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        'delete',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Pattern to match (e.g., \"user:*\")\n   * @returns Number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedPattern = this.getPrefixedKey(pattern);\n      const keys = await this.scanKeys(prefixedPattern);\n\n      if (keys.length === 0) {\n        this.log(`No keys found for pattern: ${pattern}`);\n        return 0;\n      }\n\n      // Delete keys in batches using pipeline for better performance\n      const pipeline = this.client.pipeline();\n      keys.forEach((key) => pipeline.del(key));\n      await pipeline.exec();\n\n      this.log(`Invalidated ${keys.length} keys for pattern: ${pattern}`);\n      return keys.length;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        'invalidatePattern',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Scan for keys matching a pattern using SCAN command\n   * @param pattern - Pattern to match\n   * @returns Array of matching keys\n   */\n  private async scanKeys(pattern: string): Promise<string[]> {\n    const keys: string[] = [];\n    let cursor = '0';\n\n    do {\n      const [nextCursor, foundKeys] = await this.client.scan(\n        cursor,\n        'MATCH',\n        pattern,\n        'COUNT',\n        100\n      );\n      \n      cursor = nextCursor;\n      keys.push(...foundKeys);\n    } while (cursor !== '0');\n\n    return keys;\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns True if the key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.exists(prefixedKey);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        'exists',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get the TTL (time to live) of a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      return await this.client.ttl(prefixedKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        'getTTL',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set expiry on an existing key\n   * @param key - Cache key\n   * @param ttlSeconds - Time to live in seconds\n   * @returns True if expiry was set\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.expire(prefixedKey, ttlSeconds);\n      \n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to set expiry for key: ${key}`,\n        'expire',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get multiple values at once\n   * @param keys - Array of cache keys\n   * @returns Map of key-value pairs\n   */\n  async getMany<T>(keys: string[]): Promise<Map<string, T | null>> {\n    try {\n      await this.ensureConnection();\n\n      if (keys.length === 0) {\n        return new Map();\n      }\n\n      const prefixedKeys = keys.map((key) => this.getPrefixedKey(key));\n      const values = await this.client.mget(...prefixedKeys);\n\n      const result = new Map<string, T | null>();\n      keys.forEach((key, index) => {\n        const value = values[index];\n        result.set(key, value ? this.deserialize<T>(value) : null);\n      });\n\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to get multiple values',\n        'getMany',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set multiple values at once\n   * @param entries - Array of [key, value, ttl?] tuples\n   */\n  async setMany<T>(\n    entries: Array<[string, T, number?]>\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      if (entries.length === 0) {\n        return;\n      }\n\n      const pipeline = this.client.pipeline();\n\n      entries.forEach(([key, value, ttl]) => {\n        const prefixedKey = this.getPrefixedKey(key);\n        const serializedValue = this.serialize(value);\n        const ttlSeconds = ttl ?? this.defaultTTL;\n\n        if (ttlSeconds > 0) {\n          pipeline.setex(prefixedKey, ttlSeconds, serializedValue);\n        } else {\n          pipeline.set(prefixedKey, serializedValue);\n        }\n      });\n\n      await pipeline.exec();\n      this.log(`Cache set many: ${entries.length} entries`);\n    } catch (error) {\n      throw new CacheError(\n        'Failed to set multiple values',\n        'setMany',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    try {\n      return await this.invalidatePattern('*');\n    } catch (error) {\n      throw new CacheError(\n        'Failed to clear cache',\n        'clear',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Object containing cache statistics\n   */\n  async getStats(): Promise<{\n    connected: boolean;\n    keyCount: number;\n    memoryUsed?: string;\n    uptime?: number;\n  }> {\n    try {\n      await this.ensureConnection();\n\n      const pattern = this.getPrefixedKey('*');\n      const keys = await this.scanKeys(pattern);\n      \n      let memoryUsed: string | undefined;\n      let uptime: number | undefined;\n\n      try {\n        const info = await this.client.info('memory');\n        const memoryMatch = info.match(/used_memory_human:(.+)/);\n        if (memoryMatch) {\n          memoryUsed = memoryMatch[1].trim();\n        }\n\n        const serverInfo = await this.client.info('server');\n        const uptimeMatch = serverInfo.match(/uptime_in_seconds:(\\d+)/);\n        if (uptimeMatch) {\n          uptime = parseInt(uptimeMatch[1], 10);\n        }\n      } catch (error) {\n        // INFO command might not be available in some Redis configurations\n        this.log('Could not retrieve detailed stats', 'error');\n      }\n\n      return {\n        connected: this.isConnected,\n        keyCount: keys.length,\n        memoryUsed,\n        uptime,\n      };\n    } catch (error) {\n      throw new C",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 94,
            "output_tokens": 4096,
            "cached": true
          },
          "with_skill": {
            "output": "# Redis Cache Utility Module\n\nI'll create a comprehensive TypeScript caching layer with Redis using ioredis, including proper error handling, generics, and pattern-based invalidation.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions, Redis as RedisClient } from \"ioredis\";\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig extends RedisOptions {\n  /**\n   * Redis connection string (e.g., redis://localhost:6379)\n   * Takes precedence over individual connection options\n   */\n  url?: string;\n  /**\n   * Prefix for all cache keys to avoid collisions\n   * @default \"cache:\"\n   */\n  keyPrefix?: string;\n  /**\n   * Default TTL in seconds for cached items\n   * @default 3600 (1 hour)\n   */\n  defaultTTL?: number;\n  /**\n   * Enable debug logging\n   * @default false\n   */\n  debug?: boolean;\n  /**\n   * Maximum number of connection retry attempts\n   * @default 10\n   */\n  maxRetriesPerRequest?: number;\n  /**\n   * Enable offline queue for commands when disconnected\n   * @default true\n   */\n  enableOfflineQueue?: boolean;\n}\n\n/**\n * Error thrown when cache operations fail\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error,\n  ) {\n    super(message);\n    this.name = \"CacheError\";\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Result type for cache operations that may fail gracefully\n */\nexport type CacheResult<T> =\n  | { success: true; data: T }\n  | { success: false; error: CacheError };\n\n/**\n * Generic Redis-based caching layer with TypeScript support\n */\nexport class Cache {\n  private client: RedisClient;\n  private keyPrefix: string;\n  private defaultTTL: number;\n  private debug: boolean;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.keyPrefix = config.keyPrefix ?? \"cache:\";\n    this.defaultTTL = config.defaultTTL ?? 3600;\n    this.debug = config.debug ?? false;\n\n    // Create Redis client with configuration\n    const redisOptions: RedisOptions = {\n      ...config,\n      maxRetriesPerRequest: config.maxRetriesPerRequest ?? 10,\n      enableOfflineQueue: config.enableOfflineQueue ?? true,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection (attempt ${times}), delay: ${delay}ms`);\n        return delay;\n      },\n      reconnectOnError: (err: Error) => {\n        const targetErrors = [\"READONLY\", \"ECONNREFUSED\"];\n        if (targetErrors.some((target) => err.message.includes(target))) {\n          this.log(`Reconnecting due to error: ${err.message}`);\n          return true;\n        }\n        return false;\n      },\n    };\n\n    // Initialize client with URL or options\n    if (config.url) {\n      this.client = new Redis(config.url, redisOptions);\n    } else {\n      this.client = new Redis(redisOptions);\n    }\n\n    this.setupEventHandlers();\n    this.connectionPromise = this.waitForConnection();\n  }\n\n  /**\n   * Set up Redis client event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on(\"connect\", () => {\n      this.log(\"Redis client connecting...\");\n    });\n\n    this.client.on(\"ready\", () => {\n      this.log(\"Redis client ready\");\n      this.isConnected = true;\n    });\n\n    this.client.on(\"error\", (err: Error) => {\n      this.log(`Redis client error: ${err.message}`, \"error\");\n      this.isConnected = false;\n    });\n\n    this.client.on(\"close\", () => {\n      this.log(\"Redis client connection closed\");\n      this.isConnected = false;\n    });\n\n    this.client.on(\"reconnecting\", () => {\n      this.log(\"Redis client reconnecting...\");\n    });\n\n    this.client.on(\"end\", () => {\n      this.log(\"Redis client connection ended\");\n      this.isConnected = false;\n    });\n  }\n\n  /**\n   * Wait for Redis connection to be ready\n   */\n  private async waitForConnection(): Promise<void> {\n    if (this.isConnected) return;\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(\n          new CacheError(\n            \"Connection timeout after 10 seconds\",\n            \"connect\",\n            new Error(\"Timeout\"),\n          ),\n        );\n      }, 10000);\n\n      this.client.once(\"ready\", () => {\n        clearTimeout(timeout);\n        resolve();\n      });\n\n      this.client.once(\"error\", (err: Error) => {\n        clearTimeout(timeout);\n        reject(new CacheError(\"Failed to connect to Redis\", \"connect\", err));\n      });\n    });\n  }\n\n  /**\n   * Ensure connection is ready before operations\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) return;\n\n    if (this.connectionPromise) {\n      await this.connectionPromise;\n    } else {\n      this.connectionPromise = this.waitForConnection();\n      await this.connectionPromise;\n    }\n  }\n\n  /**\n   * Build full cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Log debug messages if debug mode is enabled\n   */\n  private log(message: string, level: \"info\" | \"error\" = \"info\"): void {\n    if (this.debug) {\n      const timestamp = new Date().toISOString();\n      const prefix = `[Cache ${timestamp}]`;\n      if (level === \"error\") {\n        console.error(`${prefix} ${message}`);\n      } else {\n        console.log(`${prefix} ${message}`);\n      }\n    }\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify(value);\n    } catch (err) {\n      throw new CacheError(\n        \"Failed to serialize value\",\n        \"serialize\",\n        err as Error,\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      return JSON.parse(value) as T;\n    } catch (err) {\n      throw new CacheError(\n        \"Failed to deserialize value\",\n        \"deserialize\",\n        err as Error,\n      );\n    }\n  }\n\n  /**\n   * Get a cached value by key\n   * @param key - Cache key\n   * @returns The cached value or null if not found\n   * @throws CacheError if operation fails\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`GET ${fullKey}`);\n\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        this.log(`Cache miss: ${fullKey}`);\n        return null;\n      }\n\n      this.log(`Cache hit: ${fullKey}`);\n      return this.deserialize<T>(value);\n    } catch (err) {\n      const error = new CacheError(\n        `Failed to get key: ${key}`,\n        \"get\",\n        err as Error,\n      );\n      this.log(error.message, \"error\");\n      throw error;\n    }\n  }\n\n  /**\n   * Get a cached value by key with graceful error handling\n   * @param key - Cache key\n   * @returns Result object with success status and data or error\n   */\n  async getSafe<T>(key: string): Promise<CacheResult<T | null>> {\n    try {\n      const data = await this.get<T>(key);\n      return { success: true, data };\n    } catch (err) {\n      return {\n        success: false,\n        error: err instanceof CacheError ? err : new CacheError(\n          `Failed to get key: ${key}`,\n          \"get\",\n          err as Error,\n        ),\n      };\n    }\n  }\n\n  /**\n   * Set a cached value with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses defaultTTL if not provided)\n   * @throws CacheError if operation fails\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number,\n  ): Promise<void> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      this.log(`SET ${fullKey} (TTL: ${ttl}s)`);\n\n      await this.client.setex(fullKey, ttl, serialized);\n    } catch (err) {\n      const error = new CacheError(\n        `Failed to set key: ${key}`,\n        \"set\",\n        err as Error,\n      );\n      this.log(error.message, \"error\");\n      throw error;\n    }\n  }\n\n  /**\n   * Set a cached value with graceful error handling\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   * @returns Result object with success status\n   */\n  async setSafe<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number,\n  ): Promise<CacheResult<void>> {\n    try {\n      await this.set(key, value, ttlSeconds);\n      return { success: true, data: undefined };\n    } catch (err) {\n      return {\n        success: false,\n        error: err instanceof CacheError ? err : new CacheError(\n          `Failed to set key: ${key}`,\n          \"set\",\n          err as Error,\n        ),\n      };\n    }\n  }\n\n  /**\n   * Delete a cached value by key\n   * @param key - Cache key\n   * @returns Number of keys deleted (0 or 1)\n   * @throws CacheError if operation fails\n   */\n  async delete(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`DEL ${fullKey}`);\n\n      const result = await this.client.del(fullKey);\n      this.log(`Deleted ${result} key(s)`);\n\n      return result;\n    } catch (err) {\n      const error = new CacheError(\n        `Failed to delete key: ${key}`,\n        \"delete\",\n        err as Error,\n      );\n      this.log(error.message, \"error\");\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a cached value with graceful error handling\n   * @param key - Cache key\n   * @returns Result object with success status and number of keys deleted\n   */\n  async deleteSafe(key: string): Promise<CacheResult<number>> {\n    try {\n      const data = await this.delete(key);\n      return { success: true, data };\n    } catch (err) {\n      return {\n        success: false,\n        error: err instanceof CacheError ? err : new CacheError(\n          `Failed to delete key: ${key}`,\n          \"delete\",\n          err as Error,\n        ),\n      };\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:123:*\")\n   * @returns Number of keys deleted\n   * @throws CacheError if operation fails\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullPattern = this.buildKey(pattern);\n      this.log(`Scanning for pattern: ${fullPattern}`);\n\n      let cursor = \"0\";\n      let totalDeleted = 0;\n      const batchSize = 100;\n\n      do {\n        // Scan for keys matching the pattern\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          \"MATCH\",\n          fullPattern,\n          \"COUNT\",\n          batchSize,\n        );\n\n        cursor = nextCursor;\n\n        if (keys.length > 0) {\n          this.log(`Found ${keys.length} keys to delete`);\n\n          // Delete keys in pipeline for better performance\n          const pipeline = this.client.pipeline();\n          keys.forEach((key) => pipeline.del(key));\n          const results = await pipeline.exec();\n\n          // Count successful deletions\n          const deleted = results?.filter(([err]) => !err).length ?? 0;\n          totalDeleted += deleted;\n\n          this.log(`Deleted ${deleted} keys in batch`);\n        }\n      } while (cursor !== \"0\");\n\n      this.log(`Total deleted: ${totalDeleted} keys`);\n      return totalDeleted;\n    } catch (err) {\n      const error = new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        \"invalidatePattern\",\n        err as Error,\n      );\n      this.log(error.message, \"error\");\n      throw error;\n    }\n  }\n\n  /**\n   * Invalidate pattern with graceful error handling\n   * @param pattern - Redis pattern\n   * @returns Result object with success status and number of keys deleted\n   */\n  async invalidatePatternSafe(pattern: string): Promise<CacheResult<number>> {\n    try {\n      const data = await this.invalidatePattern(pattern);\n      return { success: true, data };\n    } catch (err) {\n      return {\n        success: false,\n        error: err instanceof CacheError ? err : new CacheError(\n          `Failed to invalidate pattern: ${pattern}`,\n          \"invalidatePattern\",\n          err as Error,\n        ),\n      };\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns true if key exists, false otherwise\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n\n      return result === 1;\n    } catch (err) {\n      const error = new CacheError(\n        `Failed to check existence of key: ${key}`,\n        \"exists\",\n        err as Error,\n      );\n      this.log(error.message, \"error\");\n      throw error;\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if key exists but has no TTL, -2 if key doesn't exist\n   */\n  async ttl(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (err) {\n      const error = new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        \"ttl\",\n        err as Error,\n      );\n      this.log(error.message, \"error\");\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern(\"*\");\n  }\n\n  /**\n   * Get multiple keys at once\n   * @param keys - Array of cache keys\n   * @returns Array of values (null for missing keys)\n   */\n  async mget<T>(keys: string[]): Promise<(",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8258,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Redis Caching Layer with TypeScript\n\nI'll create a comprehensive caching utility module with proper TypeScript generics, error handling, and Redis integration.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig {\n  /** Redis connection options */\n  redis?: RedisOptions;\n  /** Default TTL in seconds (0 = no expiration) */\n  defaultTTL?: number;\n  /** Key prefix for all cache entries */\n  keyPrefix?: string;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n/**\n * Cache operation result\n */\nexport interface CacheResult<T> {\n  success: boolean;\n  data?: T;\n  error?: Error;\n}\n\n/**\n * Cache statistics\n */\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  sets: number;\n  deletes: number;\n  errors: number;\n}\n\n/**\n * Generic caching layer using Redis with TypeScript support\n */\nexport class Cache {\n  private client: Redis;\n  private config: Required<CacheConfig>;\n  private stats: CacheStats;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      redis: config.redis || {},\n      defaultTTL: config.defaultTTL ?? 3600, // 1 hour default\n      keyPrefix: config.keyPrefix || 'cache:',\n      debug: config.debug ?? false,\n    };\n\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      deletes: 0,\n      errors: 0,\n    };\n\n    // Initialize Redis client with connection handling\n    this.client = new Redis({\n      ...this.config.redis,\n      lazyConnect: true,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection (attempt ${times}) in ${delay}ms`);\n        return delay;\n      },\n      reconnectOnError: (err: Error) => {\n        const targetError = 'READONLY';\n        if (err.message.includes(targetError)) {\n          // Reconnect on READONLY errors\n          return true;\n        }\n        return false;\n      },\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup Redis event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client ready');\n    });\n\n    this.client.on('error', (err: Error) => {\n      this.isConnected = false;\n      this.stats.errors++;\n      this.log(`Redis error: ${err.message}`, 'error');\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Ensure Redis connection is established\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    // Reuse existing connection attempt if in progress\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    this.connectionPromise = this.client\n      .connect()\n      .then(() => {\n        this.connectionPromise = null;\n      })\n      .catch((err) => {\n        this.connectionPromise = null;\n        throw new Error(`Failed to connect to Redis: ${err.message}`);\n      });\n\n    return this.connectionPromise;\n  }\n\n  /**\n   * Build full cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify({\n        data: value,\n        timestamp: Date.now(),\n      });\n    } catch (err) {\n      throw new Error(\n        `Failed to serialize value: ${err instanceof Error ? err.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const parsed = JSON.parse(value);\n      return parsed.data as T;\n    } catch (err) {\n      throw new Error(\n        `Failed to deserialize value: ${err instanceof Error ? err.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Log debug messages\n   */\n  private log(message: string, level: 'info' | 'error' = 'info'): void {\n    if (this.config.debug) {\n      const timestamp = new Date().toISOString();\n      const prefix = `[Cache ${timestamp}]`;\n      if (level === 'error') {\n        console.error(`${prefix} ${message}`);\n      } else {\n        console.log(`${prefix} ${message}`);\n      }\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns Promise resolving to the cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`GET ${fullKey}`);\n\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        this.stats.misses++;\n        this.log(`MISS ${fullKey}`);\n        return null;\n      }\n\n      this.stats.hits++;\n      this.log(`HIT ${fullKey}`);\n\n      return this.deserialize<T>(value);\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error getting key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Set a value in cache\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses defaultTTL if not provided)\n   * @returns Promise resolving to true if successful\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      this.log(`SET ${fullKey} (TTL: ${ttl}s)`);\n\n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n      } else {\n        await this.client.set(fullKey, serialized);\n      }\n\n      this.stats.sets++;\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error setting key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key was deleted, false if key didn't exist\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`DELETE ${fullKey}`);\n\n      const result = await this.client.del(fullKey);\n      this.stats.deletes++;\n\n      return result > 0;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error deleting key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:*\")\n   * @returns Promise resolving to the number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullPattern = this.buildKey(pattern);\n      this.log(`INVALIDATE PATTERN ${fullPattern}`);\n\n      let cursor = '0';\n      let totalDeleted = 0;\n\n      // Use SCAN to avoid blocking Redis with KEYS\n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100\n        );\n\n        cursor = nextCursor;\n\n        if (keys.length > 0) {\n          const deleted = await this.client.del(...keys);\n          totalDeleted += deleted;\n          this.stats.deletes += deleted;\n          this.log(`Deleted ${deleted} keys matching ${fullPattern}`);\n        }\n      } while (cursor !== '0');\n\n      this.log(`Total deleted: ${totalDeleted} keys`);\n      return totalDeleted;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(\n        `Error invalidating pattern ${pattern}: ${error.message}`,\n        'error'\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n\n      return result === 1;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error checking existence of key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns Promise resolving to TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async ttl(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error getting TTL for key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Update TTL for an existing key\n   * @param key - Cache key\n   * @param ttlSeconds - New TTL in seconds\n   * @returns Promise resolving to true if successful\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const result = await this.client.expire(fullKey, ttlSeconds);\n\n      return result === 1;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error setting expiry for key ${key}: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Get multiple values at once\n   * @param keys - Array of cache keys\n   * @returns Promise resolving to array of values (null for missing keys)\n   */\n  async mget<T>(keys: string[]): Promise<(T | null)[]> {\n    try {\n      await this.ensureConnection();\n\n      const fullKeys = keys.map((k) => this.buildKey(k));\n      this.log(`MGET ${fullKeys.length} keys`);\n\n      const values = await this.client.mget(...fullKeys);\n\n      return values.map((value, index) => {\n        if (value === null) {\n          this.stats.misses++;\n          return null;\n        }\n        this.stats.hits++;\n        try {\n          return this.deserialize<T>(value);\n        } catch (err) {\n          this.log(\n            `Error deserializing key ${keys[index]}: ${err instanceof Error ? err.message : 'Unknown error'}`,\n            'error'\n          );\n          return null;\n        }\n      });\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error in mget: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Set multiple values at once\n   * @param entries - Array of [key, value, ttl?] tuples\n   * @returns Promise resolving to true if all successful\n   */\n  async mset<T>(\n    entries: Array<[string, T, number?]>\n  ): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      this.log(`MSET ${entries.length} keys`);\n\n      // Use pipeline for atomic operations\n      const pipeline = this.client.pipeline();\n\n      for (const [key, value, ttl] of entries) {\n        const fullKey = this.buildKey(key);\n        const serialized = this.serialize(value);\n        const ttlToUse = ttl ?? this.config.defaultTTL;\n\n        if (ttlToUse > 0) {\n          pipeline.setex(fullKey, ttlToUse, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      }\n\n      await pipeline.exec();\n      this.stats.sets += entries.length;\n\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.log(`Error in mset: ${error.message}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * @returns Promise resolving to the number of keys deleted\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern('*');\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Current cache statistics\n   */\n  getStats(): Readonly<CacheStats> {\n    return { ...this.stats };\n  }\n\n  /**\n   * Reset cache statistics\n   */\n  resetStats(): void {\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      deletes: 0,\n      errors: 0,\n    };\n  }\n\n  /**\n   * Get cache hit rate\n   * @returns Hit rate as a percentage (0-100)\n   */\n  getHitRate(): number {\n    const total = this.stats.hits + this.stats.misses;\n    if (total === 0) return 0;\n    return (this.stats.hits / total) * 100;\n  }\n\n  /**\n   * Check if cache is connected\n   * @returns True if connected to Redis\n   */\n  isReady(): boolean {\n    return this.isConnected;\n  }\n\n  /**\n   * Disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    this.log('Disconnecting from Redis...');\n    await this.client.quit();\n    this.isConnected = false;\n  }\n\n  /**\n   * Get the underlying Redis client (for advanced operations)\n   * @returns",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2236,
            "output_tokens": 4096,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive Redis caching utility module with proper TypeScript generics and error handling.\n\n```typescript\n// src/lib/cache.ts\nimport Redis, { Redis as RedisClient, RedisOptions } from \"ioredis\";\n\nexport interface CacheOptions {\n  host?: string;\n  port?: number;\n  password?: string;\n  db?: number;\n  keyPrefix?: string;\n  retryStrategy?: (times: number) => number | void;\n  maxRetriesPerRequest?: number;\n}\n\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly cause?: Error,\n  ) {\n    super(message);\n    this.name = \"CacheError\";\n  }\n}\n\nexport class Cache {\n  private client: RedisClient;\n  private keyPrefix: string;\n  private isConnected: boolean = false;\n\n  constructor(options: CacheOptions = {}) {\n    this.keyPrefix = options.keyPrefix ?? \"cache:\";\n\n    const redisOptions: RedisOptions = {\n      host: options.host ?? process.env.REDIS_HOST ?? \"localhost\",\n      port: options.port ?? Number(process.env.REDIS_PORT) ?? 6379,\n      password: options.password ?? process.env.REDIS_PASSWORD,\n      db: options.db ?? 0,\n      maxRetriesPerRequest: options.maxRetriesPerRequest ?? 3,\n      retryStrategy:\n        options.retryStrategy ??\n        ((times: number) => {\n          if (times > 10) {\n            return null; // Stop retrying\n          }\n          return Math.min(times * 100, 3000); // Exponential backoff, max 3s\n        }),\n      lazyConnect: true, // Don't connect immediately\n      enableOfflineQueue: false, // Fail fast if not connected\n    };\n\n    this.client = new Redis(redisOptions);\n\n    this.client.on(\"connect\", () => {\n      this.isConnected = true;\n    });\n\n    this.client.on(\"error\", (error) => {\n      this.isConnected = false;\n      console.error(\"Redis connection error:\", error);\n    });\n\n    this.client.on(\"close\", () => {\n      this.isConnected = false;\n    });\n  }\n\n  /**\n   * Connect to Redis. Call this before using the cache.\n   */\n  async connect(): Promise<void> {\n    try {\n      await this.client.connect();\n      this.isConnected = true;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to connect to Redis\",\n        \"connect\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Check if the cache is connected and ready\n   */\n  isReady(): boolean {\n    return this.isConnected && this.client.status === \"ready\";\n  }\n\n  /**\n   * Get a value from cache\n   */\n  async get<T>(key: string): Promise<T | null> {\n    if (!this.isReady()) {\n      throw new CacheError(\n        \"Redis client is not connected\",\n        \"get\",\n      );\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const value = await this.client.get(prefixedKey);\n\n      if (value === null) {\n        return null;\n      }\n\n      return this.deserialize<T>(value);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get key: ${key}`,\n        \"get\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number,\n  ): Promise<void> {\n    if (!this.isReady()) {\n      throw new CacheError(\n        \"Redis client is not connected\",\n        \"set\",\n      );\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const serialized = this.serialize(value);\n\n      if (ttlSeconds !== undefined && ttlSeconds > 0) {\n        await this.client.setex(prefixedKey, ttlSeconds, serialized);\n      } else {\n        await this.client.set(prefixedKey, serialized);\n      }\n    } catch (error) {\n      throw new CacheError(\n        `Failed to set key: ${key}`,\n        \"set\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Delete a specific key from cache\n   */\n  async delete(key: string): Promise<boolean> {\n    if (!this.isReady()) {\n      throw new CacheError(\n        \"Redis client is not connected\",\n        \"delete\",\n      );\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.del(prefixedKey);\n      return result > 0;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        \"delete\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * Pattern examples: \"user:*\", \"*:session\", \"user:123:*\"\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    if (!this.isReady()) {\n      throw new CacheError(\n        \"Redis client is not connected\",\n        \"invalidatePattern\",\n      );\n    }\n\n    try {\n      const prefixedPattern = this.getPrefixedKey(pattern);\n      const keys = await this.scanKeys(prefixedPattern);\n\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      // Delete in batches to avoid blocking Redis\n      const batchSize = 100;\n      let deletedCount = 0;\n\n      for (let i = 0; i < keys.length; i += batchSize) {\n        const batch = keys.slice(i, i + batchSize);\n        const result = await this.client.del(...batch);\n        deletedCount += result;\n      }\n\n      return deletedCount;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        \"invalidatePattern\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   */\n  async exists(key: string): Promise<boolean> {\n    if (!this.isReady()) {\n      throw new CacheError(\n        \"Redis client is not connected\",\n        \"exists\",\n      );\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      const result = await this.client.exists(prefixedKey);\n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        \"exists\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key in seconds\n   */\n  async ttl(key: string): Promise<number> {\n    if (!this.isReady()) {\n      throw new CacheError(\n        \"Redis client is not connected\",\n        \"ttl\",\n      );\n    }\n\n    try {\n      const prefixedKey = this.getPrefixedKey(key);\n      return await this.client.ttl(prefixedKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        \"ttl\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern(\"*\");\n  }\n\n  /**\n   * Disconnect from Redis\n   */\n  async disconnect(): Promise<void> {\n    try {\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to disconnect from Redis\",\n        \"disconnect\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Scan for keys matching a pattern using SCAN command\n   * This is more efficient than KEYS for large datasets\n   */\n  private async scanKeys(pattern: string): Promise<string[]> {\n    const keys: string[] = [];\n    let cursor = \"0\";\n\n    do {\n      const [nextCursor, batch] = await this.client.scan(\n        cursor,\n        \"MATCH\",\n        pattern,\n        \"COUNT\",\n        100,\n      );\n      cursor = nextCursor;\n      keys.push(...batch);\n    } while (cursor !== \"0\");\n\n    return keys;\n  }\n\n  /**\n   * Add prefix to key\n   */\n  private getPrefixedKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify(value);\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to serialize value\",\n        \"serialize\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      return JSON.parse(value) as T;\n    } catch (error) {\n      throw new CacheError(\n        \"Failed to deserialize value\",\n        \"deserialize\",\n        error as Error,\n      );\n    }\n  }\n}\n\n/**\n * Create a singleton cache instance\n */\nlet cacheInstance: Cache | null = null;\n\nexport function getCache(options?: CacheOptions): Cache {\n  if (!cacheInstance) {\n    cacheInstance = new Cache(options);\n  }\n  return cacheInstance;\n}\n\n/**\n * Helper function for cache-aside pattern\n */\nexport async function withCache<T>(\n  cache: Cache,\n  key: string,\n  fetcher: () => Promise<T>,\n  ttlSeconds?: number,\n): Promise<T> {\n  // Try to get from cache\n  const cached = await cache.get<T>(key);\n  if (cached !== null) {\n    return cached;\n  }\n\n  // Fetch fresh data\n  const data = await fetcher();\n\n  // Store in cache (fire and forget)\n  cache.set(key, data, ttlSeconds).catch((error) => {\n    console.error(\"Failed to cache data:\", error);\n  });\n\n  return data;\n}\n```\n\nNow let me create a comprehensive test file:\n\n```typescript\n// src/lib/cache.test.ts\nimport { describe, it, expect, beforeEach, afterEach, vi } from \"vitest\";\nimport { Cache, CacheError, withCache } from \"./cache\";\n\n// Mock ioredis\nvi.mock(\"ioredis\", () => {\n  const mockRedis = {\n    connect: vi.fn().mockResolvedValue(undefined),\n    get: vi.fn(),\n    set: vi.fn().mockResolvedValue(\"OK\"),\n    setex: vi.fn().mockResolvedValue(\"OK\"),\n    del: vi.fn(),\n    exists: vi.fn(),\n    ttl: vi.fn(),\n    scan: vi.fn(),\n    quit: vi.fn().mockResolvedValue(\"OK\"),\n    on: vi.fn(),\n    status: \"ready\",\n  };\n\n  return {\n    default: vi.fn(() => mockRedis),\n  };\n});\n\ndescribe(\"Cache\", () => {\n  let cache: Cache;\n  let mockClient: any;\n\n  beforeEach(async () => {\n    const Redis = (await import(\"ioredis\")).default;\n    cache = new Cache({ keyPrefix: \"test:\" });\n    await cache.connect();\n    mockClient = (Redis as any).mock.results[0].value;\n  });\n\n  afterEach(async () => {\n    vi.clearAllMocks();\n  });\n\n  describe(\"get\", () => {\n    it(\"should return null for non-existent key\", async () => {\n      mockClient.get.mockResolvedValue(null);\n\n      const result = await cache.get(\"nonexistent\");\n\n      expect(result).toBeNull();\n      expect(mockClient.get).toHaveBeenCalledWith(\"test:nonexistent\");\n    });\n\n    it(\"should deserialize and return cached value\", async () => {\n      const data = { id: 1, name: \"Test\" };\n      mockClient.get.mockResolvedValue(JSON.stringify(data));\n\n      const result = await cache.get<typeof data>(\"user:1\");\n\n      expect(result).toEqual(data);\n      expect(mockClient.get).toHaveBeenCalledWith(\"test:user:1\");\n    });\n\n    it(\"should throw CacheError on connection failure\", async () => {\n      mockClient.status = \"disconnected\";\n\n      await expect(cache.get(\"key\")).rejects.toThrow(CacheError);\n    });\n\n    it(\"should throw CacheError on deserialization failure\", async () => {\n      mockClient.get.mockResolvedValue(\"invalid json\");\n\n      await expect(cache.get(\"key\")).rejects.toThrow(CacheError);\n    });\n  });\n\n  describe(\"set\", () => {\n    it(\"should serialize and store value without TTL\", async () => {\n      const data = { id: 1, name: \"Test\" };\n\n      await cache.set(\"user:1\", data);\n\n      expect(mockClient.set).toHaveBeenCalledWith(\n        \"test:user:1\",\n        JSON.stringify(data),\n      );\n    });\n\n    it(\"should serialize and store value with TTL\", async () => {\n      const data = { id: 1, name: \"Test\" };\n      const ttl = 3600;\n\n      await cache.set(\"user:1\", data, ttl);\n\n      expect(mockClient.setex).toHaveBeenCalledWith(\n        \"test:user:1\",\n        ttl,\n        JSON.stringify(data),\n      );\n    });\n\n    it(\"should handle primitive values\", async () => {\n      await cache.set(\"count\", 42);\n      expect(mockClient.set).toHaveBeenCalledWith(\"test:count\", \"42\");\n\n      await cache.set(\"flag\", true);\n      expect(mockClient.set).toHaveBeenCalledWith(\"test:flag\", \"true\");\n\n      await cache.set(\"message\", \"hello\");\n      expect(mockClient.set).toHaveBeenCalledWith(\"test:message\", '\"hello\"');\n    });\n\n    it(\"should throw CacheError on connection failure\", async () => {\n      mockClient.status = \"disconnected\";\n\n      await expect(cache.set(\"key\", \"value\")).rejects.toThrow(CacheError);\n    });\n  });\n\n  describe(\"delete\", () => {\n    it(\"should delete key and return true if existed\", async () => {\n      mockClient.del.mockResolvedValue(1);\n\n      const result = await cache.delete(\"user:1\");\n\n      expect(result).toBe(true);\n      expect(mockClient.del).toHaveBeenCalledWith(\"test:user:1\");\n    });\n\n    it(\"should return false if key did not exist\", async () => {\n      mockClient.del.mockResolvedValue(0);\n\n      const result = await cache.delete(\"nonexistent\");\n\n      expect(result).toBe(false);\n    });\n  });\n\n  describe(\"invalidatePattern\", () => {\n    it(\"should delete all keys matching pattern\", async () => {\n      mockClient.scan\n        .mockResolvedValueOnce([\"0\", [\"test:user:1\", \"test:user:2\"]])\n        .mockResolvedValueOnce([\"0\", []]);\n      mockClient.del.mockResolvedValue(2);\n\n      const result = await cache.invalidatePattern(\"user:*\");\n\n      expect(result).toBe(2);\n      expect(mockClient.scan).toHaveBeenCalledWith(\n        \"0\",\n        \"MATCH\",\n        \"test:user:*\",\n        \"COUNT\",\n        100,\n      );\n      expect(mockClient.del).toHaveBeenCalledWith(\"test:user:1\", \"test:user",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8753,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Redis Caching Layer Utility Module\n\n```typescript\n// cache.ts\nimport Redis, { Redis as RedisClient, RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig extends RedisOptions {\n  host?: string;\n  port?: number;\n  password?: string;\n  db?: number;\n  keyPrefix?: string;\n  retryStrategy?: (times: number) => number | void;\n  maxRetriesPerRequest?: number;\n}\n\n/**\n * Custom error class for cache-related errors\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Result wrapper for cache operations\n */\nexport interface CacheResult<T> {\n  success: boolean;\n  data?: T;\n  error?: CacheError;\n}\n\n/**\n * Generic Redis caching layer with TypeScript support\n */\nexport class Cache {\n  private client: RedisClient;\n  private isConnected: boolean = false;\n  private readonly keyPrefix: string;\n\n  constructor(config: CacheConfig = {}) {\n    this.keyPrefix = config.keyPrefix || 'cache:';\n\n    const defaultConfig: CacheConfig = {\n      host: config.host || process.env.REDIS_HOST || 'localhost',\n      port: config.port || parseInt(process.env.REDIS_PORT || '6379'),\n      password: config.password || process.env.REDIS_PASSWORD,\n      db: config.db || 0,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      lazyConnect: true,\n      ...config,\n    };\n\n    this.client = new Redis(defaultConfig);\n\n    // Connection event handlers\n    this.client.on('connect', () => {\n      this.isConnected = true;\n      console.log('Redis client connected');\n    });\n\n    this.client.on('ready', () => {\n      console.log('Redis client ready');\n    });\n\n    this.client.on('error', (err: Error) => {\n      console.error('Redis client error:', err);\n      this.isConnected = false;\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      console.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      console.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Establish connection to Redis\n   */\n  async connect(): Promise<void> {\n    try {\n      await this.client.connect();\n      this.isConnected = true;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to connect to Redis',\n        'connect',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if the client is connected\n   */\n  public get connected(): boolean {\n    return this.isConnected && this.client.status === 'ready';\n  }\n\n  /**\n   * Get the full key with prefix\n   */\n  private getFullKey(key: string): string {\n    return `${this.keyPrefix}${key}`;\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify({\n        data: value,\n        timestamp: Date.now(),\n        type: typeof value,\n      });\n    } catch (error) {\n      throw new CacheError(\n        'Failed to serialize value',\n        'serialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to typed value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const parsed = JSON.parse(value);\n      return parsed.data as T;\n    } catch (error) {\n      throw new CacheError(\n        'Failed to deserialize value',\n        'deserialize',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns Promise resolving to the cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'get'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        return null;\n      }\n\n      return this.deserialize<T>(value);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get key: ${key}`,\n        'get',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get a value from cache with error handling wrapper\n   * @param key - Cache key\n   * @returns Promise resolving to CacheResult\n   */\n  async getSafe<T>(key: string): Promise<CacheResult<T>> {\n    try {\n      const data = await this.get<T>(key);\n      return {\n        success: true,\n        data: data || undefined,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error as CacheError,\n      };\n    }\n  }\n\n  /**\n   * Set a value in cache\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   * @returns Promise resolving to true if successful\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'set'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const serialized = this.serialize(value);\n\n      if (ttlSeconds && ttlSeconds > 0) {\n        const result = await this.client.setex(\n          fullKey,\n          ttlSeconds,\n          serialized\n        );\n        return result === 'OK';\n      } else {\n        const result = await this.client.set(fullKey, serialized);\n        return result === 'OK';\n      }\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set key: ${key}`,\n        'set',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with error handling wrapper\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional)\n   * @returns Promise resolving to CacheResult\n   */\n  async setSafe<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<CacheResult<boolean>> {\n    try {\n      const success = await this.set(key, value, ttlSeconds);\n      return {\n        success: true,\n        data: success,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error as CacheError,\n      };\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key to delete\n   * @returns Promise resolving to true if key was deleted\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'delete'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.del(fullKey);\n      return result > 0;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        'delete',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Delete multiple keys from cache\n   * @param keys - Array of cache keys to delete\n   * @returns Promise resolving to number of keys deleted\n   */\n  async deleteMany(keys: string[]): Promise<number> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'deleteMany'\n        );\n      }\n\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      const fullKeys = keys.map((key) => this.getFullKey(key));\n      const result = await this.client.del(...fullKeys);\n      return result;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        'Failed to delete multiple keys',\n        'deleteMany',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Pattern to match (e.g., \"user:*\")\n   * @returns Promise resolving to number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'invalidatePattern'\n        );\n      }\n\n      const fullPattern = this.getFullKey(pattern);\n      const keys: string[] = [];\n\n      // Use SCAN to find all matching keys (safer than KEYS for production)\n      let cursor = '0';\n      do {\n        const [nextCursor, foundKeys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100\n        );\n        cursor = nextCursor;\n        keys.push(...foundKeys);\n      } while (cursor !== '0');\n\n      if (keys.length === 0) {\n        return 0;\n      }\n\n      // Delete all found keys\n      const result = await this.client.del(...keys);\n      return result;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        'invalidatePattern',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'exists'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.exists(fullKey);\n      return result === 1;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to check existence of key: ${key}`,\n        'exists',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get the TTL (time to live) of a key in seconds\n   * @param key - Cache key\n   * @returns Promise resolving to TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'getTTL'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        'getTTL',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set expiry time for a key\n   * @param key - Cache key\n   * @param ttlSeconds - Time to live in seconds\n   * @returns Promise resolving to true if expiry was set\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'expire'\n        );\n      }\n\n      const fullKey = this.getFullKey(key);\n      const result = await this.client.expire(fullKey, ttlSeconds);\n      return result === 1;\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        `Failed to set expiry for key: ${key}`,\n        'expire',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Clear all keys with the configured prefix\n   * WARNING: Use with caution in production\n   * @returns Promise resolving to number of keys deleted\n   */\n  async clear(): Promise<number> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'clear'\n        );\n      }\n\n      return await this.invalidatePattern('*');\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        'Failed to clear cache',\n        'clear',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Get multiple values from cache\n   * @param keys - Array of cache keys\n   * @returns Promise resolving to array of values (null for missing keys)\n   */\n  async getMany<T>(keys: string[]): Promise<(T | null)[]> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'getMany'\n        );\n      }\n\n      if (keys.length === 0) {\n        return [];\n      }\n\n      const fullKeys = keys.map((key) => this.getFullKey(key));\n      const values = await this.client.mget(...fullKeys);\n\n      return values.map((value) => {\n        if (value === null) {\n          return null;\n        }\n        return this.deserialize<T>(value);\n      });\n    } catch (error) {\n      if (error instanceof CacheError) {\n        throw error;\n      }\n      throw new CacheError(\n        'Failed to get multiple keys',\n        'getMany',\n        error as Error\n      );\n    }\n  }\n\n  /**\n   * Set multiple key-value pairs\n   * @param entries - Array of [key, value, ttl?] tuples\n   * @returns Promise resolving to true if all operations succeeded\n   */\n  async setMany<T>(\n    entries: Array<[string, T, number?]>\n  ): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        throw new CacheError(\n          'Redis client is not connected',\n          'setMany'\n        );\n      }\n\n      if (entries.length === 0) {\n        return true;\n      }\n\n      const pipeline = this.client.pipeline();\n\n      for (const [key, value, ttl] of entries) {\n        const fullKey = this.getFullKey(key);\n        const serialized = this.serialize(value);\n\n        if (ttl && ttl > 0) {\n          pipeline.setex(fullKey, ttl, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      }\n\n      const results = await pipeline.exec();\n\n      if (!results) {\n        return false;\n      }\n\n      // Check if all operations succeeded\n      return results.every(\n        ([error, result]) => error === null && result === '",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 94,
            "output_tokens": 4096,
            "cached": true
          },
          "with_skill": {
            "output": "# Redis Cache Utility Module\n\nI'll create a comprehensive TypeScript caching layer with Redis using ioredis, including proper error handling, generics, and pattern-based invalidation.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions, Cluster } from \"ioredis\";\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig {\n  /**\n   * Redis connection string or options object\n   * @example \"redis://localhost:6379\"\n   * @example { host: \"localhost\", port: 6379 }\n   */\n  connection: string | RedisOptions;\n\n  /**\n   * Default TTL in seconds for cached items (optional)\n   * @default undefined (no expiration)\n   */\n  defaultTTL?: number;\n\n  /**\n   * Prefix for all cache keys (optional)\n   * @default \"cache:\"\n   */\n  keyPrefix?: string;\n\n  /**\n   * Enable debug logging (optional)\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * Maximum number of connection retry attempts (optional)\n   * @default 3\n   */\n  maxRetries?: number;\n\n  /**\n   * Retry delay in milliseconds (optional)\n   * @default 1000\n   */\n  retryDelay?: number;\n}\n\n/**\n * Error thrown when cache operations fail\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error,\n  ) {\n    super(message);\n    this.name = \"CacheError\";\n    Object.setPrototypeOf(this, CacheError.prototype);\n  }\n}\n\n/**\n * Result type for cache operations that may fail\n */\nexport type CacheResult<T> =\n  | { success: true; data: T }\n  | { success: false; error: CacheError };\n\n/**\n * Generic Redis-based caching layer with TypeScript support\n *\n * @example\n * ```typescript\n * const cache = new Cache({\n *   connection: process.env.REDIS_URL!,\n *   defaultTTL: 3600,\n *   keyPrefix: \"myapp:\"\n * });\n *\n * await cache.connect();\n *\n * // Set a value\n * await cache.set(\"user:123\", { id: 123, name: \"John\" }, 300);\n *\n * // Get a value with type safety\n * const user = await cache.get<User>(\"user:123\");\n *\n * // Delete a key\n * await cache.delete(\"user:123\");\n *\n * // Invalidate all keys matching a pattern\n * await cache.invalidatePattern(\"user:*\");\n *\n * await cache.disconnect();\n * ```\n */\nexport class Cache {\n  private client: Redis | null = null;\n  private config: Required<\n    Omit<CacheConfig, \"connection\" | \"defaultTTL\">\n  > & {\n    connection: string | RedisOptions;\n    defaultTTL?: number;\n  };\n  private isConnected = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig) {\n    this.config = {\n      connection: config.connection,\n      defaultTTL: config.defaultTTL,\n      keyPrefix: config.keyPrefix ?? \"cache:\",\n      debug: config.debug ?? false,\n      maxRetries: config.maxRetries ?? 3,\n      retryDelay: config.retryDelay ?? 1000,\n    };\n  }\n\n  /**\n   * Establishes connection to Redis server\n   * @throws {CacheError} If connection fails after max retries\n   */\n  async connect(): Promise<void> {\n    // Return existing connection promise if already connecting\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    // Return immediately if already connected\n    if (this.isConnected && this.client) {\n      return;\n    }\n\n    this.connectionPromise = this.establishConnection();\n    return this.connectionPromise;\n  }\n\n  private async establishConnection(): Promise<void> {\n    let lastError: Error | undefined;\n\n    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {\n      try {\n        this.log(`Connection attempt ${attempt}/${this.config.maxRetries}`);\n\n        // Create Redis client\n        if (typeof this.config.connection === \"string\") {\n          this.client = new Redis(this.config.connection, {\n            lazyConnect: true,\n            enableOfflineQueue: false,\n          });\n        } else {\n          this.client = new Redis({\n            ...this.config.connection,\n            lazyConnect: true,\n            enableOfflineQueue: false,\n          });\n        }\n\n        // Set up error handlers\n        this.client.on(\"error\", (err) => {\n          this.log(`Redis error: ${err.message}`, true);\n        });\n\n        this.client.on(\"close\", () => {\n          this.isConnected = false;\n          this.log(\"Redis connection closed\");\n        });\n\n        this.client.on(\"reconnecting\", () => {\n          this.log(\"Redis reconnecting...\");\n        });\n\n        // Attempt connection\n        await this.client.connect();\n\n        // Test connection with PING\n        await this.client.ping();\n\n        this.isConnected = true;\n        this.connectionPromise = null;\n        this.log(\"Successfully connected to Redis\");\n        return;\n      } catch (error) {\n        lastError = error as Error;\n        this.log(\n          `Connection attempt ${attempt} failed: ${lastError.message}`,\n          true,\n        );\n\n        // Clean up failed client\n        if (this.client) {\n          try {\n            await this.client.quit();\n          } catch {\n            // Ignore cleanup errors\n          }\n          this.client = null;\n        }\n\n        // Wait before retry (except on last attempt)\n        if (attempt < this.config.maxRetries) {\n          await this.sleep(this.config.retryDelay);\n        }\n      }\n    }\n\n    this.connectionPromise = null;\n    throw new CacheError(\n      `Failed to connect to Redis after ${this.config.maxRetries} attempts`,\n      \"connect\",\n      lastError,\n    );\n  }\n\n  /**\n   * Disconnects from Redis server\n   */\n  async disconnect(): Promise<void> {\n    if (this.client) {\n      try {\n        await this.client.quit();\n        this.log(\"Disconnected from Redis\");\n      } catch (error) {\n        this.log(`Error during disconnect: ${(error as Error).message}`, true);\n      } finally {\n        this.client = null;\n        this.isConnected = false;\n        this.connectionPromise = null;\n      }\n    }\n  }\n\n  /**\n   * Retrieves a value from cache with type safety\n   *\n   * @template T - The expected type of the cached value\n   * @param key - Cache key (will be prefixed automatically)\n   * @returns The cached value or null if not found\n   * @throws {CacheError} If Redis operation fails\n   *\n   * @example\n   * ```typescript\n   * interface User { id: number; name: string; }\n   * const user = await cache.get<User>(\"user:123\");\n   * if (user) {\n   *   console.log(user.name); // Type-safe access\n   * }\n   * ```\n   */\n  async get<T>(key: string): Promise<T | null> {\n    await this.ensureConnected();\n\n    try {\n      const fullKey = this.buildKey(key);\n      this.log(`GET ${fullKey}`);\n\n      const value = await this.client!.get(fullKey);\n\n      if (value === null) {\n        this.log(`Cache miss: ${fullKey}`);\n        return null;\n      }\n\n      this.log(`Cache hit: ${fullKey}`);\n      return this.deserialize<T>(value);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get key \"${key}\": ${(error as Error).message}`,\n        \"get\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Stores a value in cache with optional TTL\n   *\n   * @template T - The type of value to cache\n   * @param key - Cache key (will be prefixed automatically)\n   * @param value - Value to cache (will be JSON serialized)\n   * @param ttlSeconds - Time to live in seconds (optional, uses defaultTTL if not provided)\n   * @throws {CacheError} If Redis operation fails\n   *\n   * @example\n   * ```typescript\n   * await cache.set(\"user:123\", { id: 123, name: \"John\" }, 300);\n   * await cache.set(\"config\", { theme: \"dark\" }); // Uses defaultTTL\n   * ```\n   */\n  async set<T>(key: string, value: T, ttlSeconds?: number): Promise<void> {\n    await this.ensureConnected();\n\n    try {\n      const fullKey = this.buildKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      this.log(`SET ${fullKey} (TTL: ${ttl ?? \"none\"})`);\n\n      if (ttl !== undefined && ttl > 0) {\n        await this.client!.setex(fullKey, ttl, serialized);\n      } else {\n        await this.client!.set(fullKey, serialized);\n      }\n    } catch (error) {\n      throw new CacheError(\n        `Failed to set key \"${key}\": ${(error as Error).message}`,\n        \"set\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Deletes a key from cache\n   *\n   * @param key - Cache key to delete (will be prefixed automatically)\n   * @returns Number of keys deleted (0 or 1)\n   * @throws {CacheError} If Redis operation fails\n   *\n   * @example\n   * ```typescript\n   * const deleted = await cache.delete(\"user:123\");\n   * console.log(deleted ? \"Deleted\" : \"Not found\");\n   * ```\n   */\n  async delete(key: string): Promise<number> {\n    await this.ensureConnected();\n\n    try {\n      const fullKey = this.buildKey(key);\n      this.log(`DEL ${fullKey}`);\n\n      const result = await this.client!.del(fullKey);\n      this.log(`Deleted ${result} key(s)`);\n      return result;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to delete key \"${key}\": ${(error as Error).message}`,\n        \"delete\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Invalidates all keys matching a pattern\n   *\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"*:session\", \"cache:*\")\n   * @returns Number of keys deleted\n   * @throws {CacheError} If Redis operation fails\n   *\n   * @example\n   * ```typescript\n   * // Delete all user cache entries\n   * await cache.invalidatePattern(\"user:*\");\n   *\n   * // Delete all session entries\n   * await cache.invalidatePattern(\"*:session\");\n   * ```\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    await this.ensureConnected();\n\n    try {\n      const fullPattern = this.buildKey(pattern);\n      this.log(`Invalidating pattern: ${fullPattern}`);\n\n      const keys = await this.scanKeys(fullPattern);\n\n      if (keys.length === 0) {\n        this.log(\"No keys found matching pattern\");\n        return 0;\n      }\n\n      this.log(`Found ${keys.length} keys to delete`);\n\n      // Delete in batches using pipeline for better performance\n      const batchSize = 100;\n      let totalDeleted = 0;\n\n      for (let i = 0; i < keys.length; i += batchSize) {\n        const batch = keys.slice(i, i + batchSize);\n        const pipeline = this.client!.pipeline();\n\n        batch.forEach((key) => pipeline.del(key));\n\n        const results = await pipeline.exec();\n\n        if (results) {\n          totalDeleted += results.reduce(\n            (sum, [err, result]) => sum + (err ? 0 : (result as number)),\n            0,\n          );\n        }\n      }\n\n      this.log(`Deleted ${totalDeleted} keys`);\n      return totalDeleted;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to invalidate pattern \"${pattern}\": ${(error as Error).message}`,\n        \"invalidatePattern\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Checks if a key exists in cache\n   *\n   * @param key - Cache key to check\n   * @returns true if key exists, false otherwise\n   * @throws {CacheError} If Redis operation fails\n   */\n  async exists(key: string): Promise<boolean> {\n    await this.ensureConnected();\n\n    try {\n      const fullKey = this.buildKey(key);\n      const result = await this.client!.exists(fullKey);\n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to check existence of key \"${key}\": ${(error as Error).message}`,\n        \"exists\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Gets the remaining TTL for a key in seconds\n   *\n   * @param key - Cache key\n   * @returns TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   * @throws {CacheError} If Redis operation fails\n   */\n  async getTTL(key: string): Promise<number> {\n    await this.ensureConnected();\n\n    try {\n      const fullKey = this.buildKey(key);\n      return await this.client!.ttl(fullKey);\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get TTL for key \"${key}\": ${(error as Error).message}`,\n        \"getTTL\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Updates the TTL for an existing key\n   *\n   * @param key - Cache key\n   * @param ttlSeconds - New TTL in seconds\n   * @returns true if TTL was updated, false if key doesn't exist\n   * @throws {CacheError} If Redis operation fails\n   */\n  async updateTTL(key: string, ttlSeconds: number): Promise<boolean> {\n    await this.ensureConnected();\n\n    try {\n      const fullKey = this.buildKey(key);\n      const result = await this.client!.expire(fullKey, ttlSeconds);\n      return result === 1;\n    } catch (error) {\n      throw new CacheError(\n        `Failed to update TTL for key \"${key}\": ${(error as Error).message}`,\n        \"updateTTL\",\n        error as Error,\n      );\n    }\n  }\n\n  /**\n   * Clears all keys with the configured prefix\n   *\n   * @returns Number of keys deleted\n   * @throws {CacheError} If Redis operation fails\n   */\n  async clear(): Promise<number> {\n    return this.invalidatePattern(\"*\");\n  }\n\n  /**\n   * Gets multiple keys at once\n   *\n   * @template T - The expected type of cached values\n   * @param keys - Array of cache keys\n   * @returns Array of values (null for missing keys)\n   * @throws {CacheError} If Redis operation fails\n   */\n  async getMany<T>(keys: string[]): Promise<(T | null)[]> {\n    await this.ensureConnected();\n\n    if (keys.length === 0) {\n      return [];\n    }\n\n    try {\n      const fullKeys = keys.map((key) => this.buildKey(key));\n      const values = await this.client!.mget(...fullKeys);\n\n      return values.map((value) =>\n        value === null ? null : this.deserialize<T>(value),\n      );\n    } catch (error) {\n      throw new CacheError(\n        `Failed to get multiple keys: ${(error as Error).message}`,\n        \"get",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8258,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": {
            "output": "# Redis Caching Layer with TypeScript\n\nI'll create a comprehensive caching utility module with proper TypeScript generics, error handling, and Redis integration.\n\n```typescript\n// cache.ts\nimport Redis, { RedisOptions } from 'ioredis';\n\n/**\n * Configuration options for the Cache class\n */\nexport interface CacheConfig {\n  /** Redis connection options */\n  redis?: RedisOptions;\n  /** Default TTL in seconds (optional) */\n  defaultTTL?: number;\n  /** Key prefix for all cache entries */\n  keyPrefix?: string;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n/**\n * Cache operation result\n */\nexport interface CacheResult<T> {\n  success: boolean;\n  data?: T;\n  error?: Error;\n}\n\n/**\n * Cache statistics\n */\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  errors: number;\n}\n\n/**\n * Custom error class for cache operations\n */\nexport class CacheError extends Error {\n  constructor(\n    message: string,\n    public readonly operation: string,\n    public readonly originalError?: Error\n  ) {\n    super(message);\n    this.name = 'CacheError';\n  }\n}\n\n/**\n * Generic caching layer using Redis with ioredis\n */\nexport class Cache {\n  private client: Redis;\n  private readonly config: Required<CacheConfig>;\n  private stats: CacheStats = { hits: 0, misses: 0, errors: 0 };\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void> | null = null;\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      redis: config.redis || {},\n      defaultTTL: config.defaultTTL || 3600,\n      keyPrefix: config.keyPrefix || 'cache:',\n      debug: config.debug || false,\n    };\n\n    // Initialize Redis client with error handling\n    this.client = new Redis({\n      ...this.config.redis,\n      lazyConnect: true,\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        this.log(`Retrying connection (attempt ${times}) in ${delay}ms`);\n        return delay;\n      },\n      reconnectOnError: (err: Error) => {\n        const targetError = 'READONLY';\n        if (err.message.includes(targetError)) {\n          // Reconnect on READONLY errors\n          return true;\n        }\n        return false;\n      },\n    });\n\n    this.setupEventHandlers();\n  }\n\n  /**\n   * Setup Redis event handlers\n   */\n  private setupEventHandlers(): void {\n    this.client.on('connect', () => {\n      this.log('Redis client connecting...');\n    });\n\n    this.client.on('ready', () => {\n      this.isConnected = true;\n      this.log('Redis client ready');\n    });\n\n    this.client.on('error', (err: Error) => {\n      this.isConnected = false;\n      this.stats.errors++;\n      this.log(`Redis client error: ${err.message}`, true);\n    });\n\n    this.client.on('close', () => {\n      this.isConnected = false;\n      this.log('Redis client connection closed');\n    });\n\n    this.client.on('reconnecting', () => {\n      this.log('Redis client reconnecting...');\n    });\n  }\n\n  /**\n   * Ensure Redis connection is established\n   */\n  private async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    // Reuse existing connection attempt if in progress\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    this.connectionPromise = this.client\n      .connect()\n      .then(() => {\n        this.connectionPromise = null;\n      })\n      .catch((err: Error) => {\n        this.connectionPromise = null;\n        throw new CacheError(\n          'Failed to connect to Redis',\n          'connect',\n          err\n        );\n      });\n\n    return this.connectionPromise;\n  }\n\n  /**\n   * Build full cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`;\n  }\n\n  /**\n   * Log debug messages\n   */\n  private log(message: string, isError: boolean = false): void {\n    if (this.config.debug) {\n      const timestamp = new Date().toISOString();\n      const prefix = isError ? '[ERROR]' : '[DEBUG]';\n      console.log(`${timestamp} ${prefix} Cache: ${message}`);\n    }\n  }\n\n  /**\n   * Serialize value to JSON string\n   */\n  private serialize<T>(value: T): string {\n    try {\n      return JSON.stringify({\n        data: value,\n        timestamp: Date.now(),\n      });\n    } catch (err) {\n      throw new CacheError(\n        'Failed to serialize value',\n        'serialize',\n        err as Error\n      );\n    }\n  }\n\n  /**\n   * Deserialize JSON string to value\n   */\n  private deserialize<T>(value: string): T {\n    try {\n      const parsed = JSON.parse(value);\n      return parsed.data as T;\n    } catch (err) {\n      throw new CacheError(\n        'Failed to deserialize value',\n        'deserialize',\n        err as Error\n      );\n    }\n  }\n\n  /**\n   * Get a value from cache\n   * @param key - Cache key\n   * @returns Promise resolving to the cached value or null if not found\n   */\n  async get<T>(key: string): Promise<T | null> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`GET ${fullKey}`);\n\n      const value = await this.client.get(fullKey);\n\n      if (value === null) {\n        this.stats.misses++;\n        this.log(`MISS ${fullKey}`);\n        return null;\n      }\n\n      this.stats.hits++;\n      this.log(`HIT ${fullKey}`);\n\n      return this.deserialize<T>(value);\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error getting key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to get key: ${key}`,\n        'get',\n        error\n      );\n    }\n  }\n\n  /**\n   * Set a value in cache with optional TTL\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttlSeconds - Time to live in seconds (optional, uses default if not provided)\n   * @returns Promise resolving to true if successful\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number\n  ): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const serialized = this.serialize(value);\n      const ttl = ttlSeconds ?? this.config.defaultTTL;\n\n      this.log(`SET ${fullKey} (TTL: ${ttl}s)`);\n\n      if (ttl > 0) {\n        await this.client.setex(fullKey, ttl, serialized);\n      } else {\n        await this.client.set(fullKey, serialized);\n      }\n\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error setting key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to set key: ${key}`,\n        'set',\n        error\n      );\n    }\n  }\n\n  /**\n   * Delete a key from cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key was deleted, false if key didn't exist\n   */\n  async delete(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      this.log(`DELETE ${fullKey}`);\n\n      const result = await this.client.del(fullKey);\n      return result > 0;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error deleting key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to delete key: ${key}`,\n        'delete',\n        error\n      );\n    }\n  }\n\n  /**\n   * Invalidate all keys matching a pattern\n   * @param pattern - Redis pattern (e.g., \"user:*\", \"session:*\")\n   * @returns Promise resolving to the number of keys deleted\n   */\n  async invalidatePattern(pattern: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullPattern = this.buildKey(pattern);\n      this.log(`INVALIDATE PATTERN ${fullPattern}`);\n\n      let cursor = '0';\n      let deletedCount = 0;\n\n      // Use SCAN to iterate through keys matching pattern\n      do {\n        const [nextCursor, keys] = await this.client.scan(\n          cursor,\n          'MATCH',\n          fullPattern,\n          'COUNT',\n          100\n        );\n\n        cursor = nextCursor;\n\n        if (keys.length > 0) {\n          const deleted = await this.client.del(...keys);\n          deletedCount += deleted;\n          this.log(`Deleted ${deleted} keys matching pattern`);\n        }\n      } while (cursor !== '0');\n\n      this.log(`Total deleted: ${deletedCount} keys`);\n      return deletedCount;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(\n        `Error invalidating pattern ${pattern}: ${error.message}`,\n        true\n      );\n      throw new CacheError(\n        `Failed to invalidate pattern: ${pattern}`,\n        'invalidatePattern',\n        error\n      );\n    }\n  }\n\n  /**\n   * Check if a key exists in cache\n   * @param key - Cache key\n   * @returns Promise resolving to true if key exists\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      const result = await this.client.exists(fullKey);\n      return result === 1;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error checking key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to check key existence: ${key}`,\n        'exists',\n        error\n      );\n    }\n  }\n\n  /**\n   * Get remaining TTL for a key\n   * @param key - Cache key\n   * @returns Promise resolving to TTL in seconds, -1 if no expiry, -2 if key doesn't exist\n   */\n  async getTTL(key: string): Promise<number> {\n    try {\n      await this.ensureConnection();\n\n      const fullKey = this.buildKey(key);\n      return await this.client.ttl(fullKey);\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error getting TTL for key ${key}: ${error.message}`, true);\n      throw new CacheError(\n        `Failed to get TTL for key: ${key}`,\n        'getTTL',\n        error\n      );\n    }\n  }\n\n  /**\n   * Set multiple key-value pairs atomically\n   * @param entries - Array of [key, value, ttl?] tuples\n   * @returns Promise resolving to true if successful\n   */\n  async setMultiple<T>(\n    entries: Array<[string, T, number?]>\n  ): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      const pipeline = this.client.pipeline();\n\n      for (const [key, value, ttl] of entries) {\n        const fullKey = this.buildKey(key);\n        const serialized = this.serialize(value);\n        const ttlValue = ttl ?? this.config.defaultTTL;\n\n        if (ttlValue > 0) {\n          pipeline.setex(fullKey, ttlValue, serialized);\n        } else {\n          pipeline.set(fullKey, serialized);\n        }\n      }\n\n      await pipeline.exec();\n      this.log(`SET MULTIPLE: ${entries.length} keys`);\n\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error setting multiple keys: ${error.message}`, true);\n      throw new CacheError(\n        'Failed to set multiple keys',\n        'setMultiple',\n        error\n      );\n    }\n  }\n\n  /**\n   * Get multiple values by keys\n   * @param keys - Array of cache keys\n   * @returns Promise resolving to Map of key-value pairs\n   */\n  async getMultiple<T>(keys: string[]): Promise<Map<string, T>> {\n    try {\n      await this.ensureConnection();\n\n      const fullKeys = keys.map((key) => this.buildKey(key));\n      const values = await this.client.mget(...fullKeys);\n\n      const result = new Map<string, T>();\n\n      values.forEach((value, index) => {\n        if (value !== null) {\n          const originalKey = keys[index];\n          result.set(originalKey, this.deserialize<T>(value));\n          this.stats.hits++;\n        } else {\n          this.stats.misses++;\n        }\n      });\n\n      this.log(`GET MULTIPLE: ${keys.length} keys, ${result.size} hits`);\n\n      return result;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error getting multiple keys: ${error.message}`, true);\n      throw new CacheError(\n        'Failed to get multiple keys',\n        'getMultiple',\n        error\n      );\n    }\n  }\n\n  /**\n   * Clear all cache entries (use with caution)\n   * @returns Promise resolving to true if successful\n   */\n  async clear(): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n\n      this.log('CLEAR ALL CACHE');\n      await this.client.flushdb();\n\n      return true;\n    } catch (err) {\n      this.stats.errors++;\n      const error = err as Error;\n      this.log(`Error clearing cache: ${error.message}`, true);\n      throw new CacheError('Failed to clear cache', 'clear', error);\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * @returns Current cache statistics\n   */\n  getStats(): Readonly<CacheStats> {\n    return { ...this.stats };\n  }\n\n  /**\n   * Reset cache statistics\n   */\n  resetStats(): void {\n    this.stats = { hits: 0, misses: 0, errors: 0 };\n    this.log('Statistics reset');\n  }\n\n  /**\n   * Check if cache is connected\n   * @returns Current connection status\n   */\n  isReady(): boolean {\n    return this.isConnected;\n  }\n\n  /**\n   * Ping Redis server\n   * @returns Promise resolving to true if server responds\n   */\n  async ping(): Promise<boolean> {\n    try {\n      await this.ensureConnection();\n      const result = await this.client.ping();\n      return result === 'PONG';\n    } catch (err) {\n      return false;\n    }\n  }\n\n  /**\n   * Close Redis connection\n   * @returns Promise that resolves when connection is closed\n   */\n  async disconnect(): Promise<void> {\n    try {\n      this.log('Disconnecting from Redis');\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (err) {\n      const error = err as Error;\n      this.log(`Error disconnecting: ${error.message}`, true);\n      throw new CacheError('Failed to disconnect', 'disconnect', error);\n    }\n  }\n}\n\n/**\n ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 2236,
            "output_tokens": 4096,
            "cached": true
          },
          "realistic": {
            "output": "I'll create a comprehensive Redis caching utility module with proper TypeScript generics and error handling.\n\n```typescript\n// src/lib/cache.ts\nimport Redis, { RedisOptions } from \"ioredis\";\n\ninterface CacheOptions {\n  redis?: RedisOptions;\n  prefix?: string;\n  defaultTTL?: number;\n}\n\ninterface CacheResult<T> {\n  data: T | null;\n  error?: string;\n}\n\nexport class Cache {\n  private client: Redis;\n  private prefix: string;\n  private defaultTTL: number;\n  private isConnected: boolean = false;\n\n  constructor(options: CacheOptions = {}) {\n    const redisOptions: RedisOptions = {\n      host: process.env.REDIS_HOST ?? \"localhost\",\n      port: parseInt(process.env.REDIS_PORT ?? \"6379\", 10),\n      password: process.env.REDIS_PASSWORD,\n      db: parseInt(process.env.REDIS_DB ?? \"0\", 10),\n      retryStrategy: (times: number) => {\n        const delay = Math.min(times * 50, 2000);\n        return delay;\n      },\n      maxRetriesPerRequest: 3,\n      enableReadyCheck: true,\n      ...options.redis,\n    };\n\n    this.client = new Redis(redisOptions);\n    this.prefix = options.prefix ?? \"cache:\";\n    this.defaultTTL = options.defaultTTL ?? 3600; // 1 hour default\n\n    this.client.on(\"connect\", () => {\n      this.isConnected = true;\n      console.log(\"Redis cache connected\");\n    });\n\n    this.client.on(\"error\", (error) => {\n      this.isConnected = false;\n      console.error(\"Redis cache error:\", error);\n    });\n\n    this.client.on(\"close\", () => {\n      this.isConnected = false;\n      console.log(\"Redis cache connection closed\");\n    });\n  }\n\n  /**\n   * Generates a prefixed cache key\n   */\n  private getKey(key: string): string {\n    return `${this.prefix}${key}`;\n  }\n\n  /**\n   * Retrieves a value from cache with type safety\n   */\n  async get<T>(key: string): Promise<CacheResult<T>> {\n    try {\n      if (!this.isConnected) {\n        return {\n          data: null,\n          error: \"Redis connection not available\",\n        };\n      }\n\n      const prefixedKey = this.getKey(key);\n      const value = await this.client.get(prefixedKey);\n\n      if (value === null) {\n        return { data: null };\n      }\n\n      try {\n        const parsed = JSON.parse(value) as T;\n        return { data: parsed };\n      } catch (parseError) {\n        return {\n          data: null,\n          error: `Failed to parse cached value: ${parseError instanceof Error ? parseError.message : \"Unknown error\"}`,\n        };\n      }\n    } catch (error) {\n      return {\n        data: null,\n        error: `Cache get error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      };\n    }\n  }\n\n  /**\n   * Sets a value in cache with optional TTL\n   */\n  async set<T>(\n    key: string,\n    value: T,\n    ttlSeconds?: number,\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      if (!this.isConnected) {\n        return {\n          success: false,\n          error: \"Redis connection not available\",\n        };\n      }\n\n      const prefixedKey = this.getKey(key);\n      const serialized = JSON.stringify(value);\n      const ttl = ttlSeconds ?? this.defaultTTL;\n\n      if (ttl > 0) {\n        await this.client.setex(prefixedKey, ttl, serialized);\n      } else {\n        await this.client.set(prefixedKey, serialized);\n      }\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Cache set error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      };\n    }\n  }\n\n  /**\n   * Deletes a specific key from cache\n   */\n  async delete(key: string): Promise<{ success: boolean; error?: string }> {\n    try {\n      if (!this.isConnected) {\n        return {\n          success: false,\n          error: \"Redis connection not available\",\n        };\n      }\n\n      const prefixedKey = this.getKey(key);\n      await this.client.del(prefixedKey);\n\n      return { success: true };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Cache delete error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      };\n    }\n  }\n\n  /**\n   * Invalidates all keys matching a pattern\n   * Pattern examples: \"user:*\", \"*:session\", \"product:123:*\"\n   */\n  async invalidatePattern(\n    pattern: string,\n  ): Promise<{ success: boolean; deletedCount: number; error?: string }> {\n    try {\n      if (!this.isConnected) {\n        return {\n          success: false,\n          deletedCount: 0,\n          error: \"Redis connection not available\",\n        };\n      }\n\n      const prefixedPattern = this.getKey(pattern);\n      const keys: string[] = [];\n\n      // Use SCAN for safe iteration over large keysets\n      const stream = this.client.scanStream({\n        match: prefixedPattern,\n        count: 100,\n      });\n\n      return new Promise((resolve, reject) => {\n        stream.on(\"data\", (resultKeys: string[]) => {\n          keys.push(...resultKeys);\n        });\n\n        stream.on(\"end\", async () => {\n          try {\n            if (keys.length === 0) {\n              resolve({ success: true, deletedCount: 0 });\n              return;\n            }\n\n            // Delete in batches using pipeline for efficiency\n            const pipeline = this.client.pipeline();\n            keys.forEach((key) => pipeline.del(key));\n            await pipeline.exec();\n\n            resolve({ success: true, deletedCount: keys.length });\n          } catch (error) {\n            reject(error);\n          }\n        });\n\n        stream.on(\"error\", (error) => {\n          reject(error);\n        });\n      });\n    } catch (error) {\n      return {\n        success: false,\n        deletedCount: 0,\n        error: `Cache invalidate pattern error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      };\n    }\n  }\n\n  /**\n   * Checks if a key exists in cache\n   */\n  async exists(key: string): Promise<boolean> {\n    try {\n      if (!this.isConnected) {\n        return false;\n      }\n\n      const prefixedKey = this.getKey(key);\n      const result = await this.client.exists(prefixedKey);\n      return result === 1;\n    } catch (error) {\n      console.error(\"Cache exists error:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Gets the TTL (time to live) of a key in seconds\n   */\n  async getTTL(key: string): Promise<number | null> {\n    try {\n      if (!this.isConnected) {\n        return null;\n      }\n\n      const prefixedKey = this.getKey(key);\n      const ttl = await this.client.ttl(prefixedKey);\n\n      // -2 means key doesn't exist, -1 means no expiry\n      if (ttl === -2) return null;\n      return ttl;\n    } catch (error) {\n      console.error(\"Cache getTTL error:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Clears all keys with the configured prefix\n   */\n  async clear(): Promise<{ success: boolean; error?: string }> {\n    return this.invalidatePattern(\"*\");\n  }\n\n  /**\n   * Gracefully closes the Redis connection\n   */\n  async disconnect(): Promise<void> {\n    try {\n      await this.client.quit();\n      this.isConnected = false;\n    } catch (error) {\n      console.error(\"Error disconnecting from Redis:\", error);\n      // Force disconnect if graceful quit fails\n      this.client.disconnect();\n    }\n  }\n\n  /**\n   * Gets the connection status\n   */\n  getConnectionStatus(): boolean {\n    return this.isConnected;\n  }\n}\n\n// Singleton instance for application-wide use\nlet cacheInstance: Cache | null = null;\n\nexport function getCache(options?: CacheOptions): Cache {\n  if (!cacheInstance) {\n    cacheInstance = new Cache(options);\n  }\n  return cacheInstance;\n}\n\nexport default Cache;\n```\n\nNow let me create a comprehensive test file:\n\n```typescript\n// src/lib/cache.test.ts\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from \"vitest\";\nimport { Cache } from \"./cache\";\n\ndescribe(\"Cache\", () => {\n  let cache: Cache;\n\n  beforeAll(() => {\n    cache = new Cache({\n      prefix: \"test:\",\n      defaultTTL: 60,\n    });\n  });\n\n  afterAll(async () => {\n    await cache.disconnect();\n  });\n\n  beforeEach(async () => {\n    // Clear all test keys before each test\n    await cache.clear();\n  });\n\n  describe(\"get and set\", () => {\n    it(\"should set and get a string value\", async () => {\n      const key = \"test-string\";\n      const value = \"hello world\";\n\n      const setResult = await cache.set(key, value);\n      expect(setResult.success).toBe(true);\n\n      const getResult = await cache.get<string>(key);\n      expect(getResult.data).toBe(value);\n      expect(getResult.error).toBeUndefined();\n    });\n\n    it(\"should set and get an object value\", async () => {\n      const key = \"test-object\";\n      const value = { id: 1, name: \"Test User\", active: true };\n\n      await cache.set(key, value);\n      const result = await cache.get<typeof value>(key);\n\n      expect(result.data).toEqual(value);\n    });\n\n    it(\"should set and get an array value\", async () => {\n      const key = \"test-array\";\n      const value = [1, 2, 3, 4, 5];\n\n      await cache.set(key, value);\n      const result = await cache.get<number[]>(key);\n\n      expect(result.data).toEqual(value);\n    });\n\n    it(\"should return null for non-existent key\", async () => {\n      const result = await cache.get<string>(\"non-existent-key\");\n      expect(result.data).toBeNull();\n    });\n\n    it(\"should respect custom TTL\", async () => {\n      const key = \"test-ttl\";\n      const value = \"expires soon\";\n\n      await cache.set(key, value, 1); // 1 second TTL\n\n      const ttl = await cache.getTTL(key);\n      expect(ttl).toBeLessThanOrEqual(1);\n      expect(ttl).toBeGreaterThan(0);\n    });\n  });\n\n  describe(\"delete\", () => {\n    it(\"should delete a key\", async () => {\n      const key = \"test-delete\";\n      const value = \"to be deleted\";\n\n      await cache.set(key, value);\n      expect(await cache.exists(key)).toBe(true);\n\n      const deleteResult = await cache.delete(key);\n      expect(deleteResult.success).toBe(true);\n      expect(await cache.exists(key)).toBe(false);\n    });\n  });\n\n  describe(\"invalidatePattern\", () => {\n    it(\"should invalidate keys matching pattern\", async () => {\n      // Set multiple keys with same prefix\n      await cache.set(\"user:1\", { id: 1, name: \"User 1\" });\n      await cache.set(\"user:2\", { id: 2, name: \"User 2\" });\n      await cache.set(\"user:3\", { id: 3, name: \"User 3\" });\n      await cache.set(\"product:1\", { id: 1, name: \"Product 1\" });\n\n      const result = await cache.invalidatePattern(\"user:*\");\n      expect(result.success).toBe(true);\n      expect(result.deletedCount).toBe(3);\n\n      // User keys should be gone\n      expect(await cache.exists(\"user:1\")).toBe(false);\n      expect(await cache.exists(\"user:2\")).toBe(false);\n      expect(await cache.exists(\"user:3\")).toBe(false);\n\n      // Product key should still exist\n      expect(await cache.exists(\"product:1\")).toBe(true);\n    });\n\n    it(\"should handle pattern with no matches\", async () => {\n      const result = await cache.invalidatePattern(\"nonexistent:*\");\n      expect(result.success).toBe(true);\n      expect(result.deletedCount).toBe(0);\n    });\n  });\n\n  describe(\"exists\", () => {\n    it(\"should return true for existing key\", async () => {\n      const key = \"test-exists\";\n      await cache.set(key, \"value\");\n      expect(await cache.exists(key)).toBe(true);\n    });\n\n    it(\"should return false for non-existing key\", async () => {\n      expect(await cache.exists(\"non-existent\")).toBe(false);\n    });\n  });\n\n  describe(\"getTTL\", () => {\n    it(\"should return TTL for key with expiry\", async () => {\n      const key = \"test-ttl-check\";\n      await cache.set(key, \"value\", 100);\n\n      const ttl = await cache.getTTL(key);\n      expect(ttl).toBeGreaterThan(0);\n      expect(ttl).toBeLessThanOrEqual(100);\n    });\n\n    it(\"should return null for non-existent key\", async () => {\n      const ttl = await cache.getTTL(\"non-existent\");\n      expect(ttl).toBeNull();\n    });\n  });\n\n  describe(\"clear\", () => {\n    it(\"should clear all keys with prefix\", async () => {\n      await cache.set(\"key1\", \"value1\");\n      await cache.set(\"key2\", \"value2\");\n      await cache.set(\"key3\", \"value3\");\n\n      const result = await cache.clear();\n      expect(result.success).toBe(true);\n\n      expect(await cache.exists(\"key1\")).toBe(false);\n      expect(await cache.exists(\"key2\")).toBe(false);\n      expect(await cache.exists(\"key3\")).toBe(false);\n    });\n  });\n\n  describe(\"connection status\", () => {\n    it(\"should report connection status\", () => {\n      const status = cache.getConnectionStatus();\n      expect(typeof status).toBe(\"boolean\");\n    });\n  });\n});\n```\n\nNow let me create a usage example file:\n\n```typescript\n// src/lib/cache.example.ts\nimport { Cache, getCache } from \"./cache\";\n\n// Example 1: Basic usage with singleton\nasync function basicUsageExample() {\n  const cache = getCache();\n\n  // Set a simple value\n  await cache.set(\"user:123\", { id: 123, name: \"John Doe\" }, 3600);\n\n  // Get the value\n  const result = await cache.get<{ id: number; name: string }>(\"user:123\");\n  if (result.data) {\n    console.log(\"User:\", result.data);\n  }\n\n  // Delete the value\n  await cache.delete(\"user:123\");\n}\n\n// Example 2: Custom cache instance with configuration\nasync function customInstanceExample() {\n  const cache = new Cache({\n    prefix: \"myapp:\",\n    defaultTTL: 7200, // 2 hours\n    redis: {\n      host: \"redis.example.com\",\n      port: 6379,\n      password: \"secret\",\n    },\n  });\n\n  await cache.set(\"session:abc123\", { userId: 1, token: \"xyz\" });\n}\n\n// Example 3: Caching API responses\ninterface ApiResponse {\n  data: unknown;\n  timestamp: number;\n}\n\nasync function cacheApiResponse(endpoint: string, data: unknown) {\n  const cache = getCache();",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8753,
            "output_tokens": 4096,
            "cached": false
          }
        }
      ]
    }
  ]
}