{
  "skill_name": "azure-security-keyvault-secrets-java",
  "generated_at": "2026-02-16T09:31:23.552734+00:00",
  "model": "claude-sonnet-4-5-20250929",
  "temperature": 0.3,
  "runs_per_condition": 3,
  "contamination_score": 0.52,
  "risk_level": "high",
  "test_category": "sdk_cross_lang",
  "tasks": [
    {
      "task_id": "azure-security-keyvault-secrets-java-01",
      "task_type": "direct_target",
      "target_language": "java",
      "expected_patterns": [
        "SecretClientBuilder",
        "SecretClient",
        "DefaultAzureCredentialBuilder",
        "setSecret\\(",
        "getSecret\\(",
        "updateSecretProperties\\(",
        "setEnabled\\(false\\)",
        "ResourceNotFoundException",
        "HttpResponseException"
      ],
      "anti_patterns": [
        "SecretClient\\(",
        "from azure\\.keyvault",
        "require.*@azure/keyvault-secrets",
        "secret_client\\.set_secret",
        "secretClient\\.setSecret\\(.*\\{",
        "KeyVaultSecret\\.new"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclient",
          "description": "Java SecretClient: setSecret, getSecret, updateSecretProperties methods"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclientbuilder",
          "description": "Java SecretClientBuilder: vaultUrl, credential, buildClient pattern"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.identity.defaultazurecredentialbuilder",
          "description": "Java DefaultAzureCredentialBuilder: source of DefaultAzureCredentialBuilder and .build() pattern as required by prompt ('Use SecretClient with DefaultAzureCredential')"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.models.secretproperties",
          "description": "Java SecretProperties: setEnabled(false) for disabling old secret versions"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.core.exception.resourcenotfoundexception",
          "description": "Java ResourceNotFoundException and HttpResponseException for error handling"
        },
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-keyvault-secrets/azure.keyvault.secrets.secretclient",
          "description": "Anti-patterns: Python from azure.keyvault, secret_client.set_secret snake_case"
        },
        {
          "url": "https://learn.microsoft.com/en-us/javascript/api/@azure/keyvault-secrets/secretclient",
          "description": "Anti-patterns: JavaScript require @azure/keyvault-secrets"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Azure Key Vault Secret Rotation Service\n\nHere's a comprehensive Java service class that implements a secret rotation pattern using Azure Key Vault:\n\n```java\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.OffsetDateTime;\nimport java.util.Optional;\n\n/**\n * Service class for managing Azure Key Vault secret rotation.\n * Implements a secure pattern for rotating secrets with proper version management.\n */\npublic class SecretRotationService {\n    \n    private static final Logger logger = LoggerFactory.getLogger(SecretRotationService.class);\n    \n    private final SecretClient secretClient;\n    private final String keyVaultUrl;\n    \n    /**\n     * Constructor that initializes the SecretClient with DefaultAzureCredential\n     * \n     * @param keyVaultUrl The URL of the Azure Key Vault (e.g., https://myvault.vault.azure.net/)\n     */\n    public SecretRotationService(String keyVaultUrl) {\n        this.keyVaultUrl = keyVaultUrl;\n        \n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .build();\n        \n        this.secretClient = new SecretClientBuilder()\n                .vaultUrl(keyVaultUrl)\n                .credential(credential)\n                .buildClient();\n        \n        logger.info(\"SecretRotationService initialized for Key Vault: {}\", keyVaultUrl);\n    }\n    \n    /**\n     * Constructor for dependency injection (useful for testing)\n     * \n     * @param secretClient Pre-configured SecretClient instance\n     * @param keyVaultUrl The URL of the Azure Key Vault\n     */\n    public SecretRotationService(SecretClient secretClient, String keyVaultUrl) {\n        this.secretClient = secretClient;\n        this.keyVaultUrl = keyVaultUrl;\n        logger.info(\"SecretRotationService initialized with provided SecretClient\");\n    }\n    \n    /**\n     * Rotates a secret by creating a new version and disabling the old version.\n     * \n     * @param secretName The name of the secret to rotate\n     * @param newSecretValue The new value for the secret\n     * @return RotationResult containing information about the rotation operation\n     * @throws SecretRotationException if rotation fails\n     */\n    public RotationResult rotateSecret(String secretName, String newSecretValue) \n            throws SecretRotationException {\n        \n        logger.info(\"Starting secret rotation for: {}\", secretName);\n        \n        validateInputs(secretName, newSecretValue);\n        \n        try {\n            // Step 1: Get the current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String oldVersion = currentSecret.getProperties().getVersion();\n            logger.info(\"Current secret version: {}\", oldVersion);\n            \n            // Step 2: Create new version with updated value\n            KeyVaultSecret newSecret = createNewSecretVersion(secretName, newSecretValue);\n            String newVersion = newSecret.getProperties().getVersion();\n            logger.info(\"New secret version created: {}\", newVersion);\n            \n            // Step 3: Verify the new version is active\n            verifyNewVersion(secretName, newVersion, newSecretValue);\n            logger.info(\"New secret version verified successfully\");\n            \n            // Step 4: Disable the old version\n            disableOldVersion(secretName, oldVersion);\n            logger.info(\"Old secret version disabled: {}\", oldVersion);\n            \n            RotationResult result = new RotationResult(\n                    secretName,\n                    oldVersion,\n                    newVersion,\n                    OffsetDateTime.now(),\n                    true,\n                    \"Secret rotated successfully\"\n            );\n            \n            logger.info(\"Secret rotation completed successfully for: {}\", secretName);\n            return result;\n            \n        } catch (ResourceNotFoundException e) {\n            String errorMsg = String.format(\"Secret '%s' not found in Key Vault\", secretName);\n            logger.error(errorMsg, e);\n            throw new SecretRotationException(errorMsg, e);\n            \n        } catch (HttpResponseException e) {\n            String errorMsg = String.format(\n                    \"HTTP error during secret rotation: Status=%d, Message=%s\",\n                    e.getResponse().getStatusCode(),\n                    e.getMessage()\n            );\n            logger.error(errorMsg, e);\n            throw new SecretRotationException(errorMsg, e);\n            \n        } catch (Exception e) {\n            String errorMsg = String.format(\"Unexpected error during secret rotation: %s\", e.getMessage());\n            logger.error(errorMsg, e);\n            throw new SecretRotationException(errorMsg, e);\n        }\n    }\n    \n    /**\n     * Gets the current active secret from Key Vault\n     */\n    private KeyVaultSecret getCurrentSecret(String secretName) throws ResourceNotFoundException {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            \n            if (secret == null || secret.getValue() == null) {\n                throw new ResourceNotFoundException(\n                        String.format(\"Secret '%s' exists but has no value\", secretName),\n                        null\n                );\n            }\n            \n            return secret;\n            \n        } catch (ResourceNotFoundException e) {\n            logger.error(\"Secret '{}' not found in Key Vault\", secretName);\n            throw e;\n        }\n    }\n    \n    /**\n     * Creates a new version of the secret with the updated value\n     */\n    private KeyVaultSecret createNewSecretVersion(String secretName, String newValue) {\n        try {\n            KeyVaultSecret newSecret = secretClient.setSecret(secretName, newValue);\n            \n            if (newSecret == null || newSecret.getProperties() == null) {\n                throw new SecretRotationException(\"Failed to create new secret version\");\n            }\n            \n            return newSecret;\n            \n        } catch (HttpResponseException e) {\n            logger.error(\"Failed to create new secret version: {}\", e.getMessage());\n            throw e;\n        }\n    }\n    \n    /**\n     * Verifies that the new secret version is active and contains the expected value\n     */\n    private void verifyNewVersion(String secretName, String expectedVersion, String expectedValue) \n            throws SecretRotationException {\n        \n        try {\n            // Get the secret by specific version\n            KeyVaultSecret verifiedSecret = secretClient.getSecret(secretName, expectedVersion);\n            \n            if (verifiedSecret == null) {\n                throw new SecretRotationException(\n                        String.format(\"Failed to retrieve new secret version: %s\", expectedVersion)\n                );\n            }\n            \n            // Verify the version matches\n            String actualVersion = verifiedSecret.getProperties().getVersion();\n            if (!expectedVersion.equals(actualVersion)) {\n                throw new SecretRotationException(\n                        String.format(\"Version mismatch. Expected: %s, Actual: %s\", \n                                expectedVersion, actualVersion)\n                );\n            }\n            \n            // Verify the value matches\n            if (!expectedValue.equals(verifiedSecret.getValue())) {\n                throw new SecretRotationException(\"New secret value does not match expected value\");\n            }\n            \n            // Verify the secret is enabled\n            if (!verifiedSecret.getProperties().isEnabled()) {\n                throw new SecretRotationException(\"New secret version is not enabled\");\n            }\n            \n            logger.debug(\"New secret version verified: {}\", expectedVersion);\n            \n        } catch (ResourceNotFoundException e) {\n            throw new SecretRotationException(\n                    String.format(\"New secret version not found: %s\", expectedVersion), e\n            );\n        }\n    }\n    \n    /**\n     * Disables the old version of the secret\n     */\n    private void disableOldVersion(String secretName, String oldVersion) {\n        try {\n            SecretProperties properties = secretClient.getSecret(secretName, oldVersion).getProperties();\n            properties.setEnabled(false);\n            \n            SecretProperties updatedProperties = secretClient.updateSecretProperties(properties);\n            \n            if (updatedProperties.isEnabled()) {\n                logger.warn(\"Warning: Old version may not have been disabled properly\");\n            }\n            \n            logger.debug(\"Old secret version disabled: {}\", oldVersion);\n            \n        } catch (HttpResponseException e) {\n            // Log but don't fail the rotation if we can't disable the old version\n            logger.error(\"Failed to disable old secret version {}: {}\", oldVersion, e.getMessage());\n            // In production, you might want to implement retry logic or alerting here\n        }\n    }\n    \n    /**\n     * Validates input parameters\n     */\n    private void validateInputs(String secretName, String newSecretValue) \n            throws SecretRotationException {\n        \n        if (secretName == null || secretName.trim().isEmpty()) {\n            throw new SecretRotationException(\"Secret name cannot be null or empty\");\n        }\n        \n        if (newSecretValue == null || newSecretValue.trim().isEmpty()) {\n            throw new SecretRotationException(\"New secret value cannot be null or empty\");\n        }\n        \n        // Azure Key Vault secret name constraints\n        if (!secretName.matches(\"^[0-9a-zA-Z-]+$\")) {\n            throw new SecretRotationException(\n                    \"Secret name can only contain alphanumeric characters and hyphens\"\n            );\n        }\n        \n        if (secretName.length() > 127) {\n            throw new SecretRotationException(\"Secret name cannot exceed 127 characters\");\n        }\n    }\n    \n    /**\n     * Gets a secret by name and optionally by version\n     * \n     * @param secretName The name of the secret\n     * @param version Optional version (null for latest)\n     * @return Optional containing the secret if found\n     */\n    public Optional<KeyVaultSecret> getSecret(String secretName, String version) {\n        try {\n            KeyVaultSecret secret;\n            if (version != null && !version.isEmpty()) {\n                secret = secretClient.getSecret(secretName, version);\n            } else {\n                secret = secretClient.getSecret(secretName);\n            }\n            return Optional.ofNullable(secret);\n            \n        } catch (ResourceNotFoundException e) {\n            logger.warn(\"Secret '{}' not found\", secretName);\n            return Optional.empty();\n            \n        } catch (HttpResponseException e) {\n            logger.error(\"Error retrieving secret '{}': {}\", secretName, e.getMessage());\n            return Optional.empty();\n        }\n    }\n    \n    /**\n     * Lists all versions of a secret\n     * \n     * @param secretName The name of the secret\n     * @return Iterable of SecretProperties for all versions\n     */\n    public Iterable<SecretProperties> listSecretVersions(String secretName) {\n        try {\n            return secretClient.listPropertiesOfSecretVersions(secretName);\n        } catch (ResourceNotFoundException e) {\n            logger.error(\"Secret '{}' not found\", secretName);\n            throw e;\n        }\n    }\n    \n    /**\n     * Result object containing information about the rotation operation\n     */\n    public static class RotationResult {\n        private final String secretName;\n        private final String oldVersion;\n        private final String newVersion;\n        private final OffsetDateTime rotationTime;\n        private final boolean success;\n        private final String message;\n        \n        public RotationResult(String secretName, String oldVersion, String newVersion,\n                            OffsetDateTime rotationTime, boolean success, String message) {\n            this.secretName = secretName;\n            this.oldVersion = oldVersion;\n            this.newVersion = newVersion;\n            this.rotationTime = rotationTime;\n            this.success = success;\n            this.message = message;\n        }\n        \n        // Getters\n        public String getSecretName() { return secretName; }\n        public String getOldVersion() { return oldVersion; }\n        public String getNewVersion() { return newVersion; }\n        public OffsetDateTime getRotationTime() { return rotationTime; }\n        public boolean isSuccess() { return success; }\n        public String getMessage() { return message; }\n        \n        @Override\n        public String toString() {\n            return String.format(\n                    \"RotationResult{secretName='%s', oldVersion='%s', newVersion='%s', \" +\n                    \"rotationTime=%s, success=%s, message='%s'}\",\n                    secretName, oldVersion, newVersion, rotationTime, success, message\n            );\n        }\n    }\n    \n    /**\n     * Custom exception for secret rotation operations\n     */\n    public static class SecretRotationException extends RuntimeException {\n        public SecretRotationException(String message) {\n            super(message);\n        }\n        \n        public SecretRotationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```\n\n## Usage Example\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SecretRotationExample {\n    \n    private static final Logger logger = LoggerFactory.getLogger(SecretRotationExample.class);\n    \n    public static void main(String[] args) {\n        // Initialize the service\n        String keyVaultUrl = \"https://your-keyvault.vault.azure.net/\";\n        SecretRotationService rotationService = new SecretRotationService(keyVaultUrl);\n        \n        try {\n            // Example 1: Rotate a database password\n            String secretName = \"database-password\";\n            String newPassword = generateSecurePassword();\n            \n            SecretRotationService.RotationResult result = \n                    rotationService.rotateSecret(secretName, newPassword);\n            \n            logger.info(\"Rotation successful: {}\", result);\n            logger.info(\"Old version: {}\", result.getOldVersion());\n            logger.info(\"New version: {}\", result.getNewVersion());\n            \n            // Example 2: Retrieve the current secret\n            rotationService.getSecret(secretName, null)\n                    .ifPresent(secret -> {\n                        logger.info(\"Current secret version: {}\", \n                                secret.getProperties().getVersion());\n                    });\n            \n            // Example 3: List all versions of a secret\n            logger.info(\"All versions of secret '{}':\", secretName);\n            rotationService.listSecretVersions(secretName)\n                    .forEach(properties -> {\n                        logger.info(\"Version: {}, Enabled: {}, Created: {}\", \n                                properties.getVersion(),\n                                properties.isEnabled(),\n                                properties.getCreatedOn());\n                    });\n            \n        } catch (SecretRotationService.SecretRotationException e) {\n            logger.error(\"Secret rotation failed: {}\", e.getMessage(), e);\n            // Handle the error appropriately (alert, retry, etc.)\n        }\n    }\n    \n    private static String generateSecurePassword() {\n        // Implement secure password generation logic\n        return \"NewSecurePassword123!\";\n    }\n}\n```\n\n## Unit Test Example\n\n```java\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.core.http.HttpResponse;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\nimport java.time.OffsetDateTime;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.ArgumentMatchers.*;\nimport static org.mockito.Mockito.*;\n\nclass SecretRotationServiceTest {\n    \n    @Mock\n    private SecretClient mockSecretClient;\n    \n    private SecretRotationService rotationService;\n    private static final String KEY_VAULT_URL = \"https://test-",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 83,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secret Rotation Service\n\nHere's a comprehensive Java service class implementing a secret rotation pattern with the Azure Key Vault Secrets SDK:\n\n```java\npackage com.example.keyvault.service;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\n\nimport java.time.OffsetDateTime;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Service class for managing secret rotation in Azure Key Vault.\n * Implements a safe rotation pattern that disables old versions before creating new ones.\n */\npublic class SecretRotationService {\n    \n    private static final Logger LOGGER = Logger.getLogger(SecretRotationService.class.getName());\n    \n    private final SecretClient secretClient;\n    private final String vaultUrl;\n    \n    /**\n     * Creates a new SecretRotationService with the specified vault URL.\n     * Uses DefaultAzureCredential for authentication.\n     *\n     * @param vaultUrl The Azure Key Vault URL (e.g., https://my-vault.vault.azure.net)\n     */\n    public SecretRotationService(String vaultUrl) {\n        if (vaultUrl == null || vaultUrl.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Vault URL cannot be null or empty\");\n        }\n        \n        this.vaultUrl = vaultUrl;\n        this.secretClient = createSecretClient();\n        \n        LOGGER.info(\"SecretRotationService initialized for vault: \" + vaultUrl);\n    }\n    \n    /**\n     * Creates a SecretClient with DefaultAzureCredential.\n     */\n    private SecretClient createSecretClient() {\n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n            .build();\n        \n        return new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildClient();\n    }\n    \n    /**\n     * Rotates a secret by disabling the old version and creating a new version.\n     *\n     * @param secretName The name of the secret to rotate\n     * @param newValue The new secret value\n     * @return RotationResult containing information about the rotation\n     * @throws SecretRotationException if rotation fails\n     */\n    public RotationResult rotateSecret(String secretName, String newValue) {\n        validateInputs(secretName, newValue);\n        \n        LOGGER.info(String.format(\"Starting rotation for secret: %s\", secretName));\n        \n        try {\n            // Step 1: Get the current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String oldVersion = currentSecret.getProperties().getVersion();\n            \n            LOGGER.info(String.format(\"Current secret version: %s\", oldVersion));\n            \n            // Step 2: Disable the old version\n            disableSecretVersion(currentSecret);\n            \n            LOGGER.info(String.format(\"Disabled old version: %s\", oldVersion));\n            \n            // Step 3: Create new version with updated value\n            KeyVaultSecret newSecret = createNewSecretVersion(secretName, newValue);\n            String newVersion = newSecret.getProperties().getVersion();\n            \n            LOGGER.info(String.format(\"Created new secret version: %s\", newVersion));\n            \n            // Step 4: Verify the new version is active\n            verifyNewVersion(secretName, newVersion, newValue);\n            \n            LOGGER.info(String.format(\"Successfully rotated secret: %s\", secretName));\n            \n            return new RotationResult(\n                secretName,\n                oldVersion,\n                newVersion,\n                OffsetDateTime.now(),\n                true,\n                \"Secret rotated successfully\"\n            );\n            \n        } catch (ResourceNotFoundException e) {\n            String message = String.format(\"Secret not found: %s\", secretName);\n            LOGGER.log(Level.SEVERE, message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (HttpResponseException e) {\n            String message = handleHttpResponseException(secretName, e);\n            LOGGER.log(Level.SEVERE, message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (Exception e) {\n            String message = String.format(\"Unexpected error rotating secret: %s\", secretName);\n            LOGGER.log(Level.SEVERE, message, e);\n            throw new SecretRotationException(message, e);\n        }\n    }\n    \n    /**\n     * Rotates a secret with additional metadata tags.\n     *\n     * @param secretName The name of the secret to rotate\n     * @param newValue The new secret value\n     * @param tags Additional metadata tags for the new version\n     * @return RotationResult containing information about the rotation\n     * @throws SecretRotationException if rotation fails\n     */\n    public RotationResult rotateSecretWithTags(\n            String secretName, \n            String newValue, \n            Map<String, String> tags) {\n        \n        validateInputs(secretName, newValue);\n        \n        LOGGER.info(String.format(\"Starting rotation with tags for secret: %s\", secretName));\n        \n        try {\n            // Get current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String oldVersion = currentSecret.getProperties().getVersion();\n            \n            // Disable old version\n            disableSecretVersion(currentSecret);\n            \n            // Create new version with tags\n            KeyVaultSecret newSecretWithTags = new KeyVaultSecret(secretName, newValue)\n                .setProperties(new SecretProperties()\n                    .setTags(tags)\n                    .setEnabled(true));\n            \n            KeyVaultSecret newSecret = secretClient.setSecret(newSecretWithTags);\n            String newVersion = newSecret.getProperties().getVersion();\n            \n            LOGGER.info(String.format(\"Created new version with tags: %s\", newVersion));\n            \n            // Verify new version\n            verifyNewVersion(secretName, newVersion, newValue);\n            \n            return new RotationResult(\n                secretName,\n                oldVersion,\n                newVersion,\n                OffsetDateTime.now(),\n                true,\n                \"Secret rotated successfully with tags\"\n            );\n            \n        } catch (ResourceNotFoundException e) {\n            String message = String.format(\"Secret not found: %s\", secretName);\n            LOGGER.log(Level.SEVERE, message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (HttpResponseException e) {\n            String message = handleHttpResponseException(secretName, e);\n            LOGGER.log(Level.SEVERE, message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (Exception e) {\n            String message = String.format(\"Unexpected error rotating secret: %s\", secretName);\n            LOGGER.log(Level.SEVERE, message, e);\n            throw new SecretRotationException(message, e);\n        }\n    }\n    \n    /**\n     * Rotates a secret with an expiration date.\n     *\n     * @param secretName The name of the secret to rotate\n     * @param newValue The new secret value\n     * @param expiresOn The expiration date for the new version\n     * @return RotationResult containing information about the rotation\n     * @throws SecretRotationException if rotation fails\n     */\n    public RotationResult rotateSecretWithExpiration(\n            String secretName, \n            String newValue, \n            OffsetDateTime expiresOn) {\n        \n        validateInputs(secretName, newValue);\n        \n        if (expiresOn == null || expiresOn.isBefore(OffsetDateTime.now())) {\n            throw new IllegalArgumentException(\"Expiration date must be in the future\");\n        }\n        \n        LOGGER.info(String.format(\n            \"Starting rotation with expiration for secret: %s (expires: %s)\", \n            secretName, \n            expiresOn\n        ));\n        \n        try {\n            // Get current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String oldVersion = currentSecret.getProperties().getVersion();\n            \n            // Disable old version\n            disableSecretVersion(currentSecret);\n            \n            // Create new version with expiration\n            KeyVaultSecret newSecretWithExpiration = new KeyVaultSecret(secretName, newValue)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(expiresOn)\n                    .setEnabled(true));\n            \n            KeyVaultSecret newSecret = secretClient.setSecret(newSecretWithExpiration);\n            String newVersion = newSecret.getProperties().getVersion();\n            \n            LOGGER.info(String.format(\n                \"Created new version with expiration: %s (expires: %s)\", \n                newVersion, \n                expiresOn\n            ));\n            \n            // Verify new version\n            verifyNewVersion(secretName, newVersion, newValue);\n            \n            return new RotationResult(\n                secretName,\n                oldVersion,\n                newVersion,\n                OffsetDateTime.now(),\n                true,\n                String.format(\"Secret rotated successfully, expires: %s\", expiresOn)\n            );\n            \n        } catch (ResourceNotFoundException e) {\n            String message = String.format(\"Secret not found: %s\", secretName);\n            LOGGER.log(Level.SEVERE, message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (HttpResponseException e) {\n            String message = handleHttpResponseException(secretName, e);\n            LOGGER.log(Level.SEVERE, message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (Exception e) {\n            String message = String.format(\"Unexpected error rotating secret: %s\", secretName);\n            LOGGER.log(Level.SEVERE, message, e);\n            throw new SecretRotationException(message, e);\n        }\n    }\n    \n    /**\n     * Gets the current (latest) version of a secret.\n     */\n    private KeyVaultSecret getCurrentSecret(String secretName) {\n        try {\n            return secretClient.getSecret(secretName);\n        } catch (ResourceNotFoundException e) {\n            throw new SecretRotationException(\n                String.format(\"Secret '%s' does not exist in vault\", secretName), \n                e\n            );\n        }\n    }\n    \n    /**\n     * Disables a secret version by updating its properties.\n     */\n    private void disableSecretVersion(KeyVaultSecret secret) {\n        SecretProperties properties = secret.getProperties();\n        properties.setEnabled(false);\n        \n        // Add rotation metadata\n        Map<String, String> tags = properties.getTags();\n        if (tags == null) {\n            tags = new HashMap<>();\n        }\n        tags.put(\"rotated-on\", OffsetDateTime.now().toString());\n        tags.put(\"status\", \"disabled\");\n        properties.setTags(tags);\n        \n        secretClient.updateSecretProperties(properties);\n    }\n    \n    /**\n     * Creates a new version of the secret with the updated value.\n     */\n    private KeyVaultSecret createNewSecretVersion(String secretName, String newValue) {\n        Map<String, String> tags = new HashMap<>();\n        tags.put(\"created-on\", OffsetDateTime.now().toString());\n        tags.put(\"rotation-type\", \"automatic\");\n        \n        KeyVaultSecret newSecret = new KeyVaultSecret(secretName, newValue)\n            .setProperties(new SecretProperties()\n                .setTags(tags)\n                .setEnabled(true));\n        \n        return secretClient.setSecret(newSecret);\n    }\n    \n    /**\n     * Verifies that the new secret version is active and has the correct value.\n     */\n    private void verifyNewVersion(String secretName, String expectedVersion, String expectedValue) {\n        KeyVaultSecret verifiedSecret = secretClient.getSecret(secretName, expectedVersion);\n        \n        if (!verifiedSecret.getProperties().isEnabled()) {\n            throw new SecretRotationException(\n                String.format(\"New version %s is not enabled\", expectedVersion)\n            );\n        }\n        \n        if (!expectedValue.equals(verifiedSecret.getValue())) {\n            throw new SecretRotationException(\n                String.format(\"New version %s has incorrect value\", expectedVersion)\n            );\n        }\n        \n        LOGGER.info(String.format(\"Verified new version: %s\", expectedVersion));\n    }\n    \n    /**\n     * Validates input parameters.\n     */\n    private void validateInputs(String secretName, String newValue) {\n        if (secretName == null || secretName.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Secret name cannot be null or empty\");\n        }\n        \n        if (newValue == null || newValue.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"New value cannot be null or empty\");\n        }\n    }\n    \n    /**\n     * Handles HTTP response exceptions and returns appropriate error messages.\n     */\n    private String handleHttpResponseException(String secretName, HttpResponseException e) {\n        int statusCode = e.getResponse().getStatusCode();\n        \n        switch (statusCode) {\n            case 401:\n                return String.format(\n                    \"Authentication failed for secret '%s'. Check credentials.\", \n                    secretName\n                );\n            case 403:\n                return String.format(\n                    \"Access denied for secret '%s'. Check Key Vault permissions.\", \n                    secretName\n                );\n            case 404:\n                return String.format(\"Secret '%s' not found in vault\", secretName);\n            case 409:\n                return String.format(\n                    \"Conflict rotating secret '%s'. Secret may be in deleted state.\", \n                    secretName\n                );\n            case 429:\n                return String.format(\n                    \"Rate limit exceeded for secret '%s'. Retry after delay.\", \n                    secretName\n                );\n            default:\n                return String.format(\n                    \"HTTP error %d rotating secret '%s': %s\", \n                    statusCode, \n                    secretName, \n                    e.getMessage()\n                );\n        }\n    }\n    \n    /**\n     * Gets the SecretClient instance (for testing purposes).\n     */\n    SecretClient getSecretClient() {\n        return secretClient;\n    }\n    \n    /**\n     * Result object containing information about a secret rotation operation.\n     */\n    public static class RotationResult {\n        private final String secretName;\n        private final String oldVersion;\n        private final String newVersion;\n        private final OffsetDateTime rotationTime;\n        private final boolean success;\n        private final String message;\n        \n        public RotationResult(\n                String secretName,\n                String oldVersion,\n                String newVersion,\n                OffsetDateTime rotationTime,\n                boolean success,\n                String message) {\n            this.secretName = secretName;\n            this.oldVersion = oldVersion;\n            this.newVersion = newVersion;\n            this.rotationTime = rotationTime;\n            this.success = success;\n            this.message = message;\n        }\n        \n        public String getSecretName() {\n            return secretName;\n        }\n        \n        public String getOldVersion() {\n            return oldVersion;\n        }\n        \n        public String getNewVersion() {\n            return newVersion;\n        }\n        \n        public OffsetDateTime getRotationTime() {\n            return rotationTime;\n        }\n        \n        public boolean isSuccess() {\n            return success;\n        }\n        \n        public String getMessage() {\n            return message;\n        }\n        \n        @Override\n        public String toString() {\n            return String.format(\n                \"RotationResult{secretName='%s', oldVersion='%s', newVersion='%s', \" +\n                \"rotationTime=%s, success=%s, message='%s'}\",\n                secretName, oldVersion, newVersion, rotationTime, success, message\n            );\n        }\n    }\n    \n    /**\n     * Custom exception for secret rotation failures",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8152,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive secret rotation service class using the Azure Key Vault Secrets SDK.\n\n```java\npackage com.example.app.service;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport java.time.OffsetDateTime;\nimport java.util.Map;\n\n@Service\npublic class SecretRotationService {\n    \n    private static final Logger log = LoggerFactory.getLogger(SecretRotationService.class);\n    \n    private final SecretClient secretClient;\n    \n    public SecretRotationService(@Value(\"${azure.keyvault.url}\") String vaultUrl) {\n        this.secretClient = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        log.info(\"SecretRotationService initialized with vault: {}\", vaultUrl);\n    }\n    \n    /**\n     * Rotates a secret by disabling the old version and creating a new version.\n     * \n     * @param secretName the name of the secret to rotate\n     * @param newValue the new secret value\n     * @return the newly created secret\n     * @throws SecretRotationException if rotation fails\n     */\n    public KeyVaultSecret rotateSecret(String secretName, String newValue) {\n        log.info(\"Starting secret rotation for: {}\", secretName);\n        \n        try {\n            // Step 1: Get current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String oldVersion = currentSecret.getProperties().getVersion();\n            log.info(\"Retrieved current secret version: {}\", oldVersion);\n            \n            // Step 2: Disable old version\n            disableSecretVersion(currentSecret);\n            log.info(\"Disabled old secret version: {}\", oldVersion);\n            \n            // Step 3: Create new version with new value\n            KeyVaultSecret newSecret = createNewSecretVersion(secretName, newValue);\n            String newVersion = newSecret.getProperties().getVersion();\n            log.info(\"Created new secret version: {}\", newVersion);\n            \n            // Step 4: Verify new version is active\n            verifySecretActive(secretName, newVersion);\n            log.info(\"Verified new secret version is active: {}\", newVersion);\n            \n            log.info(\"Successfully rotated secret: {} from version {} to {}\", \n                secretName, oldVersion, newVersion);\n            \n            return newSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            String message = String.format(\"Secret not found: %s\", secretName);\n            log.error(message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (HttpResponseException e) {\n            int statusCode = e.getResponse().getStatusCode();\n            String message = handleHttpError(secretName, statusCode);\n            log.error(message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (Exception e) {\n            String message = String.format(\"Unexpected error rotating secret: %s\", secretName);\n            log.error(message, e);\n            throw new SecretRotationException(message, e);\n        }\n    }\n    \n    /**\n     * Rotates a secret with additional metadata tags.\n     * \n     * @param secretName the name of the secret to rotate\n     * @param newValue the new secret value\n     * @param tags metadata tags for the new secret version\n     * @return the newly created secret\n     */\n    public KeyVaultSecret rotateSecretWithTags(String secretName, String newValue, Map<String, String> tags) {\n        log.info(\"Starting secret rotation with tags for: {}\", secretName);\n        \n        try {\n            // Get and disable current version\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String oldVersion = currentSecret.getProperties().getVersion();\n            disableSecretVersion(currentSecret);\n            \n            // Create new version with tags\n            KeyVaultSecret newSecret = new KeyVaultSecret(secretName, newValue)\n                .setProperties(new SecretProperties()\n                    .setEnabled(true)\n                    .setTags(tags));\n            \n            KeyVaultSecret createdSecret = secretClient.setSecret(newSecret);\n            String newVersion = createdSecret.getProperties().getVersion();\n            \n            verifySecretActive(secretName, newVersion);\n            \n            log.info(\"Successfully rotated secret with tags: {} from {} to {}\", \n                secretName, oldVersion, newVersion);\n            \n            return createdSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            String message = String.format(\"Secret not found: %s\", secretName);\n            log.error(message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (HttpResponseException e) {\n            int statusCode = e.getResponse().getStatusCode();\n            String message = handleHttpError(secretName, statusCode);\n            log.error(message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (Exception e) {\n            String message = String.format(\"Unexpected error rotating secret: %s\", secretName);\n            log.error(message, e);\n            throw new SecretRotationException(message, e);\n        }\n    }\n    \n    /**\n     * Rotates a secret with an expiration date.\n     * \n     * @param secretName the name of the secret to rotate\n     * @param newValue the new secret value\n     * @param expiresOn the expiration date for the new secret\n     * @return the newly created secret\n     */\n    public KeyVaultSecret rotateSecretWithExpiration(String secretName, String newValue, OffsetDateTime expiresOn) {\n        log.info(\"Starting secret rotation with expiration for: {}\", secretName);\n        \n        try {\n            // Get and disable current version\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            disableSecretVersion(currentSecret);\n            \n            // Create new version with expiration\n            KeyVaultSecret newSecret = new KeyVaultSecret(secretName, newValue)\n                .setProperties(new SecretProperties()\n                    .setEnabled(true)\n                    .setExpiresOn(expiresOn));\n            \n            KeyVaultSecret createdSecret = secretClient.setSecret(newSecret);\n            verifySecretActive(secretName, createdSecret.getProperties().getVersion());\n            \n            log.info(\"Successfully rotated secret with expiration: {}, expires: {}\", \n                secretName, expiresOn);\n            \n            return createdSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            String message = String.format(\"Secret not found: %s\", secretName);\n            log.error(message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (HttpResponseException e) {\n            int statusCode = e.getResponse().getStatusCode();\n            String message = handleHttpError(secretName, statusCode);\n            log.error(message, e);\n            throw new SecretRotationException(message, e);\n            \n        } catch (Exception e) {\n            String message = String.format(\"Unexpected error rotating secret: %s\", secretName);\n            log.error(message, e);\n            throw new SecretRotationException(message, e);\n        }\n    }\n    \n    /**\n     * Gets the current (latest) version of a secret.\n     */\n    private KeyVaultSecret getCurrentSecret(String secretName) {\n        return secretClient.getSecret(secretName);\n    }\n    \n    /**\n     * Disables a specific version of a secret.\n     */\n    private void disableSecretVersion(KeyVaultSecret secret) {\n        SecretProperties properties = secret.getProperties();\n        properties.setEnabled(false);\n        secretClient.updateSecretProperties(properties);\n    }\n    \n    /**\n     * Creates a new version of a secret with the given value.\n     */\n    private KeyVaultSecret createNewSecretVersion(String secretName, String newValue) {\n        return secretClient.setSecret(secretName, newValue);\n    }\n    \n    /**\n     * Verifies that a specific version of a secret is active and enabled.\n     */\n    private void verifySecretActive(String secretName, String version) {\n        KeyVaultSecret secret = secretClient.getSecret(secretName, version);\n        \n        if (!secret.getProperties().isEnabled()) {\n            throw new SecretRotationException(\n                String.format(\"New secret version is not enabled: %s (version: %s)\", \n                    secretName, version));\n        }\n        \n        if (secret.getValue() == null || secret.getValue().isEmpty()) {\n            throw new SecretRotationException(\n                String.format(\"New secret version has no value: %s (version: %s)\", \n                    secretName, version));\n        }\n    }\n    \n    /**\n     * Handles HTTP errors and returns appropriate error messages.\n     */\n    private String handleHttpError(String secretName, int statusCode) {\n        return switch (statusCode) {\n            case 401 -> String.format(\"Authentication failed for secret: %s. Check credentials.\", secretName);\n            case 403 -> String.format(\"Access denied for secret: %s. Check Key Vault permissions.\", secretName);\n            case 404 -> String.format(\"Secret not found: %s\", secretName);\n            case 409 -> String.format(\"Conflict rotating secret: %s. Secret may be in deleted state.\", secretName);\n            case 429 -> String.format(\"Rate limited rotating secret: %s. Retry later.\", secretName);\n            default -> String.format(\"HTTP error %d rotating secret: %s\", statusCode, secretName);\n        };\n    }\n    \n    /**\n     * Custom exception for secret rotation failures.\n     */\n    public static class SecretRotationException extends RuntimeException {\n        public SecretRotationException(String message) {\n            super(message);\n        }\n        \n        public SecretRotationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```\n\nNow let me create a corresponding test class:\n\n```java\npackage com.example.app.service;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.core.http.HttpResponse;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.time.OffsetDateTime;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.ArgumentMatchers.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\nclass SecretRotationServiceTest {\n    \n    @Mock\n    private SecretClient secretClient;\n    \n    private SecretRotationService service;\n    \n    @BeforeEach\n    void setUp() {\n        service = new SecretRotationService(\"https://test-vault.vault.azure.net\");\n        // Inject mock client via reflection for testing\n        try {\n            var field = SecretRotationService.class.getDeclaredField(\"secretClient\");\n            field.setAccessible(true);\n            field.set(service, secretClient);\n        } catch (Exception e) {\n            fail(\"Failed to inject mock client: \" + e.getMessage());\n        }\n    }\n    \n    @Test\n    void rotateSecret_Success() {\n        // Arrange\n        String secretName = \"database-password\";\n        String oldValue = \"oldPassword123\";\n        String newValue = \"newPassword456\";\n        String oldVersion = \"v1\";\n        String newVersion = \"v2\";\n        \n        KeyVaultSecret oldSecret = createSecret(secretName, oldValue, oldVersion, true);\n        KeyVaultSecret newSecret = createSecret(secretName, newValue, newVersion, true);\n        \n        when(secretClient.getSecret(secretName)).thenReturn(oldSecret);\n        when(secretClient.updateSecretProperties(any(SecretProperties.class)))\n            .thenReturn(oldSecret.getProperties());\n        when(secretClient.setSecret(secretName, newValue)).thenReturn(newSecret);\n        when(secretClient.getSecret(secretName, newVersion)).thenReturn(newSecret);\n        \n        // Act\n        KeyVaultSecret result = service.rotateSecret(secretName, newValue);\n        \n        // Assert\n        assertNotNull(result);\n        assertEquals(secretName, result.getName());\n        assertEquals(newValue, result.getValue());\n        assertEquals(newVersion, result.getProperties().getVersion());\n        \n        verify(secretClient).getSecret(secretName);\n        verify(secretClient).updateSecretProperties(argThat(props -> \n            !props.isEnabled() && props.getVersion().equals(oldVersion)));\n        verify(secretClient).setSecret(secretName, newValue);\n        verify(secretClient).getSecret(secretName, newVersion);\n    }\n    \n    @Test\n    void rotateSecret_SecretNotFound() {\n        // Arrange\n        String secretName = \"nonexistent-secret\";\n        when(secretClient.getSecret(secretName))\n            .thenThrow(new ResourceNotFoundException(\"Secret not found\", null));\n        \n        // Act & Assert\n        SecretRotationService.SecretRotationException exception = \n            assertThrows(SecretRotationService.SecretRotationException.class, \n                () -> service.rotateSecret(secretName, \"newValue\"));\n        \n        assertTrue(exception.getMessage().contains(\"Secret not found\"));\n        assertTrue(exception.getCause() instanceof ResourceNotFoundException);\n    }\n    \n    @Test\n    void rotateSecret_AccessDenied() {\n        // Arrange\n        String secretName = \"protected-secret\";\n        HttpResponse mockResponse = mock(HttpResponse.class);\n        when(mockResponse.getStatusCode()).thenReturn(403);\n        \n        HttpResponseException httpException = new HttpResponseException(\"Access denied\", mockResponse);\n        when(secretClient.getSecret(secretName)).thenThrow(httpException);\n        \n        // Act & Assert\n        SecretRotationService.SecretRotationException exception = \n            assertThrows(SecretRotationService.SecretRotationException.class, \n                () -> service.rotateSecret(secretName, \"newValue\"));\n        \n        assertTrue(exception.getMessage().contains(\"Access denied\"));\n        assertTrue(exception.getMessage().contains(\"permissions\"));\n    }\n    \n    @Test\n    void rotateSecret_RateLimited() {\n        // Arrange\n        String secretName = \"rate-limited-secret\";\n        HttpResponse mockResponse = mock(HttpResponse.class);\n        when(mockResponse.getStatusCode()).thenReturn(429);\n        \n        HttpResponseException httpException = new HttpResponseException(\"Rate limited\", mockResponse);\n        when(secretClient.getSecret(secretName)).thenThrow(httpException);\n        \n        // Act & Assert\n        SecretRotationService.SecretRotationException exception = \n            assertThrows(SecretRotationService.SecretRotationException.class, \n                () -> service.rotateSecret(secretName, \"newValue\"));\n        \n        assertTrue(exception.getMessage().contains(\"Rate limited\"));\n        assertTrue(exception.getMessage().contains(\"Retry later\"));\n    }\n    \n    @Test\n    void rotateSecretWithTags_Success() {\n        // Arrange\n        String secretName = \"api-key\";\n        String newValue = \"sk_live_new123\";\n        Map<String, String> tags = Map.of(\n            \"environment\", \"production\",\n            \"rotated-by\", \"admin\"\n        );\n        \n        KeyVaultSecret oldSecret = create",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8677,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "```java\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport java.time.OffsetDateTime;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * Service class for managing Azure Key Vault secret rotation.\n * Implements a secure pattern for rotating secrets with proper version management.\n */\n@Service\npublic class SecretRotationService {\n\n    private static final Logger logger = LoggerFactory.getLogger(SecretRotationService.class);\n\n    @Value(\"${azure.keyvault.uri}\")\n    private String keyVaultUri;\n\n    private SecretClient secretClient;\n\n    /**\n     * Initialize the SecretClient with DefaultAzureCredential\n     */\n    @PostConstruct\n    public void init() {\n        try {\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                    .build();\n\n            this.secretClient = new SecretClientBuilder()\n                    .vaultUrl(keyVaultUri)\n                    .credential(credential)\n                    .buildClient();\n\n            logger.info(\"SecretClient initialized successfully for vault: {}\", keyVaultUri);\n        } catch (Exception e) {\n            logger.error(\"Failed to initialize SecretClient\", e);\n            throw new RuntimeException(\"Failed to initialize Azure Key Vault client\", e);\n        }\n    }\n\n    /**\n     * Rotates a secret by creating a new version and disabling old versions.\n     *\n     * @param secretName The name of the secret to rotate\n     * @param newSecretValue The new secret value\n     * @return The newly created secret version\n     * @throws SecretRotationException if rotation fails\n     */\n    public KeyVaultSecret rotateSecret(String secretName, String newSecretValue) \n            throws SecretRotationException {\n        \n        logger.info(\"Starting secret rotation for: {}\", secretName);\n\n        try {\n            // Step 1: Get the current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String currentVersion = currentSecret.getProperties().getVersion();\n            logger.info(\"Current secret version: {}\", currentVersion);\n\n            // Step 2: Create new version with updated value\n            KeyVaultSecret newSecret = createNewSecretVersion(secretName, newSecretValue);\n            String newVersion = newSecret.getProperties().getVersion();\n            logger.info(\"New secret version created: {}\", newVersion);\n\n            // Step 3: Verify the new version is active\n            verifySecretVersion(secretName, newVersion);\n            logger.info(\"New secret version verified successfully\");\n\n            // Step 4: Disable old versions (keeping the new one active)\n            disableOldVersions(secretName, newVersion);\n            logger.info(\"Old secret versions disabled\");\n\n            logger.info(\"Secret rotation completed successfully for: {}\", secretName);\n            return newSecret;\n\n        } catch (ResourceNotFoundException e) {\n            logger.error(\"Secret not found: {}\", secretName, e);\n            throw new SecretRotationException(\"Secret not found: \" + secretName, e);\n        } catch (HttpResponseException e) {\n            logger.error(\"HTTP error during secret rotation: {} - Status: {}\", \n                    secretName, e.getResponse().getStatusCode(), e);\n            throw new SecretRotationException(\n                    String.format(\"HTTP error during secret rotation: %s (Status: %d)\", \n                            secretName, e.getResponse().getStatusCode()), e);\n        } catch (Exception e) {\n            logger.error(\"Unexpected error during secret rotation: {}\", secretName, e);\n            throw new SecretRotationException(\"Unexpected error during secret rotation\", e);\n        }\n    }\n\n    /**\n     * Gets the current (latest) version of a secret.\n     *\n     * @param secretName The name of the secret\n     * @return The current secret\n     * @throws ResourceNotFoundException if secret doesn't exist\n     */\n    private KeyVaultSecret getCurrentSecret(String secretName) {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            if (secret == null) {\n                throw new ResourceNotFoundException(\n                        String.format(\"Secret '%s' not found\", secretName), null);\n            }\n            return secret;\n        } catch (ResourceNotFoundException e) {\n            logger.warn(\"Secret '{}' does not exist in Key Vault\", secretName);\n            throw e;\n        } catch (HttpResponseException e) {\n            logger.error(\"HTTP error retrieving secret '{}': Status {}\", \n                    secretName, e.getResponse().getStatusCode());\n            throw e;\n        }\n    }\n\n    /**\n     * Creates a new version of the secret with the updated value.\n     *\n     * @param secretName The name of the secret\n     * @param newValue The new secret value\n     * @return The newly created secret\n     */\n    private KeyVaultSecret createNewSecretVersion(String secretName, String newValue) {\n        try {\n            KeyVaultSecret newSecret = secretClient.setSecret(secretName, newValue);\n            \n            // Optionally set metadata\n            SecretProperties properties = newSecret.getProperties();\n            properties.setExpiresOn(OffsetDateTime.now().plusMonths(6));\n            properties.setContentType(\"application/secret\");\n            secretClient.updateSecretProperties(properties);\n            \n            return newSecret;\n        } catch (HttpResponseException e) {\n            logger.error(\"Failed to create new secret version for '{}': Status {}\", \n                    secretName, e.getResponse().getStatusCode());\n            throw e;\n        }\n    }\n\n    /**\n     * Verifies that the new secret version is active and retrievable.\n     *\n     * @param secretName The name of the secret\n     * @param expectedVersion The expected version ID\n     * @throws SecretRotationException if verification fails\n     */\n    private void verifySecretVersion(String secretName, String expectedVersion) \n            throws SecretRotationException {\n        try {\n            KeyVaultSecret verifiedSecret = secretClient.getSecret(secretName, expectedVersion);\n            \n            if (verifiedSecret == null) {\n                throw new SecretRotationException(\n                        String.format(\"Failed to verify secret version: %s\", expectedVersion));\n            }\n\n            if (!verifiedSecret.getProperties().isEnabled()) {\n                throw new SecretRotationException(\n                        String.format(\"New secret version is not enabled: %s\", expectedVersion));\n            }\n\n            String actualVersion = verifiedSecret.getProperties().getVersion();\n            if (!expectedVersion.equals(actualVersion)) {\n                throw new SecretRotationException(\n                        String.format(\"Version mismatch. Expected: %s, Actual: %s\", \n                                expectedVersion, actualVersion));\n            }\n\n            logger.debug(\"Secret version verified: {} - {}\", secretName, expectedVersion);\n        } catch (ResourceNotFoundException e) {\n            throw new SecretRotationException(\n                    String.format(\"Failed to verify secret version: %s\", expectedVersion), e);\n        }\n    }\n\n    /**\n     * Disables all versions of the secret except the specified version.\n     *\n     * @param secretName The name of the secret\n     * @param versionToKeep The version to keep enabled\n     */\n    private void disableOldVersions(String secretName, String versionToKeep) {\n        try {\n            List<SecretProperties> allVersions = secretClient\n                    .listPropertiesOfSecretVersions(secretName)\n                    .stream()\n                    .collect(Collectors.toList());\n\n            logger.info(\"Found {} versions of secret '{}'\", allVersions.size(), secretName);\n\n            for (SecretProperties properties : allVersions) {\n                String version = properties.getVersion();\n                \n                // Skip the version we want to keep\n                if (version.equals(versionToKeep)) {\n                    continue;\n                }\n\n                // Only disable if currently enabled\n                if (properties.isEnabled()) {\n                    try {\n                        properties.setEnabled(false);\n                        secretClient.updateSecretProperties(properties);\n                        logger.info(\"Disabled secret version: {} - {}\", secretName, version);\n                    } catch (HttpResponseException e) {\n                        logger.warn(\"Failed to disable version {} of secret '{}': Status {}\", \n                                version, secretName, e.getResponse().getStatusCode());\n                        // Continue with other versions even if one fails\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Error disabling old versions of secret '{}'\", secretName, e);\n            // Don't throw - this is a cleanup operation\n        }\n    }\n\n    /**\n     * Retrieves a specific version of a secret.\n     *\n     * @param secretName The name of the secret\n     * @param version The version to retrieve\n     * @return The secret\n     * @throws ResourceNotFoundException if secret or version doesn't exist\n     */\n    public KeyVaultSecret getSecretVersion(String secretName, String version) {\n        try {\n            return secretClient.getSecret(secretName, version);\n        } catch (ResourceNotFoundException e) {\n            logger.error(\"Secret version not found: {} - {}\", secretName, version);\n            throw e;\n        } catch (HttpResponseException e) {\n            logger.error(\"HTTP error retrieving secret version: {} - {} (Status: {})\", \n                    secretName, version, e.getResponse().getStatusCode());\n            throw e;\n        }\n    }\n\n    /**\n     * Lists all versions of a secret.\n     *\n     * @param secretName The name of the secret\n     * @return List of secret properties for all versions\n     */\n    public List<SecretProperties> listSecretVersions(String secretName) {\n        try {\n            return secretClient.listPropertiesOfSecretVersions(secretName)\n                    .stream()\n                    .collect(Collectors.toList());\n        } catch (ResourceNotFoundException e) {\n            logger.error(\"Secret not found: {}\", secretName);\n            throw e;\n        } catch (HttpResponseException e) {\n            logger.error(\"HTTP error listing secret versions: {} (Status: {})\", \n                    secretName, e.getResponse().getStatusCode());\n            throw e;\n        }\n    }\n\n    /**\n     * Performs a rollback by enabling a previous version and disabling the current one.\n     *\n     * @param secretName The name of the secret\n     * @param versionToRestore The version to restore\n     * @throws SecretRotationException if rollback fails\n     */\n    public void rollbackSecret(String secretName, String versionToRestore) \n            throws SecretRotationException {\n        \n        logger.info(\"Starting secret rollback for: {} to version: {}\", secretName, versionToRestore);\n\n        try {\n            // Get the version to restore\n            KeyVaultSecret secretToRestore = secretClient.getSecret(secretName, versionToRestore);\n            \n            if (secretToRestore == null) {\n                throw new SecretRotationException(\n                        String.format(\"Version to restore not found: %s\", versionToRestore));\n            }\n\n            // Enable the target version\n            SecretProperties properties = secretToRestore.getProperties();\n            properties.setEnabled(true);\n            secretClient.updateSecretProperties(properties);\n            \n            logger.info(\"Enabled version: {}\", versionToRestore);\n\n            // Disable all other versions\n            disableOldVersions(secretName, versionToRestore);\n            \n            logger.info(\"Secret rollback completed successfully\");\n        } catch (ResourceNotFoundException e) {\n            logger.error(\"Failed to rollback secret: version not found\", e);\n            throw new SecretRotationException(\"Failed to rollback secret: version not found\", e);\n        } catch (HttpResponseException e) {\n            logger.error(\"HTTP error during rollback: Status {}\", e.getResponse().getStatusCode());\n            throw new SecretRotationException(\"HTTP error during rollback\", e);\n        }\n    }\n\n    /**\n     * Custom exception for secret rotation operations.\n     */\n    public static class SecretRotationException extends Exception {\n        public SecretRotationException(String message) {\n            super(message);\n        }\n\n        public SecretRotationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```\n\n```java\n// Example usage and test class\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class SecretRotationExample {\n\n    @Autowired\n    private SecretRotationService secretRotationService;\n\n    private static final Logger logger = LoggerFactory.getLogger(SecretRotationExample.class);\n\n    /**\n     * Example method demonstrating secret rotation usage.\n     */\n    public void demonstrateSecretRotation() {\n        String secretName = \"database-password\";\n        String newPassword = generateSecurePassword();\n\n        try {\n            // Rotate the secret\n            KeyVaultSecret newSecret = secretRotationService.rotateSecret(secretName, newPassword);\n            logger.info(\"Secret rotated successfully. New version: {}\", \n                    newSecret.getProperties().getVersion());\n\n            // List all versions\n            List<SecretProperties> versions = secretRotationService.listSecretVersions(secretName);\n            logger.info(\"Total versions: {}\", versions.size());\n            \n            for (SecretProperties props : versions) {\n                logger.info(\"Version: {} - Enabled: {} - Created: {}\", \n                        props.getVersion(), \n                        props.isEnabled(), \n                        props.getCreatedOn());\n            }\n\n        } catch (SecretRotationService.SecretRotationException e) {\n            logger.error(\"Failed to rotate secret\", e);\n            \n            // Optionally perform rollback\n            try {\n                String previousVersion = getPreviousVersion(secretName);\n                if (previousVersion != null) {\n                    secretRotationService.rollbackSecret(secretName, previousVersion);\n                    logger.info(\"Rolled back to previous version\");\n                }\n            } catch (Exception rollbackException) {\n                logger.error(\"Rollback also failed\", rollbackException);\n            }\n        }\n    }\n\n    private String generateSecurePassword() {\n        // Implement secure password generation\n        return java.util.UUID.randomUUID().toString();\n    }\n\n    private String getPreviousVersion(String secretName) {\n        List<SecretProperties> versions = secretRotationService.listSecretVersions(secretName);\n        return versions.size() > 1 ? versions.get(1).getVersion() : null;\n    }\n}\n```\n\n```properties\n# application.properties\nazure.keyvault.uri=https://your-keyvault-name.vault.azure.net/\n```\n\n```xml\n<!-- pom.xml dependencies -->\n<dependencies>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-secrets</artifactId>\n        <version>4.6.0</version>\n    </dependency>\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.10.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n    </dependency>\n</dependencies>\n```\n\nThis implementation provides:\n\n1. **Complete Secret Rotation Pattern**: Gets current secret, creates new version, verifies it, and disables old versions\n2. **Proper Error Handling**: Catches `ResourceNotFoundException` and `HttpResponseException` with detailed logging\n3. **DefaultAzureCredential**: Uses Azure's recommended authentication method\n4. **Version Management**: Tracks and manages multiple secret versions\n5. **Rollback Capability**: Can restore previous versions if needed\n6. **Comprehensive Logging**:",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 83,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secret Rotation Service\n\nHere's a comprehensive Java service class implementing the secret rotation pattern with proper error handling:\n\n```java\npackage com.example.keyvault.service;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\n\nimport java.time.OffsetDateTime;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Service class for managing Azure Key Vault secret rotation.\n * Implements a secure rotation pattern that disables old versions\n * before creating new ones.\n */\npublic class SecretRotationService {\n    \n    private static final Logger LOGGER = Logger.getLogger(SecretRotationService.class.getName());\n    \n    private final SecretClient secretClient;\n    private final String vaultUrl;\n    \n    /**\n     * Creates a new SecretRotationService with the specified vault URL.\n     * Uses DefaultAzureCredential for authentication.\n     *\n     * @param vaultUrl The Azure Key Vault URL (e.g., https://my-vault.vault.azure.net)\n     */\n    public SecretRotationService(String vaultUrl) {\n        if (vaultUrl == null || vaultUrl.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Vault URL cannot be null or empty\");\n        }\n        \n        this.vaultUrl = vaultUrl;\n        this.secretClient = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        LOGGER.info(\"SecretRotationService initialized for vault: \" + vaultUrl);\n    }\n    \n    /**\n     * Constructor for dependency injection (testing).\n     *\n     * @param secretClient The SecretClient instance to use\n     * @param vaultUrl The vault URL for logging purposes\n     */\n    public SecretRotationService(SecretClient secretClient, String vaultUrl) {\n        this.secretClient = secretClient;\n        this.vaultUrl = vaultUrl;\n    }\n    \n    /**\n     * Rotates a secret by disabling the old version and creating a new one.\n     *\n     * @param secretName The name of the secret to rotate\n     * @param newValue The new secret value\n     * @return RotationResult containing details about the rotation\n     * @throws SecretRotationException if rotation fails\n     */\n    public RotationResult rotateSecret(String secretName, String newValue) {\n        return rotateSecret(secretName, newValue, null);\n    }\n    \n    /**\n     * Rotates a secret with additional metadata.\n     *\n     * @param secretName The name of the secret to rotate\n     * @param newValue The new secret value\n     * @param metadata Additional metadata (tags, content type, expiration)\n     * @return RotationResult containing details about the rotation\n     * @throws SecretRotationException if rotation fails\n     */\n    public RotationResult rotateSecret(String secretName, String newValue, SecretMetadata metadata) {\n        if (secretName == null || secretName.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Secret name cannot be null or empty\");\n        }\n        if (newValue == null || newValue.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"New secret value cannot be null or empty\");\n        }\n        \n        LOGGER.info(String.format(\"Starting rotation for secret: %s\", secretName));\n        \n        RotationResult result = new RotationResult(secretName);\n        \n        try {\n            // Step 1: Get current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            result.setOldVersion(currentSecret.getProperties().getVersion());\n            LOGGER.info(String.format(\"Retrieved current secret version: %s\", result.getOldVersion()));\n            \n            // Step 2: Disable old version\n            disableOldVersion(currentSecret);\n            LOGGER.info(String.format(\"Disabled old version: %s\", result.getOldVersion()));\n            \n            // Step 3: Create new version\n            KeyVaultSecret newSecret = createNewVersion(secretName, newValue, metadata);\n            result.setNewVersion(newSecret.getProperties().getVersion());\n            result.setRotationTime(OffsetDateTime.now());\n            LOGGER.info(String.format(\"Created new version: %s\", result.getNewVersion()));\n            \n            // Step 4: Verify new version is active\n            verifyNewVersion(secretName, newSecret.getProperties().getVersion(), newValue);\n            result.setVerified(true);\n            result.setSuccess(true);\n            LOGGER.info(String.format(\"Successfully rotated secret: %s\", secretName));\n            \n            return result;\n            \n        } catch (ResourceNotFoundException e) {\n            String errorMsg = String.format(\"Secret not found: %s\", secretName);\n            LOGGER.log(Level.SEVERE, errorMsg, e);\n            result.setSuccess(false);\n            result.setErrorMessage(errorMsg);\n            throw new SecretRotationException(errorMsg, e);\n            \n        } catch (HttpResponseException e) {\n            String errorMsg = handleHttpResponseException(secretName, e);\n            LOGGER.log(Level.SEVERE, errorMsg, e);\n            result.setSuccess(false);\n            result.setErrorMessage(errorMsg);\n            throw new SecretRotationException(errorMsg, e);\n            \n        } catch (Exception e) {\n            String errorMsg = String.format(\"Unexpected error rotating secret %s: %s\", \n                secretName, e.getMessage());\n            LOGGER.log(Level.SEVERE, errorMsg, e);\n            result.setSuccess(false);\n            result.setErrorMessage(errorMsg);\n            throw new SecretRotationException(errorMsg, e);\n        }\n    }\n    \n    /**\n     * Gets the current (latest) version of a secret.\n     *\n     * @param secretName The secret name\n     * @return The current KeyVaultSecret\n     * @throws ResourceNotFoundException if secret doesn't exist\n     */\n    private KeyVaultSecret getCurrentSecret(String secretName) {\n        try {\n            return secretClient.getSecret(secretName);\n        } catch (ResourceNotFoundException e) {\n            LOGGER.severe(String.format(\"Secret '%s' not found in vault %s\", secretName, vaultUrl));\n            throw e;\n        }\n    }\n    \n    /**\n     * Disables the old version of a secret.\n     *\n     * @param currentSecret The current secret to disable\n     */\n    private void disableOldVersion(KeyVaultSecret currentSecret) {\n        SecretProperties properties = currentSecret.getProperties();\n        properties.setEnabled(false);\n        \n        // Add rotation metadata\n        Map<String, String> tags = properties.getTags();\n        if (tags == null) {\n            tags = new HashMap<>();\n        }\n        tags.put(\"rotated-at\", OffsetDateTime.now().toString());\n        tags.put(\"status\", \"disabled\");\n        properties.setTags(tags);\n        \n        secretClient.updateSecretProperties(properties);\n    }\n    \n    /**\n     * Creates a new version of the secret with the updated value.\n     *\n     * @param secretName The secret name\n     * @param newValue The new secret value\n     * @param metadata Optional metadata\n     * @return The newly created KeyVaultSecret\n     */\n    private KeyVaultSecret createNewVersion(String secretName, String newValue, SecretMetadata metadata) {\n        KeyVaultSecret newSecret = new KeyVaultSecret(secretName, newValue);\n        \n        if (metadata != null) {\n            SecretProperties properties = new SecretProperties();\n            \n            if (metadata.getContentType() != null) {\n                properties.setContentType(metadata.getContentType());\n            }\n            \n            if (metadata.getExpiresOn() != null) {\n                properties.setExpiresOn(metadata.getExpiresOn());\n            }\n            \n            if (metadata.getNotBefore() != null) {\n                properties.setNotBefore(metadata.getNotBefore());\n            }\n            \n            Map<String, String> tags = metadata.getTags();\n            if (tags == null) {\n                tags = new HashMap<>();\n            }\n            tags.put(\"created-at\", OffsetDateTime.now().toString());\n            tags.put(\"status\", \"active\");\n            properties.setTags(tags);\n            \n            newSecret.setProperties(properties);\n        }\n        \n        return secretClient.setSecret(newSecret);\n    }\n    \n    /**\n     * Verifies that the new version is active and retrievable.\n     *\n     * @param secretName The secret name\n     * @param expectedVersion The expected version ID\n     * @param expectedValue The expected secret value\n     * @throws SecretRotationException if verification fails\n     */\n    private void verifyNewVersion(String secretName, String expectedVersion, String expectedValue) {\n        KeyVaultSecret verifiedSecret = secretClient.getSecret(secretName);\n        \n        if (!verifiedSecret.getProperties().getVersion().equals(expectedVersion)) {\n            throw new SecretRotationException(\n                String.format(\"Version mismatch: expected %s, got %s\", \n                    expectedVersion, verifiedSecret.getProperties().getVersion())\n            );\n        }\n        \n        if (!verifiedSecret.getValue().equals(expectedValue)) {\n            throw new SecretRotationException(\"Secret value verification failed\");\n        }\n        \n        if (!verifiedSecret.getProperties().isEnabled()) {\n            throw new SecretRotationException(\"New secret version is not enabled\");\n        }\n    }\n    \n    /**\n     * Handles HTTP response exceptions with detailed error messages.\n     *\n     * @param secretName The secret name\n     * @param e The HttpResponseException\n     * @return Detailed error message\n     */\n    private String handleHttpResponseException(String secretName, HttpResponseException e) {\n        int statusCode = e.getResponse().getStatusCode();\n        \n        switch (statusCode) {\n            case 401:\n                return String.format(\"Authentication failed for vault %s. Check credentials.\", vaultUrl);\n            case 403:\n                return String.format(\"Access denied to secret '%s'. Check Key Vault permissions.\", secretName);\n            case 404:\n                return String.format(\"Secret '%s' not found in vault %s\", secretName, vaultUrl);\n            case 409:\n                return String.format(\"Conflict updating secret '%s'. It may be in a deleted state.\", secretName);\n            case 429:\n                return String.format(\"Rate limit exceeded for vault %s. Retry after delay.\", vaultUrl);\n            case 500:\n            case 502:\n            case 503:\n            case 504:\n                return String.format(\"Key Vault service error (HTTP %d). Retry operation.\", statusCode);\n            default:\n                return String.format(\"HTTP error %d rotating secret '%s': %s\", \n                    statusCode, secretName, e.getMessage());\n        }\n    }\n    \n    /**\n     * Checks if a secret exists in the vault.\n     *\n     * @param secretName The secret name\n     * @return true if secret exists, false otherwise\n     */\n    public boolean secretExists(String secretName) {\n        try {\n            secretClient.getSecret(secretName);\n            return true;\n        } catch (ResourceNotFoundException e) {\n            return false;\n        } catch (Exception e) {\n            LOGGER.log(Level.WARNING, \"Error checking secret existence: \" + secretName, e);\n            return false;\n        }\n    }\n    \n    /**\n     * Gets the current version ID of a secret.\n     *\n     * @param secretName The secret name\n     * @return The version ID, or null if secret doesn't exist\n     */\n    public String getCurrentVersion(String secretName) {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            return secret.getProperties().getVersion();\n        } catch (ResourceNotFoundException e) {\n            LOGGER.warning(String.format(\"Secret '%s' not found\", secretName));\n            return null;\n        }\n    }\n    \n    /**\n     * Result object containing rotation details.\n     */\n    public static class RotationResult {\n        private final String secretName;\n        private String oldVersion;\n        private String newVersion;\n        private OffsetDateTime rotationTime;\n        private boolean success;\n        private boolean verified;\n        private String errorMessage;\n        \n        public RotationResult(String secretName) {\n            this.secretName = secretName;\n        }\n        \n        // Getters and setters\n        public String getSecretName() { return secretName; }\n        public String getOldVersion() { return oldVersion; }\n        public void setOldVersion(String oldVersion) { this.oldVersion = oldVersion; }\n        public String getNewVersion() { return newVersion; }\n        public void setNewVersion(String newVersion) { this.newVersion = newVersion; }\n        public OffsetDateTime getRotationTime() { return rotationTime; }\n        public void setRotationTime(OffsetDateTime rotationTime) { this.rotationTime = rotationTime; }\n        public boolean isSuccess() { return success; }\n        public void setSuccess(boolean success) { this.success = success; }\n        public boolean isVerified() { return verified; }\n        public void setVerified(boolean verified) { this.verified = verified; }\n        public String getErrorMessage() { return errorMessage; }\n        public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }\n        \n        @Override\n        public String toString() {\n            return String.format(\"RotationResult{secretName='%s', oldVersion='%s', newVersion='%s', \" +\n                \"rotationTime=%s, success=%s, verified=%s, errorMessage='%s'}\",\n                secretName, oldVersion, newVersion, rotationTime, success, verified, errorMessage);\n        }\n    }\n    \n    /**\n     * Metadata for secret creation.\n     */\n    public static class SecretMetadata {\n        private String contentType;\n        private OffsetDateTime expiresOn;\n        private OffsetDateTime notBefore;\n        private Map<String, String> tags;\n        \n        public SecretMetadata() {\n            this.tags = new HashMap<>();\n        }\n        \n        // Getters and setters\n        public String getContentType() { return contentType; }\n        public SecretMetadata setContentType(String contentType) {\n            this.contentType = contentType;\n            return this;\n        }\n        public OffsetDateTime getExpiresOn() { return expiresOn; }\n        public SecretMetadata setExpiresOn(OffsetDateTime expiresOn) {\n            this.expiresOn = expiresOn;\n            return this;\n        }\n        public OffsetDateTime getNotBefore() { return notBefore; }\n        public SecretMetadata setNotBefore(OffsetDateTime notBefore) {\n            this.notBefore = notBefore;\n            return this;\n        }\n        public Map<String, String> getTags() { return tags; }\n        public SecretMetadata setTags(Map<String, String> tags) {\n            this.tags = tags;\n            return this;\n        }\n        public SecretMetadata addTag(String key, String value) {\n            this.tags.put(key, value);\n            return this;\n        }\n    }\n    \n    /**\n     * Custom exception for secret rotation failures.\n     */\n    public static class SecretRotationException extends RuntimeException {\n        public SecretRotationException(String message) {\n            super(message);\n        }\n        \n        public SecretRotationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```\n\n## Usage Examples\n\n### Basic Secret Rotation\n\n```java\npackage com.example.keyvault;\n\nimport com.example.keyvault.service.SecretRotationService;\nimport com.example.keyvault.service.SecretRotationService.RotationResult;\n\npublic class BasicRotationExample {\n    public static void main(String[] args) {\n        String vaultUrl = System.getenv(\"",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8152,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive secret rotation service class using the Azure Key Vault Secrets SDK.\n\n```java\npackage com.example.app.service;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport java.time.OffsetDateTime;\nimport java.util.Map;\n\n@Service\npublic class SecretRotationService {\n    private static final Logger log = LoggerFactory.getLogger(SecretRotationService.class);\n    \n    private final SecretClient secretClient;\n\n    public SecretRotationService(@Value(\"${azure.keyvault.url}\") String vaultUrl) {\n        this.secretClient = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        log.info(\"SecretRotationService initialized with vault: {}\", vaultUrl);\n    }\n\n    /**\n     * Rotates a secret by disabling the old version and creating a new version.\n     *\n     * @param secretName the name of the secret to rotate\n     * @param newValue the new secret value\n     * @return the newly created secret\n     * @throws ResourceNotFoundException if the secret doesn't exist\n     * @throws HttpResponseException if there's an HTTP error (403, 429, etc.)\n     */\n    public KeyVaultSecret rotateSecret(String secretName, String newValue) {\n        log.info(\"Starting secret rotation for: {}\", secretName);\n        \n        try {\n            // Step 1: Get current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String oldVersion = currentSecret.getProperties().getVersion();\n            log.info(\"Retrieved current secret version: {}\", oldVersion);\n            \n            // Step 2: Disable old version\n            disableSecretVersion(currentSecret);\n            log.info(\"Disabled old secret version: {}\", oldVersion);\n            \n            // Step 3: Create new version with new value\n            KeyVaultSecret newSecret = createNewSecretVersion(secretName, newValue);\n            String newVersion = newSecret.getProperties().getVersion();\n            log.info(\"Created new secret version: {}\", newVersion);\n            \n            // Step 4: Verify new version is active\n            verifySecretActive(newSecret);\n            log.info(\"Verified new secret version is active: {}\", newVersion);\n            \n            log.info(\"Successfully rotated secret '{}' from version {} to {}\", \n                secretName, oldVersion, newVersion);\n            \n            return newSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            log.error(\"Secret not found: {}\", secretName, e);\n            throw new SecretRotationException(\n                \"Cannot rotate secret - secret not found: \" + secretName, e);\n                \n        } catch (HttpResponseException e) {\n            int statusCode = e.getResponse().getStatusCode();\n            log.error(\"HTTP error during secret rotation: {} - Status: {}\", \n                secretName, statusCode, e);\n            \n            if (statusCode == 403) {\n                throw new SecretRotationException(\n                    \"Access denied - check Key Vault permissions for secret: \" + secretName, e);\n            } else if (statusCode == 429) {\n                throw new SecretRotationException(\n                    \"Rate limited - retry secret rotation later: \" + secretName, e);\n            } else {\n                throw new SecretRotationException(\n                    \"HTTP error during secret rotation: \" + statusCode, e);\n            }\n            \n        } catch (Exception e) {\n            log.error(\"Unexpected error during secret rotation: {}\", secretName, e);\n            throw new SecretRotationException(\n                \"Failed to rotate secret: \" + secretName, e);\n        }\n    }\n\n    /**\n     * Rotates a secret with additional metadata (tags, expiration).\n     *\n     * @param secretName the name of the secret to rotate\n     * @param newValue the new secret value\n     * @param expirationDays days until the new secret expires\n     * @param tags metadata tags for the new secret\n     * @return the newly created secret\n     */\n    public KeyVaultSecret rotateSecretWithMetadata(\n            String secretName, \n            String newValue,\n            int expirationDays,\n            Map<String, String> tags) {\n        \n        log.info(\"Starting secret rotation with metadata for: {}\", secretName);\n        \n        try {\n            // Get and disable current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            disableSecretVersion(currentSecret);\n            \n            // Create new version with metadata\n            KeyVaultSecret newSecret = new KeyVaultSecret(secretName, newValue)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusDays(expirationDays))\n                    .setContentType(\"text/plain\")\n                    .setTags(tags));\n            \n            KeyVaultSecret createdSecret = secretClient.setSecret(newSecret);\n            verifySecretActive(createdSecret);\n            \n            log.info(\"Successfully rotated secret '{}' with expiration in {} days\", \n                secretName, expirationDays);\n            \n            return createdSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            log.error(\"Secret not found: {}\", secretName, e);\n            throw new SecretRotationException(\n                \"Cannot rotate secret - secret not found: \" + secretName, e);\n        } catch (HttpResponseException e) {\n            handleHttpException(secretName, e);\n            throw new SecretRotationException(\"HTTP error during rotation\", e);\n        } catch (Exception e) {\n            log.error(\"Unexpected error during secret rotation: {}\", secretName, e);\n            throw new SecretRotationException(\n                \"Failed to rotate secret: \" + secretName, e);\n        }\n    }\n\n    /**\n     * Gets the current (latest) version of a secret.\n     */\n    private KeyVaultSecret getCurrentSecret(String secretName) {\n        KeyVaultSecret secret = secretClient.getSecret(secretName);\n        \n        if (secret == null || secret.getValue() == null) {\n            throw new SecretRotationException(\n                \"Secret exists but has no value: \" + secretName);\n        }\n        \n        return secret;\n    }\n\n    /**\n     * Disables a specific secret version.\n     */\n    private void disableSecretVersion(KeyVaultSecret secret) {\n        SecretProperties properties = secret.getProperties();\n        properties.setEnabled(false);\n        \n        SecretProperties updated = secretClient.updateSecretProperties(properties);\n        \n        if (updated.isEnabled()) {\n            throw new SecretRotationException(\n                \"Failed to disable old secret version: \" + secret.getName());\n        }\n    }\n\n    /**\n     * Creates a new version of a secret with the given value.\n     */\n    private KeyVaultSecret createNewSecretVersion(String secretName, String newValue) {\n        if (newValue == null || newValue.trim().isEmpty()) {\n            throw new IllegalArgumentException(\n                \"New secret value cannot be null or empty\");\n        }\n        \n        KeyVaultSecret newSecret = secretClient.setSecret(secretName, newValue);\n        \n        if (newSecret == null || newSecret.getValue() == null) {\n            throw new SecretRotationException(\n                \"Failed to create new secret version: \" + secretName);\n        }\n        \n        return newSecret;\n    }\n\n    /**\n     * Verifies that a secret is active and can be retrieved.\n     */\n    private void verifySecretActive(KeyVaultSecret secret) {\n        String secretName = secret.getName();\n        String version = secret.getProperties().getVersion();\n        \n        // Retrieve the specific version to verify it's accessible\n        KeyVaultSecret verified = secretClient.getSecret(secretName, version);\n        \n        if (!verified.getProperties().isEnabled()) {\n            throw new SecretRotationException(\n                \"New secret version is not enabled: \" + secretName);\n        }\n        \n        if (!verified.getValue().equals(secret.getValue())) {\n            throw new SecretRotationException(\n                \"New secret value verification failed: \" + secretName);\n        }\n    }\n\n    /**\n     * Handles HTTP exceptions with detailed logging.\n     */\n    private void handleHttpException(String secretName, HttpResponseException e) {\n        int statusCode = e.getResponse().getStatusCode();\n        \n        switch (statusCode) {\n            case 403:\n                log.error(\"Access denied for secret: {} - Check Key Vault access policies\", \n                    secretName);\n                break;\n            case 429:\n                log.error(\"Rate limited for secret: {} - Retry after delay\", secretName);\n                break;\n            case 409:\n                log.error(\"Conflict for secret: {} - Secret may be in deleted state\", \n                    secretName);\n                break;\n            default:\n                log.error(\"HTTP {} error for secret: {}\", statusCode, secretName);\n        }\n    }\n\n    /**\n     * Custom exception for secret rotation failures.\n     */\n    public static class SecretRotationException extends RuntimeException {\n        public SecretRotationException(String message) {\n            super(message);\n        }\n        \n        public SecretRotationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```\n\nNow let me create a configuration class for the application properties:\n\n```java\npackage com.example.app.config;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ConfigurationProperties(prefix = \"azure.keyvault\")\npublic class KeyVaultConfig {\n    private String url;\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n}\n```\n\nAnd here's an example usage controller:\n\n```java\npackage com.example.app.controller;\n\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.example.app.service.SecretRotationService;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/api/secrets\")\npublic class SecretRotationController {\n    \n    private final SecretRotationService secretRotationService;\n\n    public SecretRotationController(SecretRotationService secretRotationService) {\n        this.secretRotationService = secretRotationService;\n    }\n\n    @PostMapping(\"/{secretName}/rotate\")\n    public ResponseEntity<SecretRotationResponse> rotateSecret(\n            @PathVariable String secretName,\n            @RequestBody SecretRotationRequest request) {\n        \n        try {\n            KeyVaultSecret rotatedSecret = secretRotationService.rotateSecret(\n                secretName, \n                request.getNewValue()\n            );\n            \n            return ResponseEntity.ok(new SecretRotationResponse(\n                rotatedSecret.getName(),\n                rotatedSecret.getProperties().getVersion(),\n                \"Secret rotated successfully\"\n            ));\n            \n        } catch (SecretRotationService.SecretRotationException e) {\n            return ResponseEntity.badRequest()\n                .body(new SecretRotationResponse(secretName, null, e.getMessage()));\n        }\n    }\n\n    @PostMapping(\"/{secretName}/rotate-with-metadata\")\n    public ResponseEntity<SecretRotationResponse> rotateSecretWithMetadata(\n            @PathVariable String secretName,\n            @RequestBody SecretRotationWithMetadataRequest request) {\n        \n        try {\n            KeyVaultSecret rotatedSecret = secretRotationService.rotateSecretWithMetadata(\n                secretName,\n                request.getNewValue(),\n                request.getExpirationDays(),\n                request.getTags()\n            );\n            \n            return ResponseEntity.ok(new SecretRotationResponse(\n                rotatedSecret.getName(),\n                rotatedSecret.getProperties().getVersion(),\n                \"Secret rotated successfully with metadata\"\n            ));\n            \n        } catch (SecretRotationService.SecretRotationException e) {\n            return ResponseEntity.badRequest()\n                .body(new SecretRotationResponse(secretName, null, e.getMessage()));\n        }\n    }\n\n    // DTOs\n    public static class SecretRotationRequest {\n        private String newValue;\n\n        public String getNewValue() {\n            return newValue;\n        }\n\n        public void setNewValue(String newValue) {\n            this.newValue = newValue;\n        }\n    }\n\n    public static class SecretRotationWithMetadataRequest {\n        private String newValue;\n        private int expirationDays;\n        private Map<String, String> tags;\n\n        public String getNewValue() {\n            return newValue;\n        }\n\n        public void setNewValue(String newValue) {\n            this.newValue = newValue;\n        }\n\n        public int getExpirationDays() {\n            return expirationDays;\n        }\n\n        public void setExpirationDays(int expirationDays) {\n            this.expirationDays = expirationDays;\n        }\n\n        public Map<String, String> getTags() {\n            return tags;\n        }\n\n        public void setTags(Map<String, String> tags) {\n            this.tags = tags;\n        }\n    }\n\n    public static class SecretRotationResponse {\n        private String secretName;\n        private String version;\n        private String message;\n\n        public SecretRotationResponse(String secretName, String version, String message) {\n            this.secretName = secretName;\n            this.version = version;\n            this.message = message;\n        }\n\n        public String getSecretName() {\n            return secretName;\n        }\n\n        public String getVersion() {\n            return version;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n    }\n}\n```\n\nFinally, add this to your `application.properties`:\n\n```properties\n# Azure Key Vault Configuration\nazure.keyvault.url=${AZURE_KEYVAULT_URL:https://your-vault-name.vault.azure.net}\n```\n\n## Key Features:\n\n1. **Complete Rotation Pattern**: Gets current secret \u2192 Disables old version \u2192 Creates new version \u2192 Verifies activation\n2. **Proper Authentication**: Uses `DefaultAzureCredential` for flexible authentication\n3. **Comprehensive Error Handling**: \n   - `ResourceNotFoundException` for missing secrets\n   - `HttpResponseException` with specific handling for 403, 429, 409 status codes\n4. **Verification**: Confirms new secret version is enabled and retrievable\n5. **Metadata Support**: Optional method to rotate with expiration and tags\n6. **Detailed Logging**: Logs each step of the rotation process\n7. **Custom Exception**: `SecretRotationException` for rotation-specific errors\n8. **Spring Integration**: Ready to use as a Spring service with dependency injection\n\nThe service follows Azure SDK best practices and includes proper validation at each step.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8677,
            "output_tokens": 3824,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Azure Key Vault Secret Rotation Service\n\nHere's a comprehensive Java service class that implements a secret rotation pattern using Azure Key Vault Secrets SDK:\n\n```java\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.OffsetDateTime;\nimport java.util.Optional;\n\n/**\n * Service class for managing Azure Key Vault secret rotation.\n * Implements a pattern to safely rotate secrets with proper version management.\n */\npublic class SecretRotationService {\n    \n    private static final Logger logger = LoggerFactory.getLogger(SecretRotationService.class);\n    \n    private final SecretClient secretClient;\n    private final String keyVaultUrl;\n    \n    /**\n     * Constructor that initializes the SecretClient with DefaultAzureCredential.\n     *\n     * @param keyVaultUrl The URL of the Azure Key Vault (e.g., https://myvault.vault.azure.net/)\n     */\n    public SecretRotationService(String keyVaultUrl) {\n        this.keyVaultUrl = keyVaultUrl;\n        \n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .build();\n        \n        this.secretClient = new SecretClientBuilder()\n                .vaultUrl(keyVaultUrl)\n                .credential(credential)\n                .buildClient();\n        \n        logger.info(\"SecretRotationService initialized for Key Vault: {}\", keyVaultUrl);\n    }\n    \n    /**\n     * Constructor for dependency injection (useful for testing).\n     *\n     * @param secretClient Pre-configured SecretClient instance\n     * @param keyVaultUrl The URL of the Azure Key Vault\n     */\n    public SecretRotationService(SecretClient secretClient, String keyVaultUrl) {\n        this.secretClient = secretClient;\n        this.keyVaultUrl = keyVaultUrl;\n        logger.info(\"SecretRotationService initialized with provided SecretClient\");\n    }\n    \n    /**\n     * Rotates a secret by creating a new version and disabling the old version.\n     *\n     * @param secretName The name of the secret to rotate\n     * @param newSecretValue The new value for the secret\n     * @return RotationResult containing information about the rotation operation\n     * @throws SecretRotationException if rotation fails\n     */\n    public RotationResult rotateSecret(String secretName, String newSecretValue) \n            throws SecretRotationException {\n        \n        logger.info(\"Starting secret rotation for: {}\", secretName);\n        \n        try {\n            // Step 1: Get the current secret\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String oldVersion = currentSecret.getProperties().getVersion();\n            logger.info(\"Current secret version: {}\", oldVersion);\n            \n            // Step 2: Create a new version with the updated value\n            KeyVaultSecret newSecret = createNewSecretVersion(secretName, newSecretValue);\n            String newVersion = newSecret.getProperties().getVersion();\n            logger.info(\"Created new secret version: {}\", newVersion);\n            \n            // Step 3: Verify the new version is active\n            boolean isActive = verifySecretVersion(secretName, newVersion);\n            if (!isActive) {\n                throw new SecretRotationException(\n                    \"New secret version is not active after creation\"\n                );\n            }\n            logger.info(\"Verified new secret version is active\");\n            \n            // Step 4: Disable the old version\n            disableSecretVersion(secretName, oldVersion);\n            logger.info(\"Disabled old secret version: {}\", oldVersion);\n            \n            RotationResult result = new RotationResult(\n                secretName,\n                oldVersion,\n                newVersion,\n                true,\n                \"Secret rotated successfully\"\n            );\n            \n            logger.info(\"Secret rotation completed successfully for: {}\", secretName);\n            return result;\n            \n        } catch (ResourceNotFoundException e) {\n            String errorMsg = String.format(\"Secret '%s' not found in Key Vault\", secretName);\n            logger.error(errorMsg, e);\n            throw new SecretRotationException(errorMsg, e);\n            \n        } catch (HttpResponseException e) {\n            String errorMsg = String.format(\n                \"HTTP error during secret rotation: Status=%d, Message=%s\",\n                e.getResponse().getStatusCode(),\n                e.getMessage()\n            );\n            logger.error(errorMsg, e);\n            throw new SecretRotationException(errorMsg, e);\n            \n        } catch (Exception e) {\n            String errorMsg = String.format(\n                \"Unexpected error during secret rotation for '%s'\",\n                secretName\n            );\n            logger.error(errorMsg, e);\n            throw new SecretRotationException(errorMsg, e);\n        }\n    }\n    \n    /**\n     * Gets the current (latest) version of a secret.\n     *\n     * @param secretName The name of the secret\n     * @return The current KeyVaultSecret\n     * @throws ResourceNotFoundException if secret doesn't exist\n     */\n    private KeyVaultSecret getCurrentSecret(String secretName) \n            throws ResourceNotFoundException {\n        \n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            logger.debug(\"Retrieved current secret: {} (version: {})\", \n                secretName, secret.getProperties().getVersion());\n            return secret;\n            \n        } catch (ResourceNotFoundException e) {\n            logger.error(\"Secret '{}' not found\", secretName);\n            throw e;\n        }\n    }\n    \n    /**\n     * Creates a new version of a secret with the specified value.\n     *\n     * @param secretName The name of the secret\n     * @param secretValue The new secret value\n     * @return The newly created KeyVaultSecret\n     */\n    private KeyVaultSecret createNewSecretVersion(String secretName, String secretValue) {\n        KeyVaultSecret newSecret = secretClient.setSecret(secretName, secretValue);\n        logger.debug(\"Created new secret version: {}\", \n            newSecret.getProperties().getVersion());\n        return newSecret;\n    }\n    \n    /**\n     * Verifies that a specific version of a secret is active.\n     *\n     * @param secretName The name of the secret\n     * @param version The version to verify\n     * @return true if the version is active, false otherwise\n     */\n    private boolean verifySecretVersion(String secretName, String version) {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName, version);\n            boolean isEnabled = secret.getProperties().isEnabled();\n            \n            logger.debug(\"Secret version {} enabled status: {}\", version, isEnabled);\n            return isEnabled;\n            \n        } catch (ResourceNotFoundException e) {\n            logger.error(\"Secret version not found during verification: {}/{}\", \n                secretName, version);\n            return false;\n        }\n    }\n    \n    /**\n     * Disables a specific version of a secret.\n     *\n     * @param secretName The name of the secret\n     * @param version The version to disable\n     */\n    private void disableSecretVersion(String secretName, String version) {\n        try {\n            SecretProperties properties = secretClient.getSecret(secretName, version)\n                    .getProperties();\n            properties.setEnabled(false);\n            \n            secretClient.updateSecretProperties(properties);\n            logger.debug(\"Disabled secret version: {}\", version);\n            \n        } catch (ResourceNotFoundException e) {\n            logger.warn(\"Secret version not found when attempting to disable: {}/{}\", \n                secretName, version);\n            // Don't throw - old version might already be deleted\n        }\n    }\n    \n    /**\n     * Retrieves a specific version of a secret.\n     *\n     * @param secretName The name of the secret\n     * @param version The version to retrieve\n     * @return Optional containing the secret if found\n     */\n    public Optional<KeyVaultSecret> getSecretVersion(String secretName, String version) {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName, version);\n            return Optional.of(secret);\n            \n        } catch (ResourceNotFoundException e) {\n            logger.warn(\"Secret version not found: {}/{}\", secretName, version);\n            return Optional.empty();\n            \n        } catch (HttpResponseException e) {\n            logger.error(\"HTTP error retrieving secret version: {}/{}\", \n                secretName, version, e);\n            return Optional.empty();\n        }\n    }\n    \n    /**\n     * Lists all versions of a secret.\n     *\n     * @param secretName The name of the secret\n     */\n    public void listSecretVersions(String secretName) {\n        try {\n            logger.info(\"Listing all versions for secret: {}\", secretName);\n            \n            secretClient.listPropertiesOfSecretVersions(secretName)\n                    .forEach(properties -> {\n                        logger.info(\"Version: {}, Enabled: {}, Created: {}\", \n                            properties.getVersion(),\n                            properties.isEnabled(),\n                            properties.getCreatedOn());\n                    });\n                    \n        } catch (ResourceNotFoundException e) {\n            logger.error(\"Secret not found: {}\", secretName);\n        } catch (HttpResponseException e) {\n            logger.error(\"HTTP error listing secret versions for: {}\", secretName, e);\n        }\n    }\n    \n    /**\n     * Performs a rollback by re-enabling a previous version and disabling the current one.\n     *\n     * @param secretName The name of the secret\n     * @param versionToRestore The version to restore\n     * @return RotationResult containing information about the rollback operation\n     * @throws SecretRotationException if rollback fails\n     */\n    public RotationResult rollbackSecret(String secretName, String versionToRestore) \n            throws SecretRotationException {\n        \n        logger.info(\"Starting secret rollback for: {} to version: {}\", \n            secretName, versionToRestore);\n        \n        try {\n            // Get current version\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String currentVersion = currentSecret.getProperties().getVersion();\n            \n            // Enable the old version\n            SecretProperties oldProperties = secretClient\n                    .getSecret(secretName, versionToRestore)\n                    .getProperties();\n            oldProperties.setEnabled(true);\n            secretClient.updateSecretProperties(oldProperties);\n            \n            logger.info(\"Re-enabled version: {}\", versionToRestore);\n            \n            // Disable current version\n            disableSecretVersion(secretName, currentVersion);\n            \n            RotationResult result = new RotationResult(\n                secretName,\n                currentVersion,\n                versionToRestore,\n                true,\n                \"Secret rolled back successfully\"\n            );\n            \n            logger.info(\"Secret rollback completed successfully\");\n            return result;\n            \n        } catch (ResourceNotFoundException e) {\n            String errorMsg = String.format(\n                \"Secret or version not found during rollback: %s/%s\",\n                secretName, versionToRestore\n            );\n            logger.error(errorMsg, e);\n            throw new SecretRotationException(errorMsg, e);\n            \n        } catch (HttpResponseException e) {\n            String errorMsg = String.format(\n                \"HTTP error during rollback: Status=%d\",\n                e.getResponse().getStatusCode()\n            );\n            logger.error(errorMsg, e);\n            throw new SecretRotationException(errorMsg, e);\n        }\n    }\n    \n    /**\n     * Result object containing information about a rotation operation.\n     */\n    public static class RotationResult {\n        private final String secretName;\n        private final String oldVersion;\n        private final String newVersion;\n        private final boolean success;\n        private final String message;\n        private final OffsetDateTime timestamp;\n        \n        public RotationResult(String secretName, String oldVersion, String newVersion,\n                            boolean success, String message) {\n            this.secretName = secretName;\n            this.oldVersion = oldVersion;\n            this.newVersion = newVersion;\n            this.success = success;\n            this.message = message;\n            this.timestamp = OffsetDateTime.now();\n        }\n        \n        // Getters\n        public String getSecretName() { return secretName; }\n        public String getOldVersion() { return oldVersion; }\n        public String getNewVersion() { return newVersion; }\n        public boolean isSuccess() { return success; }\n        public String getMessage() { return message; }\n        public OffsetDateTime getTimestamp() { return timestamp; }\n        \n        @Override\n        public String toString() {\n            return String.format(\n                \"RotationResult{secretName='%s', oldVersion='%s', newVersion='%s', \" +\n                \"success=%s, message='%s', timestamp=%s}\",\n                secretName, oldVersion, newVersion, success, message, timestamp\n            );\n        }\n    }\n    \n    /**\n     * Custom exception for secret rotation operations.\n     */\n    public static class SecretRotationException extends Exception {\n        public SecretRotationException(String message) {\n            super(message);\n        }\n        \n        public SecretRotationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```\n\n## Usage Example\n\n```java\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\n\npublic class SecretRotationExample {\n    \n    public static void main(String[] args) {\n        String keyVaultUrl = \"https://your-keyvault.vault.azure.net/\";\n        SecretRotationService rotationService = new SecretRotationService(keyVaultUrl);\n        \n        try {\n            // Example 1: Rotate a database password\n            String secretName = \"database-password\";\n            String newPassword = generateSecurePassword();\n            \n            SecretRotationService.RotationResult result = \n                rotationService.rotateSecret(secretName, newPassword);\n            \n            System.out.println(\"Rotation successful!\");\n            System.out.println(\"Old version: \" + result.getOldVersion());\n            System.out.println(\"New version: \" + result.getNewVersion());\n            System.out.println(\"Timestamp: \" + result.getTimestamp());\n            \n            // Example 2: List all versions\n            rotationService.listSecretVersions(secretName);\n            \n            // Example 3: Rollback if needed\n            if (needsRollback()) {\n                SecretRotationService.RotationResult rollbackResult = \n                    rotationService.rollbackSecret(secretName, result.getOldVersion());\n                System.out.println(\"Rollback completed: \" + rollbackResult);\n            }\n            \n            // Example 4: Get a specific version\n            rotationService.getSecretVersion(secretName, result.getNewVersion())\n                    .ifPresent(secret -> {\n                        System.out.println(\"Retrieved secret version: \" + \n                            secret.getProperties().getVersion());\n                    });\n            \n        } catch (SecretRotationService.SecretRotationException e) {\n            System.err.println(\"Secret rotation failed: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n    \n    private static String generateSecurePassword() {\n        // Implement secure password generation\n        return \"NewSecurePassword123!\";\n    }\n    \n    private static boolean needsRollback() {\n        // Implement rollback logic\n        return false;\n    }\n}\n```\n\n## Unit Test Example\n\n```java\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.core.http.rest.PagedIterable;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\nimport java.time.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 83,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secret Rotation Service\n\nHere's a comprehensive Java service class implementing a secret rotation pattern with proper error handling:\n\n```java\npackage com.example.keyvault;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\n\nimport java.time.OffsetDateTime;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\n/**\n * Service class for managing Azure Key Vault secret rotation.\n * Implements a safe rotation pattern that disables old versions before creating new ones.\n */\npublic class SecretRotationService {\n    \n    private static final Logger LOGGER = Logger.getLogger(SecretRotationService.class.getName());\n    \n    private final SecretClient secretClient;\n    private final String vaultUrl;\n    \n    /**\n     * Creates a new SecretRotationService with the specified vault URL.\n     * Uses DefaultAzureCredential for authentication.\n     *\n     * @param vaultUrl The Azure Key Vault URL (e.g., https://my-vault.vault.azure.net)\n     */\n    public SecretRotationService(String vaultUrl) {\n        if (vaultUrl == null || vaultUrl.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Vault URL cannot be null or empty\");\n        }\n        \n        this.vaultUrl = vaultUrl;\n        this.secretClient = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        LOGGER.info(\"SecretRotationService initialized for vault: \" + vaultUrl);\n    }\n    \n    /**\n     * Constructor for dependency injection (testing).\n     *\n     * @param secretClient Pre-configured SecretClient instance\n     * @param vaultUrl The vault URL\n     */\n    public SecretRotationService(SecretClient secretClient, String vaultUrl) {\n        this.secretClient = secretClient;\n        this.vaultUrl = vaultUrl;\n    }\n    \n    /**\n     * Rotates a secret by disabling the old version and creating a new version.\n     *\n     * @param secretName The name of the secret to rotate\n     * @param newValue The new secret value\n     * @return RotationResult containing details of the rotation operation\n     * @throws SecretRotationException if rotation fails\n     */\n    public RotationResult rotateSecret(String secretName, String newValue) {\n        return rotateSecret(secretName, newValue, null);\n    }\n    \n    /**\n     * Rotates a secret with additional metadata.\n     *\n     * @param secretName The name of the secret to rotate\n     * @param newValue The new secret value\n     * @param metadata Additional metadata (tags, content type, expiration)\n     * @return RotationResult containing details of the rotation operation\n     * @throws SecretRotationException if rotation fails\n     */\n    public RotationResult rotateSecret(String secretName, String newValue, SecretMetadata metadata) {\n        validateInputs(secretName, newValue);\n        \n        LOGGER.info(String.format(\"Starting rotation for secret: %s\", secretName));\n        \n        try {\n            // Step 1: Get current secret version\n            KeyVaultSecret currentSecret = getCurrentSecret(secretName);\n            String oldVersion = currentSecret.getProperties().getVersion();\n            LOGGER.info(String.format(\"Current version: %s\", oldVersion));\n            \n            // Step 2: Disable old version\n            disableSecretVersion(currentSecret);\n            LOGGER.info(String.format(\"Disabled old version: %s\", oldVersion));\n            \n            // Step 3: Create new version with updated value\n            KeyVaultSecret newSecret = createNewSecretVersion(secretName, newValue, metadata);\n            String newVersion = newSecret.getProperties().getVersion();\n            LOGGER.info(String.format(\"Created new version: %s\", newVersion));\n            \n            // Step 4: Verify new version is active\n            verifyNewVersion(secretName, newVersion, newValue);\n            LOGGER.info(\"New version verified successfully\");\n            \n            // Step 5: Build and return result\n            RotationResult result = RotationResult.builder()\n                .secretName(secretName)\n                .oldVersion(oldVersion)\n                .newVersion(newVersion)\n                .rotationTime(OffsetDateTime.now())\n                .success(true)\n                .build();\n            \n            LOGGER.info(String.format(\"Secret rotation completed successfully for: %s\", secretName));\n            return result;\n            \n        } catch (ResourceNotFoundException e) {\n            String message = String.format(\"Secret not found: %s\", secretName);\n            LOGGER.severe(message);\n            throw new SecretRotationException(message, e);\n            \n        } catch (HttpResponseException e) {\n            String message = handleHttpException(secretName, e);\n            LOGGER.severe(message);\n            throw new SecretRotationException(message, e);\n            \n        } catch (Exception e) {\n            String message = String.format(\"Unexpected error during rotation of secret: %s\", secretName);\n            LOGGER.severe(message + \" - \" + e.getMessage());\n            throw new SecretRotationException(message, e);\n        }\n    }\n    \n    /**\n     * Gets the current (latest) version of a secret.\n     *\n     * @param secretName The secret name\n     * @return The current KeyVaultSecret\n     * @throws ResourceNotFoundException if secret doesn't exist\n     */\n    private KeyVaultSecret getCurrentSecret(String secretName) {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            \n            if (secret == null) {\n                throw new ResourceNotFoundException(\n                    String.format(\"Secret '%s' returned null\", secretName),\n                    null\n                );\n            }\n            \n            return secret;\n            \n        } catch (ResourceNotFoundException e) {\n            LOGGER.warning(String.format(\"Secret not found: %s\", secretName));\n            throw e;\n        }\n    }\n    \n    /**\n     * Disables a specific secret version.\n     *\n     * @param secret The secret to disable\n     */\n    private void disableSecretVersion(KeyVaultSecret secret) {\n        SecretProperties properties = secret.getProperties();\n        properties.setEnabled(false);\n        \n        // Add rotation metadata\n        Map<String, String> tags = properties.getTags();\n        if (tags == null) {\n            tags = new HashMap<>();\n        }\n        tags.put(\"rotation-status\", \"disabled\");\n        tags.put(\"disabled-at\", OffsetDateTime.now().toString());\n        properties.setTags(tags);\n        \n        secretClient.updateSecretProperties(properties);\n    }\n    \n    /**\n     * Creates a new version of the secret with the updated value.\n     *\n     * @param secretName The secret name\n     * @param newValue The new secret value\n     * @param metadata Optional metadata\n     * @return The newly created KeyVaultSecret\n     */\n    private KeyVaultSecret createNewSecretVersion(String secretName, String newValue, SecretMetadata metadata) {\n        KeyVaultSecret newSecret = new KeyVaultSecret(secretName, newValue);\n        \n        if (metadata != null) {\n            SecretProperties properties = new SecretProperties();\n            \n            // Set content type\n            if (metadata.getContentType() != null) {\n                properties.setContentType(metadata.getContentType());\n            }\n            \n            // Set expiration\n            if (metadata.getExpiresOn() != null) {\n                properties.setExpiresOn(metadata.getExpiresOn());\n            }\n            \n            // Set tags\n            Map<String, String> tags = new HashMap<>();\n            if (metadata.getTags() != null) {\n                tags.putAll(metadata.getTags());\n            }\n            tags.put(\"rotation-status\", \"active\");\n            tags.put(\"rotated-at\", OffsetDateTime.now().toString());\n            properties.setTags(tags);\n            \n            newSecret.setProperties(properties);\n        } else {\n            // Default tags\n            SecretProperties properties = new SecretProperties();\n            Map<String, String> tags = new HashMap<>();\n            tags.put(\"rotation-status\", \"active\");\n            tags.put(\"rotated-at\", OffsetDateTime.now().toString());\n            properties.setTags(tags);\n            newSecret.setProperties(properties);\n        }\n        \n        return secretClient.setSecret(newSecret);\n    }\n    \n    /**\n     * Verifies that the new secret version is active and retrievable.\n     *\n     * @param secretName The secret name\n     * @param expectedVersion The expected version ID\n     * @param expectedValue The expected secret value\n     * @throws SecretRotationException if verification fails\n     */\n    private void verifyNewVersion(String secretName, String expectedVersion, String expectedValue) {\n        // Get the latest version\n        KeyVaultSecret verifiedSecret = secretClient.getSecret(secretName);\n        \n        // Verify version matches\n        String actualVersion = verifiedSecret.getProperties().getVersion();\n        if (!expectedVersion.equals(actualVersion)) {\n            throw new SecretRotationException(\n                String.format(\"Version mismatch. Expected: %s, Actual: %s\", \n                    expectedVersion, actualVersion)\n            );\n        }\n        \n        // Verify value matches\n        String actualValue = verifiedSecret.getValue();\n        if (!expectedValue.equals(actualValue)) {\n            throw new SecretRotationException(\"Secret value verification failed\");\n        }\n        \n        // Verify it's enabled\n        if (!verifiedSecret.getProperties().isEnabled()) {\n            throw new SecretRotationException(\"New secret version is not enabled\");\n        }\n    }\n    \n    /**\n     * Handles HTTP exceptions and returns appropriate error messages.\n     *\n     * @param secretName The secret name\n     * @param e The HttpResponseException\n     * @return Error message\n     */\n    private String handleHttpException(String secretName, HttpResponseException e) {\n        int statusCode = e.getResponse().getStatusCode();\n        \n        switch (statusCode) {\n            case 401:\n                return String.format(\"Authentication failed for secret: %s. Check credentials.\", secretName);\n            case 403:\n                return String.format(\"Access denied for secret: %s. Check Key Vault permissions.\", secretName);\n            case 429:\n                return String.format(\"Rate limit exceeded while rotating secret: %s. Retry later.\", secretName);\n            case 409:\n                return String.format(\"Conflict while rotating secret: %s. Secret may be in deleted state.\", secretName);\n            default:\n                return String.format(\"HTTP error %d while rotating secret: %s - %s\", \n                    statusCode, secretName, e.getMessage());\n        }\n    }\n    \n    /**\n     * Validates input parameters.\n     *\n     * @param secretName The secret name\n     * @param newValue The new value\n     */\n    private void validateInputs(String secretName, String newValue) {\n        if (secretName == null || secretName.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Secret name cannot be null or empty\");\n        }\n        if (newValue == null || newValue.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"New secret value cannot be null or empty\");\n        }\n    }\n    \n    /**\n     * Gets the vault URL.\n     *\n     * @return The vault URL\n     */\n    public String getVaultUrl() {\n        return vaultUrl;\n    }\n    \n    /**\n     * Result object containing rotation operation details.\n     */\n    public static class RotationResult {\n        private final String secretName;\n        private final String oldVersion;\n        private final String newVersion;\n        private final OffsetDateTime rotationTime;\n        private final boolean success;\n        \n        private RotationResult(Builder builder) {\n            this.secretName = builder.secretName;\n            this.oldVersion = builder.oldVersion;\n            this.newVersion = builder.newVersion;\n            this.rotationTime = builder.rotationTime;\n            this.success = builder.success;\n        }\n        \n        public static Builder builder() {\n            return new Builder();\n        }\n        \n        public String getSecretName() { return secretName; }\n        public String getOldVersion() { return oldVersion; }\n        public String getNewVersion() { return newVersion; }\n        public OffsetDateTime getRotationTime() { return rotationTime; }\n        public boolean isSuccess() { return success; }\n        \n        @Override\n        public String toString() {\n            return String.format(\n                \"RotationResult{secretName='%s', oldVersion='%s', newVersion='%s', rotationTime=%s, success=%s}\",\n                secretName, oldVersion, newVersion, rotationTime, success\n            );\n        }\n        \n        public static class Builder {\n            private String secretName;\n            private String oldVersion;\n            private String newVersion;\n            private OffsetDateTime rotationTime;\n            private boolean success;\n            \n            public Builder secretName(String secretName) {\n                this.secretName = secretName;\n                return this;\n            }\n            \n            public Builder oldVersion(String oldVersion) {\n                this.oldVersion = oldVersion;\n                return this;\n            }\n            \n            public Builder newVersion(String newVersion) {\n                this.newVersion = newVersion;\n                return this;\n            }\n            \n            public Builder rotationTime(OffsetDateTime rotationTime) {\n                this.rotationTime = rotationTime;\n                return this;\n            }\n            \n            public Builder success(boolean success) {\n                this.success = success;\n                return this;\n            }\n            \n            public RotationResult build() {\n                return new RotationResult(this);\n            }\n        }\n    }\n    \n    /**\n     * Metadata for secret creation.\n     */\n    public static class SecretMetadata {\n        private String contentType;\n        private OffsetDateTime expiresOn;\n        private Map<String, String> tags;\n        \n        public SecretMetadata() {\n            this.tags = new HashMap<>();\n        }\n        \n        public String getContentType() { return contentType; }\n        public void setContentType(String contentType) { this.contentType = contentType; }\n        \n        public OffsetDateTime getExpiresOn() { return expiresOn; }\n        public void setExpiresOn(OffsetDateTime expiresOn) { this.expiresOn = expiresOn; }\n        \n        public Map<String, String> getTags() { return tags; }\n        public void setTags(Map<String, String> tags) { this.tags = tags; }\n        \n        public SecretMetadata withContentType(String contentType) {\n            this.contentType = contentType;\n            return this;\n        }\n        \n        public SecretMetadata withExpiresOn(OffsetDateTime expiresOn) {\n            this.expiresOn = expiresOn;\n            return this;\n        }\n        \n        public SecretMetadata withTag(String key, String value) {\n            this.tags.put(key, value);\n            return this;\n        }\n    }\n    \n    /**\n     * Custom exception for secret rotation failures.\n     */\n    public static class SecretRotationException extends RuntimeException {\n        public SecretRotationException(String message) {\n            super(message);\n        }\n        \n        public SecretRotationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```\n\n## Usage Examples\n\n```java\npackage com.example.keyvault;\n\nimport java.time.OffsetDateTime;\n\npublic class SecretRotationExample {\n    \n    public static void main(String[] args) {\n        // Initialize service\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        SecretRotationService rotationService = new SecretRotationService(vaultUrl);\n        \n        // Example 1: Simple rotation\n        simpleRotation(rotationService);\n        \n        // Example 2: Rotation with metadata\n        rotationWithMetadata(rotationService);\n        \n        // Example",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8152,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java service class that implements the Azure Key Vault secret rotation pattern with proper error handling.\n\n```java\npackage com.example.app.service;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport java.time.OffsetDateTime;\nimport java.util.Map;\n\n@Service\npublic class SecretRotationService {\n    private static final Logger log = LoggerFactory.getLogger(SecretRotationService.class);\n    \n    private final SecretClient secretClient;\n\n    public SecretRotationService(@Value(\"${azure.keyvault.url}\") String vaultUrl) {\n        this.secretClient = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        log.info(\"Initialized SecretRotationService with vault: {}\", vaultUrl);\n    }\n\n    /**\n     * Rotates a secret by disabling the old version and creating a new version.\n     * \n     * @param secretName the name of the secret to rotate\n     * @param newValue the new secret value\n     * @return the newly created secret version\n     * @throws ResourceNotFoundException if the secret doesn't exist\n     * @throws HttpResponseException if there's an HTTP error (403, 429, etc.)\n     */\n    public KeyVaultSecret rotateSecret(String secretName, String newValue) {\n        try {\n            log.info(\"Starting secret rotation for: {}\", secretName);\n            \n            // Step 1: Get current secret\n            KeyVaultSecret currentSecret = secretClient.getSecret(secretName);\n            String currentVersion = currentSecret.getProperties().getVersion();\n            log.info(\"Retrieved current secret version: {}\", currentVersion);\n            \n            // Step 2: Disable old version\n            SecretProperties currentProperties = currentSecret.getProperties();\n            currentProperties.setEnabled(false);\n            SecretProperties disabledProperties = secretClient.updateSecretProperties(currentProperties);\n            log.info(\"Disabled old secret version: {}\", currentVersion);\n            \n            // Step 3: Create new version with new value\n            KeyVaultSecret newSecret = secretClient.setSecret(secretName, newValue);\n            String newVersion = newSecret.getProperties().getVersion();\n            log.info(\"Created new secret version: {}\", newVersion);\n            \n            // Step 4: Verify new version is active\n            KeyVaultSecret verifiedSecret = secretClient.getSecret(secretName);\n            if (!verifiedSecret.getProperties().isEnabled()) {\n                throw new IllegalStateException(\"New secret version is not enabled\");\n            }\n            if (!verifiedSecret.getProperties().getVersion().equals(newVersion)) {\n                throw new IllegalStateException(\"Retrieved version doesn't match new version\");\n            }\n            \n            log.info(\"Successfully rotated secret '{}' from version {} to {}\", \n                secretName, currentVersion, newVersion);\n            \n            return verifiedSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            log.error(\"Secret not found: {}\", secretName, e);\n            throw new IllegalArgumentException(\"Secret '\" + secretName + \"' does not exist in Key Vault\", e);\n        } catch (HttpResponseException e) {\n            int statusCode = e.getResponse().getStatusCode();\n            if (statusCode == 403) {\n                log.error(\"Access denied for secret: {}. Check Key Vault permissions.\", secretName, e);\n                throw new SecurityException(\"Access denied to Key Vault secret: \" + secretName, e);\n            } else if (statusCode == 429) {\n                log.error(\"Rate limited while rotating secret: {}\", secretName, e);\n                throw new IllegalStateException(\"Key Vault rate limit exceeded. Retry later.\", e);\n            } else {\n                log.error(\"HTTP error {} while rotating secret: {}\", statusCode, secretName, e);\n                throw new IllegalStateException(\"Key Vault HTTP error: \" + statusCode, e);\n            }\n        } catch (Exception e) {\n            log.error(\"Unexpected error rotating secret: {}\", secretName, e);\n            throw new IllegalStateException(\"Failed to rotate secret: \" + secretName, e);\n        }\n    }\n\n    /**\n     * Rotates a secret with additional metadata (tags, expiration).\n     * \n     * @param secretName the name of the secret to rotate\n     * @param newValue the new secret value\n     * @param expirationDays number of days until expiration\n     * @param tags metadata tags for the secret\n     * @return the newly created secret version\n     */\n    public KeyVaultSecret rotateSecretWithMetadata(\n            String secretName, \n            String newValue, \n            int expirationDays,\n            Map<String, String> tags) {\n        \n        try {\n            log.info(\"Starting secret rotation with metadata for: {}\", secretName);\n            \n            // Get and disable current version\n            KeyVaultSecret currentSecret = secretClient.getSecret(secretName);\n            String currentVersion = currentSecret.getProperties().getVersion();\n            \n            currentSecret.getProperties().setEnabled(false);\n            secretClient.updateSecretProperties(currentSecret.getProperties());\n            log.info(\"Disabled old secret version: {}\", currentVersion);\n            \n            // Create new version with metadata\n            KeyVaultSecret newSecretWithProps = new KeyVaultSecret(secretName, newValue)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusDays(expirationDays))\n                    .setContentType(\"text/plain\")\n                    .setTags(tags));\n            \n            KeyVaultSecret newSecret = secretClient.setSecret(newSecretWithProps);\n            String newVersion = newSecret.getProperties().getVersion();\n            log.info(\"Created new secret version with expiration: {}\", newVersion);\n            \n            // Verify new version\n            KeyVaultSecret verifiedSecret = secretClient.getSecret(secretName);\n            if (!verifiedSecret.getProperties().isEnabled()) {\n                throw new IllegalStateException(\"New secret version is not enabled\");\n            }\n            \n            log.info(\"Successfully rotated secret '{}' with metadata from version {} to {}\", \n                secretName, currentVersion, newVersion);\n            \n            return verifiedSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            log.error(\"Secret not found: {}\", secretName, e);\n            throw new IllegalArgumentException(\"Secret '\" + secretName + \"' does not exist in Key Vault\", e);\n        } catch (HttpResponseException e) {\n            handleHttpResponseException(e, secretName);\n            throw e; // Won't reach here, but satisfies compiler\n        } catch (Exception e) {\n            log.error(\"Unexpected error rotating secret with metadata: {}\", secretName, e);\n            throw new IllegalStateException(\"Failed to rotate secret: \" + secretName, e);\n        }\n    }\n\n    /**\n     * Gets the current active secret value.\n     * \n     * @param secretName the name of the secret\n     * @return the secret value\n     */\n    public String getSecretValue(String secretName) {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            log.debug(\"Retrieved secret: {}\", secretName);\n            return secret.getValue();\n        } catch (ResourceNotFoundException e) {\n            log.error(\"Secret not found: {}\", secretName, e);\n            throw new IllegalArgumentException(\"Secret '\" + secretName + \"' does not exist\", e);\n        } catch (HttpResponseException e) {\n            handleHttpResponseException(e, secretName);\n            throw e; // Won't reach here\n        }\n    }\n\n    /**\n     * Checks if a secret exists and is enabled.\n     * \n     * @param secretName the name of the secret\n     * @return true if secret exists and is enabled\n     */\n    public boolean isSecretActive(String secretName) {\n        try {\n            KeyVaultSecret secret = secretClient.getSecret(secretName);\n            return secret.getProperties().isEnabled();\n        } catch (ResourceNotFoundException e) {\n            log.debug(\"Secret not found: {}\", secretName);\n            return false;\n        } catch (HttpResponseException e) {\n            log.warn(\"Error checking secret status: {}\", secretName, e);\n            return false;\n        }\n    }\n\n    private void handleHttpResponseException(HttpResponseException e, String secretName) {\n        int statusCode = e.getResponse().getStatusCode();\n        if (statusCode == 403) {\n            log.error(\"Access denied for secret: {}. Check Key Vault permissions.\", secretName, e);\n            throw new SecurityException(\"Access denied to Key Vault secret: \" + secretName, e);\n        } else if (statusCode == 429) {\n            log.error(\"Rate limited while accessing secret: {}\", secretName, e);\n            throw new IllegalStateException(\"Key Vault rate limit exceeded. Retry later.\", e);\n        } else {\n            log.error(\"HTTP error {} while accessing secret: {}\", statusCode, secretName, e);\n            throw new IllegalStateException(\"Key Vault HTTP error: \" + statusCode, e);\n        }\n    }\n}\n```\n\nNow let me create a configuration properties class and application.properties entry:\n\n```java\npackage com.example.app.config;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ConfigurationProperties(prefix = \"azure.keyvault\")\npublic class KeyVaultProperties {\n    private String url;\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n}\n```\n\nAnd here's a test class demonstrating usage:\n\n```java\npackage com.example.app.service;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.TestPropertySource;\n\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n@SpringBootTest\n@TestPropertySource(properties = {\n    \"azure.keyvault.url=https://your-vault.vault.azure.net\"\n})\nclass SecretRotationServiceTest {\n\n    @Autowired\n    private SecretRotationService secretRotationService;\n\n    @Test\n    void testRotateSecret_Success() {\n        // Arrange\n        String secretName = \"test-secret\";\n        String newValue = \"new-secret-value-\" + System.currentTimeMillis();\n\n        // Act\n        KeyVaultSecret rotatedSecret = secretRotationService.rotateSecret(secretName, newValue);\n\n        // Assert\n        assertNotNull(rotatedSecret);\n        assertEquals(secretName, rotatedSecret.getName());\n        assertEquals(newValue, rotatedSecret.getValue());\n        assertTrue(rotatedSecret.getProperties().isEnabled());\n    }\n\n    @Test\n    void testRotateSecret_NotFound() {\n        // Arrange\n        String nonExistentSecret = \"non-existent-secret\";\n\n        // Act & Assert\n        assertThrows(IllegalArgumentException.class, () -> {\n            secretRotationService.rotateSecret(nonExistentSecret, \"new-value\");\n        });\n    }\n\n    @Test\n    void testRotateSecretWithMetadata() {\n        // Arrange\n        String secretName = \"test-secret-with-metadata\";\n        String newValue = \"new-value-\" + System.currentTimeMillis();\n        Map<String, String> tags = Map.of(\n            \"environment\", \"test\",\n            \"rotated-by\", \"automated-test\"\n        );\n\n        // Act\n        KeyVaultSecret rotatedSecret = secretRotationService.rotateSecretWithMetadata(\n            secretName, newValue, 90, tags\n        );\n\n        // Assert\n        assertNotNull(rotatedSecret);\n        assertEquals(secretName, rotatedSecret.getName());\n        assertTrue(rotatedSecret.getProperties().isEnabled());\n        assertNotNull(rotatedSecret.getProperties().getExpiresOn());\n    }\n\n    @Test\n    void testGetSecretValue() {\n        // Arrange\n        String secretName = \"existing-secret\";\n\n        // Act\n        String value = secretRotationService.getSecretValue(secretName);\n\n        // Assert\n        assertNotNull(value);\n        assertFalse(value.isEmpty());\n    }\n\n    @Test\n    void testIsSecretActive() {\n        // Arrange\n        String secretName = \"existing-secret\";\n\n        // Act\n        boolean isActive = secretRotationService.isSecretActive(secretName);\n\n        // Assert\n        assertTrue(isActive);\n    }\n\n    @Test\n    void testIsSecretActive_NotFound() {\n        // Arrange\n        String nonExistentSecret = \"non-existent-secret\";\n\n        // Act\n        boolean isActive = secretRotationService.isSecretActive(nonExistentSecret);\n\n        // Assert\n        assertFalse(isActive);\n    }\n}\n```\n\nAdd this to your `application.properties`:\n\n```properties\n# Azure Key Vault Configuration\nazure.keyvault.url=${AZURE_KEYVAULT_URL:https://your-vault.vault.azure.net}\n```\n\n**Key Features:**\n\n1. \u2705 Uses `SecretClient` with `DefaultAzureCredential`\n2. \u2705 Implements complete rotation pattern: get \u2192 disable old \u2192 create new \u2192 verify\n3. \u2705 Proper error handling for `ResourceNotFoundException` and `HttpResponseException`\n4. \u2705 Handles 403 (access denied) and 429 (rate limit) specifically\n5. \u2705 Includes metadata support (tags, expiration)\n6. \u2705 Comprehensive logging at each step\n7. \u2705 Helper methods for getting values and checking status\n8. \u2705 Full test coverage\n\nThe service is production-ready with proper Spring Boot integration!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8677,
            "output_tokens": 3593,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-security-keyvault-secrets-java-02",
      "task_type": "cross_language",
      "target_language": "python",
      "expected_patterns": [
        "from azure\\.keyvault\\.secrets import SecretClient",
        "from azure\\.identity import DefaultAzureCredential",
        "SecretClient\\(",
        "vault_url=",
        "list_properties_of_secrets",
        "get_secret\\(",
        "\\.value"
      ],
      "anti_patterns": [
        "SecretClientBuilder",
        "\\.buildClient\\(\\)",
        "import com\\.azure",
        "new SecretClientBuilder\\(\\)",
        "listPropertiesOfSecrets\\(\\)",
        "getSecret\\("
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-keyvault-secrets/azure.keyvault.secrets.secretclient",
          "description": "Python SecretClient: list_properties_of_secrets, get_secret, vault_url= constructor"
        },
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-identity/azure.identity.defaultazurecredential",
          "description": "Python DefaultAzureCredential: direct instantiation without builder"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclientbuilder",
          "description": "Anti-patterns: Java SecretClientBuilder, .buildClient(), listPropertiesOfSecrets camelCase"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclient",
          "description": "Anti-patterns: Java getSecret camelCase method name"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Azure Key Vault Secrets to .env Exporter\n\nHere's a complete Python script that exports Azure Key Vault secrets to a `.env` file:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Key Vault Secrets to .env File Exporter\n\nThis script retrieves all enabled secrets from an Azure Key Vault\nand exports them as environment variables to a .env file.\n\"\"\"\n\nimport os\nimport sys\nfrom typing import List, Tuple\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import AzureError\n\n\ndef get_vault_url(vault_name: str) -> str:\n    \"\"\"\n    Construct the Key Vault URL from the vault name.\n    \n    Args:\n        vault_name: Name of the Azure Key Vault\n        \n    Returns:\n        Full URL to the Key Vault\n    \"\"\"\n    return f\"https://{vault_name}.vault.azure.net/\"\n\n\ndef sanitize_key_name(secret_name: str) -> str:\n    \"\"\"\n    Convert Azure Key Vault secret name to valid environment variable name.\n    Key Vault allows hyphens, but env vars typically use underscores.\n    \n    Args:\n        secret_name: Original secret name from Key Vault\n        \n    Returns:\n        Sanitized environment variable name\n    \"\"\"\n    # Replace hyphens with underscores and convert to uppercase\n    return secret_name.replace(\"-\", \"_\").upper()\n\n\ndef fetch_secrets(vault_url: str) -> List[Tuple[str, str]]:\n    \"\"\"\n    Fetch all enabled secrets from Azure Key Vault.\n    \n    Args:\n        vault_url: Full URL to the Azure Key Vault\n        \n    Returns:\n        List of tuples containing (secret_name, secret_value)\n    \"\"\"\n    print(f\"Connecting to Key Vault: {vault_url}\")\n    \n    # Create credential object using DefaultAzureCredential\n    # This will try multiple authentication methods in order:\n    # 1. Environment variables\n    # 2. Managed Identity\n    # 3. Visual Studio Code\n    # 4. Azure CLI\n    # 5. Azure PowerShell\n    credential = DefaultAzureCredential()\n    \n    # Create the SecretClient\n    client = SecretClient(vault_url=vault_url, credential=credential)\n    \n    secrets = []\n    \n    try:\n        # List all secret properties (metadata only, not values)\n        print(\"Fetching secret list...\")\n        secret_properties = client.list_properties_of_secrets()\n        \n        for secret_property in secret_properties:\n            # Skip disabled secrets\n            if not secret_property.enabled:\n                print(f\"  Skipping disabled secret: {secret_property.name}\")\n                continue\n            \n            try:\n                # Retrieve the actual secret value\n                print(f\"  Retrieving: {secret_property.name}\")\n                secret = client.get_secret(secret_property.name)\n                secrets.append((secret.name, secret.value))\n                \n            except AzureError as e:\n                print(f\"  Warning: Could not retrieve secret '{secret_property.name}': {e}\")\n                continue\n        \n        print(f\"\\nSuccessfully retrieved {len(secrets)} secrets\")\n        return secrets\n        \n    except AzureError as e:\n        print(f\"Error accessing Key Vault: {e}\")\n        sys.exit(1)\n    finally:\n        credential.close()\n\n\ndef write_env_file(secrets: List[Tuple[str, str]], output_file: str = \".env\", \n                   overwrite: bool = False) -> None:\n    \"\"\"\n    Write secrets to a .env file.\n    \n    Args:\n        secrets: List of tuples containing (secret_name, secret_value)\n        output_file: Path to the output .env file\n        overwrite: Whether to overwrite existing file\n    \"\"\"\n    # Check if file exists\n    if os.path.exists(output_file) and not overwrite:\n        response = input(f\"\\n{output_file} already exists. Overwrite? (y/n): \")\n        if response.lower() != 'y':\n            print(\"Operation cancelled.\")\n            sys.exit(0)\n    \n    try:\n        with open(output_file, 'w', encoding='utf-8') as f:\n            # Write header\n            f.write(\"# Azure Key Vault Secrets\\n\")\n            f.write(\"# Generated automatically - DO NOT COMMIT TO VERSION CONTROL\\n\")\n            f.write(f\"# Total secrets: {len(secrets)}\\n\\n\")\n            \n            # Write each secret\n            for secret_name, secret_value in sorted(secrets):\n                env_var_name = sanitize_key_name(secret_name)\n                \n                # Escape special characters in values\n                # Handle multiline values\n                if '\\n' in secret_value:\n                    # For multiline values, use quotes and escape\n                    escaped_value = secret_value.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"').replace('\\n', '\\\\n')\n                    f.write(f'{env_var_name}=\"{escaped_value}\"\\n')\n                elif ' ' in secret_value or any(char in secret_value for char in ['#', '$', '\"', \"'\"]):\n                    # For values with spaces or special chars, use quotes\n                    escaped_value = secret_value.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n                    f.write(f'{env_var_name}=\"{escaped_value}\"\\n')\n                else:\n                    # Simple values don't need quotes\n                    f.write(f'{env_var_name}={secret_value}\\n')\n        \n        print(f\"\\n\u2713 Successfully wrote {len(secrets)} secrets to {output_file}\")\n        print(f\"\\nIMPORTANT: Add '{output_file}' to your .gitignore file!\")\n        \n    except IOError as e:\n        print(f\"Error writing to file: {e}\")\n        sys.exit(1)\n\n\ndef create_gitignore_entry(env_file: str = \".env\") -> None:\n    \"\"\"\n    Add .env file to .gitignore if it exists.\n    \n    Args:\n        env_file: Name of the .env file to add to .gitignore\n    \"\"\"\n    gitignore_path = \".gitignore\"\n    \n    # Check if .gitignore exists\n    if os.path.exists(gitignore_path):\n        # Check if .env is already in .gitignore\n        with open(gitignore_path, 'r', encoding='utf-8') as f:\n            content = f.read()\n            if env_file in content:\n                return\n        \n        # Add .env to .gitignore\n        response = input(f\"\\nAdd {env_file} to .gitignore? (y/n): \")\n        if response.lower() == 'y':\n            with open(gitignore_path, 'a', encoding='utf-8') as f:\n                f.write(f\"\\n# Azure Key Vault secrets\\n{env_file}\\n\")\n            print(f\"\u2713 Added {env_file} to .gitignore\")\n\n\ndef main():\n    \"\"\"Main execution function.\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(\n        description=\"Export Azure Key Vault secrets to a .env file\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  %(prog)s my-keyvault\n  %(prog)s my-keyvault -o secrets.env\n  %(prog)s my-keyvault --overwrite\n  \nAuthentication:\n  This script uses DefaultAzureCredential which tries multiple methods:\n  - Environment variables (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET)\n  - Managed Identity (when running in Azure)\n  - Azure CLI (az login)\n  - Azure PowerShell\n  \n  Make sure you're authenticated using one of these methods before running.\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        \"vault_name\",\n        help=\"Name of the Azure Key Vault (without .vault.azure.net)\"\n    )\n    \n    parser.add_argument(\n        \"-o\", \"--output\",\n        default=\".env\",\n        help=\"Output file path (default: .env)\"\n    )\n    \n    parser.add_argument(\n        \"--overwrite\",\n        action=\"store_true\",\n        help=\"Overwrite output file without prompting\"\n    )\n    \n    parser.add_argument(\n        \"--no-gitignore\",\n        action=\"store_true\",\n        help=\"Don't prompt to add output file to .gitignore\"\n    )\n    \n    args = parser.parse_args()\n    \n    # Construct vault URL\n    vault_url = get_vault_url(args.vault_name)\n    \n    # Fetch secrets from Key Vault\n    secrets = fetch_secrets(vault_url)\n    \n    if not secrets:\n        print(\"\\nNo enabled secrets found in the Key Vault.\")\n        sys.exit(0)\n    \n    # Write to .env file\n    write_env_file(secrets, args.output, args.overwrite)\n    \n    # Optionally add to .gitignore\n    if not args.no_gitignore:\n        create_gitignore_entry(args.output)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Installation Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nazure-keyvault-secrets>=4.7.0\nazure-identity>=1.15.0\n```\n\nInstall dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n## Usage Examples\n\n### Basic Usage\n\n```bash\n# Export secrets from a Key Vault named \"my-keyvault\"\npython export_secrets.py my-keyvault\n```\n\n### Advanced Usage\n\n```bash\n# Specify custom output file\npython export_secrets.py my-keyvault -o production.env\n\n# Overwrite without prompting\npython export_secrets.py my-keyvault --overwrite\n\n# Don't prompt for .gitignore update\npython export_secrets.py my-keyvault --no-gitignore\n```\n\n## Authentication Setup\n\nBefore running the script, authenticate using one of these methods:\n\n### Azure CLI (Recommended for local development)\n```bash\naz login\n```\n\n### Service Principal (Environment Variables)\n```bash\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\n```\n\n### Managed Identity\nWhen running in Azure (VM, App Service, etc.), Managed Identity is used automatically.\n\n## Required Permissions\n\nThe authenticated identity needs these permissions on the Key Vault:\n- `Get` (secrets)\n- `List` (secrets)\n\nYou can assign these using Azure CLI:\n\n```bash\naz keyvault set-policy --name my-keyvault \\\n  --upn user@example.com \\\n  --secret-permissions get list\n```\n\n## Security Notes\n\n1. **Never commit `.env` files** to version control\n2. The script automatically prompts to add `.env` to `.gitignore`\n3. Secrets are written with proper escaping for special characters\n4. File permissions should be restricted: `chmod 600 .env`\n\nThis script provides a secure and convenient way to sync Azure Key Vault secrets to local development environments!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 58,
            "output_tokens": 2805,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secrets Export Script\n\nI'll create a comprehensive Python script that lists all secrets, retrieves enabled secret values, and exports them to a `.env` file.\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Key Vault Secrets Export Script\n\nExports all enabled secrets from Azure Key Vault to a .env file.\nUses DefaultAzureCredential for authentication.\n\nRequirements:\n    pip install azure-keyvault-secrets azure-identity python-dotenv\n\nUsage:\n    python export_secrets.py --vault-url https://myvault.vault.azure.net\n    python export_secrets.py --vault-url https://myvault.vault.azure.net --output custom.env\n    python export_secrets.py --vault-url https://myvault.vault.azure.net --prefix APP_\n\"\"\"\n\nimport argparse\nimport os\nimport sys\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.core.exceptions import (\n    HttpResponseException,\n    ResourceNotFoundError,\n    ClientAuthenticationError\n)\n\n\nclass SecretExporter:\n    \"\"\"Exports Azure Key Vault secrets to .env file.\"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the SecretExporter.\n        \n        Args:\n            vault_url: Azure Key Vault URL (e.g., https://myvault.vault.azure.net)\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=vault_url, credential=self.credential)\n        \n    def list_secret_names(self) -> List[str]:\n        \"\"\"\n        List all secret names in the vault.\n        \n        Returns:\n            List of secret names\n        \"\"\"\n        print(f\"\ud83d\udccb Listing secrets from: {self.vault_url}\")\n        secret_names = []\n        \n        try:\n            for secret_properties in self.client.list_properties_of_secrets():\n                secret_names.append(secret_properties.name)\n                \n            print(f\"\u2713 Found {len(secret_names)} secrets\")\n            return secret_names\n            \n        except ClientAuthenticationError as e:\n            print(f\"\u274c Authentication failed: {e.message}\", file=sys.stderr)\n            print(\"\ud83d\udca1 Ensure you're logged in with: az login\", file=sys.stderr)\n            sys.exit(1)\n        except HttpResponseException as e:\n            if e.status_code == 403:\n                print(f\"\u274c Access denied. Ensure you have 'Get' and 'List' permissions.\", file=sys.stderr)\n            else:\n                print(f\"\u274c HTTP error {e.status_code}: {e.message}\", file=sys.stderr)\n            sys.exit(1)\n        except Exception as e:\n            print(f\"\u274c Unexpected error: {str(e)}\", file=sys.stderr)\n            sys.exit(1)\n    \n    def get_enabled_secrets(self, secret_names: List[str]) -> Dict[str, str]:\n        \"\"\"\n        Retrieve values for all enabled secrets.\n        \n        Args:\n            secret_names: List of secret names to retrieve\n            \n        Returns:\n            Dictionary mapping secret names to values\n        \"\"\"\n        print(f\"\\n\ud83d\udd10 Retrieving secret values...\")\n        secrets = {}\n        skipped = []\n        errors = []\n        \n        for name in secret_names:\n            try:\n                # Get secret with properties\n                secret = self.client.get_secret(name)\n                \n                # Check if secret is enabled\n                if not secret.properties.enabled:\n                    skipped.append(f\"{name} (disabled)\")\n                    continue\n                \n                # Check if secret is expired\n                if secret.properties.expires_on:\n                    if secret.properties.expires_on < datetime.now(secret.properties.expires_on.tzinfo):\n                        skipped.append(f\"{name} (expired)\")\n                        continue\n                \n                # Check if secret is not yet valid\n                if secret.properties.not_before:\n                    if secret.properties.not_before > datetime.now(secret.properties.not_before.tzinfo):\n                        skipped.append(f\"{name} (not yet valid)\")\n                        continue\n                \n                secrets[name] = secret.value\n                print(f\"  \u2713 {name}\")\n                \n            except ResourceNotFoundError:\n                errors.append(f\"{name} (not found)\")\n            except HttpResponseException as e:\n                if e.status_code == 403:\n                    errors.append(f\"{name} (access denied)\")\n                else:\n                    errors.append(f\"{name} (HTTP {e.status_code})\")\n            except Exception as e:\n                errors.append(f\"{name} ({str(e)})\")\n        \n        # Print summary\n        print(f\"\\n\ud83d\udcca Summary:\")\n        print(f\"  \u2713 Retrieved: {len(secrets)}\")\n        if skipped:\n            print(f\"  \u2298 Skipped: {len(skipped)}\")\n            for item in skipped:\n                print(f\"    - {item}\")\n        if errors:\n            print(f\"  \u274c Errors: {len(errors)}\")\n            for item in errors:\n                print(f\"    - {item}\")\n        \n        return secrets\n    \n    def sanitize_env_var_name(self, name: str, prefix: Optional[str] = None) -> str:\n        \"\"\"\n        Convert secret name to valid environment variable name.\n        \n        Args:\n            name: Secret name\n            prefix: Optional prefix to add\n            \n        Returns:\n            Sanitized environment variable name\n        \"\"\"\n        # Replace hyphens with underscores\n        env_name = name.replace(\"-\", \"_\")\n        \n        # Convert to uppercase\n        env_name = env_name.upper()\n        \n        # Remove invalid characters (keep only alphanumeric and underscore)\n        env_name = \"\".join(c if c.isalnum() or c == \"_\" else \"_\" for c in env_name)\n        \n        # Add prefix if provided\n        if prefix:\n            env_name = f\"{prefix}{env_name}\"\n        \n        return env_name\n    \n    def export_to_env_file(\n        self,\n        secrets: Dict[str, str],\n        output_file: str = \".env\",\n        prefix: Optional[str] = None,\n        overwrite: bool = False\n    ) -> None:\n        \"\"\"\n        Export secrets to .env file.\n        \n        Args:\n            secrets: Dictionary of secret names and values\n            output_file: Output file path\n            prefix: Optional prefix for environment variable names\n            overwrite: Whether to overwrite existing file\n        \"\"\"\n        output_path = Path(output_file)\n        \n        # Check if file exists\n        if output_path.exists() and not overwrite:\n            response = input(f\"\\n\u26a0\ufe0f  {output_file} already exists. Overwrite? (y/N): \")\n            if response.lower() != 'y':\n                print(\"\u274c Export cancelled\")\n                return\n        \n        print(f\"\\n\ud83d\udcdd Writing secrets to: {output_file}\")\n        \n        try:\n            with open(output_path, 'w', encoding='utf-8') as f:\n                # Write header\n                f.write(f\"# Azure Key Vault Secrets Export\\n\")\n                f.write(f\"# Vault: {self.vault_url}\\n\")\n                f.write(f\"# Exported: {datetime.now().isoformat()}\\n\")\n                f.write(f\"# Total secrets: {len(secrets)}\\n\")\n                f.write(\"\\n\")\n                \n                # Write secrets\n                for name, value in sorted(secrets.items()):\n                    env_name = self.sanitize_env_var_name(name, prefix)\n                    \n                    # Escape special characters in value\n                    escaped_value = value.replace(\"\\\\\", \"\\\\\\\\\").replace('\"', '\\\\\"')\n                    \n                    # Quote value if it contains spaces or special characters\n                    if \" \" in value or \"\\n\" in value or any(c in value for c in ['$', '`', '!', '#']):\n                        f.write(f'{env_name}=\"{escaped_value}\"\\n')\n                    else:\n                        f.write(f'{env_name}={escaped_value}\\n')\n                    \n                    print(f\"  \u2713 {env_name}\")\n            \n            print(f\"\\n\u2705 Successfully exported {len(secrets)} secrets to {output_file}\")\n            \n            # Set restrictive permissions on Unix-like systems\n            if os.name != 'nt':  # Not Windows\n                output_path.chmod(0o600)\n                print(f\"\ud83d\udd12 Set file permissions to 600 (owner read/write only)\")\n            \n        except IOError as e:\n            print(f\"\u274c Failed to write file: {str(e)}\", file=sys.stderr)\n            sys.exit(1)\n    \n    def export_secrets(\n        self,\n        output_file: str = \".env\",\n        prefix: Optional[str] = None,\n        overwrite: bool = False\n    ) -> None:\n        \"\"\"\n        Main export workflow.\n        \n        Args:\n            output_file: Output file path\n            prefix: Optional prefix for environment variable names\n            overwrite: Whether to overwrite existing file\n        \"\"\"\n        # List all secrets\n        secret_names = self.list_secret_names()\n        \n        if not secret_names:\n            print(\"\u26a0\ufe0f  No secrets found in vault\")\n            return\n        \n        # Get enabled secrets\n        secrets = self.get_enabled_secrets(secret_names)\n        \n        if not secrets:\n            print(\"\u26a0\ufe0f  No enabled secrets to export\")\n            return\n        \n        # Export to file\n        self.export_to_env_file(secrets, output_file, prefix, overwrite)\n\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Export Azure Key Vault secrets to .env file\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Export from vault\n  %(prog)s --vault-url https://myvault.vault.azure.net\n  \n  # Export to custom file\n  %(prog)s --vault-url https://myvault.vault.azure.net --output production.env\n  \n  # Add prefix to variable names\n  %(prog)s --vault-url https://myvault.vault.azure.net --prefix APP_\n  \n  # Overwrite existing file without prompt\n  %(prog)s --vault-url https://myvault.vault.azure.net --overwrite\n\nEnvironment Variables:\n  AZURE_KEYVAULT_URL    Default vault URL if --vault-url not provided\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        \"--vault-url\",\n        help=\"Azure Key Vault URL (e.g., https://myvault.vault.azure.net)\",\n        default=os.getenv(\"AZURE_KEYVAULT_URL\")\n    )\n    \n    parser.add_argument(\n        \"-o\", \"--output\",\n        help=\"Output file path (default: .env)\",\n        default=\".env\"\n    )\n    \n    parser.add_argument(\n        \"-p\", \"--prefix\",\n        help=\"Prefix for environment variable names (e.g., APP_)\",\n        default=None\n    )\n    \n    parser.add_argument(\n        \"--overwrite\",\n        help=\"Overwrite existing file without prompt\",\n        action=\"store_true\"\n    )\n    \n    parser.add_argument(\n        \"-v\", \"--verbose\",\n        help=\"Enable verbose output\",\n        action=\"store_true\"\n    )\n    \n    args = parser.parse_args()\n    \n    # Validate vault URL\n    if not args.vault_url:\n        print(\"\u274c Error: --vault-url is required or set AZURE_KEYVAULT_URL\", file=sys.stderr)\n        parser.print_help()\n        sys.exit(1)\n    \n    if not args.vault_url.startswith(\"https://\"):\n        print(\"\u274c Error: vault-url must start with https://\", file=sys.stderr)\n        sys.exit(1)\n    \n    # Run export\n    try:\n        exporter = SecretExporter(args.vault_url)\n        exporter.export_secrets(\n            output_file=args.output,\n            prefix=args.prefix,\n            overwrite=args.overwrite\n        )\n    except KeyboardInterrupt:\n        print(\"\\n\\n\u26a0\ufe0f  Export cancelled by user\")\n        sys.exit(130)\n    except Exception as e:\n        print(f\"\\n\u274c Unexpected error: {str(e)}\", file=sys.stderr)\n        if args.verbose:\n            import traceback\n            traceback.print_exc()\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Usage Examples\n\n### Basic Usage\n\n```bash\n# Export all secrets\npython export_secrets.py --vault-url https://myvault.vault.azure.net\n\n# Export to custom file\npython export_secrets.py --vault-url https://myvault.vault.azure.net --output production.env\n\n# Add prefix to variable names\npython export_secrets.py --vault-url https://myvault.vault.azure.net --prefix APP_\n\n# Overwrite without prompt\npython export_secrets.py --vault-url https://myvault.vault.azure.net --overwrite\n```\n\n### Using Environment Variable\n\n```bash\n# Set vault URL in environment\nexport AZURE_KEYVAULT_URL=https://myvault.vault.azure.net\n\n# Run without --vault-url argument\npython export_secrets.py\n```\n\n## Example Output\n\n```\n\ud83d\udccb Listing secrets from: https://myvault.vault.azure.net\n\u2713 Found 8 secrets\n\n\ud83d\udd10 Retrieving secret values...\n  \u2713 database-password\n  \u2713 api-key\n  \u2713 jwt-secret\n  \u2713 stripe-api-key\n  \u2713 sendgrid-api-key\n\n\ud83d\udcca Summary:\n  \u2713 Retrieved: 5\n  \u2298 Skipped: 2\n    - old-api-key (disabled)\n    - temp-secret (expired)\n  \u274c Errors: 1\n    - restricted-secret (access denied)\n\n\ud83d\udcdd Writing secrets to: .env\n  \u2713 DATABASE_PASSWORD\n  \u2713 API_KEY\n  \u2713 JWT_SECRET\n  \u2713 STRIPE_API_KEY\n  \u2713 SENDGRID_API_KEY\n\n\u2705 Successfully exported 5 secrets to .env\n\ud83d\udd12 Set file permissions to 600 (owner read/write only)\n```\n\n## Generated .env File\n\n```bash\n# Azure Key Vault Secrets Export\n# Vault: https://myvault.vault.azure.net\n# Exported: 2024-01-15T10:30:45.123456\n# Total secrets: 5\n\nAPI_KEY=sk_live_abc123xyz\nDATABASE_PASSWORD=\"P@ssw0rd123!\"\nJWT_SECRET=super-secret-key-here\nSENDGRID_API_KEY=SG.abc123.xyz789\nSTRIPE_API_KEY=sk_live_stripe123\n```\n\n## Advanced Script with Filtering\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAdvanced secret export with filtering and validation.\n\"\"\"\n\nimport argparse\nimport re\nfrom typing import Dict, List, Optional, Callable\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.keyvault.secrets import SecretClient\n\n\nclass AdvancedSecretExporter:\n    \"\"\"Advanced secret exporter with filtering capabilities.\"\"\"\n    \n    def __init__(self, vault_url: str):\n        self.vault_url = vault_url\n        self.client = SecretClient(\n            vault_url=vault_url,\n            credential=DefaultAzureCredential()\n        )\n    \n    def export_with_filter(\n        self,\n        output_file: str = \".env\",\n        include_pattern: Optional[str] = None,\n        exclude_pattern: Optional[str] = None,\n        tag_filter: Optional[Dict[str, str]] = None,\n        validate: bool = False\n    ) -> None:\n        \"\"\"\n        Export secrets with filtering options.\n        \n        Args:\n            output_",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8127,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Python script to list secrets from Azure Key Vault and export them to a .env file.\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nExport Azure Key Vault secrets to a .env file.\n\nThis script connects to an Azure Key Vault, retrieves all enabled secrets,\nand writes them to a .env file in KEY=VALUE format.\n\"\"\"\nimport os\nimport sys\nimport logging\nfrom typing import List, Dict\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.core.exceptions import ResourceNotFoundError, HttpResponseException\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\ndef get_vault_url() -> str:\n    \"\"\"Get the Key Vault URL from environment variable.\"\"\"\n    vault_url = os.getenv(\"AZURE_KEYVAULT_URL\")\n    if not vault_url:\n        raise ValueError(\n            \"AZURE_KEYVAULT_URL environment variable is required. \"\n            \"Example: https://my-vault.vault.azure.net\"\n        )\n    return vault_url\n\n\ndef create_secret_client(vault_url: str) -> SecretClient:\n    \"\"\"Create and return an authenticated SecretClient.\"\"\"\n    try:\n        credential = DefaultAzureCredential()\n        client = SecretClient(vault_url=vault_url, credential=credential)\n        logger.info(f\"Connected to Key Vault: {vault_url}\")\n        return client\n    except Exception as e:\n        logger.error(f\"Failed to create SecretClient: {e}\")\n        raise\n\n\ndef list_enabled_secrets(client: SecretClient) -> List[Dict[str, str]]:\n    \"\"\"\n    List all enabled secrets from the Key Vault.\n    \n    Returns a list of dicts with 'name' and 'value' keys.\n    \"\"\"\n    secrets = []\n    \n    try:\n        # List all secret properties (doesn't include values)\n        logger.info(\"Listing secrets from Key Vault...\")\n        secret_properties = client.list_properties_of_secrets()\n        \n        for props in secret_properties:\n            secret_name = props.name\n            \n            # Skip disabled secrets\n            if not props.enabled:\n                logger.info(f\"Skipping disabled secret: {secret_name}\")\n                continue\n            \n            # Retrieve the actual secret value\n            try:\n                secret = client.get_secret(secret_name)\n                secrets.append({\n                    'name': secret_name,\n                    'value': secret.value\n                })\n                logger.info(f\"Retrieved secret: {secret_name}\")\n                \n            except ResourceNotFoundError:\n                logger.warning(f\"Secret not found: {secret_name}\")\n            except HttpResponseException as e:\n                if e.status_code == 403:\n                    logger.error(f\"Access denied for secret: {secret_name}\")\n                else:\n                    logger.error(f\"HTTP error retrieving {secret_name}: {e}\")\n            except Exception as e:\n                logger.error(f\"Error retrieving secret {secret_name}: {e}\")\n        \n        logger.info(f\"Retrieved {len(secrets)} enabled secrets\")\n        return secrets\n        \n    except HttpResponseException as e:\n        if e.status_code == 403:\n            logger.error(\"Access denied. Check Key Vault permissions (Secret List, Get)\")\n        else:\n            logger.error(f\"HTTP error listing secrets: {e}\")\n        raise\n    except Exception as e:\n        logger.error(f\"Error listing secrets: {e}\")\n        raise\n\n\ndef sanitize_env_key(name: str) -> str:\n    \"\"\"\n    Convert Key Vault secret name to valid environment variable name.\n    \n    Replaces hyphens with underscores and converts to uppercase.\n    \"\"\"\n    return name.replace('-', '_').upper()\n\n\ndef write_env_file(secrets: List[Dict[str, str]], output_path: str = \".env\") -> None:\n    \"\"\"Write secrets to a .env file.\"\"\"\n    try:\n        with open(output_path, 'w') as f:\n            f.write(\"# Azure Key Vault Secrets Export\\n\")\n            f.write(\"# Generated automatically - DO NOT COMMIT TO VERSION CONTROL\\n\\n\")\n            \n            for secret in secrets:\n                env_key = sanitize_env_key(secret['name'])\n                env_value = secret['value']\n                \n                # Escape quotes and newlines in values\n                env_value = env_value.replace('\\\\', '\\\\\\\\')\n                env_value = env_value.replace('\"', '\\\\\"')\n                env_value = env_value.replace('\\n', '\\\\n')\n                \n                # Write in KEY=\"VALUE\" format\n                f.write(f'{env_key}=\"{env_value}\"\\n')\n        \n        logger.info(f\"Successfully wrote {len(secrets)} secrets to {output_path}\")\n        \n    except IOError as e:\n        logger.error(f\"Failed to write .env file: {e}\")\n        raise\n\n\ndef main():\n    \"\"\"Main execution function.\"\"\"\n    try:\n        # Get vault URL from environment\n        vault_url = get_vault_url()\n        \n        # Create authenticated client\n        client = create_secret_client(vault_url)\n        \n        # List and retrieve all enabled secrets\n        secrets = list_enabled_secrets(client)\n        \n        if not secrets:\n            logger.warning(\"No enabled secrets found in Key Vault\")\n            return\n        \n        # Write to .env file\n        output_path = os.getenv(\"OUTPUT_FILE\", \".env\")\n        write_env_file(secrets, output_path)\n        \n        logger.info(\"Export completed successfully\")\n        \n    except ValueError as e:\n        logger.error(f\"Configuration error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNow let me create a requirements file for the dependencies:\n\n```txt\n# Azure Key Vault dependencies\nazure-identity==1.18.0\nazure-keyvault-secrets==4.9.0\n\n# Core dependencies\npython-dotenv==1.0.0\n```\n\nAnd a usage example/documentation:\n\n```markdown\n# Azure Key Vault to .env Exporter\n\n## Setup\n\n1. Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n2. Set the Key Vault URL:\n```bash\nexport AZURE_KEYVAULT_URL=\"https://my-vault.vault.azure.net\"\n```\n\n3. Ensure you have Azure credentials configured (one of):\n   - Azure CLI: `az login`\n   - Environment variables: `AZURE_CLIENT_ID`, `AZURE_TENANT_ID`, `AZURE_CLIENT_SECRET`\n   - Managed Identity (when running in Azure)\n\n## Usage\n\nBasic usage:\n```bash\npython export_secrets.py\n```\n\nCustom output file:\n```bash\nexport OUTPUT_FILE=\"config/.env\"\npython export_secrets.py\n```\n\n## Required Permissions\n\nYour Azure identity needs these Key Vault permissions:\n- **Secret List**: List all secrets\n- **Secret Get**: Retrieve secret values\n\n## Output Format\n\nThe script generates a `.env` file with:\n- Secret names converted to UPPERCASE_WITH_UNDERSCORES\n- Values properly escaped and quoted\n- Header warning not to commit to version control\n\nExample output:\n```\n# Azure Key Vault Secrets Export\n# Generated automatically - DO NOT COMMIT TO VERSION CONTROL\n\nDATABASE_PASSWORD=\"P@ssw0rd123!\"\nAPI_KEY=\"sk_live_abc123xyz\"\nJWT_SECRET=\"super-secret-key\"\n```\n\n## Security Notes\n\n- Add `.env` to your `.gitignore`\n- The script only exports **enabled** secrets\n- Disabled secrets are skipped with a log message\n- Access denied errors are logged but don't stop the export\n```\n\nThe script includes:\n\n1. **Authentication**: Uses `DefaultAzureCredential` which tries multiple auth methods\n2. **List secrets**: Gets all secret properties first (no values)\n3. **Filter enabled**: Only processes secrets where `enabled=True`\n4. **Retrieve values**: Calls `get_secret()` for each enabled secret\n5. **Error handling**: Handles 403 (access denied), 404 (not found), and other errors\n6. **Name conversion**: Converts `my-secret-name` \u2192 `MY_SECRET_NAME`\n7. **Value escaping**: Properly escapes quotes, backslashes, and newlines\n8. **Logging**: Comprehensive logging at each step\n9. **.env format**: Writes in standard `KEY=\"VALUE\"` format\n\nWould you like me to add any additional features, such as filtering by tags, secret name patterns, or different output formats?",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8653,
            "output_tokens": 2156,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Azure Key Vault Secrets to .env Exporter\n\nHere's a complete Python script that exports Azure Key Vault secrets to a `.env` file:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Key Vault Secrets to .env Exporter\n\nThis script retrieves all enabled secrets from an Azure Key Vault\nand exports them to a .env file for local development.\n\"\"\"\n\nimport os\nimport sys\nfrom typing import Dict, List\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import AzureError\n\n\ndef get_vault_url(vault_name: str) -> str:\n    \"\"\"\n    Construct the Key Vault URL from the vault name.\n    \n    Args:\n        vault_name: Name of the Azure Key Vault\n        \n    Returns:\n        Full URL to the Key Vault\n    \"\"\"\n    return f\"https://{vault_name}.vault.azure.net/\"\n\n\ndef list_and_retrieve_secrets(vault_url: str) -> Dict[str, str]:\n    \"\"\"\n    List all secrets in the vault and retrieve enabled secrets' values.\n    \n    Args:\n        vault_url: URL of the Azure Key Vault\n        \n    Returns:\n        Dictionary of secret names and their values\n    \"\"\"\n    secrets_dict = {}\n    \n    try:\n        # Authenticate using DefaultAzureCredential\n        credential = DefaultAzureCredential()\n        \n        # Create a SecretClient\n        client = SecretClient(vault_url=vault_url, credential=credential)\n        \n        print(f\"Connected to Key Vault: {vault_url}\")\n        print(\"Retrieving secrets...\\n\")\n        \n        # List all secrets\n        secret_properties = client.list_properties_of_secrets()\n        \n        for secret_property in secret_properties:\n            secret_name = secret_property.name\n            \n            # Check if the secret is enabled\n            if secret_property.enabled:\n                try:\n                    # Retrieve the secret value\n                    secret = client.get_secret(secret_name)\n                    secrets_dict[secret_name] = secret.value\n                    print(f\"\u2713 Retrieved: {secret_name}\")\n                    \n                except AzureError as e:\n                    print(f\"\u2717 Failed to retrieve {secret_name}: {str(e)}\")\n            else:\n                print(f\"\u2298 Skipped (disabled): {secret_name}\")\n        \n        print(f\"\\nTotal secrets retrieved: {len(secrets_dict)}\")\n        \n    except AzureError as e:\n        print(f\"Error connecting to Key Vault: {str(e)}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"Unexpected error: {str(e)}\")\n        sys.exit(1)\n    \n    return secrets_dict\n\n\ndef sanitize_key_name(key_name: str) -> str:\n    \"\"\"\n    Sanitize Key Vault secret names for .env file format.\n    Azure Key Vault allows hyphens, but environment variables typically use underscores.\n    \n    Args:\n        key_name: Original secret name from Key Vault\n        \n    Returns:\n        Sanitized key name suitable for environment variables\n    \"\"\"\n    # Replace hyphens with underscores\n    sanitized = key_name.replace(\"-\", \"_\")\n    # Convert to uppercase (common convention for env vars)\n    sanitized = sanitized.upper()\n    return sanitized\n\n\ndef export_to_env_file(secrets: Dict[str, str], output_file: str = \".env\", \n                       preserve_case: bool = False) -> None:\n    \"\"\"\n    Export secrets to a .env file.\n    \n    Args:\n        secrets: Dictionary of secret names and values\n        output_file: Path to the output .env file\n        preserve_case: If True, preserve original key names; if False, sanitize them\n    \"\"\"\n    try:\n        # Check if file exists and create backup\n        if os.path.exists(output_file):\n            backup_file = f\"{output_file}.backup\"\n            os.rename(output_file, backup_file)\n            print(f\"\\nBackup created: {backup_file}\")\n        \n        # Write secrets to .env file\n        with open(output_file, 'w', encoding='utf-8') as f:\n            # Write header\n            f.write(\"# Azure Key Vault Secrets\\n\")\n            f.write(\"# Auto-generated - Do not commit this file to version control\\n\")\n            f.write(f\"# Source: {vault_url}\\n\\n\")\n            \n            # Write each secret\n            for key, value in sorted(secrets.items()):\n                env_key = key if preserve_case else sanitize_key_name(key)\n                \n                # Escape special characters in values if needed\n                escaped_value = value.replace('\\n', '\\\\n').replace('\"', '\\\\\"')\n                \n                # Use quotes if value contains spaces or special characters\n                if ' ' in escaped_value or any(char in escaped_value for char in ['#', '$', '&']):\n                    f.write(f'{env_key}=\"{escaped_value}\"\\n')\n                else:\n                    f.write(f'{env_key}={escaped_value}\\n')\n        \n        print(f\"\\n\u2713 Successfully exported {len(secrets)} secrets to {output_file}\")\n        print(f\"\\nIMPORTANT: Add '{output_file}' to your .gitignore file!\")\n        \n    except IOError as e:\n        print(f\"Error writing to file: {str(e)}\")\n        sys.exit(1)\n\n\ndef create_gitignore_entry(env_file: str = \".env\") -> None:\n    \"\"\"\n    Add .env file to .gitignore if it exists, or create a reminder.\n    \n    Args:\n        env_file: Name of the .env file to add to .gitignore\n    \"\"\"\n    gitignore_path = \".gitignore\"\n    \n    try:\n        # Check if .gitignore exists\n        if os.path.exists(gitignore_path):\n            with open(gitignore_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n            \n            # Check if .env is already in .gitignore\n            if env_file not in content:\n                with open(gitignore_path, 'a', encoding='utf-8') as f:\n                    f.write(f\"\\n# Azure Key Vault secrets\\n{env_file}\\n{env_file}.backup\\n\")\n                print(f\"\u2713 Added {env_file} to .gitignore\")\n            else:\n                print(f\"\u2713 {env_file} already in .gitignore\")\n        else:\n            print(f\"\\n\u26a0 No .gitignore found. Create one and add: {env_file}\")\n    except IOError as e:\n        print(f\"Warning: Could not update .gitignore: {str(e)}\")\n\n\nif __name__ == \"__main__\":\n    # Configuration\n    VAULT_NAME = os.getenv(\"AZURE_KEYVAULT_NAME\")\n    OUTPUT_FILE = \".env\"\n    PRESERVE_CASE = False  # Set to True to keep original key names\n    \n    # Check if vault name is provided\n    if not VAULT_NAME:\n        if len(sys.argv) > 1:\n            VAULT_NAME = sys.argv[1]\n        else:\n            print(\"Usage: python export_keyvault_secrets.py <vault-name>\")\n            print(\"   or: Set AZURE_KEYVAULT_NAME environment variable\")\n            sys.exit(1)\n    \n    # Construct vault URL\n    vault_url = get_vault_url(VAULT_NAME)\n    \n    print(\"=\" * 60)\n    print(\"Azure Key Vault to .env Exporter\")\n    print(\"=\" * 60)\n    \n    # Retrieve secrets\n    secrets = list_and_retrieve_secrets(vault_url)\n    \n    if not secrets:\n        print(\"\\n\u26a0 No enabled secrets found in the vault.\")\n        sys.exit(0)\n    \n    # Export to .env file\n    export_to_env_file(secrets, OUTPUT_FILE, PRESERVE_CASE)\n    \n    # Update .gitignore\n    create_gitignore_entry(OUTPUT_FILE)\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"Export completed successfully!\")\n    print(\"=\" * 60)\n```\n\n## Installation Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nazure-keyvault-secrets>=4.7.0\nazure-identity>=1.15.0\n```\n\nInstall dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n## Usage\n\n### Method 1: Command Line Argument\n```bash\npython export_keyvault_secrets.py my-keyvault-name\n```\n\n### Method 2: Environment Variable\n```bash\nexport AZURE_KEYVAULT_NAME=my-keyvault-name\npython export_keyvault_secrets.py\n```\n\n## Authentication Setup\n\nThe script uses `DefaultAzureCredential`, which tries multiple authentication methods in order:\n\n1. **Environment Variables** (Service Principal):\n```bash\nexport AZURE_CLIENT_ID=<client-id>\nexport AZURE_TENANT_ID=<tenant-id>\nexport AZURE_CLIENT_SECRET=<client-secret>\n```\n\n2. **Azure CLI** (for local development):\n```bash\naz login\n```\n\n3. **Managed Identity** (when running in Azure)\n\n## Required Permissions\n\nEnsure your identity has these permissions on the Key Vault:\n- `Key Vault Secrets User` role, or\n- Access policy with `Get` and `List` permissions for secrets\n\n## Features\n\n- \u2705 Lists all secrets in the vault\n- \u2705 Retrieves only enabled secrets\n- \u2705 Sanitizes secret names (converts hyphens to underscores, uppercase)\n- \u2705 Creates backup of existing .env file\n- \u2705 Handles special characters in values\n- \u2705 Automatically updates .gitignore\n- \u2705 Comprehensive error handling\n- \u2705 Progress indicators\n\n## Example Output\n\n```\n============================================================\nAzure Key Vault to .env Exporter\n============================================================\nConnected to Key Vault: https://my-vault.vault.azure.net/\nRetrieving secrets...\n\n\u2713 Retrieved: database-password\n\u2713 Retrieved: api-key\n\u2298 Skipped (disabled): old-secret\n\u2713 Retrieved: connection-string\n\nTotal secrets retrieved: 3\n\nBackup created: .env.backup\n\u2713 Successfully exported 3 secrets to .env\n\nIMPORTANT: Add '.env' to your .gitignore file!\n\u2713 Added .env to .gitignore\n\n============================================================\nExport completed successfully!\n============================================================\n```\n\n## Generated .env File Example\n\n```bash\n# Azure Key Vault Secrets\n# Auto-generated - Do not commit this file to version control\n# Source: https://my-vault.vault.azure.net/\n\nAPI_KEY=abc123xyz789\nCONNECTION_STRING=\"Server=myserver;Database=mydb\"\nDATABASE_PASSWORD=SecureP@ssw0rd\n```\n\nThis script provides a secure and convenient way to sync Azure Key Vault secrets to your local development environment!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 58,
            "output_tokens": 2767,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secrets Export Script\n\nI'll create a comprehensive Python script that lists all secrets, retrieves enabled secret values, and exports them to a `.env` file.\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Key Vault Secrets Export Script\n\nExports all enabled secrets from Azure Key Vault to a .env file.\nUses DefaultAzureCredential for authentication.\n\nRequirements:\n    pip install azure-keyvault-secrets azure-identity python-dotenv\n\nUsage:\n    python export_secrets.py --vault-url https://myvault.vault.azure.net\n    python export_secrets.py --vault-url https://myvault.vault.azure.net --output custom.env\n    python export_secrets.py --vault-url https://myvault.vault.azure.net --prefix APP_\n\"\"\"\n\nimport argparse\nimport os\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nfrom azure.core.exceptions import (\n    HttpResponseException,\n    ResourceNotFoundError,\n    ServiceRequestError\n)\nfrom azure.identity import DefaultAzureCredential\nfrom azure.keyvault.secrets import SecretClient, SecretProperties\n\n\nclass KeyVaultSecretsExporter:\n    \"\"\"Exports Azure Key Vault secrets to .env file.\"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the exporter.\n        \n        Args:\n            vault_url: Azure Key Vault URL (e.g., https://myvault.vault.azure.net)\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=vault_url, credential=self.credential)\n        \n    def list_secret_properties(self) -> List[SecretProperties]:\n        \"\"\"\n        List all secret properties in the vault.\n        \n        Returns:\n            List of SecretProperties objects\n        \"\"\"\n        print(f\"\ud83d\udccb Listing secrets from: {self.vault_url}\")\n        \n        try:\n            secret_properties = list(self.client.list_properties_of_secrets())\n            print(f\"\u2705 Found {len(secret_properties)} secrets\")\n            return secret_properties\n        except HttpResponseException as e:\n            if e.status_code == 403:\n                print(\"\u274c Access denied. Ensure you have 'List' and 'Get' permissions.\")\n                print(\"   Required permissions: Key Vault Secrets User or Key Vault Reader\")\n            else:\n                print(f\"\u274c HTTP error {e.status_code}: {e.message}\")\n            sys.exit(1)\n        except ServiceRequestError as e:\n            print(f\"\u274c Network error: {e}\")\n            print(\"   Check your vault URL and network connectivity\")\n            sys.exit(1)\n        except Exception as e:\n            print(f\"\u274c Unexpected error: {e}\")\n            sys.exit(1)\n    \n    def get_enabled_secrets(\n        self, \n        secret_properties: List[SecretProperties],\n        include_expired: bool = False\n    ) -> Dict[str, str]:\n        \"\"\"\n        Retrieve values for all enabled secrets.\n        \n        Args:\n            secret_properties: List of secret properties\n            include_expired: Whether to include expired secrets\n            \n        Returns:\n            Dictionary of secret names to values\n        \"\"\"\n        secrets = {}\n        skipped = []\n        errors = []\n        \n        print(f\"\\n\ud83d\udd0d Retrieving secret values...\")\n        \n        for props in secret_properties:\n            secret_name = props.name\n            \n            # Check if secret is enabled\n            if not props.enabled:\n                skipped.append(f\"{secret_name} (disabled)\")\n                continue\n            \n            # Check expiration\n            if not include_expired and props.expires_on:\n                if props.expires_on < datetime.now(props.expires_on.tzinfo):\n                    skipped.append(f\"{secret_name} (expired)\")\n                    continue\n            \n            # Retrieve secret value\n            try:\n                secret = self.client.get_secret(secret_name)\n                secrets[secret_name] = secret.value\n                print(f\"  \u2713 {secret_name}\")\n                \n            except ResourceNotFoundError:\n                errors.append(f\"{secret_name} (not found)\")\n            except HttpResponseException as e:\n                if e.status_code == 403:\n                    errors.append(f\"{secret_name} (access denied)\")\n                else:\n                    errors.append(f\"{secret_name} (HTTP {e.status_code})\")\n            except Exception as e:\n                errors.append(f\"{secret_name} ({str(e)})\")\n        \n        # Print summary\n        print(f\"\\n\ud83d\udcca Summary:\")\n        print(f\"  \u2705 Retrieved: {len(secrets)}\")\n        if skipped:\n            print(f\"  \u23ed\ufe0f  Skipped: {len(skipped)}\")\n            for item in skipped:\n                print(f\"     - {item}\")\n        if errors:\n            print(f\"  \u274c Errors: {len(errors)}\")\n            for item in errors:\n                print(f\"     - {item}\")\n        \n        return secrets\n    \n    def sanitize_key_name(self, name: str, prefix: str = \"\") -> str:\n        \"\"\"\n        Convert Key Vault secret name to valid environment variable name.\n        \n        Args:\n            name: Secret name from Key Vault\n            prefix: Optional prefix to add\n            \n        Returns:\n            Sanitized environment variable name\n        \"\"\"\n        # Replace hyphens with underscores\n        sanitized = name.replace(\"-\", \"_\")\n        \n        # Convert to uppercase\n        sanitized = sanitized.upper()\n        \n        # Add prefix if provided\n        if prefix:\n            sanitized = f\"{prefix}{sanitized}\"\n        \n        return sanitized\n    \n    def export_to_env_file(\n        self,\n        secrets: Dict[str, str],\n        output_file: str = \".env\",\n        prefix: str = \"\",\n        overwrite: bool = False\n    ) -> None:\n        \"\"\"\n        Export secrets to .env file.\n        \n        Args:\n            secrets: Dictionary of secret names to values\n            output_file: Output file path\n            prefix: Optional prefix for environment variable names\n            overwrite: Whether to overwrite existing file\n        \"\"\"\n        output_path = Path(output_file)\n        \n        # Check if file exists\n        if output_path.exists() and not overwrite:\n            print(f\"\\n\u26a0\ufe0f  File '{output_file}' already exists.\")\n            response = input(\"Overwrite? (y/N): \").strip().lower()\n            if response != 'y':\n                print(\"\u274c Export cancelled\")\n                return\n        \n        # Create backup if file exists\n        if output_path.exists():\n            backup_path = output_path.with_suffix(f\".env.backup.{datetime.now().strftime('%Y%m%d_%H%M%S')}\")\n            output_path.rename(backup_path)\n            print(f\"\ud83d\udcbe Backup created: {backup_path}\")\n        \n        # Write secrets to file\n        try:\n            with open(output_path, 'w', encoding='utf-8') as f:\n                # Write header\n                f.write(f\"# Azure Key Vault Secrets Export\\n\")\n                f.write(f\"# Vault: {self.vault_url}\\n\")\n                f.write(f\"# Exported: {datetime.now().isoformat()}\\n\")\n                f.write(f\"# Total secrets: {len(secrets)}\\n\")\n                f.write(f\"\\n\")\n                \n                # Write secrets\n                for name, value in sorted(secrets.items()):\n                    env_var_name = self.sanitize_key_name(name, prefix)\n                    \n                    # Escape special characters in value\n                    escaped_value = value.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n                    \n                    # Quote value if it contains spaces or special characters\n                    if ' ' in value or any(c in value for c in ['#', '$', '&', '|', ';']):\n                        f.write(f'{env_var_name}=\"{escaped_value}\"\\n')\n                    else:\n                        f.write(f'{env_var_name}={escaped_value}\\n')\n            \n            print(f\"\\n\u2705 Secrets exported to: {output_path.absolute()}\")\n            print(f\"   Total variables: {len(secrets)}\")\n            \n        except IOError as e:\n            print(f\"\u274c Failed to write file: {e}\")\n            sys.exit(1)\n    \n    def export_secrets(\n        self,\n        output_file: str = \".env\",\n        prefix: str = \"\",\n        include_expired: bool = False,\n        overwrite: bool = False\n    ) -> None:\n        \"\"\"\n        Complete export workflow.\n        \n        Args:\n            output_file: Output file path\n            prefix: Optional prefix for environment variable names\n            include_expired: Whether to include expired secrets\n            overwrite: Whether to overwrite existing file\n        \"\"\"\n        # List all secrets\n        secret_properties = self.list_secret_properties()\n        \n        if not secret_properties:\n            print(\"\u26a0\ufe0f  No secrets found in vault\")\n            return\n        \n        # Get enabled secrets\n        secrets = self.get_enabled_secrets(secret_properties, include_expired)\n        \n        if not secrets:\n            print(\"\u26a0\ufe0f  No enabled secrets to export\")\n            return\n        \n        # Export to file\n        self.export_to_env_file(secrets, output_file, prefix, overwrite)\n\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Export Azure Key Vault secrets to .env file\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Export from vault to .env\n  python export_secrets.py --vault-url https://myvault.vault.azure.net\n  \n  # Export to custom file with prefix\n  python export_secrets.py --vault-url https://myvault.vault.azure.net \\\\\n      --output production.env --prefix PROD_\n  \n  # Include expired secrets and overwrite without prompt\n  python export_secrets.py --vault-url https://myvault.vault.azure.net \\\\\n      --include-expired --overwrite\n\nEnvironment Variables:\n  AZURE_KEYVAULT_URL    - Default vault URL if --vault-url not provided\n  AZURE_TENANT_ID       - Azure AD tenant ID (for DefaultAzureCredential)\n  AZURE_CLIENT_ID       - Service principal client ID\n  AZURE_CLIENT_SECRET   - Service principal client secret\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        '--vault-url',\n        type=str,\n        default=os.getenv('AZURE_KEYVAULT_URL'),\n        help='Azure Key Vault URL (or set AZURE_KEYVAULT_URL env var)'\n    )\n    \n    parser.add_argument(\n        '--output',\n        type=str,\n        default='.env',\n        help='Output file path (default: .env)'\n    )\n    \n    parser.add_argument(\n        '--prefix',\n        type=str,\n        default='',\n        help='Prefix for environment variable names (e.g., APP_)'\n    )\n    \n    parser.add_argument(\n        '--include-expired',\n        action='store_true',\n        help='Include expired secrets'\n    )\n    \n    parser.add_argument(\n        '--overwrite',\n        action='store_true',\n        help='Overwrite output file without prompting'\n    )\n    \n    parser.add_argument(\n        '--dry-run',\n        action='store_true',\n        help='List secrets without exporting'\n    )\n    \n    args = parser.parse_args()\n    \n    # Validate vault URL\n    if not args.vault_url:\n        print(\"\u274c Error: --vault-url is required (or set AZURE_KEYVAULT_URL)\")\n        print(\"\\nExample:\")\n        print(\"  python export_secrets.py --vault-url https://myvault.vault.azure.net\")\n        sys.exit(1)\n    \n    # Validate vault URL format\n    if not args.vault_url.startswith('https://'):\n        print(\"\u274c Error: Vault URL must start with https://\")\n        sys.exit(1)\n    \n    if not args.vault_url.endswith('.vault.azure.net'):\n        print(\"\u26a0\ufe0f  Warning: Vault URL should end with .vault.azure.net\")\n    \n    print(\"\ud83d\udd10 Azure Key Vault Secrets Exporter\")\n    print(\"=\" * 50)\n    \n    # Create exporter\n    exporter = KeyVaultSecretsExporter(args.vault_url)\n    \n    if args.dry_run:\n        # Dry run - just list secrets\n        secret_properties = exporter.list_secret_properties()\n        secrets = exporter.get_enabled_secrets(secret_properties, args.include_expired)\n        \n        print(\"\\n\ud83d\udccb Secrets that would be exported:\")\n        for name in sorted(secrets.keys()):\n            env_var = exporter.sanitize_key_name(name, args.prefix)\n            print(f\"  {name} \u2192 {env_var}\")\n    else:\n        # Full export\n        exporter.export_secrets(\n            output_file=args.output,\n            prefix=args.prefix,\n            include_expired=args.include_expired,\n            overwrite=args.overwrite\n        )\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Usage Examples\n\n### 1. Basic Export\n\n```bash\n# Export all enabled secrets to .env\npython export_secrets.py --vault-url https://myvault.vault.azure.net\n```\n\n### 2. Custom Output File with Prefix\n\n```bash\n# Export to production.env with PROD_ prefix\npython export_secrets.py \\\n    --vault-url https://myvault.vault.azure.net \\\n    --output production.env \\\n    --prefix PROD_\n```\n\n### 3. Include Expired Secrets\n\n```bash\n# Include expired secrets in export\npython export_secrets.py \\\n    --vault-url https://myvault.vault.azure.net \\\n    --include-expired\n```\n\n### 4. Dry Run (Preview)\n\n```bash\n# Preview what would be exported without creating file\npython export_secrets.py \\\n    --vault-url https://myvault.vault.azure.net \\\n    --dry-run\n```\n\n### 5. Using Environment Variable\n\n```bash\n# Set vault URL via environment variable\nexport AZURE_KEYVAULT_URL=https://myvault.vault.azure.net\npython export_secrets.py --output .env\n```\n\n## Sample Output\n\n```\n\ud83d\udd10 Azure Key Vault Secrets Exporter\n==================================================\n\ud83d\udccb Listing secrets from: https://myvault.vault.azure.net\n\u2705 Found 8 secrets\n\n\ud83d\udd0d Retrieving secret values...\n  \u2713 database-password\n  \u2713 api-key\n  \u2713 jwt-secret\n  \u2713 stripe-api-key\n  \u2713 sendgrid-api-key\n\n\ud83d\udcca Summary:\n  \u2705 Retrieved: 5\n  \u23ed\ufe0f  Skipped: 2\n     - old-api-key (disabled)\n     - temp-secret (expired)\n  \u274c Errors: 1\n     - restricted-secret (access denied)\n\n\ud83d\udcbe Backup created: .env.backup.20240115_143022\n\u2705 Secrets exported to: /path/to/project/.env\n   Total variables: 5\n```\n\n## Generated .env File Example\n\n```bash\n# Azure Key Vault Secrets Export\n# Vault: https://myvault.vault.azure.net\n# Exported: 2024-01-15T14:30:22.123456\n# Total secrets: 5\n\nAPI_KEY=sk_live_abc123xyz789\nDATABASE_PASSWORD=\"P@ssw0rd with spaces!\"\nJWT_SECRET=super-secret-jwt-key-12345\nSENDGRID_API_KEY=SG.abc123.xyz789\nSTRIPE_API_KEY=sk_live_stripe123\n```\n\n## Authentication Setup\n\n### Option 1: Azure CLI (Development)\n\n```bash\n# Login with Azure CLI\naz login\n\n# Set subscription\naz account set --subscription \"My Subscription\"\n\n# Run script\npython",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8127,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Python script to list secrets from Azure Key Vault and export them to a .env file.\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nExport Azure Key Vault secrets to .env file.\n\nUsage:\n    python export_secrets.py --vault-url https://your-vault.vault.azure.net\n    \nEnvironment variables:\n    AZURE_KEYVAULT_URL: Key Vault URL (alternative to --vault-url)\n\"\"\"\n\nimport argparse\nimport logging\nimport os\nimport sys\nfrom pathlib import Path\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.core.exceptions import (\n    HttpResponseException,\n    ResourceNotFoundException,\n    ClientAuthenticationException,\n)\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n\ndef sanitize_env_var_name(secret_name: str) -> str:\n    \"\"\"\n    Convert Key Vault secret name to valid environment variable name.\n    \n    Key Vault allows hyphens, but env vars typically use underscores.\n    Convert to uppercase for convention.\n    \"\"\"\n    return secret_name.replace(\"-\", \"_\").upper()\n\n\ndef export_secrets_to_env(vault_url: str, output_file: str = \".env\") -> None:\n    \"\"\"\n    Export all enabled secrets from Key Vault to .env file.\n    \n    Args:\n        vault_url: Azure Key Vault URL\n        output_file: Output file path (default: .env)\n    \"\"\"\n    try:\n        # Create client with DefaultAzureCredential\n        credential = DefaultAzureCredential()\n        client = SecretClient(vault_url=vault_url, credential=credential)\n        \n        logger.info(f\"Connecting to Key Vault: {vault_url}\")\n        \n        # Collect secrets\n        secrets_data = []\n        secret_count = 0\n        enabled_count = 0\n        \n        # List all secret properties (doesn't include values)\n        for secret_properties in client.list_properties_of_secrets():\n            secret_count += 1\n            secret_name = secret_properties.name\n            \n            # Check if secret is enabled\n            if not secret_properties.enabled:\n                logger.debug(f\"Skipping disabled secret: {secret_name}\")\n                continue\n            \n            enabled_count += 1\n            \n            try:\n                # Retrieve the actual secret value\n                secret = client.get_secret(secret_name)\n                env_var_name = sanitize_env_var_name(secret_name)\n                secrets_data.append((env_var_name, secret.value))\n                \n                logger.info(f\"Retrieved secret: {secret_name} -> {env_var_name}\")\n                \n            except ResourceNotFoundException:\n                logger.warning(f\"Secret not found: {secret_name}\")\n            except HttpResponseException as e:\n                if e.status_code == 403:\n                    logger.error(f\"Access denied to secret: {secret_name}\")\n                else:\n                    logger.error(f\"HTTP error retrieving {secret_name}: {e.status_code}\")\n        \n        # Write to .env file\n        output_path = Path(output_file)\n        \n        # Backup existing file if it exists\n        if output_path.exists():\n            backup_path = output_path.with_suffix(\".env.backup\")\n            output_path.rename(backup_path)\n            logger.info(f\"Backed up existing file to: {backup_path}\")\n        \n        # Write secrets\n        with output_path.open(\"w\", encoding=\"utf-8\") as f:\n            f.write(\"# Azure Key Vault Secrets Export\\n\")\n            f.write(f\"# Source: {vault_url}\\n\")\n            f.write(f\"# Total secrets: {secret_count}, Enabled: {enabled_count}\\n\\n\")\n            \n            for env_var_name, value in sorted(secrets_data):\n                # Escape quotes and newlines in values\n                escaped_value = value.replace(\"\\\\\", \"\\\\\\\\\").replace('\"', '\\\\\"').replace(\"\\n\", \"\\\\n\")\n                f.write(f'{env_var_name}=\"{escaped_value}\"\\n')\n        \n        logger.info(f\"\u2713 Exported {len(secrets_data)} secrets to {output_file}\")\n        logger.info(f\"  Total secrets in vault: {secret_count}\")\n        logger.info(f\"  Enabled secrets: {enabled_count}\")\n        logger.info(f\"  Successfully exported: {len(secrets_data)}\")\n        \n    except ClientAuthenticationException as e:\n        logger.error(\"Authentication failed. Ensure you have valid Azure credentials.\")\n        logger.error(\"Try running: az login\")\n        sys.exit(1)\n        \n    except HttpResponseException as e:\n        if e.status_code == 403:\n            logger.error(\"Access denied. Check your Key Vault access policies.\")\n            logger.error(\"Required permissions: Get, List secrets\")\n        elif e.status_code == 404:\n            logger.error(f\"Key Vault not found: {vault_url}\")\n        else:\n            logger.error(f\"HTTP error: {e.status_code} - {e.message}\")\n        sys.exit(1)\n        \n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        sys.exit(1)\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Export Azure Key Vault secrets to .env file\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  python export_secrets.py --vault-url https://my-vault.vault.azure.net\n  python export_secrets.py --vault-url https://my-vault.vault.azure.net --output secrets.env\n  \n  # Using environment variable\n  export AZURE_KEYVAULT_URL=https://my-vault.vault.azure.net\n  python export_secrets.py\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        \"--vault-url\",\n        help=\"Azure Key Vault URL (e.g., https://my-vault.vault.azure.net)\",\n        default=os.getenv(\"AZURE_KEYVAULT_URL\")\n    )\n    \n    parser.add_argument(\n        \"--output\",\n        \"-o\",\n        help=\"Output file path (default: .env)\",\n        default=\".env\"\n    )\n    \n    parser.add_argument(\n        \"--verbose\",\n        \"-v\",\n        action=\"store_true\",\n        help=\"Enable verbose logging\"\n    )\n    \n    args = parser.parse_args()\n    \n    if args.verbose:\n        logging.getLogger().setLevel(logging.DEBUG)\n    \n    if not args.vault_url:\n        parser.error(\"--vault-url is required or set AZURE_KEYVAULT_URL environment variable\")\n    \n    export_secrets_to_env(args.vault_url, args.output)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNow let me create a `requirements.txt` file for the dependencies:\n\n```txt\nazure-identity==1.18.0\nazure-keyvault-secrets==4.9.0\n```\n\nAnd a usage example in a README:\n\n```markdown\n# Azure Key Vault Secret Exporter\n\nExport secrets from Azure Key Vault to a `.env` file for local development.\n\n## Installation\n\n```bash\npip install -r requirements.txt\n```\n\n## Authentication\n\nThe script uses `DefaultAzureCredential` which tries multiple authentication methods:\n\n1. Environment variables (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_CLIENT_SECRET)\n2. Managed Identity (when running in Azure)\n3. Azure CLI (`az login`)\n4. Visual Studio Code\n5. Azure PowerShell\n\nFor local development, the easiest method is:\n\n```bash\naz login\n```\n\n## Usage\n\n### Basic usage:\n\n```bash\npython export_secrets.py --vault-url https://my-vault.vault.azure.net\n```\n\n### Using environment variable:\n\n```bash\nexport AZURE_KEYVAULT_URL=https://my-vault.vault.azure.net\npython export_secrets.py\n```\n\n### Custom output file:\n\n```bash\npython export_secrets.py --vault-url https://my-vault.vault.azure.net --output secrets.env\n```\n\n### Verbose logging:\n\n```bash\npython export_secrets.py --vault-url https://my-vault.vault.azure.net --verbose\n```\n\n## Output Format\n\nThe script generates a `.env` file with:\n\n```env\n# Azure Key Vault Secrets Export\n# Source: https://my-vault.vault.azure.net\n# Total secrets: 10, Enabled: 8\n\nDATABASE_PASSWORD=\"P@ssw0rd123!\"\nAPI_KEY=\"sk_live_abc123xyz\"\nJWT_SECRET=\"super-secret-key\"\n```\n\n## Features\n\n- \u2705 Lists all secrets in the vault\n- \u2705 Only exports enabled secrets\n- \u2705 Converts secret names to valid env var names (hyphens \u2192 underscores, uppercase)\n- \u2705 Escapes special characters in values\n- \u2705 Backs up existing .env file before overwriting\n- \u2705 Detailed logging with counts\n- \u2705 Proper error handling for auth, permissions, and HTTP errors\n\n## Required Permissions\n\nYour Azure identity needs these Key Vault permissions:\n- **Get** (secrets)\n- **List** (secrets)\n\n## Security Notes\n\n\u26a0\ufe0f **Important**: The generated `.env` file contains sensitive data in plain text.\n\n- Add `.env` to `.gitignore`\n- Restrict file permissions: `chmod 600 .env`\n- Never commit to version control\n- Use only for local development\n```\n\nThe script:\n\n1. **Uses DefaultAzureCredential** for authentication (tries multiple methods)\n2. **Lists all secrets** using `list_properties_of_secrets()`\n3. **Filters enabled secrets** by checking `secret_properties.enabled`\n4. **Retrieves values** with `get_secret()` for each enabled secret\n5. **Converts names** to valid env var format (uppercase, underscores)\n6. **Exports to .env** with proper escaping and formatting\n7. **Handles errors** for auth failures, permissions, and HTTP errors\n8. **Backs up existing files** before overwriting\n9. **Provides detailed logging** with counts and status",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8653,
            "output_tokens": 2566,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Azure Key Vault Secrets to .env Exporter\n\nHere's a complete Python script that exports Azure Key Vault secrets to a `.env` file:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Key Vault Secrets to .env Exporter\n\nThis script retrieves all enabled secrets from an Azure Key Vault\nand exports them to a .env file for local development.\n\"\"\"\n\nimport os\nimport sys\nfrom typing import Dict, List\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import AzureError\n\n\ndef get_vault_url(vault_name: str) -> str:\n    \"\"\"\n    Construct the Key Vault URL from the vault name.\n    \n    Args:\n        vault_name: Name of the Azure Key Vault\n        \n    Returns:\n        Full URL to the Key Vault\n    \"\"\"\n    return f\"https://{vault_name}.vault.azure.net/\"\n\n\ndef list_enabled_secrets(client: SecretClient) -> List[str]:\n    \"\"\"\n    List all enabled secrets in the Key Vault.\n    \n    Args:\n        client: Authenticated SecretClient instance\n        \n    Returns:\n        List of enabled secret names\n    \"\"\"\n    enabled_secrets = []\n    \n    try:\n        # List all secret properties\n        secret_properties = client.list_properties_of_secrets()\n        \n        for secret_property in secret_properties:\n            # Check if secret is enabled\n            if secret_property.enabled:\n                enabled_secrets.append(secret_property.name)\n                print(f\"Found enabled secret: {secret_property.name}\")\n            else:\n                print(f\"Skipping disabled secret: {secret_property.name}\")\n                \n    except AzureError as e:\n        print(f\"Error listing secrets: {e}\")\n        sys.exit(1)\n        \n    return enabled_secrets\n\n\ndef retrieve_secret_values(client: SecretClient, secret_names: List[str]) -> Dict[str, str]:\n    \"\"\"\n    Retrieve values for all specified secrets.\n    \n    Args:\n        client: Authenticated SecretClient instance\n        secret_names: List of secret names to retrieve\n        \n    Returns:\n        Dictionary mapping secret names to their values\n    \"\"\"\n    secrets = {}\n    \n    for secret_name in secret_names:\n        try:\n            # Retrieve the secret\n            secret = client.get_secret(secret_name)\n            secrets[secret_name] = secret.value\n            print(f\"Retrieved secret: {secret_name}\")\n            \n        except AzureError as e:\n            print(f\"Error retrieving secret '{secret_name}': {e}\")\n            # Continue with other secrets instead of failing completely\n            \n    return secrets\n\n\ndef sanitize_env_var_name(name: str) -> str:\n    \"\"\"\n    Sanitize secret name to be a valid environment variable name.\n    \n    Azure Key Vault allows hyphens in names, but env vars typically use underscores.\n    \n    Args:\n        name: Original secret name\n        \n    Returns:\n        Sanitized environment variable name\n    \"\"\"\n    # Replace hyphens with underscores and convert to uppercase\n    return name.replace(\"-\", \"_\").upper()\n\n\ndef export_to_env_file(secrets: Dict[str, str], output_file: str = \".env\", \n                       sanitize_names: bool = True) -> None:\n    \"\"\"\n    Export secrets to a .env file.\n    \n    Args:\n        secrets: Dictionary of secret names and values\n        output_file: Path to the output .env file\n        sanitize_names: Whether to sanitize secret names for env var compatibility\n    \"\"\"\n    try:\n        with open(output_file, 'w') as f:\n            # Write header\n            f.write(\"# Azure Key Vault Secrets\\n\")\n            f.write(\"# Auto-generated - DO NOT COMMIT THIS FILE\\n\")\n            f.write(\"# Add .env to your .gitignore\\n\\n\")\n            \n            # Write each secret\n            for name, value in sorted(secrets.items()):\n                env_var_name = sanitize_env_var_name(name) if sanitize_names else name\n                \n                # Escape special characters in values\n                # Handle multiline values and quotes\n                if '\\n' in value or '\"' in value:\n                    # Use single quotes for multiline or values with double quotes\n                    escaped_value = value.replace(\"'\", \"\\\\'\")\n                    f.write(f\"{env_var_name}='{escaped_value}'\\n\")\n                else:\n                    f.write(f'{env_var_name}=\"{value}\"\\n')\n                    \n        print(f\"\\n\u2713 Successfully exported {len(secrets)} secrets to {output_file}\")\n        print(f\"\u26a0 WARNING: The {output_file} file contains sensitive data. Keep it secure!\")\n        \n    except IOError as e:\n        print(f\"Error writing to file '{output_file}': {e}\")\n        sys.exit(1)\n\n\ndef create_gitignore_if_needed(env_file: str = \".env\") -> None:\n    \"\"\"\n    Ensure .env is in .gitignore to prevent accidental commits.\n    \n    Args:\n        env_file: Name of the .env file to add to .gitignore\n    \"\"\"\n    gitignore_path = \".gitignore\"\n    \n    try:\n        # Check if .gitignore exists and if .env is already in it\n        if os.path.exists(gitignore_path):\n            with open(gitignore_path, 'r') as f:\n                content = f.read()\n                if env_file in content:\n                    return\n        \n        # Append .env to .gitignore\n        with open(gitignore_path, 'a') as f:\n            f.write(f\"\\n# Azure Key Vault secrets\\n{env_file}\\n\")\n            \n        print(f\"\u2713 Added {env_file} to .gitignore\")\n        \n    except IOError as e:\n        print(f\"Warning: Could not update .gitignore: {e}\")\n\n\ndef main():\n    \"\"\"Main execution function.\"\"\"\n    \n    # Configuration\n    VAULT_NAME = os.getenv(\"AZURE_KEYVAULT_NAME\")\n    OUTPUT_FILE = os.getenv(\"ENV_OUTPUT_FILE\", \".env\")\n    \n    if not VAULT_NAME:\n        print(\"Error: AZURE_KEYVAULT_NAME environment variable is required\")\n        print(\"\\nUsage:\")\n        print(\"  export AZURE_KEYVAULT_NAME='your-vault-name'\")\n        print(\"  python export_secrets.py\")\n        print(\"\\nOptional:\")\n        print(\"  export ENV_OUTPUT_FILE='.env.local'  # Default: .env\")\n        sys.exit(1)\n    \n    print(f\"Azure Key Vault Secrets Exporter\")\n    print(f\"=\" * 50)\n    print(f\"Vault: {VAULT_NAME}\")\n    print(f\"Output: {OUTPUT_FILE}\\n\")\n    \n    try:\n        # Authenticate using DefaultAzureCredential\n        print(\"Authenticating with Azure...\")\n        credential = DefaultAzureCredential()\n        \n        # Create SecretClient\n        vault_url = get_vault_url(VAULT_NAME)\n        client = SecretClient(vault_url=vault_url, credential=credential)\n        print(f\"\u2713 Connected to {vault_url}\\n\")\n        \n        # List enabled secrets\n        print(\"Listing enabled secrets...\")\n        secret_names = list_enabled_secrets(client)\n        \n        if not secret_names:\n            print(\"\\nNo enabled secrets found in the vault.\")\n            sys.exit(0)\n        \n        print(f\"\\nFound {len(secret_names)} enabled secret(s)\\n\")\n        \n        # Retrieve secret values\n        print(\"Retrieving secret values...\")\n        secrets = retrieve_secret_values(client, secret_names)\n        \n        if not secrets:\n            print(\"\\nNo secrets could be retrieved.\")\n            sys.exit(1)\n        \n        print(f\"\\nRetrieved {len(secrets)} secret value(s)\\n\")\n        \n        # Export to .env file\n        print(f\"Exporting to {OUTPUT_FILE}...\")\n        export_to_env_file(secrets, OUTPUT_FILE)\n        \n        # Update .gitignore\n        create_gitignore_if_needed(OUTPUT_FILE)\n        \n        print(\"\\n\u2713 Export completed successfully!\")\n        \n    except AzureError as e:\n        print(f\"\\nAzure Error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"\\nUnexpected Error: {e}\")\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Installation Requirements\n\nCreate a `requirements.txt` file:\n\n```txt\nazure-keyvault-secrets>=4.7.0\nazure-identity>=1.15.0\n```\n\nInstall dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n## Usage\n\n### Basic Usage\n\n```bash\n# Set your Key Vault name\nexport AZURE_KEYVAULT_NAME=\"your-vault-name\"\n\n# Run the script\npython export_secrets.py\n```\n\n### Custom Output File\n\n```bash\nexport AZURE_KEYVAULT_NAME=\"your-vault-name\"\nexport ENV_OUTPUT_FILE=\".env.local\"\npython export_secrets.py\n```\n\n## Authentication Methods\n\nThe script uses `DefaultAzureCredential`, which tries multiple authentication methods in order:\n\n1. **Environment Variables** (Service Principal):\n   ```bash\n   export AZURE_TENANT_ID=\"your-tenant-id\"\n   export AZURE_CLIENT_ID=\"your-client-id\"\n   export AZURE_CLIENT_SECRET=\"your-client-secret\"\n   ```\n\n2. **Azure CLI** (for local development):\n   ```bash\n   az login\n   ```\n\n3. **Managed Identity** (when running in Azure)\n\n## Required Azure Permissions\n\nThe identity running this script needs the following Key Vault permissions:\n\n- `Get` (secrets)\n- `List` (secrets)\n\nOr the Azure RBAC role: **Key Vault Secrets User**\n\n## Security Notes\n\n1. **Never commit the `.env` file** - The script automatically adds it to `.gitignore`\n2. **Rotate secrets regularly** in production environments\n3. **Use Managed Identities** when running in Azure\n4. **Limit access** to the generated `.env` file using file permissions:\n   ```bash\n   chmod 600 .env\n   ```\n\n## Example Output\n\n```\nAzure Key Vault Secrets Exporter\n==================================================\nVault: my-keyvault\nOutput: .env\n\nAuthenticating with Azure...\n\u2713 Connected to https://my-keyvault.vault.azure.net/\n\nListing enabled secrets...\nFound enabled secret: database-password\nFound enabled secret: api-key\nSkipping disabled secret: old-secret\n\nFound 2 enabled secret(s)\n\nRetrieving secret values...\nRetrieved secret: database-password\nRetrieved secret: api-key\n\nRetrieved 2 secret value(s)\n\nExporting to .env...\n\n\u2713 Successfully exported 2 secrets to .env\n\u26a0 WARNING: The .env file contains sensitive data. Keep it secure!\n\u2713 Added .env to .gitignore\n\n\u2713 Export completed successfully!\n```\n\nThis script provides a secure and convenient way to export Azure Key Vault secrets for local development while maintaining security best practices.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 58,
            "output_tokens": 2813,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secrets Export Script\n\nI'll create a Python script that lists all secrets, retrieves enabled secret values, and exports them to a `.env` file.\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nAzure Key Vault Secrets Exporter\nExports all enabled secrets from Azure Key Vault to a .env file\n\"\"\"\n\nimport os\nimport sys\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.core.exceptions import (\n    ResourceNotFoundError,\n    HttpResponseException,\n    ClientAuthenticationError\n)\n\n\nclass KeyVaultSecretsExporter:\n    \"\"\"Export secrets from Azure Key Vault to .env file\"\"\"\n    \n    def __init__(self, vault_url: str):\n        \"\"\"\n        Initialize the exporter\n        \n        Args:\n            vault_url: Azure Key Vault URL (e.g., https://my-vault.vault.azure.net)\n        \"\"\"\n        self.vault_url = vault_url\n        self.credential = DefaultAzureCredential()\n        self.client = SecretClient(vault_url=vault_url, credential=self.credential)\n        \n    def list_all_secrets(self) -> List[Dict[str, any]]:\n        \"\"\"\n        List all secrets in the vault\n        \n        Returns:\n            List of secret properties dictionaries\n        \"\"\"\n        secrets = []\n        \n        try:\n            print(f\"\ud83d\udccb Listing secrets from: {self.vault_url}\")\n            \n            for secret_properties in self.client.list_properties_of_secrets():\n                secret_info = {\n                    'name': secret_properties.name,\n                    'enabled': secret_properties.enabled,\n                    'content_type': secret_properties.content_type,\n                    'created_on': secret_properties.created_on,\n                    'updated_on': secret_properties.updated_on,\n                    'expires_on': secret_properties.expires_on,\n                    'tags': secret_properties.tags or {}\n                }\n                secrets.append(secret_info)\n                \n            print(f\"\u2705 Found {len(secrets)} secrets\")\n            return secrets\n            \n        except ClientAuthenticationError as e:\n            print(f\"\u274c Authentication failed: {e.message}\")\n            sys.exit(1)\n        except HttpResponseException as e:\n            print(f\"\u274c HTTP error ({e.status_code}): {e.message}\")\n            sys.exit(1)\n        except Exception as e:\n            print(f\"\u274c Error listing secrets: {str(e)}\")\n            sys.exit(1)\n    \n    def get_secret_value(self, secret_name: str) -> Optional[str]:\n        \"\"\"\n        Retrieve a secret's value\n        \n        Args:\n            secret_name: Name of the secret\n            \n        Returns:\n            Secret value or None if error\n        \"\"\"\n        try:\n            secret = self.client.get_secret(secret_name)\n            return secret.value\n        except ResourceNotFoundError:\n            print(f\"\u26a0\ufe0f  Secret not found: {secret_name}\")\n            return None\n        except HttpResponseException as e:\n            if e.status_code == 403:\n                print(f\"\u26a0\ufe0f  Access denied for secret: {secret_name}\")\n            else:\n                print(f\"\u26a0\ufe0f  Error retrieving {secret_name}: {e.message}\")\n            return None\n        except Exception as e:\n            print(f\"\u26a0\ufe0f  Unexpected error for {secret_name}: {str(e)}\")\n            return None\n    \n    def export_enabled_secrets(\n        self, \n        output_file: str = \".env\",\n        include_disabled: bool = False,\n        include_expired: bool = False,\n        prefix: str = \"\",\n        exclude_tags: Optional[List[str]] = None\n    ) -> Dict[str, str]:\n        \"\"\"\n        Export enabled secrets to .env file\n        \n        Args:\n            output_file: Output file path (default: .env)\n            include_disabled: Include disabled secrets\n            include_expired: Include expired secrets\n            prefix: Prefix to add to environment variable names\n            exclude_tags: List of tag keys to exclude secrets\n            \n        Returns:\n            Dictionary of exported secrets\n        \"\"\"\n        secrets_list = self.list_all_secrets()\n        exported_secrets = {}\n        skipped_secrets = []\n        \n        print(f\"\\n\ud83d\udd0d Processing secrets...\")\n        \n        for secret_info in secrets_list:\n            secret_name = secret_info['name']\n            \n            # Check if secret should be skipped\n            skip_reason = self._should_skip_secret(\n                secret_info,\n                include_disabled,\n                include_expired,\n                exclude_tags\n            )\n            \n            if skip_reason:\n                skipped_secrets.append((secret_name, skip_reason))\n                print(f\"\u23ed\ufe0f  Skipping {secret_name}: {skip_reason}\")\n                continue\n            \n            # Retrieve secret value\n            print(f\"\ud83d\udd10 Retrieving: {secret_name}\")\n            secret_value = self.get_secret_value(secret_name)\n            \n            if secret_value is not None:\n                # Convert secret name to environment variable format\n                env_var_name = self._to_env_var_name(secret_name, prefix)\n                exported_secrets[env_var_name] = secret_value\n                print(f\"\u2705 Exported: {env_var_name}\")\n        \n        # Write to .env file\n        self._write_env_file(output_file, exported_secrets)\n        \n        # Print summary\n        self._print_summary(exported_secrets, skipped_secrets, output_file)\n        \n        return exported_secrets\n    \n    def _should_skip_secret(\n        self,\n        secret_info: Dict,\n        include_disabled: bool,\n        include_expired: bool,\n        exclude_tags: Optional[List[str]]\n    ) -> Optional[str]:\n        \"\"\"\n        Determine if a secret should be skipped\n        \n        Returns:\n            Skip reason or None if should not skip\n        \"\"\"\n        # Check if disabled\n        if not secret_info['enabled'] and not include_disabled:\n            return \"disabled\"\n        \n        # Check if expired\n        if secret_info['expires_on']:\n            if secret_info['expires_on'] < datetime.now(secret_info['expires_on'].tzinfo):\n                if not include_expired:\n                    return \"expired\"\n        \n        # Check exclude tags\n        if exclude_tags:\n            secret_tags = secret_info['tags']\n            for exclude_tag in exclude_tags:\n                if exclude_tag in secret_tags:\n                    return f\"has excluded tag: {exclude_tag}\"\n        \n        return None\n    \n    def _to_env_var_name(self, secret_name: str, prefix: str = \"\") -> str:\n        \"\"\"\n        Convert secret name to environment variable format\n        \n        Args:\n            secret_name: Original secret name\n            prefix: Optional prefix\n            \n        Returns:\n            Environment variable name (UPPER_CASE_WITH_UNDERSCORES)\n        \"\"\"\n        # Replace hyphens and spaces with underscores\n        env_name = secret_name.replace('-', '_').replace(' ', '_')\n        \n        # Convert to uppercase\n        env_name = env_name.upper()\n        \n        # Add prefix if provided\n        if prefix:\n            prefix = prefix.upper().rstrip('_')\n            env_name = f\"{prefix}_{env_name}\"\n        \n        return env_name\n    \n    def _write_env_file(self, output_file: str, secrets: Dict[str, str]):\n        \"\"\"\n        Write secrets to .env file\n        \n        Args:\n            output_file: Output file path\n            secrets: Dictionary of environment variables\n        \"\"\"\n        try:\n            output_path = Path(output_file)\n            \n            # Create backup if file exists\n            if output_path.exists():\n                backup_path = output_path.with_suffix('.env.backup')\n                output_path.rename(backup_path)\n                print(f\"\\n\ud83d\udcbe Created backup: {backup_path}\")\n            \n            # Write .env file\n            with open(output_path, 'w', encoding='utf-8') as f:\n                # Write header\n                f.write(f\"# Azure Key Vault Secrets Export\\n\")\n                f.write(f\"# Generated: {datetime.now().isoformat()}\\n\")\n                f.write(f\"# Vault: {self.vault_url}\\n\")\n                f.write(f\"# Total secrets: {len(secrets)}\\n\\n\")\n                \n                # Write secrets (sorted for consistency)\n                for key in sorted(secrets.keys()):\n                    value = secrets[key]\n                    # Escape special characters and quote if needed\n                    if any(c in value for c in [' ', '\"', \"'\", '\\n', '\\r', '\\t']):\n                        # Escape quotes and wrap in double quotes\n                        value = value.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n                        f.write(f'{key}=\"{value}\"\\n')\n                    else:\n                        f.write(f'{key}={value}\\n')\n            \n            print(f\"\u2705 Secrets exported to: {output_path.absolute()}\")\n            \n        except IOError as e:\n            print(f\"\u274c Error writing to file: {str(e)}\")\n            sys.exit(1)\n    \n    def _print_summary(\n        self,\n        exported_secrets: Dict[str, str],\n        skipped_secrets: List[tuple],\n        output_file: str\n    ):\n        \"\"\"Print export summary\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"\ud83d\udcca EXPORT SUMMARY\")\n        print(\"=\"*60)\n        print(f\"\u2705 Exported: {len(exported_secrets)} secrets\")\n        print(f\"\u23ed\ufe0f  Skipped: {len(skipped_secrets)} secrets\")\n        print(f\"\ud83d\udcc4 Output file: {output_file}\")\n        \n        if skipped_secrets:\n            print(\"\\n\u23ed\ufe0f  Skipped secrets:\")\n            for name, reason in skipped_secrets:\n                print(f\"   - {name}: {reason}\")\n        \n        print(\"=\"*60)\n\n\ndef main():\n    \"\"\"Main entry point\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(\n        description=\"Export Azure Key Vault secrets to .env file\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Export from environment variable\n  export AZURE_KEYVAULT_URL=https://my-vault.vault.azure.net\n  python keyvault_export.py\n\n  # Export with vault URL\n  python keyvault_export.py --vault-url https://my-vault.vault.azure.net\n\n  # Export to custom file with prefix\n  python keyvault_export.py --output prod.env --prefix PROD\n\n  # Include disabled secrets\n  python keyvault_export.py --include-disabled\n\n  # Exclude secrets with specific tags\n  python keyvault_export.py --exclude-tag environment:dev --exclude-tag temp\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        '--vault-url',\n        help='Azure Key Vault URL (or set AZURE_KEYVAULT_URL env var)',\n        default=os.getenv('AZURE_KEYVAULT_URL')\n    )\n    \n    parser.add_argument(\n        '--output', '-o',\n        help='Output file path (default: .env)',\n        default='.env'\n    )\n    \n    parser.add_argument(\n        '--prefix', '-p',\n        help='Prefix for environment variable names',\n        default=''\n    )\n    \n    parser.add_argument(\n        '--include-disabled',\n        help='Include disabled secrets',\n        action='store_true'\n    )\n    \n    parser.add_argument(\n        '--include-expired',\n        help='Include expired secrets',\n        action='store_true'\n    )\n    \n    parser.add_argument(\n        '--exclude-tag',\n        help='Exclude secrets with tag (format: key or key:value)',\n        action='append',\n        dest='exclude_tags'\n    )\n    \n    parser.add_argument(\n        '--dry-run',\n        help='List secrets without exporting',\n        action='store_true'\n    )\n    \n    args = parser.parse_args()\n    \n    # Validate vault URL\n    if not args.vault_url:\n        print(\"\u274c Error: Vault URL required\")\n        print(\"   Set AZURE_KEYVAULT_URL environment variable or use --vault-url\")\n        sys.exit(1)\n    \n    # Create exporter\n    exporter = KeyVaultSecretsExporter(args.vault_url)\n    \n    if args.dry_run:\n        # Dry run - just list secrets\n        print(\"\ud83d\udd0d DRY RUN MODE - Listing secrets only\\n\")\n        secrets = exporter.list_all_secrets()\n        \n        print(\"\\n\ud83d\udccb Secrets found:\")\n        for secret in secrets:\n            status = \"\u2705 enabled\" if secret['enabled'] else \"\u274c disabled\"\n            expires = f\", expires: {secret['expires_on']}\" if secret['expires_on'] else \"\"\n            tags = f\", tags: {secret['tags']}\" if secret['tags'] else \"\"\n            print(f\"  - {secret['name']} ({status}{expires}{tags})\")\n    else:\n        # Export secrets\n        exporter.export_enabled_secrets(\n            output_file=args.output,\n            include_disabled=args.include_disabled,\n            include_expired=args.include_expired,\n            prefix=args.prefix,\n            exclude_tags=args.exclude_tags\n        )\n\n\nif __name__ == '__main__':\n    main()\n```\n\n## Usage Examples\n\n### 1. Basic Export\n\n```bash\n# Set vault URL via environment variable\nexport AZURE_KEYVAULT_URL=https://my-vault.vault.azure.net\n\n# Export all enabled secrets to .env\npython keyvault_export.py\n```\n\n### 2. Custom Output File\n\n```bash\n# Export to custom file\npython keyvault_export.py --output production.env\n\n# Export with prefix\npython keyvault_export.py --output prod.env --prefix PROD\n```\n\n### 3. Include Disabled/Expired Secrets\n\n```bash\n# Include disabled secrets\npython keyvault_export.py --include-disabled\n\n# Include expired secrets\npython keyvault_export.py --include-expired\n\n# Include both\npython keyvault_export.py --include-disabled --include-expired\n```\n\n### 4. Exclude by Tags\n\n```bash\n# Exclude secrets with specific tag key\npython keyvault_export.py --exclude-tag environment\n\n# Exclude secrets with specific tag key:value\npython keyvault_export.py --exclude-tag environment:dev\n\n# Multiple exclusions\npython keyvault_export.py --exclude-tag temp --exclude-tag test\n```\n\n### 5. Dry Run\n\n```bash\n# List secrets without exporting\npython keyvault_export.py --dry-run\n```\n\n## Output Format\n\nThe generated `.env` file will look like:\n\n```bash\n# Azure Key Vault Secrets Export\n# Generated: 2024-01-15T10:30:00\n# Vault: https://my-vault.vault.azure.net\n# Total secrets: 5\n\nDATABASE_CONNECTION_STRING=\"Server=myserver.database.windows.net;Database=mydb;...\"\nAPI_KEY=sk_live_abc123xyz\nJWT_SECRET=super-secret-key-here\nSTRIPE_WEBHOOK_SECRET=whsec_abc123\nREDIS_PASSWORD=redis-pass-123\n```\n\n## Requirements File\n\n```txt\n# requirements.txt\nazure-identity==1.19.0\nazure-keyvault-secrets==4.9.0\n```\n\nInstall dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n## Authentication Setup\n\nThe script uses `DefaultAzureCredential`, which tries multiple authentication methods:\n\n1. **Environment Variables** (for service principals):\n```bash\nexport AZURE_CLIENT_ID=<client-id>\nexport AZURE_TENANT_ID=<tenant-id>\nexport AZURE_CLIENT_SECRET=<client-secret>\n```\n\n2. **Azure CLI** (for local development):\n```bash\naz login\n```\n\n3. **Managed Identity** (for Azure resources)\n\n## Key Features\n\n\u2705 **Lists",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8127,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Python script to list secrets from Azure Key Vault and export them to a .env file.\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nExport Azure Key Vault secrets to a .env file.\n\nThis script connects to an Azure Key Vault, retrieves all enabled secrets,\nand writes them to a .env file in KEY=VALUE format.\n\nRequirements:\n    pip install azure-keyvault-secrets azure-identity\n\nEnvironment Variables:\n    AZURE_KEYVAULT_URL: The URL of your Key Vault (e.g., https://my-vault.vault.azure.net)\n\"\"\"\n\nimport os\nimport sys\nimport logging\nfrom pathlib import Path\nfrom typing import Dict\n\nfrom azure.identity import DefaultAzureCredential\nfrom azure.keyvault.secrets import SecretClient\nfrom azure.core.exceptions import ResourceNotFoundError, HttpResponseException\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\ndef get_vault_url() -> str:\n    \"\"\"Get the Key Vault URL from environment variables.\"\"\"\n    vault_url = os.getenv(\"AZURE_KEYVAULT_URL\")\n    if not vault_url:\n        logger.error(\"AZURE_KEYVAULT_URL environment variable is not set\")\n        sys.exit(1)\n    return vault_url\n\n\ndef create_secret_client(vault_url: str) -> SecretClient:\n    \"\"\"Create and return an authenticated SecretClient.\"\"\"\n    try:\n        credential = DefaultAzureCredential()\n        client = SecretClient(vault_url=vault_url, credential=credential)\n        logger.info(f\"Connected to Key Vault: {vault_url}\")\n        return client\n    except Exception as e:\n        logger.error(f\"Failed to create SecretClient: {e}\")\n        sys.exit(1)\n\n\ndef fetch_secrets(client: SecretClient) -> Dict[str, str]:\n    \"\"\"\n    Fetch all enabled secrets from the Key Vault.\n    \n    Returns:\n        Dictionary mapping secret names to their values.\n    \"\"\"\n    secrets = {}\n    \n    try:\n        # List all secret properties (doesn't include values)\n        logger.info(\"Listing secrets from Key Vault...\")\n        secret_properties = client.list_properties_of_secrets()\n        \n        for props in secret_properties:\n            secret_name = props.name\n            \n            # Skip disabled secrets\n            if not props.enabled:\n                logger.info(f\"Skipping disabled secret: {secret_name}\")\n                continue\n            \n            try:\n                # Retrieve the actual secret value\n                secret = client.get_secret(secret_name)\n                secrets[secret_name] = secret.value\n                logger.info(f\"Retrieved secret: {secret_name}\")\n                \n            except ResourceNotFoundError:\n                logger.warning(f\"Secret not found: {secret_name}\")\n            except HttpResponseException as e:\n                if e.status_code == 403:\n                    logger.error(f\"Access denied for secret: {secret_name}\")\n                else:\n                    logger.error(f\"HTTP error retrieving {secret_name}: {e.status_code}\")\n            except Exception as e:\n                logger.error(f\"Error retrieving secret {secret_name}: {e}\")\n        \n        logger.info(f\"Successfully retrieved {len(secrets)} secrets\")\n        return secrets\n        \n    except HttpResponseException as e:\n        if e.status_code == 403:\n            logger.error(\"Access denied - check Key Vault permissions\")\n        elif e.status_code == 429:\n            logger.error(\"Rate limited - too many requests\")\n        else:\n            logger.error(f\"HTTP error listing secrets: {e.status_code}\")\n        sys.exit(1)\n    except Exception as e:\n        logger.error(f\"Error listing secrets: {e}\")\n        sys.exit(1)\n\n\ndef sanitize_key_name(name: str) -> str:\n    \"\"\"\n    Convert Key Vault secret name to valid environment variable name.\n    \n    Key Vault allows hyphens, but env vars typically use underscores.\n    \"\"\"\n    return name.replace(\"-\", \"_\").upper()\n\n\ndef write_env_file(secrets: Dict[str, str], output_path: Path) -> None:\n    \"\"\"\n    Write secrets to a .env file.\n    \n    Args:\n        secrets: Dictionary of secret names and values\n        output_path: Path to the output .env file\n    \"\"\"\n    try:\n        with open(output_path, 'w') as f:\n            f.write(\"# Generated from Azure Key Vault\\n\")\n            f.write(\"# DO NOT COMMIT THIS FILE\\n\\n\")\n            \n            for name, value in sorted(secrets.items()):\n                env_var_name = sanitize_key_name(name)\n                # Escape quotes and newlines in values\n                escaped_value = value.replace('\"', '\\\\\"').replace('\\n', '\\\\n')\n                f.write(f'{env_var_name}=\"{escaped_value}\"\\n')\n        \n        logger.info(f\"Successfully wrote {len(secrets)} secrets to {output_path}\")\n        \n        # Set restrictive permissions (owner read/write only)\n        output_path.chmod(0o600)\n        logger.info(f\"Set file permissions to 600 (owner read/write only)\")\n        \n    except IOError as e:\n        logger.error(f\"Failed to write .env file: {e}\")\n        sys.exit(1)\n\n\ndef main():\n    \"\"\"Main execution function.\"\"\"\n    # Get Key Vault URL\n    vault_url = get_vault_url()\n    \n    # Create client\n    client = create_secret_client(vault_url)\n    \n    # Fetch secrets\n    secrets = fetch_secrets(client)\n    \n    if not secrets:\n        logger.warning(\"No enabled secrets found in Key Vault\")\n        return\n    \n    # Write to .env file\n    output_path = Path(\".env\")\n    write_env_file(secrets, output_path)\n    \n    logger.info(\"\u2713 Export complete!\")\n    logger.info(f\"  Secrets exported: {len(secrets)}\")\n    logger.info(f\"  Output file: {output_path.absolute()}\")\n    logger.info(\"\\nRemember to add .env to your .gitignore file!\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNow let me create a requirements file and usage documentation:\n\n```txt\n# requirements.txt\nazure-keyvault-secrets>=4.8.0\nazure-identity>=1.15.0\n```\n\n```markdown\n# Azure Key Vault Secret Exporter\n\n## Setup\n\n1. Install dependencies:\n```bash\npip install -r requirements.txt\n```\n\n2. Set the Key Vault URL:\n```bash\nexport AZURE_KEYVAULT_URL=\"https://your-vault-name.vault.azure.net\"\n```\n\n3. Ensure you're authenticated with Azure:\n```bash\n# Using Azure CLI\naz login\n\n# Or set service principal credentials\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\n```\n\n## Usage\n\nRun the script:\n```bash\npython export_keyvault_secrets.py\n```\n\nThis will create a `.env` file in the current directory with all enabled secrets.\n\n## Key Features\n\n- \u2713 Uses DefaultAzureCredential for flexible authentication\n- \u2713 Only exports enabled secrets\n- \u2713 Converts secret names to valid environment variable names (hyphens \u2192 underscores)\n- \u2713 Escapes special characters in values\n- \u2713 Sets restrictive file permissions (600)\n- \u2713 Comprehensive error handling and logging\n- \u2713 Skips disabled secrets automatically\n\n## Security Notes\n\n- The generated `.env` file contains sensitive data\n- File permissions are automatically set to 600 (owner read/write only)\n- **Always add `.env` to your `.gitignore`**\n- Never commit the `.env` file to version control\n\n## Example Output\n\n```\n2024-01-15 10:30:00 - INFO - Connected to Key Vault: https://my-vault.vault.azure.net\n2024-01-15 10:30:01 - INFO - Listing secrets from Key Vault...\n2024-01-15 10:30:01 - INFO - Retrieved secret: database-password\n2024-01-15 10:30:01 - INFO - Retrieved secret: api-key\n2024-01-15 10:30:01 - INFO - Skipping disabled secret: old-secret\n2024-01-15 10:30:02 - INFO - Successfully retrieved 2 secrets\n2024-01-15 10:30:02 - INFO - Successfully wrote 2 secrets to .env\n2024-01-15 10:30:02 - INFO - \u2713 Export complete!\n```\n\n## Troubleshooting\n\n**403 Forbidden**: Ensure your Azure identity has \"Get\" and \"List\" permissions on Key Vault secrets.\n\n**AZURE_KEYVAULT_URL not set**: Export the environment variable with your vault URL.\n\n**Authentication failed**: Run `az login` or set service principal credentials.\n```\n\nThe script includes:\n\n1. **DefaultAzureCredential authentication** - Works with Azure CLI, managed identity, service principals, etc.\n2. **Lists all secrets** - Uses `list_properties_of_secrets()` to get secret metadata\n3. **Retrieves enabled secrets only** - Checks `props.enabled` before fetching values\n4. **Exports to .env file** - Writes in `KEY=VALUE` format with proper escaping\n5. **Error handling** - Handles 403 (access denied), 404 (not found), 429 (rate limit)\n6. **Security** - Sets file permissions to 600, sanitizes secret names\n7. **Logging** - Comprehensive logging for debugging\n\nThe script follows the patterns from the reference documentation and handles all the edge cases properly.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8653,
            "output_tokens": 2450,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-security-keyvault-secrets-java-03",
      "task_type": "similar_syntax",
      "target_language": "java",
      "expected_patterns": [
        "SecretAsyncClient",
        "buildAsyncClient\\(\\)",
        "subscribe\\(",
        "Mono|Flux|reactor",
        "getSecret\\(",
        "onError|doOnError|onErrorResume"
      ],
      "anti_patterns": [
        "buildClient\\(\\)(?!.*Async)",
        "secretClient\\.getSecret(?!.*subscribe)",
        "CompletableFuture",
        "async def|await ",
        "asyncio"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretasyncclient",
          "description": "Java SecretAsyncClient: reactive getSecret returning Mono, subscribe-based consumption"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclientbuilder",
          "description": "Java SecretClientBuilder.buildAsyncClient() for async client creation"
        },
        {
          "url": "https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html",
          "description": "Project Reactor Mono/Flux: subscribe() consumption pattern for reactive types, onErrorResume and doOnError for reactive error handling as required by prompt"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclient",
          "description": "Anti-patterns: sync SecretClient with buildClient() and blocking getSecret calls"
        },
        {
          "url": "https://docs.python.org/3/library/asyncio.html",
          "description": "Anti-patterns: Python async def, await, asyncio patterns"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Azure Key Vault Secrets Async Client Application\n\nI'll create a comprehensive Java application that demonstrates concurrent secret retrieval using Azure Key Vault's async client with reactive patterns.\n\n## Project Structure\n\n```\nazure-keyvault-async/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/main/java/com/example/keyvault/\n\u2502   \u251c\u2500\u2500 KeyVaultAsyncApplication.java\n\u2502   \u251c\u2500\u2500 config/\n\u2502   \u2502   \u251c\u2500\u2500 KeyVaultConfig.java\n\u2502   \u2502   \u2514\u2500\u2500 SecretConfiguration.java\n\u2502   \u251c\u2500\u2500 service/\n\u2502   \u2502   \u251c\u2500\u2500 SecretRetrievalService.java\n\u2502   \u2502   \u2514\u2500\u2500 ConfigurationService.java\n\u2502   \u251c\u2500\u2500 model/\n\u2502   \u2502   \u251c\u2500\u2500 SecretResult.java\n\u2502   \u2502   \u2514\u2500\u2500 SecretStatus.java\n\u2502   \u2514\u2500\u2500 exception/\n\u2502       \u2514\u2500\u2500 SecretRetrievalException.java\n\u2514\u2500\u2500 src/main/resources/\n    \u2514\u2500\u2500 application.properties\n```\n\n## 1. Maven Dependencies (pom.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>azure-keyvault-async</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <properties>\n        <maven.compiler.source>17</maven.compiler.source>\n        <maven.compiler.target>17</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.version>1.2.18</azure.version>\n        <reactor.version>3.5.11</reactor.version>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>4.6.4</version>\n        </dependency>\n\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>1.11.0</version>\n        </dependency>\n\n        <!-- Reactor Core -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-core</artifactId>\n            <version>${reactor.version}</version>\n        </dependency>\n\n        <!-- SLF4J API -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n\n        <!-- Logback Classic -->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.4.11</version>\n        </dependency>\n\n        <!-- Lombok (Optional) -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.30</version>\n            <scope>provided</scope>\n        </dependency>\n\n        <!-- JUnit 5 -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.10.0</version>\n            <scope>test</scope>\n        </dependency>\n\n        <!-- Reactor Test -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-test</artifactId>\n            <version>${reactor.version}</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.0</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.example.keyvault.KeyVaultAsyncApplication</mainClass>\n                                </transformer>\n                            </transformers>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 2. Model Classes\n\n### SecretStatus.java\n```java\npackage com.example.keyvault.model;\n\npublic enum SecretStatus {\n    SUCCESS,\n    FAILED,\n    NOT_FOUND,\n    UNAUTHORIZED,\n    TIMEOUT\n}\n```\n\n### SecretResult.java\n```java\npackage com.example.keyvault.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.time.Instant;\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class SecretResult {\n    private String secretName;\n    private String secretValue;\n    private SecretStatus status;\n    private String errorMessage;\n    private Instant retrievedAt;\n    private long retrievalTimeMs;\n\n    public boolean isSuccess() {\n        return status == SecretStatus.SUCCESS;\n    }\n\n    public static SecretResult success(String name, String value, long timeMs) {\n        return SecretResult.builder()\n                .secretName(name)\n                .secretValue(value)\n                .status(SecretStatus.SUCCESS)\n                .retrievedAt(Instant.now())\n                .retrievalTimeMs(timeMs)\n                .build();\n    }\n\n    public static SecretResult failure(String name, SecretStatus status, String error, long timeMs) {\n        return SecretResult.builder()\n                .secretName(name)\n                .status(status)\n                .errorMessage(error)\n                .retrievedAt(Instant.now())\n                .retrievalTimeMs(timeMs)\n                .build();\n    }\n}\n```\n\n## 3. Configuration Classes\n\n### KeyVaultConfig.java\n```java\npackage com.example.keyvault.config;\n\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretAsyncClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\npublic class KeyVaultConfig {\n    private static final Logger logger = LoggerFactory.getLogger(KeyVaultConfig.class);\n    \n    private final String keyVaultUrl;\n    private final Duration timeout;\n    private final int maxRetries;\n\n    public KeyVaultConfig(String keyVaultUrl) {\n        this(keyVaultUrl, Duration.ofSeconds(30), 3);\n    }\n\n    public KeyVaultConfig(String keyVaultUrl, Duration timeout, int maxRetries) {\n        this.keyVaultUrl = keyVaultUrl;\n        this.timeout = timeout;\n        this.maxRetries = maxRetries;\n    }\n\n    public SecretAsyncClient createSecretAsyncClient() {\n        logger.info(\"Creating SecretAsyncClient for Key Vault: {}\", keyVaultUrl);\n        \n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .build();\n\n        return new SecretClientBuilder()\n                .vaultUrl(keyVaultUrl)\n                .credential(credential)\n                .buildAsyncClient();\n    }\n\n    public String getKeyVaultUrl() {\n        return keyVaultUrl;\n    }\n\n    public Duration getTimeout() {\n        return timeout;\n    }\n\n    public int getMaxRetries() {\n        return maxRetries;\n    }\n}\n```\n\n### SecretConfiguration.java\n```java\npackage com.example.keyvault.config;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class SecretConfiguration {\n    private Map<String, String> secrets;\n    private Map<String, String> errors;\n    private int successCount;\n    private int failureCount;\n    private long totalRetrievalTimeMs;\n\n    public static SecretConfiguration empty() {\n        return SecretConfiguration.builder()\n                .secrets(new HashMap<>())\n                .errors(new HashMap<>())\n                .successCount(0)\n                .failureCount(0)\n                .totalRetrievalTimeMs(0)\n                .build();\n    }\n\n    public void addSecret(String name, String value) {\n        if (secrets == null) {\n            secrets = new HashMap<>();\n        }\n        secrets.put(name, value);\n        successCount++;\n    }\n\n    public void addError(String name, String error) {\n        if (errors == null) {\n            errors = new HashMap<>();\n        }\n        errors.put(name, error);\n        failureCount++;\n    }\n\n    public String getSecret(String name) {\n        return secrets != null ? secrets.get(name) : null;\n    }\n\n    public boolean hasSecret(String name) {\n        return secrets != null && secrets.containsKey(name);\n    }\n\n    public double getSuccessRate() {\n        int total = successCount + failureCount;\n        return total > 0 ? (double) successCount / total * 100 : 0.0;\n    }\n}\n```\n\n## 4. Exception Class\n\n### SecretRetrievalException.java\n```java\npackage com.example.keyvault.exception;\n\npublic class SecretRetrievalException extends RuntimeException {\n    private final String secretName;\n\n    public SecretRetrievalException(String secretName, String message) {\n        super(message);\n        this.secretName = secretName;\n    }\n\n    public SecretRetrievalException(String secretName, String message, Throwable cause) {\n        super(message, cause);\n        this.secretName = secretName;\n    }\n\n    public String getSecretName() {\n        return secretName;\n    }\n}\n```\n\n## 5. Service Classes\n\n### SecretRetrievalService.java\n```java\npackage com.example.keyvault.service;\n\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.security.keyvault.secrets.SecretAsyncClient;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.example.keyvault.config.KeyVaultConfig;\nimport com.example.keyvault.model.SecretResult;\nimport com.example.keyvault.model.SecretStatus;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport reactor.util.retry.Retry;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.concurrent.TimeoutException;\n\npublic class SecretRetrievalService {\n    private static final Logger logger = LoggerFactory.getLogger(SecretRetrievalService.class);\n    \n    private final SecretAsyncClient secretAsyncClient;\n    private final KeyVaultConfig config;\n\n    public SecretRetrievalService(SecretAsyncClient secretAsyncClient, KeyVaultConfig config) {\n        this.secretAsyncClient = secretAsyncClient;\n        this.config = config;\n    }\n\n    /**\n     * Retrieve a single secret with error handling and retry logic\n     */\n    public Mono<SecretResult> retrieveSecret(String secretName) {\n        logger.debug(\"Starting retrieval for secret: {}\", secretName);\n        long startTime = System.currentTimeMillis();\n\n        return secretAsyncClient.getSecret(secretName)\n                .timeout(config.getTimeout())\n                .retryWhen(Retry.backoff(config.getMaxRetries(), Duration.ofMillis(100))\n                        .filter(throwable -> !(throwable instanceof ResourceNotFoundException))\n                        .doBeforeRetry(retrySignal -> \n                            logger.warn(\"Retrying secret retrieval for {}: attempt {}\", \n                                secretName, retrySignal.totalRetries() + 1)))\n                .map(secret -> {\n                    long duration = System.currentTimeMillis() - startTime;\n                    logger.info(\"Successfully retrieved secret: {} in {}ms\", secretName, duration);\n                    return SecretResult.success(secretName, secret.getValue(), duration);\n                })\n                .onErrorResume(throwable -> {\n                    long duration = System.currentTimeMillis() - startTime;\n                    return Mono.just(handleSecretError(secretName, throwable, duration));\n                });\n    }\n\n    /**\n     * Retrieve multiple secrets concurrently\n     */\n    public Flux<SecretResult> retrieveSecretsConcurrently(List<String> secretNames) {\n        logger.info(\"Starting concurrent retrieval of {} secrets\", secretNames.size());\n        \n        return Flux.fromIterable(secretNames)\n                .flatMap(this::retrieveSecret)\n                .doOnComplete(() -> logger.info(\"Completed retrieval of all secrets\"));\n    }\n\n    /**\n     * Retrieve multiple secrets with controlled concurrency\n     */\n    public Flux<SecretResult> retrieveSecretsWithConcurrency(List<String> secretNames, int concurrency) {\n        logger.info(\"Starting retrieval of {} secrets with concurrency level: {}\", \n            secretNames.size(), concurrency);\n        \n        return Flux.fromIterable(secretNames)\n                .flatMap(this::retrieveSecret, concurrency)\n                .doOnComplete(() -> logger.info(\"Completed retrieval with concurrency control\"));\n    }\n\n    /**\n     * Retrieve secrets in parallel with a timeout for the entire operation\n     */\n    public Mono<List<SecretResult>> retrieveSecretsWithGlobalTimeout(\n            List<String> secretNames, Duration globalTimeout) {\n        \n        logger.info(\"Starting retrieval with global timeout: {}\", globalTimeout);\n        \n        return Flux.fromIterable(secretNames)\n                .flatMap(this::retrieveSecret)\n                .collectList()\n                .timeout(globalTimeout)\n                .onErrorResume(TimeoutException.class, e -> {\n                    logger.error(\"Global timeout exceeded for secret retrieval\");\n                    return Mono.just(secretNames.stream()\n                            .map(name -> SecretResult.failure(\n                                name, \n                                SecretStatus.TIMEOUT, \n                                \"Global timeout exceeded\", \n                                globalTimeout.toMillis()))\n                            .toList());\n                });\n    }\n\n    /**\n     * Handle errors during secret retrieval\n     */\n    private SecretResult handleSecretError(String secretName, Throwable throwable, long duration) {\n        logger.error(\"Error retrieving secret {}: {}\", secretName, throwable.getMessage());\n\n        if (throwable instanceof ResourceNotFoundException) {\n            return SecretResult.failure(\n                secretName, \n                SecretStatus.NOT_FOUND, \n                \"Secret not found in Key Vault\", \n                duration\n            );\n        } else if (throwable instanceof TimeoutException) {\n            return SecretResult.failure(\n                secretName, \n                SecretStatus.TIMEOUT, \n                \"Timeout while retrieving secret\", \n                duration\n            );",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 60,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secrets Async Configuration Loader\n\nI'll create a comprehensive Java application that demonstrates concurrent secret retrieval using the Azure Key Vault Secrets async client with proper error handling and reactive patterns.\n\n## Project Structure\n\n```\nkeyvault-async-config/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 keyvault/\n\u2502       \u2502               \u2514\u2500\u2500 demo/\n\u2502       \u2502                   \u251c\u2500\u2500 AsyncConfigLoader.java\n\u2502       \u2502                   \u251c\u2500\u2500 ConfigurationManager.java\n\u2502       \u2502                   \u251c\u2500\u2500 SecretResult.java\n\u2502       \u2502                   \u251c\u2500\u2500 SecretStatus.java\n\u2502       \u2502                   \u2514\u2500\u2500 KeyVaultConfigDemo.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u2514\u2500\u2500 application.properties\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.keyvault</groupId>\n    <artifactId>keyvault-async-config</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Key Vault Async Configuration Loader</name>\n    <description>Concurrent secret retrieval with reactive patterns</description>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <azure.version>1.2.19</azure.version>\n    </properties>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.azure</groupId>\n                <artifactId>azure-sdk-bom</artifactId>\n                <version>${azure.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n        </dependency>\n\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n        </dependency>\n\n        <!-- Reactor Core (included transitively, but explicit for clarity) -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-core</artifactId>\n        </dependency>\n\n        <!-- SLF4J API -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n\n        <!-- Logback Classic (SLF4J implementation) -->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.4.11</version>\n        </dependency>\n\n        <!-- JUnit 5 for testing -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.10.0</version>\n            <scope>test</scope>\n        </dependency>\n\n        <!-- Reactor Test -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>3.1.2</version>\n            </plugin>\n            <plugin>\n                <groupId>org.codehaus.mojo</groupId>\n                <artifactId>exec-maven-plugin</artifactId>\n                <version>3.1.0</version>\n                <configuration>\n                    <mainClass>com.azure.keyvault.demo.KeyVaultConfigDemo</mainClass>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## SecretStatus.java\n\n```java\npackage com.azure.keyvault.demo;\n\n/**\n * Enumeration representing the status of a secret retrieval operation.\n */\npublic enum SecretStatus {\n    /**\n     * Secret was successfully retrieved.\n     */\n    SUCCESS,\n    \n    /**\n     * Secret was not found in the vault.\n     */\n    NOT_FOUND,\n    \n    /**\n     * Access was denied (permission issue).\n     */\n    ACCESS_DENIED,\n    \n    /**\n     * Network or connection error occurred.\n     */\n    NETWORK_ERROR,\n    \n    /**\n     * Rate limit was exceeded.\n     */\n    RATE_LIMITED,\n    \n    /**\n     * An unexpected error occurred.\n     */\n    ERROR\n}\n```\n\n## SecretResult.java\n\n```java\npackage com.azure.keyvault.demo;\n\nimport java.time.OffsetDateTime;\nimport java.util.Optional;\n\n/**\n * Represents the result of a secret retrieval operation.\n * Contains the secret value (if successful) and metadata about the operation.\n */\npublic class SecretResult {\n    private final String secretName;\n    private final String value;\n    private final SecretStatus status;\n    private final String errorMessage;\n    private final OffsetDateTime retrievedAt;\n    private final String version;\n\n    private SecretResult(Builder builder) {\n        this.secretName = builder.secretName;\n        this.value = builder.value;\n        this.status = builder.status;\n        this.errorMessage = builder.errorMessage;\n        this.retrievedAt = builder.retrievedAt;\n        this.version = builder.version;\n    }\n\n    public String getSecretName() {\n        return secretName;\n    }\n\n    public Optional<String> getValue() {\n        return Optional.ofNullable(value);\n    }\n\n    public SecretStatus getStatus() {\n        return status;\n    }\n\n    public Optional<String> getErrorMessage() {\n        return Optional.ofNullable(errorMessage);\n    }\n\n    public OffsetDateTime getRetrievedAt() {\n        return retrievedAt;\n    }\n\n    public Optional<String> getVersion() {\n        return Optional.ofNullable(version);\n    }\n\n    public boolean isSuccess() {\n        return status == SecretStatus.SUCCESS;\n    }\n\n    public boolean isFailure() {\n        return status != SecretStatus.SUCCESS;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"SecretResult{\");\n        sb.append(\"name='\").append(secretName).append('\\'');\n        sb.append(\", status=\").append(status);\n        \n        if (value != null) {\n            // Mask the value for security\n            sb.append(\", value='***'\");\n        }\n        \n        if (version != null) {\n            sb.append(\", version='\").append(version).append('\\'');\n        }\n        \n        if (errorMessage != null) {\n            sb.append(\", error='\").append(errorMessage).append('\\'');\n        }\n        \n        sb.append(\", retrievedAt=\").append(retrievedAt);\n        sb.append('}');\n        \n        return sb.toString();\n    }\n\n    /**\n     * Creates a new builder for SecretResult.\n     */\n    public static Builder builder(String secretName) {\n        return new Builder(secretName);\n    }\n\n    /**\n     * Builder for SecretResult.\n     */\n    public static class Builder {\n        private final String secretName;\n        private String value;\n        private SecretStatus status = SecretStatus.ERROR;\n        private String errorMessage;\n        private OffsetDateTime retrievedAt = OffsetDateTime.now();\n        private String version;\n\n        private Builder(String secretName) {\n            if (secretName == null || secretName.trim().isEmpty()) {\n                throw new IllegalArgumentException(\"Secret name cannot be null or empty\");\n            }\n            this.secretName = secretName;\n        }\n\n        public Builder value(String value) {\n            this.value = value;\n            return this;\n        }\n\n        public Builder status(SecretStatus status) {\n            this.status = status;\n            return this;\n        }\n\n        public Builder errorMessage(String errorMessage) {\n            this.errorMessage = errorMessage;\n            return this;\n        }\n\n        public Builder retrievedAt(OffsetDateTime retrievedAt) {\n            this.retrievedAt = retrievedAt;\n            return this;\n        }\n\n        public Builder version(String version) {\n            this.version = version;\n            return this;\n        }\n\n        public SecretResult build() {\n            return new SecretResult(this);\n        }\n    }\n}\n```\n\n## AsyncConfigLoader.java\n\n```java\npackage com.azure.keyvault.demo;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretAsyncClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport reactor.core.scheduler.Schedulers;\n\nimport java.time.Duration;\nimport java.time.OffsetDateTime;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Collectors;\n\n/**\n * Asynchronous configuration loader that retrieves multiple secrets concurrently\n * from Azure Key Vault using reactive patterns.\n */\npublic class AsyncConfigLoader {\n    private static final Logger logger = LoggerFactory.getLogger(AsyncConfigLoader.class);\n    \n    private final SecretAsyncClient secretAsyncClient;\n    private final Duration timeout;\n    private final int maxConcurrency;\n    private final int retryAttempts;\n\n    /**\n     * Creates a new AsyncConfigLoader with the specified vault URL.\n     *\n     * @param vaultUrl The Azure Key Vault URL\n     */\n    public AsyncConfigLoader(String vaultUrl) {\n        this(vaultUrl, Duration.ofSeconds(30), 10, 3);\n    }\n\n    /**\n     * Creates a new AsyncConfigLoader with custom configuration.\n     *\n     * @param vaultUrl The Azure Key Vault URL\n     * @param timeout Timeout for each secret retrieval\n     * @param maxConcurrency Maximum number of concurrent requests\n     * @param retryAttempts Number of retry attempts for failed requests\n     */\n    public AsyncConfigLoader(String vaultUrl, Duration timeout, \n                            int maxConcurrency, int retryAttempts) {\n        if (vaultUrl == null || vaultUrl.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Vault URL cannot be null or empty\");\n        }\n        \n        this.timeout = timeout;\n        this.maxConcurrency = maxConcurrency;\n        this.retryAttempts = retryAttempts;\n\n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder().build();\n        \n        this.secretAsyncClient = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(credential)\n            .buildAsyncClient();\n\n        logger.info(\"AsyncConfigLoader initialized for vault: {}\", vaultUrl);\n        logger.info(\"Configuration - timeout: {}, maxConcurrency: {}, retryAttempts: {}\", \n                   timeout, maxConcurrency, retryAttempts);\n    }\n\n    /**\n     * Retrieves a single secret asynchronously.\n     *\n     * @param secretName The name of the secret to retrieve\n     * @return Mono containing the SecretResult\n     */\n    public Mono<SecretResult> getSecret(String secretName) {\n        logger.debug(\"Retrieving secret: {}\", secretName);\n        \n        return secretAsyncClient.getSecret(secretName)\n            .timeout(timeout)\n            .retry(retryAttempts)\n            .map(secret -> mapToSuccessResult(secret))\n            .onErrorResume(error -> Mono.just(mapToErrorResult(secretName, error)))\n            .doOnSuccess(result -> {\n                if (result.isSuccess()) {\n                    logger.info(\"Successfully retrieved secret: {}\", secretName);\n                } else {\n                    logger.warn(\"Failed to retrieve secret: {} - Status: {}\", \n                               secretName, result.getStatus());\n                }\n            });\n    }\n\n    /**\n     * Retrieves multiple secrets concurrently.\n     *\n     * @param secretNames List of secret names to retrieve\n     * @return Mono containing a map of secret names to SecretResults\n     */\n    public Mono<Map<String, SecretResult>> getSecrets(List<String> secretNames) {\n        if (secretNames == null || secretNames.isEmpty()) {\n            return Mono.just(Map.of());\n        }\n\n        logger.info(\"Starting concurrent retrieval of {} secrets\", secretNames.size());\n        long startTime = System.currentTimeMillis();\n\n        return Flux.fromIterable(secretNames)\n            .parallel(maxConcurrency)\n            .runOn(Schedulers.boundedElastic())\n            .flatMap(this::getSecret)\n            .sequential()\n            .collectMap(SecretResult::getSecretName)\n            .doOnSuccess(results -> {\n                long duration = System.currentTimeMillis() - startTime;\n                long successCount = results.values().stream()\n                    .filter(SecretResult::isSuccess)\n                    .count();\n                \n                logger.info(\"Retrieved {} secrets in {}ms ({} successful, {} failed)\",\n                           results.size(), duration, successCount, \n                           results.size() - successCount);\n            })\n            .doOnError(error -> \n                logger.error(\"Error during batch secret retrieval\", error));\n    }\n\n    /**\n     * Retrieves multiple secrets and returns only the successful ones as a configuration map.\n     *\n     * @param secretNames List of secret names to retrieve\n     * @return Mono containing a map of secret names to values (only successful retrievals)\n     */\n    public Mono<Map<String, String>> getConfigurationMap(List<String> secretNames) {\n        return getSecrets(secretNames)\n            .map(results -> results.entrySet().stream()\n                .filter(entry -> entry.getValue().isSuccess())\n                .collect(Collectors.toMap(\n                    Map.Entry::getKey,\n                    entry -> entry.getValue().getValue().orElse(\"\")\n                )));\n    }\n\n    /**\n     * Retrieves multiple secrets with detailed results including failures.\n     *\n     * @param secretNames List of secret names to retrieve\n     * @return Mono containing detailed results for all secrets\n     */\n    public Mono<ConfigurationResult> getDetailedConfiguration(List<String> secretNames) {\n        return getSecrets(secretNames)\n            .map(results -> {\n                Map<String, String> successfulSecrets = new ConcurrentHashMap<>();\n                Map<String",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8129,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses Azure Key Vault Secrets async client with reactive patterns to retrieve multiple secrets concurrently.\n\n```java\npackage com.example.app.config;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretAsyncClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Async configuration loader that retrieves multiple secrets from Azure Key Vault\n * concurrently using reactive patterns. Handles individual secret failures gracefully.\n */\n@Component\npublic class AsyncSecretConfigLoader {\n    \n    private static final Logger log = LoggerFactory.getLogger(AsyncSecretConfigLoader.class);\n    private static final Duration TIMEOUT = Duration.ofSeconds(30);\n    private static final int MAX_RETRIES = 3;\n    \n    private final SecretAsyncClient secretAsyncClient;\n    \n    public AsyncSecretConfigLoader(@Value(\"${azure.keyvault.url}\") String vaultUrl) {\n        this.secretAsyncClient = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildAsyncClient();\n        \n        log.info(\"Initialized AsyncSecretConfigLoader with vault: {}\", vaultUrl);\n    }\n    \n    /**\n     * Loads multiple secrets concurrently and returns a configuration map.\n     * Failed secrets are logged but don't fail the entire operation.\n     * \n     * @param secretNames List of secret names to retrieve\n     * @return Mono containing map of successfully retrieved secrets\n     */\n    public Mono<Map<String, String>> loadSecretsAsync(List<String> secretNames) {\n        log.info(\"Loading {} secrets concurrently\", secretNames.size());\n        \n        Map<String, String> successfulSecrets = new ConcurrentHashMap<>();\n        Map<String, String> failedSecrets = new ConcurrentHashMap<>();\n        \n        return Flux.fromIterable(secretNames)\n            .flatMap(secretName -> \n                retrieveSecretWithRetry(secretName)\n                    .doOnSuccess(secret -> {\n                        successfulSecrets.put(secret.getName(), secret.getValue());\n                        log.info(\"Successfully retrieved secret: {}\", secret.getName());\n                    })\n                    .onErrorResume(error -> {\n                        String errorMsg = handleSecretError(secretName, error);\n                        failedSecrets.put(secretName, errorMsg);\n                        return Mono.empty(); // Continue with other secrets\n                    })\n            )\n            .then(Mono.defer(() -> {\n                logResults(successfulSecrets, failedSecrets);\n                return Mono.just(successfulSecrets);\n            }))\n            .timeout(TIMEOUT)\n            .doOnError(error -> log.error(\"Timeout or fatal error loading secrets\", error));\n    }\n    \n    /**\n     * Retrieves a single secret with exponential backoff retry logic.\n     */\n    private Mono<KeyVaultSecret> retrieveSecretWithRetry(String secretName) {\n        return secretAsyncClient.getSecret(secretName)\n            .retry(MAX_RETRIES)\n            .doOnSubscribe(sub -> log.debug(\"Fetching secret: {}\", secretName));\n    }\n    \n    /**\n     * Handles different types of errors when retrieving secrets.\n     */\n    private String handleSecretError(String secretName, Throwable error) {\n        if (error instanceof ResourceNotFoundException) {\n            log.warn(\"Secret not found: {}\", secretName);\n            return \"NOT_FOUND\";\n        } else if (error instanceof HttpResponseException) {\n            HttpResponseException httpError = (HttpResponseException) error;\n            int statusCode = httpError.getResponse().getStatusCode();\n            \n            if (statusCode == 403) {\n                log.error(\"Access denied for secret: {} - Check Key Vault permissions\", secretName);\n                return \"ACCESS_DENIED\";\n            } else if (statusCode == 429) {\n                log.warn(\"Rate limited when fetching secret: {}\", secretName);\n                return \"RATE_LIMITED\";\n            } else {\n                log.error(\"HTTP error {} for secret: {}\", statusCode, secretName);\n                return \"HTTP_ERROR_\" + statusCode;\n            }\n        } else {\n            log.error(\"Unexpected error retrieving secret: {}\", secretName, error);\n            return \"ERROR: \" + error.getMessage();\n        }\n    }\n    \n    /**\n     * Logs summary of successful and failed secret retrievals.\n     */\n    private void logResults(Map<String, String> successful, Map<String, String> failed) {\n        log.info(\"Secret retrieval complete: {} successful, {} failed\", \n            successful.size(), failed.size());\n        \n        if (!failed.isEmpty()) {\n            log.warn(\"Failed secrets: {}\", failed.keySet());\n            failed.forEach((name, reason) -> \n                log.debug(\"  {} -> {}\", name, reason));\n        }\n    }\n    \n    /**\n     * Loads secrets and returns a blocking result (for non-reactive contexts).\n     */\n    public Map<String, String> loadSecretsBlocking(List<String> secretNames) {\n        return loadSecretsAsync(secretNames)\n            .block(TIMEOUT);\n    }\n    \n    /**\n     * Retrieves a single secret asynchronously with error handling.\n     */\n    public Mono<String> getSecretValueAsync(String secretName) {\n        return secretAsyncClient.getSecret(secretName)\n            .map(KeyVaultSecret::getValue)\n            .retry(MAX_RETRIES)\n            .timeout(Duration.ofSeconds(10))\n            .doOnSuccess(value -> log.debug(\"Retrieved secret: {}\", secretName))\n            .onErrorResume(error -> {\n                handleSecretError(secretName, error);\n                return Mono.empty();\n            });\n    }\n    \n    /**\n     * Loads secrets with default values for missing ones.\n     */\n    public Mono<Map<String, String>> loadSecretsWithDefaults(\n            Map<String, String> secretNamesWithDefaults) {\n        \n        return Flux.fromIterable(secretNamesWithDefaults.entrySet())\n            .flatMap(entry -> \n                secretAsyncClient.getSecret(entry.getKey())\n                    .map(secret -> Map.entry(secret.getName(), secret.getValue()))\n                    .onErrorReturn(Map.entry(entry.getKey(), entry.getValue()))\n            )\n            .collectMap(Map.Entry::getKey, Map.Entry::getValue)\n            .doOnSuccess(map -> log.info(\"Loaded {} secrets with defaults\", map.size()));\n    }\n}\n```\n\n```java\npackage com.example.app.config;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Configuration properties for secrets to load from Key Vault.\n */\n@Configuration\n@ConfigurationProperties(prefix = \"app.secrets\")\npublic class SecretConfigProperties {\n    \n    private List<String> required = new ArrayList<>();\n    private List<String> optional = new ArrayList<>();\n    \n    public List<String> getRequired() {\n        return required;\n    }\n    \n    public void setRequired(List<String> required) {\n        this.required = required;\n    }\n    \n    public List<String> getOptional() {\n        return optional;\n    }\n    \n    public void setOptional(List<String> optional) {\n        this.optional = optional;\n    }\n    \n    public List<String> getAllSecrets() {\n        List<String> all = new ArrayList<>(required);\n        all.addAll(optional);\n        return all;\n    }\n}\n```\n\n```java\npackage com.example.app.service;\n\nimport com.example.app.config.AsyncSecretConfigLoader;\nimport com.example.app.config.SecretConfigProperties;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport reactor.core.publisher.Mono;\n\nimport jakarta.annotation.PostConstruct;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Service that manages application configuration loaded from Key Vault.\n */\n@Service\npublic class ConfigurationService {\n    \n    private static final Logger log = LoggerFactory.getLogger(ConfigurationService.class);\n    \n    private final AsyncSecretConfigLoader secretLoader;\n    private final SecretConfigProperties secretConfig;\n    private final Map<String, String> configCache = new ConcurrentHashMap<>();\n    \n    public ConfigurationService(\n            AsyncSecretConfigLoader secretLoader,\n            SecretConfigProperties secretConfig) {\n        this.secretLoader = secretLoader;\n        this.secretConfig = secretConfig;\n    }\n    \n    /**\n     * Loads all configured secrets on application startup.\n     */\n    @PostConstruct\n    public void initializeConfiguration() {\n        log.info(\"Initializing configuration from Key Vault\");\n        \n        secretLoader.loadSecretsAsync(secretConfig.getAllSecrets())\n            .doOnSuccess(secrets -> {\n                configCache.putAll(secrets);\n                validateRequiredSecrets();\n                log.info(\"Configuration initialized with {} secrets\", secrets.size());\n            })\n            .doOnError(error -> \n                log.error(\"Failed to initialize configuration\", error))\n            .subscribe();\n    }\n    \n    /**\n     * Validates that all required secrets were loaded.\n     */\n    private void validateRequiredSecrets() {\n        for (String requiredSecret : secretConfig.getRequired()) {\n            if (!configCache.containsKey(requiredSecret)) {\n                throw new IllegalStateException(\n                    \"Required secret not found: \" + requiredSecret);\n            }\n        }\n    }\n    \n    /**\n     * Gets a configuration value by key.\n     */\n    public String getConfig(String key) {\n        return configCache.get(key);\n    }\n    \n    /**\n     * Gets a configuration value with a default.\n     */\n    public String getConfig(String key, String defaultValue) {\n        return configCache.getOrDefault(key, defaultValue);\n    }\n    \n    /**\n     * Refreshes a specific secret from Key Vault.\n     */\n    public Mono<String> refreshSecret(String secretName) {\n        log.info(\"Refreshing secret: {}\", secretName);\n        \n        return secretLoader.getSecretValueAsync(secretName)\n            .doOnSuccess(value -> {\n                if (value != null) {\n                    configCache.put(secretName, value);\n                    log.info(\"Refreshed secret: {}\", secretName);\n                }\n            });\n    }\n    \n    /**\n     * Refreshes all secrets from Key Vault.\n     */\n    public Mono<Map<String, String>> refreshAllSecrets() {\n        log.info(\"Refreshing all secrets\");\n        \n        return secretLoader.loadSecretsAsync(secretConfig.getAllSecrets())\n            .doOnSuccess(secrets -> {\n                configCache.clear();\n                configCache.putAll(secrets);\n                validateRequiredSecrets();\n                log.info(\"Refreshed {} secrets\", secrets.size());\n            });\n    }\n    \n    /**\n     * Gets all current configuration values.\n     */\n    public Map<String, String> getAllConfig() {\n        return Map.copyOf(configCache);\n    }\n}\n```\n\n```java\npackage com.example.app.controller;\n\nimport com.example.app.service.ConfigurationService;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport reactor.core.publisher.Mono;\n\nimport java.util.Map;\n\n/**\n * REST controller for managing configuration.\n */\n@RestController\n@RequestMapping(\"/api/config\")\npublic class ConfigController {\n    \n    private final ConfigurationService configService;\n    \n    public ConfigController(ConfigurationService configService) {\n        this.configService = configService;\n    }\n    \n    /**\n     * Gets a specific configuration value (masked for security).\n     */\n    @GetMapping(\"/{key}\")\n    public ResponseEntity<Map<String, String>> getConfig(@PathVariable String key) {\n        String value = configService.getConfig(key);\n        \n        if (value == null) {\n            return ResponseEntity.notFound().build();\n        }\n        \n        // Mask the value for security\n        String maskedValue = maskValue(value);\n        return ResponseEntity.ok(Map.of(\n            \"key\", key,\n            \"value\", maskedValue,\n            \"masked\", \"true\"\n        ));\n    }\n    \n    /**\n     * Refreshes a specific secret from Key Vault.\n     */\n    @PostMapping(\"/refresh/{secretName}\")\n    public Mono<ResponseEntity<Map<String, String>>> refreshSecret(\n            @PathVariable String secretName) {\n        \n        return configService.refreshSecret(secretName)\n            .map(value -> ResponseEntity.ok(Map.of(\n                \"secret\", secretName,\n                \"status\", \"refreshed\"\n            )))\n            .defaultIfEmpty(ResponseEntity.notFound().build());\n    }\n    \n    /**\n     * Refreshes all secrets from Key Vault.\n     */\n    @PostMapping(\"/refresh\")\n    public Mono<ResponseEntity<Map<String, Object>>> refreshAllSecrets() {\n        return configService.refreshAllSecrets()\n            .map(secrets -> ResponseEntity.ok(Map.of(\n                \"status\", \"refreshed\",\n                \"count\", secrets.size()\n            )));\n    }\n    \n    /**\n     * Lists all configuration keys (values masked).\n     */\n    @GetMapping\n    public ResponseEntity<Map<String, String>> listConfig() {\n        Map<String, String> allConfig = configService.getAllConfig();\n        \n        // Mask all values\n        Map<String, String> maskedConfig = allConfig.entrySet().stream()\n            .collect(java.util.stream.Collectors.toMap(\n                Map.Entry::getKey,\n                e -> maskValue(e.getValue())\n            ));\n        \n        return ResponseEntity.ok(maskedConfig);\n    }\n    \n    private String maskValue(String value) {\n        if (value == null || value.length() <= 4) {\n            return \"****\";\n        }\n        return value.substring(0, 2) + \"****\" + value.substring(value.length() - 2);\n    }\n}\n```\n\n```yaml\n# src/main/resources/application.yml\nazure:\n  keyvault:\n    url: ${AZURE_KEYVAULT_URL:https://your-vault.vault.azure.net}\n\napp:\n  secrets:\n    required:\n      - database-password\n      - api-key\n      - jwt-secret\n    optional:\n      - smtp-password\n      - external-api-token\n      - cache-connection-string\n\nlogging:\n  level:\n    com.example.app.config: DEBUG\n    com.azure.security.keyvault: INFO\n```\n\n```java\npackage com.example.app;\n\nimport com.example.app.config.AsyncSecretConfigLoader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\n@SpringBootApplication\npublic class Application {\n    \n    private static final Logger log = LoggerFactory.getLogger(Application.class);\n    \n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n    \n    /**\n     * Demo of concurrent secret loading on startup.\n     */\n    @Bean",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8654,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Azure Key Vault Secrets Async Client Application\n\nI'll create a comprehensive Java application that demonstrates concurrent secret retrieval using Azure Key Vault's async client with reactive patterns.\n\n## Project Structure\n\n```\nazure-keyvault-async/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/main/java/com/example/keyvault/\n\u2502   \u251c\u2500\u2500 KeyVaultAsyncApplication.java\n\u2502   \u251c\u2500\u2500 config/\n\u2502   \u2502   \u251c\u2500\u2500 KeyVaultConfig.java\n\u2502   \u2502   \u2514\u2500\u2500 SecretConfiguration.java\n\u2502   \u251c\u2500\u2500 service/\n\u2502   \u2502   \u251c\u2500\u2500 SecretRetrievalService.java\n\u2502   \u2502   \u2514\u2500\u2500 ConfigurationService.java\n\u2502   \u251c\u2500\u2500 model/\n\u2502   \u2502   \u251c\u2500\u2500 SecretResult.java\n\u2502   \u2502   \u2514\u2500\u2500 ConfigurationMap.java\n\u2502   \u2514\u2500\u2500 exception/\n\u2502       \u2514\u2500\u2500 SecretRetrievalException.java\n\u2514\u2500\u2500 src/main/resources/\n    \u2514\u2500\u2500 application.properties\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>azure-keyvault-async</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Key Vault Async Client</name>\n    <description>Concurrent secret retrieval with reactive patterns</description>\n\n    <properties>\n        <java.version>11</java.version>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.version>1.2.18</azure.version>\n        <reactor.version>3.5.0</reactor.version>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>4.6.3</version>\n        </dependency>\n\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>1.10.0</version>\n        </dependency>\n\n        <!-- Reactor Core -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-core</artifactId>\n            <version>${reactor.version}</version>\n        </dependency>\n\n        <!-- SLF4J API -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n\n        <!-- Logback Classic -->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.4.11</version>\n        </dependency>\n\n        <!-- Lombok (Optional) -->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.30</version>\n            <scope>provided</scope>\n        </dependency>\n\n        <!-- JUnit 5 -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.10.0</version>\n            <scope>test</scope>\n        </dependency>\n\n        <!-- Reactor Test -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-test</artifactId>\n            <version>${reactor.version}</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.0</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.example.keyvault.KeyVaultAsyncApplication</mainClass>\n                                </transformer>\n                            </transformers>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## Model Classes\n\n### SecretResult.java\n\n```java\npackage com.example.keyvault.model;\n\nimport java.time.Instant;\nimport java.util.Optional;\n\n/**\n * Represents the result of a secret retrieval operation\n */\npublic class SecretResult {\n    private final String secretName;\n    private final String secretValue;\n    private final boolean success;\n    private final String errorMessage;\n    private final Instant retrievedAt;\n\n    private SecretResult(String secretName, String secretValue, \n                        boolean success, String errorMessage) {\n        this.secretName = secretName;\n        this.secretValue = secretValue;\n        this.success = success;\n        this.errorMessage = errorMessage;\n        this.retrievedAt = Instant.now();\n    }\n\n    public static SecretResult success(String secretName, String secretValue) {\n        return new SecretResult(secretName, secretValue, true, null);\n    }\n\n    public static SecretResult failure(String secretName, String errorMessage) {\n        return new SecretResult(secretName, null, false, errorMessage);\n    }\n\n    public String getSecretName() {\n        return secretName;\n    }\n\n    public Optional<String> getSecretValue() {\n        return Optional.ofNullable(secretValue);\n    }\n\n    public boolean isSuccess() {\n        return success;\n    }\n\n    public Optional<String> getErrorMessage() {\n        return Optional.ofNullable(errorMessage);\n    }\n\n    public Instant getRetrievedAt() {\n        return retrievedAt;\n    }\n\n    @Override\n    public String toString() {\n        return \"SecretResult{\" +\n                \"secretName='\" + secretName + '\\'' +\n                \", success=\" + success +\n                \", hasValue=\" + (secretValue != null) +\n                \", errorMessage='\" + errorMessage + '\\'' +\n                \", retrievedAt=\" + retrievedAt +\n                '}';\n    }\n}\n```\n\n### ConfigurationMap.java\n\n```java\npackage com.example.keyvault.model;\n\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Thread-safe configuration map that holds secrets and tracks failures\n */\npublic class ConfigurationMap {\n    private final Map<String, String> successfulSecrets;\n    private final Map<String, String> failedSecrets;\n    private final Instant createdAt;\n    private final int totalRequested;\n\n    public ConfigurationMap(int totalRequested) {\n        this.successfulSecrets = new ConcurrentHashMap<>();\n        this.failedSecrets = new ConcurrentHashMap<>();\n        this.createdAt = Instant.now();\n        this.totalRequested = totalRequested;\n    }\n\n    public void addSuccess(String key, String value) {\n        successfulSecrets.put(key, value);\n    }\n\n    public void addFailure(String key, String errorMessage) {\n        failedSecrets.put(key, errorMessage);\n    }\n\n    public Map<String, String> getSuccessfulSecrets() {\n        return Collections.unmodifiableMap(successfulSecrets);\n    }\n\n    public Map<String, String> getFailedSecrets() {\n        return Collections.unmodifiableMap(failedSecrets);\n    }\n\n    public Optional<String> getSecret(String key) {\n        return Optional.ofNullable(successfulSecrets.get(key));\n    }\n\n    public int getSuccessCount() {\n        return successfulSecrets.size();\n    }\n\n    public int getFailureCount() {\n        return failedSecrets.size();\n    }\n\n    public int getTotalRequested() {\n        return totalRequested;\n    }\n\n    public boolean isComplete() {\n        return (successfulSecrets.size() + failedSecrets.size()) == totalRequested;\n    }\n\n    public double getSuccessRate() {\n        if (totalRequested == 0) return 0.0;\n        return (double) successfulSecrets.size() / totalRequested * 100;\n    }\n\n    public Instant getCreatedAt() {\n        return createdAt;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n            \"ConfigurationMap{successful=%d, failed=%d, total=%d, successRate=%.2f%%, createdAt=%s}\",\n            getSuccessCount(), getFailureCount(), totalRequested, \n            getSuccessRate(), createdAt\n        );\n    }\n\n    public String toDetailedString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Configuration Map Summary:\\n\");\n        sb.append(\"=========================\\n\");\n        sb.append(String.format(\"Total Requested: %d\\n\", totalRequested));\n        sb.append(String.format(\"Successful: %d\\n\", getSuccessCount()));\n        sb.append(String.format(\"Failed: %d\\n\", getFailureCount()));\n        sb.append(String.format(\"Success Rate: %.2f%%\\n\", getSuccessRate()));\n        sb.append(String.format(\"Created At: %s\\n\\n\", createdAt));\n\n        if (!successfulSecrets.isEmpty()) {\n            sb.append(\"Successful Secrets:\\n\");\n            successfulSecrets.keySet().forEach(key -> \n                sb.append(String.format(\"  - %s: [REDACTED]\\n\", key))\n            );\n            sb.append(\"\\n\");\n        }\n\n        if (!failedSecrets.isEmpty()) {\n            sb.append(\"Failed Secrets:\\n\");\n            failedSecrets.forEach((key, error) -> \n                sb.append(String.format(\"  - %s: %s\\n\", key, error))\n            );\n        }\n\n        return sb.toString();\n    }\n}\n```\n\n## Exception Classes\n\n### SecretRetrievalException.java\n\n```java\npackage com.example.keyvault.exception;\n\n/**\n * Custom exception for secret retrieval operations\n */\npublic class SecretRetrievalException extends RuntimeException {\n    private final String secretName;\n\n    public SecretRetrievalException(String secretName, String message) {\n        super(message);\n        this.secretName = secretName;\n    }\n\n    public SecretRetrievalException(String secretName, String message, Throwable cause) {\n        super(message, cause);\n        this.secretName = secretName;\n    }\n\n    public String getSecretName() {\n        return secretName;\n    }\n}\n```\n\n## Configuration Classes\n\n### KeyVaultConfig.java\n\n```java\npackage com.example.keyvault.config;\n\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretAsyncClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Configuration class for Azure Key Vault client\n */\npublic class KeyVaultConfig {\n    private static final Logger logger = LoggerFactory.getLogger(KeyVaultConfig.class);\n    \n    private final String keyVaultUrl;\n    private final SecretAsyncClient secretAsyncClient;\n\n    public KeyVaultConfig(String keyVaultUrl) {\n        this.keyVaultUrl = keyVaultUrl;\n        this.secretAsyncClient = createSecretAsyncClient();\n        logger.info(\"KeyVault configuration initialized for: {}\", keyVaultUrl);\n    }\n\n    private SecretAsyncClient createSecretAsyncClient() {\n        try {\n            DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                    .build();\n\n            return new SecretClientBuilder()\n                    .vaultUrl(keyVaultUrl)\n                    .credential(credential)\n                    .buildAsyncClient();\n        } catch (Exception e) {\n            logger.error(\"Failed to create SecretAsyncClient\", e);\n            throw new RuntimeException(\"Failed to initialize Key Vault client\", e);\n        }\n    }\n\n    public SecretAsyncClient getSecretAsyncClient() {\n        return secretAsyncClient;\n    }\n\n    public String getKeyVaultUrl() {\n        return keyVaultUrl;\n    }\n}\n```\n\n### SecretConfiguration.java\n\n```java\npackage com.example.keyvault.config;\n\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Configuration for secret retrieval behavior\n */\npublic class SecretConfiguration {\n    private final List<String> secretNames;\n    private final Duration timeout;\n    private final int maxConcurrency;\n    private final boolean continueOnError;\n    private final int retryAttempts;\n\n    private SecretConfiguration(Builder builder) {\n        this.secretNames = builder.secretNames;\n        this.timeout = builder.timeout;\n        this.maxConcurrency = builder.maxConcurrency;\n        this.continueOnError = builder.continueOnError;\n        this.retryAttempts = builder.retryAttempts;\n    }\n\n    public List<String> getSecretNames() {\n        return secretNames;\n    }\n\n    public Duration getTimeout() {\n        return timeout;\n    }\n\n    public int getMaxConcurrency() {\n        return maxConcurrency;\n    }\n\n    public boolean isContinueOnError() {\n        return continueOnError;\n    }\n\n    public int getRetryAttempts() {\n        return retryAttempts;\n    }\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n        private List<String> secretNames;\n        private Duration timeout = Duration.ofSeconds(30);\n        private int maxConcurrency = 10;\n        private boolean continueOnError = true;\n        private int retryAttempts = 3;\n\n        public Builder secretNames(List<String> secretNames) {\n            this.secretNames = secretNames;\n            return this;\n        }\n\n        public Builder secretNames(String... secretNames) {\n            this.secretNames = Arrays.asList(secretNames);\n            return this;\n        }\n\n        public Builder timeout(Duration timeout) {\n            this.timeout = timeout;\n            return this;\n        }\n\n        public Builder maxConcurrency(int maxConcurrency) {\n            this.maxConcurrency = maxConcurrency;\n            return this;\n        }\n\n        public Builder continueOnError(boolean continueOnError) {\n            this.continueOnError = continueOnError;\n            return this;\n        }\n\n        public Builder retryAttempts(int retryAttempts) {\n            this.retryAttempts = retryAttempts;\n            return this;\n        }\n\n        public SecretConfiguration build() {\n            if (secretNames == null || secretNames.isEmpty()) {\n                throw new IllegalArgumentException(\"Secret names cannot be null or empty\");",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 60,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secrets Async Configuration Loader\n\nI'll create a comprehensive Java application that demonstrates concurrent secret retrieval using the Azure Key Vault Secrets async client with proper error handling and reactive patterns.\n\n## Project Structure\n\n```\nkeyvault-async-config/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 keyvault/\n\u2502       \u2502               \u2514\u2500\u2500 demo/\n\u2502       \u2502                   \u251c\u2500\u2500 AsyncConfigLoader.java\n\u2502       \u2502                   \u251c\u2500\u2500 ConfigLoaderApp.java\n\u2502       \u2502                   \u251c\u2500\u2500 model/\n\u2502       \u2502                   \u2502   \u251c\u2500\u2500 SecretConfig.java\n\u2502       \u2502                   \u2502   \u251c\u2500\u2500 SecretResult.java\n\u2502       \u2502                   \u2502   \u2514\u2500\u2500 ConfigurationMap.java\n\u2502       \u2502                   \u251c\u2500\u2500 service/\n\u2502       \u2502                   \u2502   \u251c\u2500\u2500 SecretRetriever.java\n\u2502       \u2502                   \u2502   \u2514\u2500\u2500 ConfigurationService.java\n\u2502       \u2502                   \u2514\u2500\u2500 util/\n\u2502       \u2502                       \u251c\u2500\u2500 RetryPolicy.java\n\u2502       \u2502                       \u2514\u2500\u2500 SecretValidator.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u251c\u2500\u2500 application.properties\n\u2502           \u2514\u2500\u2500 logback.xml\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.keyvault</groupId>\n    <artifactId>keyvault-async-config</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Key Vault Async Configuration Loader</name>\n    <description>Concurrent secret retrieval using Azure Key Vault Secrets async client</description>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <azure.version>1.2.19</azure.version>\n    </properties>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.azure</groupId>\n                <artifactId>azure-sdk-bom</artifactId>\n                <version>1.2.19</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>4.9.0</version>\n        </dependency>\n\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>1.11.1</version>\n        </dependency>\n\n        <!-- Reactor Core (included transitively, but explicit for clarity) -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-core</artifactId>\n            <version>3.5.11</version>\n        </dependency>\n\n        <!-- Logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.4.11</version>\n        </dependency>\n\n        <!-- Testing -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.10.1</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-test</artifactId>\n            <version>3.5.11</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.keyvault.demo.ConfigLoaderApp</mainClass>\n                                </transformer>\n                            </transformers>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## Model Classes\n\n### SecretConfig.java\n\n```java\npackage com.azure.keyvault.demo.model;\n\nimport java.time.Duration;\nimport java.util.Objects;\n\n/**\n * Configuration for a secret to be retrieved from Key Vault.\n */\npublic class SecretConfig {\n    private final String name;\n    private final String version;\n    private final boolean required;\n    private final String defaultValue;\n    private final Duration timeout;\n\n    private SecretConfig(Builder builder) {\n        this.name = Objects.requireNonNull(builder.name, \"Secret name cannot be null\");\n        this.version = builder.version;\n        this.required = builder.required;\n        this.defaultValue = builder.defaultValue;\n        this.timeout = builder.timeout;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public boolean isRequired() {\n        return required;\n    }\n\n    public String getDefaultValue() {\n        return defaultValue;\n    }\n\n    public Duration getTimeout() {\n        return timeout;\n    }\n\n    public boolean hasVersion() {\n        return version != null && !version.isEmpty();\n    }\n\n    public static Builder builder(String name) {\n        return new Builder(name);\n    }\n\n    public static class Builder {\n        private final String name;\n        private String version;\n        private boolean required = true;\n        private String defaultValue;\n        private Duration timeout = Duration.ofSeconds(10);\n\n        private Builder(String name) {\n            this.name = name;\n        }\n\n        public Builder version(String version) {\n            this.version = version;\n            return this;\n        }\n\n        public Builder required(boolean required) {\n            this.required = required;\n            return this;\n        }\n\n        public Builder defaultValue(String defaultValue) {\n            this.defaultValue = defaultValue;\n            return this;\n        }\n\n        public Builder timeout(Duration timeout) {\n            this.timeout = timeout;\n            return this;\n        }\n\n        public SecretConfig build() {\n            return new SecretConfig(this);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"SecretConfig{\" +\n                \"name='\" + name + '\\'' +\n                \", version='\" + version + '\\'' +\n                \", required=\" + required +\n                \", hasDefault=\" + (defaultValue != null) +\n                \", timeout=\" + timeout +\n                '}';\n    }\n}\n```\n\n### SecretResult.java\n\n```java\npackage com.azure.keyvault.demo.model;\n\nimport java.time.OffsetDateTime;\nimport java.util.Optional;\n\n/**\n * Result of a secret retrieval operation.\n */\npublic class SecretResult {\n    private final String name;\n    private final String value;\n    private final String version;\n    private final boolean success;\n    private final Throwable error;\n    private final OffsetDateTime retrievedAt;\n    private final boolean fromDefault;\n\n    private SecretResult(Builder builder) {\n        this.name = builder.name;\n        this.value = builder.value;\n        this.version = builder.version;\n        this.success = builder.success;\n        this.error = builder.error;\n        this.retrievedAt = builder.retrievedAt;\n        this.fromDefault = builder.fromDefault;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public Optional<String> getValue() {\n        return Optional.ofNullable(value);\n    }\n\n    public Optional<String> getVersion() {\n        return Optional.ofNullable(version);\n    }\n\n    public boolean isSuccess() {\n        return success;\n    }\n\n    public Optional<Throwable> getError() {\n        return Optional.ofNullable(error);\n    }\n\n    public OffsetDateTime getRetrievedAt() {\n        return retrievedAt;\n    }\n\n    public boolean isFromDefault() {\n        return fromDefault;\n    }\n\n    public static Builder success(String name, String value, String version) {\n        return new Builder(name)\n                .value(value)\n                .version(version)\n                .success(true);\n    }\n\n    public static Builder failure(String name, Throwable error) {\n        return new Builder(name)\n                .error(error)\n                .success(false);\n    }\n\n    public static Builder fromDefault(String name, String defaultValue) {\n        return new Builder(name)\n                .value(defaultValue)\n                .success(true)\n                .fromDefault(true);\n    }\n\n    public static class Builder {\n        private final String name;\n        private String value;\n        private String version;\n        private boolean success;\n        private Throwable error;\n        private OffsetDateTime retrievedAt = OffsetDateTime.now();\n        private boolean fromDefault = false;\n\n        private Builder(String name) {\n            this.name = name;\n        }\n\n        public Builder value(String value) {\n            this.value = value;\n            return this;\n        }\n\n        public Builder version(String version) {\n            this.version = version;\n            return this;\n        }\n\n        public Builder success(boolean success) {\n            this.success = success;\n            return this;\n        }\n\n        public Builder error(Throwable error) {\n            this.error = error;\n            return this;\n        }\n\n        public Builder retrievedAt(OffsetDateTime retrievedAt) {\n            this.retrievedAt = retrievedAt;\n            return this;\n        }\n\n        public Builder fromDefault(boolean fromDefault) {\n            this.fromDefault = fromDefault;\n            return this;\n        }\n\n        public SecretResult build() {\n            return new SecretResult(this);\n        }\n    }\n\n    @Override\n    public String toString() {\n        if (success) {\n            return String.format(\"SecretResult{name='%s', version='%s', fromDefault=%s, retrievedAt=%s}\",\n                    name, version, fromDefault, retrievedAt);\n        } else {\n            return String.format(\"SecretResult{name='%s', error='%s', retrievedAt=%s}\",\n                    name, error != null ? error.getMessage() : \"unknown\", retrievedAt);\n        }\n    }\n}\n```\n\n### ConfigurationMap.java\n\n```java\npackage com.azure.keyvault.demo.model;\n\nimport java.time.OffsetDateTime;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * Immutable configuration map containing retrieved secrets.\n */\npublic class ConfigurationMap {\n    private final Map<String, String> secrets;\n    private final Map<String, SecretResult> results;\n    private final OffsetDateTime createdAt;\n    private final int successCount;\n    private final int failureCount;\n    private final int defaultCount;\n\n    private ConfigurationMap(Builder builder) {\n        this.secrets = Collections.unmodifiableMap(new HashMap<>(builder.secrets));\n        this.results = Collections.unmodifiableMap(new HashMap<>(builder.results));\n        this.createdAt = OffsetDateTime.now();\n        this.successCount = builder.successCount;\n        this.failureCount = builder.failureCount;\n        this.defaultCount = builder.defaultCount;\n    }\n\n    public Optional<String> get(String key) {\n        return Optional.ofNullable(secrets.get(key));\n    }\n\n    public String getOrDefault(String key, String defaultValue) {\n        return secrets.getOrDefault(key, defaultValue);\n    }\n\n    public Map<String, String> asMap() {\n        return secrets;\n    }\n\n    public Map<String, SecretResult> getResults() {\n        return results;\n    }\n\n    public List<SecretResult> getSuccessfulResults() {\n        return results.values().stream()\n                .filter(SecretResult::isSuccess)\n                .collect(Collectors.toList());\n    }\n\n    public List<SecretResult> getFailedResults() {\n        return results.values().stream()\n                .filter(r -> !r.isSuccess())\n                .collect(Collectors.toList());\n    }\n\n    public OffsetDateTime getCreatedAt() {\n        return createdAt;\n    }\n\n    public int getSuccessCount() {\n        return successCount;\n    }\n\n    public int getFailureCount() {\n        return failureCount;\n    }\n\n    public int getDefaultCount() {\n        return defaultCount;\n    }\n\n    public int getTotalCount() {\n        return results.size();\n    }\n\n    public boolean hasFailures() {\n        return failureCount > 0;\n    }\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n        private final Map<String, String> secrets = new HashMap<>();\n        private final Map<String, SecretResult> results = new HashMap<>();\n        private int successCount = 0;\n        private int failureCount = 0;\n        private int defaultCount = 0;\n\n        public Builder addResult(SecretResult result) {\n            results.put(result.getName(), result);\n            \n            if (result.isSuccess()) {\n                result.getValue().ifPresent(value -> secrets.put(result.getName(), value));\n                successCount++;\n                if (result.isFromDefault()) {\n                    defaultCount++;\n                }\n            } else {\n                failureCount++;\n            }\n            \n            return this;\n        }\n\n        public Builder addResults(List<SecretResult> results) {\n            results.forEach(this::addResult);\n            return this;\n        }\n\n        public ConfigurationMap build() {\n            return new ConfigurationMap(this);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"ConfigurationMap{total=%d, success=%d, failures=%d, defaults=%d, createdAt=%s}\",\n                getTotalCount(), successCount, failureCount, defaultCount, createdAt);\n    }\n\n    public String toDetailedString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(toString()).append(\"\\n\");\n        sb.append(\"Secrets:\\n\");\n        secrets.forEach((key, value) -> {\n            SecretResult result = results.get(key);\n            String status = result.isFromDefault() ? \" (default)\" : \"\";\n            sb.append(String.format(\"  %s: %s%s\\n\", key, maskValue(value), status));\n        });\n        \n        if (hasFailures()) {\n            sb.append(\"Failures:\\n\");\n            getFailedResults().forEach(result -> {\n                String errorMsg = result.getError()\n                        .map(",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8129,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses Azure Key Vault Secrets async client with reactive patterns to retrieve multiple secrets concurrently.\n\n```java\npackage com.example.app.config;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretAsyncClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Azure Key Vault configuration loader using async reactive patterns.\n * Retrieves multiple secrets concurrently and handles individual failures gracefully.\n */\n@Component\npublic class KeyVaultConfigLoader {\n    private static final Logger log = LoggerFactory.getLogger(KeyVaultConfigLoader.class);\n    \n    private final SecretAsyncClient secretAsyncClient;\n    private final Duration timeout;\n    \n    public KeyVaultConfigLoader(\n            @Value(\"${azure.keyvault.url}\") String vaultUrl,\n            @Value(\"${azure.keyvault.timeout:30}\") int timeoutSeconds) {\n        \n        this.secretAsyncClient = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildAsyncClient();\n        \n        this.timeout = Duration.ofSeconds(timeoutSeconds);\n        \n        log.info(\"KeyVaultConfigLoader initialized with vault: {}\", vaultUrl);\n    }\n    \n    /**\n     * Load multiple secrets concurrently into a configuration map.\n     * Individual secret failures are logged but don't fail the entire operation.\n     * \n     * @param secretNames List of secret names to retrieve\n     * @return Map of successfully retrieved secrets (name -> value)\n     */\n    public Mono<Map<String, String>> loadSecrets(List<String> secretNames) {\n        log.info(\"Loading {} secrets from Key Vault\", secretNames.size());\n        \n        Map<String, String> configMap = new ConcurrentHashMap<>();\n        Map<String, String> errors = new ConcurrentHashMap<>();\n        \n        return Flux.fromIterable(secretNames)\n            .flatMap(secretName -> \n                retrieveSecretWithErrorHandling(secretName, configMap, errors)\n            )\n            .then(Mono.defer(() -> {\n                logResults(configMap, errors);\n                return Mono.just(new HashMap<>(configMap));\n            }))\n            .timeout(timeout)\n            .doOnError(error -> log.error(\"Timeout or error loading secrets\", error))\n            .onErrorReturn(new HashMap<>(configMap)); // Return partial results on timeout\n    }\n    \n    /**\n     * Retrieve a single secret with comprehensive error handling.\n     */\n    private Mono<Void> retrieveSecretWithErrorHandling(\n            String secretName,\n            Map<String, String> configMap,\n            Map<String, String> errors) {\n        \n        return secretAsyncClient.getSecret(secretName)\n            .doOnSubscribe(sub -> log.debug(\"Fetching secret: {}\", secretName))\n            .doOnSuccess(secret -> {\n                configMap.put(secretName, secret.getValue());\n                log.info(\"Successfully retrieved secret: {}\", secretName);\n            })\n            .onErrorResume(ResourceNotFoundException.class, e -> {\n                String errorMsg = \"Secret not found\";\n                errors.put(secretName, errorMsg);\n                log.warn(\"Secret '{}' not found in Key Vault\", secretName);\n                return Mono.empty();\n            })\n            .onErrorResume(HttpResponseException.class, e -> {\n                String errorMsg = handleHttpError(secretName, e);\n                errors.put(secretName, errorMsg);\n                return Mono.empty();\n            })\n            .onErrorResume(Exception.class, e -> {\n                String errorMsg = \"Unexpected error: \" + e.getMessage();\n                errors.put(secretName, errorMsg);\n                log.error(\"Unexpected error retrieving secret '{}': {}\", \n                    secretName, e.getMessage(), e);\n                return Mono.empty();\n            })\n            .then();\n    }\n    \n    /**\n     * Handle HTTP-specific errors with appropriate logging.\n     */\n    private String handleHttpError(String secretName, HttpResponseException e) {\n        int statusCode = e.getResponse().getStatusCode();\n        String errorMsg;\n        \n        switch (statusCode) {\n            case 403:\n                errorMsg = \"Access denied - check permissions\";\n                log.error(\"Access denied for secret '{}'. Check Key Vault access policies.\", \n                    secretName);\n                break;\n            case 429:\n                errorMsg = \"Rate limited - too many requests\";\n                log.warn(\"Rate limited while retrieving secret '{}'\", secretName);\n                break;\n            case 401:\n                errorMsg = \"Authentication failed\";\n                log.error(\"Authentication failed for secret '{}'\", secretName);\n                break;\n            default:\n                errorMsg = \"HTTP error: \" + statusCode;\n                log.error(\"HTTP {} error retrieving secret '{}': {}\", \n                    statusCode, secretName, e.getMessage());\n        }\n        \n        return errorMsg;\n    }\n    \n    /**\n     * Log summary of retrieval results.\n     */\n    private void logResults(Map<String, String> configMap, Map<String, String> errors) {\n        log.info(\"Secret retrieval complete: {} succeeded, {} failed\", \n            configMap.size(), errors.size());\n        \n        if (!errors.isEmpty()) {\n            log.warn(\"Failed secrets: {}\", errors.keySet());\n            errors.forEach((name, error) -> \n                log.debug(\"  {} - {}\", name, error)\n            );\n        }\n    }\n    \n    /**\n     * Load secrets with retry logic for transient failures.\n     * \n     * @param secretNames List of secret names to retrieve\n     * @param maxRetries Maximum number of retry attempts\n     * @return Map of successfully retrieved secrets\n     */\n    public Mono<Map<String, String>> loadSecretsWithRetry(\n            List<String> secretNames, \n            int maxRetries) {\n        \n        log.info(\"Loading {} secrets with retry (max {} attempts)\", \n            secretNames.size(), maxRetries);\n        \n        Map<String, String> configMap = new ConcurrentHashMap<>();\n        Map<String, String> errors = new ConcurrentHashMap<>();\n        \n        return Flux.fromIterable(secretNames)\n            .flatMap(secretName -> \n                secretAsyncClient.getSecret(secretName)\n                    .retry(maxRetries)\n                    .doOnSuccess(secret -> {\n                        configMap.put(secretName, secret.getValue());\n                        log.info(\"Retrieved secret: {}\", secretName);\n                    })\n                    .onErrorResume(e -> {\n                        errors.put(secretName, e.getMessage());\n                        log.error(\"Failed to retrieve secret '{}' after {} retries: {}\", \n                            secretName, maxRetries, e.getMessage());\n                        return Mono.empty();\n                    })\n            )\n            .then(Mono.defer(() -> {\n                logResults(configMap, errors);\n                return Mono.just(new HashMap<>(configMap));\n            }))\n            .timeout(timeout)\n            .onErrorReturn(new HashMap<>(configMap));\n    }\n    \n    /**\n     * Load a single secret asynchronously.\n     * \n     * @param secretName Name of the secret to retrieve\n     * @return Secret value or empty if not found/error\n     */\n    public Mono<String> loadSecret(String secretName) {\n        log.debug(\"Loading single secret: {}\", secretName);\n        \n        return secretAsyncClient.getSecret(secretName)\n            .map(KeyVaultSecret::getValue)\n            .doOnSuccess(value -> log.info(\"Retrieved secret: {}\", secretName))\n            .onErrorResume(ResourceNotFoundException.class, e -> {\n                log.warn(\"Secret '{}' not found\", secretName);\n                return Mono.empty();\n            })\n            .onErrorResume(e -> {\n                log.error(\"Error retrieving secret '{}': {}\", secretName, e.getMessage());\n                return Mono.empty();\n            })\n            .timeout(timeout);\n    }\n    \n    /**\n     * Check if a secret exists without retrieving its value.\n     * \n     * @param secretName Name of the secret to check\n     * @return true if secret exists and is accessible\n     */\n    public Mono<Boolean> secretExists(String secretName) {\n        return secretAsyncClient.getSecret(secretName)\n            .map(secret -> true)\n            .onErrorReturn(false)\n            .timeout(Duration.ofSeconds(5));\n    }\n}\n```\n\n```java\npackage com.example.app.config;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Configuration properties for Key Vault secret names.\n */\n@Configuration\n@ConfigurationProperties(prefix = \"app.secrets\")\npublic class SecretConfiguration {\n    \n    private List<String> required = new ArrayList<>();\n    private List<String> optional = new ArrayList<>();\n    \n    public List<String> getRequired() {\n        return required;\n    }\n    \n    public void setRequired(List<String> required) {\n        this.required = required;\n    }\n    \n    public List<String> getOptional() {\n        return optional;\n    }\n    \n    public void setOptional(List<String> optional) {\n        this.optional = optional;\n    }\n    \n    /**\n     * Get all secret names (required + optional).\n     */\n    public List<String> getAllSecrets() {\n        List<String> all = new ArrayList<>(required);\n        all.addAll(optional);\n        return all;\n    }\n}\n```\n\n```java\npackage com.example.app.service;\n\nimport com.example.app.config.KeyVaultConfigLoader;\nimport com.example.app.config.SecretConfiguration;\nimport jakarta.annotation.PostConstruct;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport reactor.core.publisher.Mono;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Service for managing application configuration from Key Vault.\n * Loads secrets on startup and provides access to configuration values.\n */\n@Service\npublic class ConfigurationService {\n    private static final Logger log = LoggerFactory.getLogger(ConfigurationService.class);\n    \n    private final KeyVaultConfigLoader keyVaultLoader;\n    private final SecretConfiguration secretConfig;\n    private final Map<String, String> configCache = new ConcurrentHashMap<>();\n    \n    public ConfigurationService(\n            KeyVaultConfigLoader keyVaultLoader,\n            SecretConfiguration secretConfig) {\n        this.keyVaultLoader = keyVaultLoader;\n        this.secretConfig = secretConfig;\n    }\n    \n    /**\n     * Load all configured secrets on application startup.\n     */\n    @PostConstruct\n    public void loadConfiguration() {\n        log.info(\"Loading configuration from Key Vault...\");\n        \n        keyVaultLoader.loadSecrets(secretConfig.getAllSecrets())\n            .doOnSuccess(secrets -> {\n                configCache.putAll(secrets);\n                log.info(\"Configuration loaded: {} secrets\", secrets.size());\n                validateRequiredSecrets();\n            })\n            .doOnError(error -> \n                log.error(\"Failed to load configuration\", error)\n            )\n            .subscribe();\n    }\n    \n    /**\n     * Validate that all required secrets were loaded.\n     */\n    private void validateRequiredSecrets() {\n        for (String requiredSecret : secretConfig.getRequired()) {\n            if (!configCache.containsKey(requiredSecret)) {\n                log.error(\"Required secret '{}' is missing!\", requiredSecret);\n                throw new IllegalStateException(\n                    \"Required secret not found: \" + requiredSecret);\n            }\n        }\n        log.info(\"All required secrets validated successfully\");\n    }\n    \n    /**\n     * Get a configuration value by key.\n     * \n     * @param key Configuration key (secret name)\n     * @return Configuration value or null if not found\n     */\n    public String getConfig(String key) {\n        return configCache.get(key);\n    }\n    \n    /**\n     * Get a configuration value with a default fallback.\n     * \n     * @param key Configuration key\n     * @param defaultValue Default value if key not found\n     * @return Configuration value or default\n     */\n    public String getConfig(String key, String defaultValue) {\n        return configCache.getOrDefault(key, defaultValue);\n    }\n    \n    /**\n     * Check if a configuration key exists.\n     */\n    public boolean hasConfig(String key) {\n        return configCache.containsKey(key);\n    }\n    \n    /**\n     * Reload a specific secret from Key Vault.\n     * \n     * @param secretName Name of the secret to reload\n     * @return Updated value or empty if failed\n     */\n    public Mono<String> reloadSecret(String secretName) {\n        log.info(\"Reloading secret: {}\", secretName);\n        \n        return keyVaultLoader.loadSecret(secretName)\n            .doOnSuccess(value -> {\n                if (value != null) {\n                    configCache.put(secretName, value);\n                    log.info(\"Secret '{}' reloaded successfully\", secretName);\n                }\n            });\n    }\n    \n    /**\n     * Reload all secrets from Key Vault.\n     * \n     * @return Map of reloaded secrets\n     */\n    public Mono<Map<String, String>> reloadAllSecrets() {\n        log.info(\"Reloading all secrets...\");\n        \n        return keyVaultLoader.loadSecrets(secretConfig.getAllSecrets())\n            .doOnSuccess(secrets -> {\n                configCache.clear();\n                configCache.putAll(secrets);\n                log.info(\"All secrets reloaded: {} total\", secrets.size());\n            });\n    }\n    \n    /**\n     * Get all loaded configuration as an immutable map.\n     */\n    public Map<String, String> getAllConfig() {\n        return Map.copyOf(configCache);\n    }\n}\n```\n\n```java\npackage com.example.app.controller;\n\nimport com.example.app.service.ConfigurationService;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport reactor.core.publisher.Mono;\n\nimport java.util.Map;\n\n/**\n * REST controller for configuration management.\n */\n@RestController\n@RequestMapping(\"/api/config\")\npublic class ConfigurationController {\n    \n    private final ConfigurationService configService;\n    \n    public ConfigurationController(ConfigurationService configService) {\n        this.configService = configService;\n    }\n    \n    /**\n     * Get a specific configuration value (masked for security).\n     */\n    @GetMapping(\"/{key}\")\n    public ResponseEntity<Map<String, Object>> getConfig(@PathVariable String key) {\n        String value = configService.getConfig(key);\n        \n        if (value == null) {\n            return ResponseEntity.notFound().build();\n        }\n        \n        // Mask the value for security\n        String maskedValue = maskValue(value);\n        \n        return ResponseEntity.ok(Map.of(\n            \"key\", key,\n            \"value\", maskedValue,\n            \"exists\", true\n        ));\n    }\n    \n    /**\n     * Check if a configuration key exists.\n     */\n    @GetMapping(\"/{key}/exists\")\n    public ResponseEntity<Map<String, Boolean>> checkConfig(@PathVariable String key) {\n        boolean exists = configService.hasConfig(key);\n        return ResponseEntity.ok(Map.of(\"exists\", exists));\n    }\n    \n    /**\n     * Reload a specific secret from Key Vault.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8654,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Azure Key Vault Secrets Async Client Application\n\nI'll create a comprehensive Java application that demonstrates concurrent secret retrieval using Azure Key Vault's async client with reactive patterns.\n\n## Project Structure\n\n```\nazure-keyvault-async/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 example/\n\u2502       \u2502           \u2514\u2500\u2500 keyvault/\n\u2502       \u2502               \u251c\u2500\u2500 KeyVaultAsyncApp.java\n\u2502       \u2502               \u251c\u2500\u2500 config/\n\u2502       \u2502               \u2502   \u251c\u2500\u2500 KeyVaultConfig.java\n\u2502       \u2502               \u2502   \u2514\u2500\u2500 ConfigurationManager.java\n\u2502       \u2502               \u251c\u2500\u2500 model/\n\u2502       \u2502               \u2502   \u251c\u2500\u2500 SecretResult.java\n\u2502       \u2502               \u2502   \u2514\u2500\u2500 SecretStatus.java\n\u2502       \u2502               \u2514\u2500\u2500 service/\n\u2502       \u2502                   \u251c\u2500\u2500 SecretRetriever.java\n\u2502       \u2502                   \u2514\u2500\u2500 SecretErrorHandler.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u2514\u2500\u2500 application.properties\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>azure-keyvault-async</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.version>1.2.18</azure.version>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>4.6.3</version>\n        </dependency>\n\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>1.10.0</version>\n        </dependency>\n\n        <!-- Reactor Core -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-core</artifactId>\n            <version>3.5.11</version>\n        </dependency>\n\n        <!-- SLF4J API -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n\n        <!-- Logback Classic -->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.4.11</version>\n        </dependency>\n\n        <!-- JUnit 5 -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.10.0</version>\n            <scope>test</scope>\n        </dependency>\n\n        <!-- Reactor Test -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-test</artifactId>\n            <version>3.5.11</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.5.0</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.example.keyvault.KeyVaultAsyncApp</mainClass>\n                                </transformer>\n                            </transformers>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## Model Classes\n\n### SecretStatus.java\n\n```java\npackage com.example.keyvault.model;\n\npublic enum SecretStatus {\n    SUCCESS,\n    FAILED,\n    NOT_FOUND,\n    ACCESS_DENIED,\n    TIMEOUT\n}\n```\n\n### SecretResult.java\n\n```java\npackage com.example.keyvault.model;\n\nimport java.time.Instant;\nimport java.util.Optional;\n\n/**\n * Represents the result of a secret retrieval operation\n */\npublic class SecretResult {\n    private final String secretName;\n    private final String secretValue;\n    private final SecretStatus status;\n    private final String errorMessage;\n    private final Instant retrievedAt;\n    private final long retrievalTimeMs;\n\n    private SecretResult(Builder builder) {\n        this.secretName = builder.secretName;\n        this.secretValue = builder.secretValue;\n        this.status = builder.status;\n        this.errorMessage = builder.errorMessage;\n        this.retrievedAt = builder.retrievedAt;\n        this.retrievalTimeMs = builder.retrievalTimeMs;\n    }\n\n    public String getSecretName() {\n        return secretName;\n    }\n\n    public Optional<String> getSecretValue() {\n        return Optional.ofNullable(secretValue);\n    }\n\n    public SecretStatus getStatus() {\n        return status;\n    }\n\n    public Optional<String> getErrorMessage() {\n        return Optional.ofNullable(errorMessage);\n    }\n\n    public Instant getRetrievedAt() {\n        return retrievedAt;\n    }\n\n    public long getRetrievalTimeMs() {\n        return retrievalTimeMs;\n    }\n\n    public boolean isSuccess() {\n        return status == SecretStatus.SUCCESS;\n    }\n\n    public static Builder builder(String secretName) {\n        return new Builder(secretName);\n    }\n\n    @Override\n    public String toString() {\n        return \"SecretResult{\" +\n                \"secretName='\" + secretName + '\\'' +\n                \", status=\" + status +\n                \", hasValue=\" + (secretValue != null) +\n                \", errorMessage='\" + errorMessage + '\\'' +\n                \", retrievalTimeMs=\" + retrievalTimeMs +\n                '}';\n    }\n\n    public static class Builder {\n        private final String secretName;\n        private String secretValue;\n        private SecretStatus status;\n        private String errorMessage;\n        private Instant retrievedAt;\n        private long retrievalTimeMs;\n\n        private Builder(String secretName) {\n            this.secretName = secretName;\n            this.retrievedAt = Instant.now();\n        }\n\n        public Builder secretValue(String secretValue) {\n            this.secretValue = secretValue;\n            return this;\n        }\n\n        public Builder status(SecretStatus status) {\n            this.status = status;\n            return this;\n        }\n\n        public Builder errorMessage(String errorMessage) {\n            this.errorMessage = errorMessage;\n            return this;\n        }\n\n        public Builder retrievedAt(Instant retrievedAt) {\n            this.retrievedAt = retrievedAt;\n            return this;\n        }\n\n        public Builder retrievalTimeMs(long retrievalTimeMs) {\n            this.retrievalTimeMs = retrievalTimeMs;\n            return this;\n        }\n\n        public SecretResult build() {\n            return new SecretResult(this);\n        }\n    }\n}\n```\n\n## Configuration Classes\n\n### KeyVaultConfig.java\n\n```java\npackage com.example.keyvault.config;\n\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretAsyncClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\n\n/**\n * Configuration class for Azure Key Vault client\n */\npublic class KeyVaultConfig {\n    private static final Logger logger = LoggerFactory.getLogger(KeyVaultConfig.class);\n    \n    private final String keyVaultUrl;\n    private final Duration timeout;\n    private final int maxRetries;\n\n    public KeyVaultConfig(String keyVaultUrl) {\n        this(keyVaultUrl, Duration.ofSeconds(30), 3);\n    }\n\n    public KeyVaultConfig(String keyVaultUrl, Duration timeout, int maxRetries) {\n        if (keyVaultUrl == null || keyVaultUrl.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Key Vault URL cannot be null or empty\");\n        }\n        this.keyVaultUrl = keyVaultUrl;\n        this.timeout = timeout;\n        this.maxRetries = maxRetries;\n    }\n\n    /**\n     * Creates and configures a SecretAsyncClient\n     */\n    public SecretAsyncClient createSecretAsyncClient() {\n        logger.info(\"Creating SecretAsyncClient for Key Vault: {}\", keyVaultUrl);\n        \n        return new SecretClientBuilder()\n                .vaultUrl(keyVaultUrl)\n                .credential(new DefaultAzureCredentialBuilder().build())\n                .buildAsyncClient();\n    }\n\n    public String getKeyVaultUrl() {\n        return keyVaultUrl;\n    }\n\n    public Duration getTimeout() {\n        return timeout;\n    }\n\n    public int getMaxRetries() {\n        return maxRetries;\n    }\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n        private String keyVaultUrl;\n        private Duration timeout = Duration.ofSeconds(30);\n        private int maxRetries = 3;\n\n        public Builder keyVaultUrl(String keyVaultUrl) {\n            this.keyVaultUrl = keyVaultUrl;\n            return this;\n        }\n\n        public Builder timeout(Duration timeout) {\n            this.timeout = timeout;\n            return this;\n        }\n\n        public Builder maxRetries(int maxRetries) {\n            this.maxRetries = maxRetries;\n            return this;\n        }\n\n        public KeyVaultConfig build() {\n            return new KeyVaultConfig(keyVaultUrl, timeout, maxRetries);\n        }\n    }\n}\n```\n\n### ConfigurationManager.java\n\n```java\npackage com.example.keyvault.config;\n\nimport com.example.keyvault.model.SecretResult;\nimport com.example.keyvault.model.SecretStatus;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Collectors;\n\n/**\n * Manages application configuration from Key Vault secrets\n */\npublic class ConfigurationManager {\n    private static final Logger logger = LoggerFactory.getLogger(ConfigurationManager.class);\n    \n    private final Map<String, String> configurationMap;\n    private final Map<String, SecretResult> secretResults;\n    private final List<String> failedSecrets;\n\n    public ConfigurationManager() {\n        this.configurationMap = new ConcurrentHashMap<>();\n        this.secretResults = new ConcurrentHashMap<>();\n        this.failedSecrets = Collections.synchronizedList(new ArrayList<>());\n    }\n\n    /**\n     * Adds a secret result to the configuration\n     */\n    public void addSecretResult(SecretResult result) {\n        secretResults.put(result.getSecretName(), result);\n        \n        if (result.isSuccess() && result.getSecretValue().isPresent()) {\n            configurationMap.put(result.getSecretName(), result.getSecretValue().get());\n            logger.info(\"Successfully added secret '{}' to configuration\", result.getSecretName());\n        } else {\n            failedSecrets.add(result.getSecretName());\n            logger.warn(\"Failed to retrieve secret '{}': {} - {}\", \n                    result.getSecretName(), \n                    result.getStatus(), \n                    result.getErrorMessage().orElse(\"Unknown error\"));\n        }\n    }\n\n    /**\n     * Gets a configuration value\n     */\n    public Optional<String> getConfig(String key) {\n        return Optional.ofNullable(configurationMap.get(key));\n    }\n\n    /**\n     * Gets a configuration value with a default\n     */\n    public String getConfig(String key, String defaultValue) {\n        return configurationMap.getOrDefault(key, defaultValue);\n    }\n\n    /**\n     * Gets all configuration as an immutable map\n     */\n    public Map<String, String> getAllConfig() {\n        return Collections.unmodifiableMap(configurationMap);\n    }\n\n    /**\n     * Gets all secret results\n     */\n    public Map<String, SecretResult> getAllSecretResults() {\n        return Collections.unmodifiableMap(secretResults);\n    }\n\n    /**\n     * Gets list of failed secret names\n     */\n    public List<String> getFailedSecrets() {\n        return Collections.unmodifiableList(failedSecrets);\n    }\n\n    /**\n     * Gets statistics about secret retrieval\n     */\n    public ConfigurationStats getStats() {\n        int total = secretResults.size();\n        int successful = (int) secretResults.values().stream()\n                .filter(SecretResult::isSuccess)\n                .count();\n        int failed = total - successful;\n        \n        Map<SecretStatus, Long> statusCounts = secretResults.values().stream()\n                .collect(Collectors.groupingBy(SecretResult::getStatus, Collectors.counting()));\n        \n        double avgRetrievalTime = secretResults.values().stream()\n                .mapToLong(SecretResult::getRetrievalTimeMs)\n                .average()\n                .orElse(0.0);\n\n        return new ConfigurationStats(total, successful, failed, statusCounts, avgRetrievalTime);\n    }\n\n    /**\n     * Prints configuration summary\n     */\n    public void printSummary() {\n        ConfigurationStats stats = getStats();\n        \n        logger.info(\"=== Configuration Summary ===\");\n        logger.info(\"Total secrets requested: {}\", stats.getTotal());\n        logger.info(\"Successfully retrieved: {}\", stats.getSuccessful());\n        logger.info(\"Failed: {}\", stats.getFailed());\n        logger.info(\"Average retrieval time: {:.2f}ms\", stats.getAvgRetrievalTime());\n        \n        if (!failedSecrets.isEmpty()) {\n            logger.warn(\"Failed secrets: {}\", String.join(\", \", failedSecrets));\n        }\n        \n        stats.getStatusCounts().forEach((status, count) -> \n            logger.info(\"Status {}: {}\", status, count));\n    }\n\n    public static class ConfigurationStats {\n        private final int total;\n        private final int successful;\n        private final int failed;\n        private final Map<SecretStatus, Long> statusCounts;\n        private final double avgRetrievalTime;\n\n        public ConfigurationStats(int total, int successful, int failed, \n                                Map<SecretStatus, Long> statusCounts, double avgRetrievalTime) {\n            this.total = total;\n            this.successful = successful;\n            this.failed = failed;\n            this.statusCounts = statusCounts;\n            this.avgRetrievalTime = avgRetrievalTime;\n        }\n\n        public int getTotal() { return total; }\n        public int getSuccessful() { return successful; }\n        public int getFailed() { return failed; }",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 60,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Secrets Async Configuration Loader\n\nI'll create a comprehensive Java application that demonstrates concurrent secret retrieval using the Azure Key Vault Secrets async client with proper error handling and reactive patterns.\n\n## Project Structure\n\n```\nkeyvault-async-config/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 keyvault/\n\u2502       \u2502               \u2514\u2500\u2500 demo/\n\u2502       \u2502                   \u251c\u2500\u2500 AsyncConfigurationLoader.java\n\u2502       \u2502                   \u251c\u2500\u2500 SecretResult.java\n\u2502       \u2502                   \u251c\u2500\u2500 ConfigurationService.java\n\u2502       \u2502                   \u2514\u2500\u2500 KeyVaultAsyncDemo.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u2514\u2500\u2500 application.properties\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.keyvault</groupId>\n    <artifactId>keyvault-async-config</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Key Vault Async Configuration Loader</name>\n    <description>Demo of concurrent secret retrieval with error handling</description>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.keyvault.version>4.9.0</azure.keyvault.version>\n        <azure.identity.version>1.13.3</azure.identity.version>\n        <reactor.version>3.6.10</reactor.version>\n        <slf4j.version>2.0.16</slf4j.version>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Key Vault Secrets -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-secrets</artifactId>\n            <version>${azure.keyvault.version}</version>\n        </dependency>\n\n        <!-- Azure Identity -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure.identity.version}</version>\n        </dependency>\n\n        <!-- Reactor Core (for additional reactive utilities) -->\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-core</artifactId>\n            <version>${reactor.version}</version>\n        </dependency>\n\n        <!-- SLF4J API -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n\n        <!-- SLF4J Simple Implementation -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>${slf4j.version}</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.13.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.codehaus.mojo</groupId>\n                <artifactId>exec-maven-plugin</artifactId>\n                <version>3.4.1</version>\n                <configuration>\n                    <mainClass>com.azure.keyvault.demo.KeyVaultAsyncDemo</mainClass>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## SecretResult.java\n\n```java\npackage com.azure.keyvault.demo;\n\nimport java.time.OffsetDateTime;\nimport java.util.Objects;\n\n/**\n * Represents the result of a secret retrieval operation.\n * Contains either the secret value or error information.\n */\npublic class SecretResult {\n    private final String secretName;\n    private final String value;\n    private final boolean success;\n    private final String errorMessage;\n    private final OffsetDateTime retrievedAt;\n    private final String version;\n\n    private SecretResult(String secretName, String value, boolean success, \n                        String errorMessage, String version) {\n        this.secretName = secretName;\n        this.value = value;\n        this.success = success;\n        this.errorMessage = errorMessage;\n        this.retrievedAt = OffsetDateTime.now();\n        this.version = version;\n    }\n\n    /**\n     * Creates a successful result with a secret value.\n     */\n    public static SecretResult success(String secretName, String value, String version) {\n        return new SecretResult(secretName, value, true, null, version);\n    }\n\n    /**\n     * Creates a failed result with an error message.\n     */\n    public static SecretResult failure(String secretName, String errorMessage) {\n        return new SecretResult(secretName, null, false, errorMessage, null);\n    }\n\n    public String getSecretName() {\n        return secretName;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public boolean isSuccess() {\n        return success;\n    }\n\n    public String getErrorMessage() {\n        return errorMessage;\n    }\n\n    public OffsetDateTime getRetrievedAt() {\n        return retrievedAt;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    @Override\n    public String toString() {\n        if (success) {\n            return String.format(\"SecretResult{name='%s', success=true, version='%s', retrievedAt=%s}\",\n                    secretName, version, retrievedAt);\n        } else {\n            return String.format(\"SecretResult{name='%s', success=false, error='%s'}\",\n                    secretName, errorMessage);\n        }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        SecretResult that = (SecretResult) o;\n        return success == that.success &&\n                Objects.equals(secretName, that.secretName) &&\n                Objects.equals(value, that.value);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(secretName, value, success);\n    }\n}\n```\n\n## AsyncConfigurationLoader.java\n\n```java\npackage com.azure.keyvault.demo;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretAsyncClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport reactor.core.scheduler.Schedulers;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Collectors;\n\n/**\n * Asynchronous configuration loader that retrieves multiple secrets concurrently\n * from Azure Key Vault with individual error handling.\n */\npublic class AsyncConfigurationLoader {\n    private static final Logger logger = LoggerFactory.getLogger(AsyncConfigurationLoader.class);\n    \n    private final SecretAsyncClient secretAsyncClient;\n    private final Duration timeout;\n    private final int maxConcurrency;\n\n    /**\n     * Creates a new AsyncConfigurationLoader.\n     *\n     * @param vaultUrl The Key Vault URL\n     * @param timeout Timeout for each secret retrieval operation\n     * @param maxConcurrency Maximum number of concurrent requests\n     */\n    public AsyncConfigurationLoader(String vaultUrl, Duration timeout, int maxConcurrency) {\n        this.secretAsyncClient = new SecretClientBuilder()\n                .vaultUrl(vaultUrl)\n                .credential(new DefaultAzureCredentialBuilder().build())\n                .buildAsyncClient();\n        this.timeout = timeout;\n        this.maxConcurrency = maxConcurrency;\n        \n        logger.info(\"Initialized AsyncConfigurationLoader for vault: {}\", vaultUrl);\n        logger.info(\"Timeout: {}, Max Concurrency: {}\", timeout, maxConcurrency);\n    }\n\n    /**\n     * Retrieves a single secret with error handling.\n     *\n     * @param secretName The name of the secret to retrieve\n     * @return Mono containing SecretResult (success or failure)\n     */\n    public Mono<SecretResult> retrieveSecret(String secretName) {\n        logger.debug(\"Retrieving secret: {}\", secretName);\n        \n        return secretAsyncClient.getSecret(secretName)\n                .timeout(timeout)\n                .map(secret -> {\n                    logger.info(\"Successfully retrieved secret: {}\", secretName);\n                    return SecretResult.success(\n                            secret.getName(),\n                            secret.getValue(),\n                            secret.getProperties().getVersion()\n                    );\n                })\n                .onErrorResume(error -> {\n                    String errorMessage = formatErrorMessage(secretName, error);\n                    logger.warn(\"Failed to retrieve secret '{}': {}\", secretName, errorMessage);\n                    return Mono.just(SecretResult.failure(secretName, errorMessage));\n                });\n    }\n\n    /**\n     * Retrieves multiple secrets concurrently.\n     *\n     * @param secretNames List of secret names to retrieve\n     * @return Mono containing a map of all results (both successful and failed)\n     */\n    public Mono<Map<String, SecretResult>> retrieveSecretsConcurrently(List<String> secretNames) {\n        logger.info(\"Starting concurrent retrieval of {} secrets\", secretNames.size());\n        \n        return Flux.fromIterable(secretNames)\n                .parallel(maxConcurrency)\n                .runOn(Schedulers.boundedElastic())\n                .flatMap(this::retrieveSecret)\n                .sequential()\n                .collectMap(SecretResult::getSecretName)\n                .doOnSuccess(results -> {\n                    long successCount = results.values().stream()\n                            .filter(SecretResult::isSuccess)\n                            .count();\n                    logger.info(\"Completed retrieval: {}/{} successful\", \n                            successCount, results.size());\n                })\n                .doOnError(error -> logger.error(\"Fatal error during retrieval\", error));\n    }\n\n    /**\n     * Retrieves multiple secrets and returns only successful results as a configuration map.\n     *\n     * @param secretNames List of secret names to retrieve\n     * @return Mono containing a map of successful secret values\n     */\n    public Mono<Map<String, String>> loadConfiguration(List<String> secretNames) {\n        return retrieveSecretsConcurrently(secretNames)\n                .map(results -> results.values().stream()\n                        .filter(SecretResult::isSuccess)\n                        .collect(Collectors.toMap(\n                                SecretResult::getSecretName,\n                                SecretResult::getValue\n                        ))\n                );\n    }\n\n    /**\n     * Retrieves secrets with retry logic for transient failures.\n     *\n     * @param secretNames List of secret names to retrieve\n     * @param maxRetries Maximum number of retries for failed secrets\n     * @return Mono containing all results after retries\n     */\n    public Mono<Map<String, SecretResult>> retrieveSecretsWithRetry(\n            List<String> secretNames, int maxRetries) {\n        \n        logger.info(\"Starting retrieval with retry (max {} retries)\", maxRetries);\n        \n        return Flux.fromIterable(secretNames)\n                .parallel(maxConcurrency)\n                .runOn(Schedulers.boundedElastic())\n                .flatMap(secretName -> retrieveSecretWithRetry(secretName, maxRetries))\n                .sequential()\n                .collectMap(SecretResult::getSecretName);\n    }\n\n    /**\n     * Retrieves a single secret with retry logic.\n     */\n    private Mono<SecretResult> retrieveSecretWithRetry(String secretName, int maxRetries) {\n        return secretAsyncClient.getSecret(secretName)\n                .timeout(timeout)\n                .retry(maxRetries)\n                .map(secret -> SecretResult.success(\n                        secret.getName(),\n                        secret.getValue(),\n                        secret.getProperties().getVersion()\n                ))\n                .onErrorResume(error -> {\n                    String errorMessage = formatErrorMessage(secretName, error);\n                    logger.warn(\"Failed to retrieve '{}' after {} retries: {}\", \n                            secretName, maxRetries, errorMessage);\n                    return Mono.just(SecretResult.failure(secretName, errorMessage));\n                });\n    }\n\n    /**\n     * Lists all secrets in the vault and retrieves their values concurrently.\n     *\n     * @return Mono containing a map of all secrets in the vault\n     */\n    public Mono<Map<String, SecretResult>> retrieveAllSecrets() {\n        logger.info(\"Retrieving all secrets from vault\");\n        \n        return secretAsyncClient.listPropertiesOfSecrets()\n                .map(props -> props.getName())\n                .collectList()\n                .flatMap(this::retrieveSecretsConcurrently);\n    }\n\n    /**\n     * Retrieves secrets and provides detailed statistics.\n     *\n     * @param secretNames List of secret names to retrieve\n     * @return Mono containing results with statistics\n     */\n    public Mono<RetrievalStatistics> retrieveSecretsWithStatistics(List<String> secretNames) {\n        long startTime = System.currentTimeMillis();\n        \n        return retrieveSecretsConcurrently(secretNames)\n                .map(results -> {\n                    long duration = System.currentTimeMillis() - startTime;\n                    return new RetrievalStatistics(results, duration);\n                });\n    }\n\n    /**\n     * Formats error messages based on exception type.\n     */\n    private String formatErrorMessage(String secretName, Throwable error) {\n        if (error instanceof ResourceNotFoundException) {\n            return \"Secret not found\";\n        } else if (error instanceof HttpResponseException) {\n            HttpResponseException httpError = (HttpResponseException) error;\n            int statusCode = httpError.getResponse().getStatusCode();\n            \n            switch (statusCode) {\n                case 401:\n                    return \"Authentication failed\";\n                case 403:\n                    return \"Access denied - check permissions\";\n                case 429:\n                    return \"Rate limited - too many requests\";\n                default:\n                    return String.format(\"HTTP error %d: %s\", statusCode, error.getMessage());\n            }\n        } else if (error instanceof java.util.concurrent.TimeoutException) {\n            return \"Request timeout\";\n        } else {\n            return error.getMessage();\n        }\n    }\n\n    /**\n     * Closes the async client and releases resources.\n     */\n    public void close() {\n        logger.info(\"Closing AsyncConfigurationLoader\");\n        // SecretAsyncClient doesn't require explicit closing\n    }\n\n    /**\n     * Statistics about a retrieval operation.\n     */\n    public static class RetrievalStatistics {\n        private final Map<String, SecretResult> results;\n        private final long durationMs;\n        private final int totalCount;\n        private final int successCount;",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8129,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a comprehensive Java application that uses Azure Key Vault Secrets async client with reactive patterns to retrieve multiple secrets concurrently.\n\n```java\npackage com.example.app.config;\n\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.secrets.SecretAsyncClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport java.time.Duration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Async configuration loader that retrieves secrets from Azure Key Vault\n * using reactive patterns with concurrent fetching and individual error handling.\n */\n@Component\npublic class AsyncKeyVaultConfigLoader {\n    \n    private static final Logger log = LoggerFactory.getLogger(AsyncKeyVaultConfigLoader.class);\n    \n    private final SecretAsyncClient secretAsyncClient;\n    private final Duration timeout;\n    \n    public AsyncKeyVaultConfigLoader(\n            @Value(\"${azure.keyvault.url}\") String vaultUrl,\n            @Value(\"${azure.keyvault.timeout:30}\") int timeoutSeconds) {\n        \n        this.secretAsyncClient = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildAsyncClient();\n        \n        this.timeout = Duration.ofSeconds(timeoutSeconds);\n        \n        log.info(\"Initialized AsyncKeyVaultConfigLoader for vault: {}\", vaultUrl);\n    }\n    \n    /**\n     * Load multiple secrets concurrently and return a configuration map.\n     * Failed secrets are logged but don't fail the entire operation.\n     * \n     * @param secretNames List of secret names to retrieve\n     * @return Mono containing map of successfully retrieved secrets\n     */\n    public Mono<Map<String, String>> loadSecrets(List<String> secretNames) {\n        log.info(\"Loading {} secrets concurrently\", secretNames.size());\n        \n        return Flux.fromIterable(secretNames)\n            .flatMap(this::fetchSecretWithErrorHandling)\n            .collectMap(\n                SecretResult::getName,\n                SecretResult::getValue,\n                ConcurrentHashMap::new\n            )\n            .timeout(timeout)\n            .doOnSuccess(map -> log.info(\"Successfully loaded {} out of {} secrets\", \n                map.size(), secretNames.size()))\n            .doOnError(error -> log.error(\"Failed to load secrets\", error));\n    }\n    \n    /**\n     * Load secrets with detailed results including success/failure status.\n     * \n     * @param secretNames List of secret names to retrieve\n     * @return Mono containing detailed results for each secret\n     */\n    public Mono<ConfigLoadResult> loadSecretsWithDetails(List<String> secretNames) {\n        log.info(\"Loading {} secrets with detailed results\", secretNames.size());\n        \n        return Flux.fromIterable(secretNames)\n            .flatMap(this::fetchSecretWithResult)\n            .collectList()\n            .map(results -> {\n                Map<String, String> successfulSecrets = new HashMap<>();\n                Map<String, String> failedSecrets = new HashMap<>();\n                \n                for (SecretFetchResult result : results) {\n                    if (result.isSuccess()) {\n                        successfulSecrets.put(result.getSecretName(), result.getValue());\n                    } else {\n                        failedSecrets.put(result.getSecretName(), result.getErrorMessage());\n                    }\n                }\n                \n                return new ConfigLoadResult(successfulSecrets, failedSecrets);\n            })\n            .timeout(timeout)\n            .doOnSuccess(result -> log.info(\n                \"Load complete: {} successful, {} failed\", \n                result.getSuccessfulSecrets().size(),\n                result.getFailedSecrets().size()\n            ));\n    }\n    \n    /**\n     * Fetch a single secret with error handling that doesn't propagate errors.\n     */\n    private Mono<SecretResult> fetchSecretWithErrorHandling(String secretName) {\n        return secretAsyncClient.getSecret(secretName)\n            .map(secret -> new SecretResult(secret.getName(), secret.getValue()))\n            .doOnSuccess(result -> log.debug(\"Successfully fetched secret: {}\", secretName))\n            .onErrorResume(error -> {\n                logSecretError(secretName, error);\n                return Mono.empty(); // Skip failed secrets\n            })\n            .timeout(Duration.ofSeconds(10))\n            .onErrorResume(error -> {\n                log.warn(\"Timeout fetching secret: {}\", secretName);\n                return Mono.empty();\n            });\n    }\n    \n    /**\n     * Fetch a single secret with detailed result including error information.\n     */\n    private Mono<SecretFetchResult> fetchSecretWithResult(String secretName) {\n        return secretAsyncClient.getSecret(secretName)\n            .map(secret -> SecretFetchResult.success(\n                secret.getName(), \n                secret.getValue()\n            ))\n            .doOnSuccess(result -> log.debug(\"Successfully fetched secret: {}\", secretName))\n            .onErrorResume(error -> {\n                logSecretError(secretName, error);\n                return Mono.just(SecretFetchResult.failure(\n                    secretName, \n                    getErrorMessage(error)\n                ));\n            })\n            .timeout(Duration.ofSeconds(10))\n            .onErrorResume(error -> {\n                log.warn(\"Timeout fetching secret: {}\", secretName);\n                return Mono.just(SecretFetchResult.failure(\n                    secretName, \n                    \"Timeout after 10 seconds\"\n                ));\n            });\n    }\n    \n    /**\n     * Load secrets with retry logic for transient failures.\n     */\n    public Mono<Map<String, String>> loadSecretsWithRetry(\n            List<String> secretNames, \n            int maxRetries) {\n        \n        log.info(\"Loading {} secrets with up to {} retries\", secretNames.size(), maxRetries);\n        \n        return Flux.fromIterable(secretNames)\n            .flatMap(secretName -> \n                secretAsyncClient.getSecret(secretName)\n                    .retry(maxRetries)\n                    .map(secret -> new SecretResult(secret.getName(), secret.getValue()))\n                    .onErrorResume(error -> {\n                        logSecretError(secretName, error);\n                        return Mono.empty();\n                    })\n            )\n            .collectMap(\n                SecretResult::getName,\n                SecretResult::getValue,\n                ConcurrentHashMap::new\n            )\n            .timeout(timeout);\n    }\n    \n    /**\n     * Load secrets with fallback values for missing secrets.\n     */\n    public Mono<Map<String, String>> loadSecretsWithFallback(\n            Map<String, String> secretNamesWithDefaults) {\n        \n        log.info(\"Loading {} secrets with fallback values\", secretNamesWithDefaults.size());\n        \n        return Flux.fromIterable(secretNamesWithDefaults.entrySet())\n            .flatMap(entry -> {\n                String secretName = entry.getKey();\n                String defaultValue = entry.getValue();\n                \n                return secretAsyncClient.getSecret(secretName)\n                    .map(secret -> new SecretResult(secret.getName(), secret.getValue()))\n                    .onErrorResume(error -> {\n                        log.warn(\"Using fallback value for secret: {}\", secretName);\n                        return Mono.just(new SecretResult(secretName, defaultValue));\n                    });\n            })\n            .collectMap(\n                SecretResult::getName,\n                SecretResult::getValue,\n                ConcurrentHashMap::new\n            )\n            .timeout(timeout);\n    }\n    \n    /**\n     * Check if specific secrets exist without retrieving their values.\n     */\n    public Mono<Map<String, Boolean>> checkSecretsExist(List<String> secretNames) {\n        log.info(\"Checking existence of {} secrets\", secretNames.size());\n        \n        return Flux.fromIterable(secretNames)\n            .flatMap(secretName ->\n                secretAsyncClient.getSecret(secretName)\n                    .map(secret -> Map.entry(secretName, true))\n                    .onErrorResume(ResourceNotFoundException.class, error ->\n                        Mono.just(Map.entry(secretName, false))\n                    )\n                    .onErrorResume(error -> {\n                        log.warn(\"Error checking secret {}: {}\", secretName, error.getMessage());\n                        return Mono.just(Map.entry(secretName, false));\n                    })\n            )\n            .collectMap(Map.Entry::getKey, Map.Entry::getValue)\n            .timeout(timeout);\n    }\n    \n    private void logSecretError(String secretName, Throwable error) {\n        if (error instanceof ResourceNotFoundException) {\n            log.warn(\"Secret not found: {}\", secretName);\n        } else if (error instanceof HttpResponseException) {\n            HttpResponseException httpError = (HttpResponseException) error;\n            int statusCode = httpError.getResponse().getStatusCode();\n            if (statusCode == 403) {\n                log.error(\"Access denied for secret: {} - check Key Vault permissions\", secretName);\n            } else if (statusCode == 429) {\n                log.warn(\"Rate limited while fetching secret: {}\", secretName);\n            } else {\n                log.error(\"HTTP error {} fetching secret {}: {}\", \n                    statusCode, secretName, httpError.getMessage());\n            }\n        } else {\n            log.error(\"Error fetching secret {}: {}\", secretName, error.getMessage());\n        }\n    }\n    \n    private String getErrorMessage(Throwable error) {\n        if (error instanceof ResourceNotFoundException) {\n            return \"Secret not found\";\n        } else if (error instanceof HttpResponseException) {\n            HttpResponseException httpError = (HttpResponseException) error;\n            int statusCode = httpError.getResponse().getStatusCode();\n            return switch (statusCode) {\n                case 403 -> \"Access denied - check permissions\";\n                case 429 -> \"Rate limited\";\n                default -> \"HTTP error \" + statusCode;\n            };\n        } else {\n            return error.getMessage();\n        }\n    }\n    \n    /**\n     * Simple result holder for successful secret fetches.\n     */\n    private static class SecretResult {\n        private final String name;\n        private final String value;\n        \n        public SecretResult(String name, String value) {\n            this.name = name;\n            this.value = value;\n        }\n        \n        public String getName() {\n            return name;\n        }\n        \n        public String getValue() {\n            return value;\n        }\n    }\n    \n    /**\n     * Detailed result for individual secret fetch operations.\n     */\n    public static class SecretFetchResult {\n        private final String secretName;\n        private final String value;\n        private final boolean success;\n        private final String errorMessage;\n        \n        private SecretFetchResult(String secretName, String value, \n                                 boolean success, String errorMessage) {\n            this.secretName = secretName;\n            this.value = value;\n            this.success = success;\n            this.errorMessage = errorMessage;\n        }\n        \n        public static SecretFetchResult success(String secretName, String value) {\n            return new SecretFetchResult(secretName, value, true, null);\n        }\n        \n        public static SecretFetchResult failure(String secretName, String errorMessage) {\n            return new SecretFetchResult(secretName, null, false, errorMessage);\n        }\n        \n        public String getSecretName() {\n            return secretName;\n        }\n        \n        public String getValue() {\n            return value;\n        }\n        \n        public boolean isSuccess() {\n            return success;\n        }\n        \n        public String getErrorMessage() {\n            return errorMessage;\n        }\n    }\n    \n    /**\n     * Result of loading multiple secrets with success/failure details.\n     */\n    public static class ConfigLoadResult {\n        private final Map<String, String> successfulSecrets;\n        private final Map<String, String> failedSecrets;\n        \n        public ConfigLoadResult(Map<String, String> successfulSecrets, \n                               Map<String, String> failedSecrets) {\n            this.successfulSecrets = successfulSecrets;\n            this.failedSecrets = failedSecrets;\n        }\n        \n        public Map<String, String> getSuccessfulSecrets() {\n            return successfulSecrets;\n        }\n        \n        public Map<String, String> getFailedSecrets() {\n            return failedSecrets;\n        }\n        \n        public boolean hasFailures() {\n            return !failedSecrets.isEmpty();\n        }\n        \n        public int getSuccessCount() {\n            return successfulSecrets.size();\n        }\n        \n        public int getFailureCount() {\n            return failedSecrets.size();\n        }\n    }\n}\n```\n\nNow let's create a service that uses this loader:\n\n```java\npackage com.example.app.service;\n\nimport com.example.app.config.AsyncKeyVaultConfigLoader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport reactor.core.publisher.Mono;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Service that manages application configuration from Azure Key Vault.\n */\n@Service\npublic class ConfigurationService {\n    \n    private static final Logger log = LoggerFactory.getLogger(ConfigurationService.class);\n    \n    private final AsyncKeyVaultConfigLoader configLoader;\n    \n    // Cache for loaded configuration\n    private volatile Map<String, String> cachedConfig = new HashMap<>();\n    \n    public ConfigurationService(AsyncKeyVaultConfigLoader configLoader) {\n        this.configLoader = configLoader;\n    }\n    \n    /**\n     * Load all application secrets from Key Vault.\n     */\n    public Mono<Map<String, String>> loadApplicationConfig() {\n        List<String> requiredSecrets = Arrays.asList(\n            \"database-connection-string\",\n            \"api-key\",\n            \"jwt-secret\",\n            \"smtp-password\",\n            \"storage-account-key\"\n        );\n        \n        return configLoader.loadSecrets(requiredSecrets)\n            .doOnSuccess(config -> {\n                cachedConfig = new HashMap<>(config);\n                log.info(\"Application configuration loaded and cached\");\n            })\n            .doOnError(error -> \n                log.error(\"Failed to load application configuration\", error)\n            );\n    }\n    \n    /**\n     * Load configuration with detailed error reporting.\n     */\n    public Mono<AsyncKeyVaultConfigLoader.ConfigLoadResult> loadConfigWithDetails() {\n        List<String> requiredSecrets = Arrays.asList(\n            \"database-connection-string\",\n            \"api-key\",\n            \"jwt-secret\",\n            \"smtp-password\",\n            \"storage-account-key\"\n        );\n        \n        return configLoader.loadSecretsWithDetails(requiredSecrets)\n            .doOnSuccess(result -> {\n                if (result.hasFailures()) {\n                    log.warn(\"Configuration loaded with {} failures:\", \n                        result.getFailureCount());\n                    result.getFailedSecrets().forEach((name, error) ->\n                        log.warn(\"  - {}: {}\", name, error)\n                    );\n                }\n                \n                // Cache successful secrets\n                cachedConfig = new HashMap<>(result.getSuccessfulSecrets());\n            });\n    }\n    \n    /**\n     * Load configuration with fallback values for non-critical secrets.\n     */\n    public Mono<Map<String, String>> loadConfigWithFallbacks() {\n        Map<String, String> secretsWithDefaults = new HashMap<>();\n        secretsWithDefaults.put(\"database-connection-string\", \"",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8654,
            "output_tokens": 4096,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-security-keyvault-secrets-java-04",
      "task_type": "grounded",
      "target_language": "java",
      "expected_patterns": [
        "beginDeleteSecret\\(",
        "SyncPoller",
        "DeletedSecret",
        "waitForCompletion\\(\\)",
        "listDeletedSecrets\\(\\)",
        "beginRecoverDeletedSecret\\("
      ],
      "anti_patterns": [
        "delete_secret\\(",
        "begin_delete_secret\\(",
        "list_deleted_secrets\\(",
        "recover_deleted_secret\\(",
        "secretClient\\.delete\\("
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclient",
          "description": "Java SecretClient: beginDeleteSecret, listDeletedSecrets, beginRecoverDeletedSecret methods"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.core.util.polling.syncpoller",
          "description": "Java SyncPoller: waitForCompletion() for long-running delete/recover operations"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.models.deletedsecret",
          "description": "Java DeletedSecret model for soft-delete operations"
        },
        {
          "url": "https://learn.microsoft.com/en-us/python/api/azure-keyvault-secrets/azure.keyvault.secrets.secretclient",
          "description": "Anti-patterns: Python snake_case methods (delete_secret, begin_delete_secret, list_deleted_secrets)"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Complete Secret Manager with Soft-Delete Functionality\n\nHere's the enhanced `SecretManager` class with soft-delete handling, polling, listing deleted secrets, and recovery:\n\n```java\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.azure.security.keyvault.secrets.models.DeletedSecret;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.core.util.polling.PollResponse;\nimport com.azure.core.util.polling.LongRunningOperationStatus;\n\nimport java.time.OffsetDateTime;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SecretManager {\n    private final SecretClient client;\n\n    public SecretManager(String vaultUrl) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n\n    public KeyVaultSecret createTaggedSecret(String name, String value, Map<String, String> tags) {\n        return client.setSecret(\n            new KeyVaultSecret(name, value)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusYears(1))\n                    .setTags(tags)\n                )\n        );\n    }\n\n    /**\n     * Soft-delete a secret with polling until completion\n     * @param secretName The name of the secret to delete\n     * @return The deleted secret\n     */\n    public DeletedSecret deleteSecretWithPolling(String secretName) {\n        System.out.println(\"Starting deletion of secret: \" + secretName);\n        \n        // Begin the delete operation\n        SyncPoller<DeletedSecret, Void> poller = client.beginDeleteSecret(secretName);\n        \n        // Poll until the operation completes\n        PollResponse<DeletedSecret> pollResponse = poller.poll();\n        \n        while (!pollResponse.getStatus().isComplete()) {\n            System.out.println(\"Deletion in progress... Status: \" + pollResponse.getStatus());\n            \n            // Wait before polling again\n            try {\n                Thread.sleep(1000); // Wait 1 second between polls\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(\"Polling interrupted\", e);\n            }\n            \n            pollResponse = poller.poll();\n        }\n        \n        // Check final status\n        if (pollResponse.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n            System.out.println(\"Secret deleted successfully: \" + secretName);\n            return pollResponse.getValue();\n        } else if (pollResponse.getStatus() == LongRunningOperationStatus.FAILED) {\n            throw new RuntimeException(\"Failed to delete secret: \" + secretName);\n        }\n        \n        // Alternative: Use waitForCompletion for simpler blocking approach\n        // return poller.waitForCompletion().getValue();\n        \n        return pollResponse.getValue();\n    }\n\n    /**\n     * Soft-delete a secret with timeout\n     * @param secretName The name of the secret to delete\n     * @param timeoutSeconds Maximum time to wait for completion\n     * @return The deleted secret\n     */\n    public DeletedSecret deleteSecretWithTimeout(String secretName, long timeoutSeconds) {\n        System.out.println(\"Starting deletion of secret: \" + secretName);\n        \n        SyncPoller<DeletedSecret, Void> poller = client.beginDeleteSecret(secretName);\n        \n        // Wait for completion with timeout\n        PollResponse<DeletedSecret> response = poller.waitForCompletion(Duration.ofSeconds(timeoutSeconds));\n        \n        if (response.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n            System.out.println(\"Secret deleted successfully: \" + secretName);\n            return response.getValue();\n        } else {\n            throw new RuntimeException(\"Failed to delete secret within timeout: \" + secretName);\n        }\n    }\n\n    /**\n     * List all deleted secrets in the vault\n     * @return List of deleted secrets\n     */\n    public List<DeletedSecret> listDeletedSecrets() {\n        System.out.println(\"Listing all deleted secrets...\");\n        \n        List<DeletedSecret> deletedSecrets = new ArrayList<>();\n        \n        // Iterate through all deleted secrets\n        client.listDeletedSecrets().forEach(deletedSecret -> {\n            deletedSecrets.add(deletedSecret);\n            System.out.println(\"Found deleted secret: \" + deletedSecret.getName() + \n                             \" (Deleted on: \" + deletedSecret.getDeletedOn() + \")\");\n        });\n        \n        System.out.println(\"Total deleted secrets: \" + deletedSecrets.size());\n        return deletedSecrets;\n    }\n\n    /**\n     * List deleted secrets with detailed information\n     * @return List of deleted secrets with properties\n     */\n    public List<Map<String, Object>> listDeletedSecretsWithDetails() {\n        List<Map<String, Object>> secretDetails = new ArrayList<>();\n        \n        client.listDeletedSecrets().forEach(deletedSecret -> {\n            Map<String, Object> details = Map.of(\n                \"name\", deletedSecret.getName(),\n                \"deletedOn\", deletedSecret.getDeletedOn(),\n                \"scheduledPurgeDate\", deletedSecret.getScheduledPurgeDate(),\n                \"recoveryId\", deletedSecret.getRecoveryId() != null ? deletedSecret.getRecoveryId() : \"N/A\"\n            );\n            secretDetails.add(details);\n        });\n        \n        return secretDetails;\n    }\n\n    /**\n     * Recover a specific deleted secret\n     * @param secretName The name of the deleted secret to recover\n     * @return The recovered secret\n     */\n    public KeyVaultSecret recoverDeletedSecret(String secretName) {\n        System.out.println(\"Starting recovery of deleted secret: \" + secretName);\n        \n        // Begin the recovery operation\n        SyncPoller<KeyVaultSecret, Void> poller = client.beginRecoverDeletedSecret(secretName);\n        \n        // Wait for completion\n        PollResponse<KeyVaultSecret> response = poller.waitForCompletion();\n        \n        if (response.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n            KeyVaultSecret recoveredSecret = response.getValue();\n            System.out.println(\"Secret recovered successfully: \" + secretName);\n            return recoveredSecret;\n        } else {\n            throw new RuntimeException(\"Failed to recover secret: \" + secretName);\n        }\n    }\n\n    /**\n     * Recover a deleted secret with custom polling\n     * @param secretName The name of the deleted secret to recover\n     * @return The recovered secret\n     */\n    public KeyVaultSecret recoverDeletedSecretWithPolling(String secretName) {\n        System.out.println(\"Starting recovery of deleted secret: \" + secretName);\n        \n        SyncPoller<KeyVaultSecret, Void> poller = client.beginRecoverDeletedSecret(secretName);\n        \n        PollResponse<KeyVaultSecret> pollResponse = poller.poll();\n        \n        while (!pollResponse.getStatus().isComplete()) {\n            System.out.println(\"Recovery in progress... Status: \" + pollResponse.getStatus());\n            \n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(\"Polling interrupted\", e);\n            }\n            \n            pollResponse = poller.poll();\n        }\n        \n        if (pollResponse.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n            System.out.println(\"Secret recovered successfully: \" + secretName);\n            return pollResponse.getValue();\n        } else {\n            throw new RuntimeException(\"Failed to recover secret: \" + secretName);\n        }\n    }\n\n    /**\n     * Get a specific deleted secret (without recovering)\n     * @param secretName The name of the deleted secret\n     * @return The deleted secret\n     */\n    public DeletedSecret getDeletedSecret(String secretName) {\n        System.out.println(\"Retrieving deleted secret: \" + secretName);\n        return client.getDeletedSecret(secretName);\n    }\n\n    /**\n     * Permanently delete (purge) a deleted secret\n     * WARNING: This is irreversible!\n     * @param secretName The name of the deleted secret to purge\n     */\n    public void purgeDeletedSecret(String secretName) {\n        System.out.println(\"Permanently purging deleted secret: \" + secretName);\n        client.purgeDeletedSecret(secretName);\n        System.out.println(\"Secret purged permanently: \" + secretName);\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        String vaultUrl = \"https://your-vault-name.vault.azure.net/\";\n        SecretManager manager = new SecretManager(vaultUrl);\n\n        try {\n            // Create a secret\n            Map<String, String> tags = Map.of(\"env\", \"dev\", \"team\", \"engineering\");\n            manager.createTaggedSecret(\"test-secret\", \"secret-value\", tags);\n            System.out.println(\"Secret created\");\n\n            // Delete the secret with polling\n            DeletedSecret deleted = manager.deleteSecretWithPolling(\"test-secret\");\n            System.out.println(\"Deleted secret ID: \" + deleted.getId());\n\n            // List all deleted secrets\n            List<DeletedSecret> deletedSecrets = manager.listDeletedSecrets();\n            System.out.println(\"Found \" + deletedSecrets.size() + \" deleted secrets\");\n\n            // Recover the deleted secret\n            KeyVaultSecret recovered = manager.recoverDeletedSecret(\"test-secret\");\n            System.out.println(\"Recovered secret: \" + recovered.getName());\n\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## Key Features Implemented:\n\n1. **Soft-Delete with Polling**: \n   - `deleteSecretWithPolling()` - Manual polling with status checks\n   - `deleteSecretWithTimeout()` - Simplified with timeout\n\n2. **List Deleted Secrets**:\n   - `listDeletedSecrets()` - Returns all deleted secrets\n   - `listDeletedSecretsWithDetails()` - Returns detailed information\n\n3. **Recovery Operations**:\n   - `recoverDeletedSecret()` - Simple recovery with `waitForCompletion()`\n   - `recoverDeletedSecretWithPolling()` - Manual polling for recovery\n\n4. **Additional Utilities**:\n   - `getDeletedSecret()` - Retrieve specific deleted secret\n   - `purgeDeletedSecret()` - Permanently delete (irreversible)\n\nThe code properly handles `SyncPoller` with both manual polling and automatic completion waiting strategies.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 354,
            "output_tokens": 2771,
            "cached": false
          },
          "with_skill": {
            "output": "Here's the complete implementation with soft-delete handling, listing deleted secrets, and recovery functionality:\n\n```java\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.azure.security.keyvault.secrets.models.DeletedSecret;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.core.util.polling.PollResponse;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport java.time.OffsetDateTime;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SecretManager {\n    private final SecretClient client;\n\n    public SecretManager(String vaultUrl) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n\n    public KeyVaultSecret createTaggedSecret(String name, String value, Map<String, String> tags) {\n        return client.setSecret(\n            new KeyVaultSecret(name, value)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusYears(1))\n                    .setTags(tags)\n                )\n        );\n    }\n\n    /**\n     * Soft-delete a secret with polling support.\n     * Returns the DeletedSecret once deletion begins (before completion).\n     */\n    public DeletedSecret deleteSecretWithPolling(String secretName) {\n        System.out.printf(\"Starting deletion of secret: %s%n\", secretName);\n        \n        // Begin delete operation - returns a SyncPoller\n        SyncPoller<DeletedSecret, Void> deletePoller = client.beginDeleteSecret(secretName);\n        \n        // Get the initial poll response - DeletedSecret is accessible immediately\n        PollResponse<DeletedSecret> pollResponse = deletePoller.poll();\n        DeletedSecret deletedSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Delete initiated - Status: %s%n\", pollResponse.getStatus());\n        System.out.printf(\"Deleted Date: %s%n\", deletedSecret.getDeletedOn());\n        System.out.printf(\"Scheduled Purge Date: %s%n\", deletedSecret.getScheduledPurgeDate());\n        System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n        \n        // Wait for deletion to complete on the server\n        deletePoller.waitForCompletion();\n        System.out.printf(\"Secret '%s' deletion completed%n\", secretName);\n        \n        return deletedSecret;\n    }\n\n    /**\n     * List all deleted secrets in the vault.\n     * Returns a list of deleted secret names with their deletion info.\n     */\n    public List<DeletedSecretInfo> listDeletedSecrets() {\n        List<DeletedSecretInfo> deletedSecrets = new ArrayList<>();\n        \n        System.out.println(\"Listing all deleted secrets:\");\n        \n        for (DeletedSecret deletedSecret : client.listDeletedSecrets()) {\n            DeletedSecretInfo info = new DeletedSecretInfo(\n                deletedSecret.getName(),\n                deletedSecret.getDeletedOn(),\n                deletedSecret.getScheduledPurgeDate(),\n                deletedSecret.getRecoveryId()\n            );\n            \n            deletedSecrets.add(info);\n            \n            System.out.printf(\"  - Name: %s%n\", info.getName());\n            System.out.printf(\"    Deleted On: %s%n\", info.getDeletedOn());\n            System.out.printf(\"    Scheduled Purge: %s%n\", info.getScheduledPurgeDate());\n            System.out.printf(\"    Recovery ID: %s%n\", info.getRecoveryId());\n        }\n        \n        System.out.printf(\"Total deleted secrets: %d%n\", deletedSecrets.size());\n        return deletedSecrets;\n    }\n\n    /**\n     * Recover a specific deleted secret with polling support.\n     * Returns the recovered secret once recovery completes.\n     */\n    public KeyVaultSecret recoverDeletedSecret(String secretName) {\n        System.out.printf(\"Starting recovery of deleted secret: %s%n\", secretName);\n        \n        try {\n            // Begin recover operation - returns a SyncPoller\n            SyncPoller<KeyVaultSecret, Void> recoverPoller = \n                client.beginRecoverDeletedSecret(secretName);\n            \n            // Get the initial poll response - recovered secret is accessible immediately\n            PollResponse<KeyVaultSecret> pollResponse = recoverPoller.poll();\n            KeyVaultSecret recoveredSecret = pollResponse.getValue();\n            \n            System.out.printf(\"Recovery initiated - Status: %s%n\", pollResponse.getStatus());\n            System.out.printf(\"Secret Name: %s%n\", recoveredSecret.getName());\n            System.out.printf(\"Secret ID: %s%n\", recoveredSecret.getId());\n            \n            // Wait for recovery to complete on the server\n            recoverPoller.waitForCompletion();\n            System.out.printf(\"Secret '%s' recovery completed%n\", secretName);\n            \n            // Get the final recovered secret (may have updated properties)\n            KeyVaultSecret finalSecret = recoverPoller.getFinalResult();\n            \n            return finalSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            System.err.printf(\"Deleted secret '%s' not found. It may have been purged.%n\", secretName);\n            throw e;\n        }\n    }\n\n    /**\n     * Get details of a specific deleted secret without recovering it.\n     */\n    public DeletedSecret getDeletedSecret(String secretName) {\n        try {\n            DeletedSecret deletedSecret = client.getDeletedSecret(secretName);\n            System.out.printf(\"Found deleted secret: %s%n\", deletedSecret.getName());\n            System.out.printf(\"Deleted On: %s%n\", deletedSecret.getDeletedOn());\n            System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n            return deletedSecret;\n        } catch (ResourceNotFoundException e) {\n            System.err.printf(\"Deleted secret '%s' not found%n\", secretName);\n            throw e;\n        }\n    }\n\n    /**\n     * Permanently purge a deleted secret (cannot be recovered after this).\n     */\n    public void purgeDeletedSecret(String secretName) {\n        System.out.printf(\"Permanently purging deleted secret: %s%n\", secretName);\n        client.purgeDeletedSecret(secretName);\n        System.out.printf(\"Secret '%s' has been permanently purged%n\", secretName);\n    }\n\n    /**\n     * Helper class to store deleted secret information.\n     */\n    public static class DeletedSecretInfo {\n        private final String name;\n        private final OffsetDateTime deletedOn;\n        private final OffsetDateTime scheduledPurgeDate;\n        private final String recoveryId;\n\n        public DeletedSecretInfo(String name, OffsetDateTime deletedOn, \n                                OffsetDateTime scheduledPurgeDate, String recoveryId) {\n            this.name = name;\n            this.deletedOn = deletedOn;\n            this.scheduledPurgeDate = scheduledPurgeDate;\n            this.recoveryId = recoveryId;\n        }\n\n        public String getName() { return name; }\n        public OffsetDateTime getDeletedOn() { return deletedOn; }\n        public OffsetDateTime getScheduledPurgeDate() { return scheduledPurgeDate; }\n        public String getRecoveryId() { return recoveryId; }\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        SecretManager manager = new SecretManager(vaultUrl);\n\n        try {\n            // Create a secret with tags\n            KeyVaultSecret secret = manager.createTaggedSecret(\n                \"test-secret\",\n                \"test-value\",\n                Map.of(\"environment\", \"dev\", \"owner\", \"team-a\")\n            );\n            System.out.printf(\"Created secret: %s%n%n\", secret.getName());\n\n            // Delete the secret with polling\n            DeletedSecret deleted = manager.deleteSecretWithPolling(\"test-secret\");\n            System.out.printf(\"%nDeleted secret recovery ID: %s%n%n\", deleted.getRecoveryId());\n\n            // Wait a moment for deletion to propagate\n            Thread.sleep(2000);\n\n            // List all deleted secrets\n            List<DeletedSecretInfo> deletedSecrets = manager.listDeletedSecrets();\n            System.out.printf(\"%nFound %d deleted secrets%n%n\", deletedSecrets.size());\n\n            // Get specific deleted secret details\n            DeletedSecret specificDeleted = manager.getDeletedSecret(\"test-secret\");\n            System.out.printf(\"%nDeleted secret details retrieved%n%n\");\n\n            // Recover the deleted secret\n            KeyVaultSecret recovered = manager.recoverDeletedSecret(\"test-secret\");\n            System.out.printf(\"%nRecovered secret: %s%n\", recovered.getName());\n            System.out.printf(\"Secret value: %s%n\", recovered.getValue());\n\n            // Optional: Clean up by deleting and purging\n            // manager.deleteSecretWithPolling(\"test-secret\");\n            // Thread.sleep(2000);\n            // manager.purgeDeletedSecret(\"test-secret\");\n\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**Key Implementation Details:**\n\n1. **SyncPoller Handling:**\n   - `beginDeleteSecret()` returns `SyncPoller<DeletedSecret, Void>`\n   - `poll()` gets the initial response with the DeletedSecret\n   - `waitForCompletion()` blocks until the operation completes on the server\n   - The DeletedSecret is accessible immediately after polling begins\n\n2. **Soft-Delete Operations:**\n   - `deleteSecretWithPolling()`: Initiates deletion and waits for completion\n   - `listDeletedSecrets()`: Iterates through all deleted secrets\n   - `recoverDeletedSecret()`: Recovers a deleted secret with polling\n   - `getDeletedSecret()`: Gets details without recovering\n   - `purgeDeletedSecret()`: Permanently deletes (no recovery possible)\n\n3. **Error Handling:**\n   - Catches `ResourceNotFoundException` for missing secrets\n   - Provides informative error messages\n\n4. **Best Practices:**\n   - Logs operation progress\n   - Returns structured data (DeletedSecretInfo)\n   - Waits for operations to complete before proceeding\n   - Includes example usage in main method",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8423,
            "output_tokens": 2724,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "Here's the complete implementation with soft-delete handling, listing deleted secrets, and recovery:\n\n```java\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.azure.security.keyvault.secrets.models.DeletedSecret;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.core.util.polling.PollResponse;\nimport java.time.OffsetDateTime;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SecretManager {\n    private final SecretClient client;\n\n    public SecretManager(String vaultUrl) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n\n    public KeyVaultSecret createTaggedSecret(String name, String value, Map<String, String> tags) {\n        return client.setSecret(\n            new KeyVaultSecret(name, value)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusYears(1))\n                    .setTags(tags)\n                )\n        );\n    }\n\n    /**\n     * Soft-delete a secret with polling support.\n     * Returns the deleted secret information once deletion begins.\n     */\n    public DeletedSecret deleteSecret(String secretName) {\n        // Begin delete operation - returns a poller for soft-delete enabled vaults\n        SyncPoller<DeletedSecret, Void> deletePoller = client.beginDeleteSecret(secretName);\n        \n        // Get initial poll response - deleted secret is accessible immediately\n        PollResponse<DeletedSecret> pollResponse = deletePoller.poll();\n        DeletedSecret deletedSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Delete initiated for secret: %s%n\", deletedSecret.getName());\n        System.out.printf(\"Deleted on: %s%n\", deletedSecret.getDeletedOn());\n        System.out.printf(\"Scheduled purge date: %s%n\", deletedSecret.getScheduledPurgeDate());\n        System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n        \n        // Wait for deletion to complete on server\n        deletePoller.waitForCompletion();\n        System.out.printf(\"Secret '%s' deletion completed%n\", secretName);\n        \n        return deletedSecret;\n    }\n\n    /**\n     * List all deleted secrets in the vault.\n     * Returns a list of deleted secret properties.\n     */\n    public List<DeletedSecret> listDeletedSecrets() {\n        List<DeletedSecret> deletedSecrets = new ArrayList<>();\n        \n        for (DeletedSecret deletedSecret : client.listDeletedSecrets()) {\n            deletedSecrets.add(deletedSecret);\n            System.out.printf(\"Deleted secret: %s%n\", deletedSecret.getName());\n            System.out.printf(\"  Deleted on: %s%n\", deletedSecret.getDeletedOn());\n            System.out.printf(\"  Scheduled purge: %s%n\", deletedSecret.getScheduledPurgeDate());\n            System.out.printf(\"  Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n        }\n        \n        return deletedSecrets;\n    }\n\n    /**\n     * Recover a specific deleted secret.\n     * Returns the recovered secret once recovery completes.\n     */\n    public KeyVaultSecret recoverDeletedSecret(String secretName) {\n        // Begin recovery operation - returns a poller\n        SyncPoller<KeyVaultSecret, Void> recoverPoller = client.beginRecoverDeletedSecret(secretName);\n        \n        // Get initial poll response - recovered secret is accessible immediately\n        PollResponse<KeyVaultSecret> pollResponse = recoverPoller.poll();\n        KeyVaultSecret recoveredSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Recovery initiated for secret: %s%n\", recoveredSecret.getName());\n        System.out.printf(\"Secret ID: %s%n\", recoveredSecret.getId());\n        \n        // Wait for recovery to complete on server\n        recoverPoller.waitForCompletion();\n        System.out.printf(\"Secret '%s' recovery completed%n\", secretName);\n        \n        return recoveredSecret;\n    }\n\n    /**\n     * Get a specific deleted secret's information.\n     */\n    public DeletedSecret getDeletedSecret(String secretName) {\n        DeletedSecret deletedSecret = client.getDeletedSecret(secretName);\n        System.out.printf(\"Found deleted secret: %s%n\", deletedSecret.getName());\n        System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n        return deletedSecret;\n    }\n\n    /**\n     * Permanently purge a deleted secret (cannot be recovered after this).\n     */\n    public void purgeDeletedSecret(String secretName) {\n        client.purgeDeletedSecret(secretName);\n        System.out.printf(\"Secret '%s' permanently purged%n\", secretName);\n    }\n}\n```\n\n**Key Implementation Details:**\n\n1. **`deleteSecret()`**: Uses `beginDeleteSecret()` which returns a `SyncPoller<DeletedSecret, Void>`. The poller allows you to:\n   - Get immediate access to `DeletedSecret` via `poll().getValue()`\n   - Wait for server-side completion with `waitForCompletion()`\n\n2. **`listDeletedSecrets()`**: Iterates through all deleted secrets and collects them into a list. Shows deletion metadata like scheduled purge date.\n\n3. **`recoverDeletedSecret()`**: Uses `beginRecoverDeletedSecret()` which returns a `SyncPoller<KeyVaultSecret, Void>`. Similar polling pattern to deletion.\n\n4. **Additional helpers**:\n   - `getDeletedSecret()`: Retrieve info about a specific deleted secret\n   - `purgeDeletedSecret()`: Permanently delete (use with caution!)\n\n**Usage Example:**\n\n```java\nSecretManager manager = new SecretManager(\"https://my-vault.vault.azure.net\");\n\n// Delete with polling\nDeletedSecret deleted = manager.deleteSecret(\"old-api-key\");\n\n// List all deleted secrets\nList<DeletedSecret> deletedList = manager.listDeletedSecrets();\n\n// Recover a deleted secret\nKeyVaultSecret recovered = manager.recoverDeletedSecret(\"old-api-key\");\n```",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8948,
            "output_tokens": 1662,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Complete Secret Manager with Soft-Delete Functionality\n\nHere's the enhanced code with soft-delete handling, polling, listing deleted secrets, and recovery:\n\n```java\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.azure.security.keyvault.secrets.models.DeletedSecret;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.core.util.polling.PollResponse;\nimport com.azure.core.util.polling.LongRunningOperationStatus;\nimport java.time.OffsetDateTime;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SecretManager {\n    private final SecretClient client;\n\n    public SecretManager(String vaultUrl) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n\n    public KeyVaultSecret createTaggedSecret(String name, String value, Map<String, String> tags) {\n        return client.setSecret(\n            new KeyVaultSecret(name, value)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusYears(1))\n                    .setTags(tags)\n                )\n        );\n    }\n\n    /**\n     * Soft-delete a secret with polling until completion\n     * @param secretName Name of the secret to delete\n     * @return The deleted secret\n     */\n    public DeletedSecret deleteSecretWithPolling(String secretName) {\n        System.out.println(\"Starting deletion of secret: \" + secretName);\n        \n        // Begin the delete operation\n        SyncPoller<DeletedSecret, Void> poller = client.beginDeleteSecret(secretName);\n        \n        // Poll until the operation completes\n        PollResponse<DeletedSecret> pollResponse = poller.poll();\n        \n        while (!pollResponse.getStatus().isComplete()) {\n            System.out.println(\"Deletion in progress... Status: \" + pollResponse.getStatus());\n            \n            // Wait before polling again\n            try {\n                Thread.sleep(1000); // Wait 1 second between polls\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(\"Polling interrupted\", e);\n            }\n            \n            pollResponse = poller.poll();\n        }\n        \n        // Check final status\n        if (pollResponse.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n            System.out.println(\"Secret deleted successfully: \" + secretName);\n            return pollResponse.getValue();\n        } else {\n            throw new RuntimeException(\"Secret deletion failed with status: \" + pollResponse.getStatus());\n        }\n    }\n\n    /**\n     * Alternative: Delete secret and wait for completion using waitForCompletion\n     * @param secretName Name of the secret to delete\n     * @return The deleted secret\n     */\n    public DeletedSecret deleteSecretAndWait(String secretName) {\n        System.out.println(\"Deleting secret: \" + secretName);\n        \n        SyncPoller<DeletedSecret, Void> poller = client.beginDeleteSecret(secretName);\n        \n        // Block until completion (simpler approach)\n        PollResponse<DeletedSecret> response = poller.waitForCompletion();\n        \n        System.out.println(\"Secret deleted: \" + secretName);\n        return response.getValue();\n    }\n\n    /**\n     * Alternative: Delete secret with timeout\n     * @param secretName Name of the secret to delete\n     * @param timeoutSeconds Maximum time to wait for completion\n     * @return The deleted secret\n     */\n    public DeletedSecret deleteSecretWithTimeout(String secretName, long timeoutSeconds) {\n        System.out.println(\"Deleting secret with timeout: \" + secretName);\n        \n        SyncPoller<DeletedSecret, Void> poller = client.beginDeleteSecret(secretName);\n        \n        // Wait for completion with timeout\n        PollResponse<DeletedSecret> response = poller.waitForCompletion(Duration.ofSeconds(timeoutSeconds));\n        \n        if (response.getStatus().isComplete()) {\n            System.out.println(\"Secret deleted within timeout: \" + secretName);\n            return response.getValue();\n        } else {\n            throw new RuntimeException(\"Secret deletion timed out after \" + timeoutSeconds + \" seconds\");\n        }\n    }\n\n    /**\n     * List all deleted secrets\n     * @return List of deleted secrets\n     */\n    public List<DeletedSecret> listDeletedSecrets() {\n        System.out.println(\"Listing all deleted secrets...\");\n        \n        List<DeletedSecret> deletedSecrets = new ArrayList<>();\n        \n        client.listDeletedSecrets().forEach(deletedSecret -> {\n            System.out.println(\"Found deleted secret: \" + deletedSecret.getName());\n            System.out.println(\"  Deleted on: \" + deletedSecret.getDeletedOn());\n            System.out.println(\"  Scheduled purge date: \" + deletedSecret.getScheduledPurgeDate());\n            System.out.println(\"  Recovery ID: \" + deletedSecret.getRecoveryId());\n            \n            deletedSecrets.add(deletedSecret);\n        });\n        \n        System.out.println(\"Total deleted secrets: \" + deletedSecrets.size());\n        return deletedSecrets;\n    }\n\n    /**\n     * Get a specific deleted secret\n     * @param secretName Name of the deleted secret\n     * @return The deleted secret\n     */\n    public DeletedSecret getDeletedSecret(String secretName) {\n        System.out.println(\"Retrieving deleted secret: \" + secretName);\n        return client.getDeletedSecret(secretName);\n    }\n\n    /**\n     * Recover a deleted secret with polling\n     * @param secretName Name of the secret to recover\n     * @return The recovered secret\n     */\n    public KeyVaultSecret recoverDeletedSecret(String secretName) {\n        System.out.println(\"Starting recovery of secret: \" + secretName);\n        \n        // Begin the recovery operation\n        SyncPoller<KeyVaultSecret, Void> poller = client.beginRecoverDeletedSecret(secretName);\n        \n        // Poll until completion\n        PollResponse<KeyVaultSecret> pollResponse = poller.poll();\n        \n        while (!pollResponse.getStatus().isComplete()) {\n            System.out.println(\"Recovery in progress... Status: \" + pollResponse.getStatus());\n            \n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(\"Polling interrupted\", e);\n            }\n            \n            pollResponse = poller.poll();\n        }\n        \n        if (pollResponse.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n            System.out.println(\"Secret recovered successfully: \" + secretName);\n            return pollResponse.getValue();\n        } else {\n            throw new RuntimeException(\"Secret recovery failed with status: \" + pollResponse.getStatus());\n        }\n    }\n\n    /**\n     * Recover a deleted secret and wait for completion (simpler approach)\n     * @param secretName Name of the secret to recover\n     * @return The recovered secret\n     */\n    public KeyVaultSecret recoverDeletedSecretAndWait(String secretName) {\n        System.out.println(\"Recovering secret: \" + secretName);\n        \n        SyncPoller<KeyVaultSecret, Void> poller = client.beginRecoverDeletedSecret(secretName);\n        PollResponse<KeyVaultSecret> response = poller.waitForCompletion();\n        \n        System.out.println(\"Secret recovered: \" + secretName);\n        return response.getValue();\n    }\n\n    /**\n     * Permanently delete a secret (purge)\n     * @param secretName Name of the secret to purge\n     */\n    public void purgeDeletedSecret(String secretName) {\n        System.out.println(\"Purging deleted secret: \" + secretName);\n        client.purgeDeletedSecret(secretName);\n        System.out.println(\"Secret purged permanently: \" + secretName);\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        String vaultUrl = \"https://your-vault-name.vault.azure.net/\";\n        SecretManager manager = new SecretManager(vaultUrl);\n\n        try {\n            // Create a secret with tags\n            Map<String, String> tags = Map.of(\n                \"environment\", \"production\",\n                \"department\", \"finance\"\n            );\n            \n            KeyVaultSecret secret = manager.createTaggedSecret(\n                \"my-secret\", \n                \"secret-value\", \n                tags\n            );\n            System.out.println(\"Created secret: \" + secret.getName());\n\n            // Delete the secret with polling\n            DeletedSecret deletedSecret = manager.deleteSecretWithPolling(\"my-secret\");\n            System.out.println(\"Deleted secret ID: \" + deletedSecret.getId());\n\n            // List all deleted secrets\n            List<DeletedSecret> deletedSecrets = manager.listDeletedSecrets();\n            System.out.println(\"Found \" + deletedSecrets.size() + \" deleted secrets\");\n\n            // Recover the deleted secret\n            KeyVaultSecret recoveredSecret = manager.recoverDeletedSecretAndWait(\"my-secret\");\n            System.out.println(\"Recovered secret: \" + recoveredSecret.getName());\n\n            // Alternative: Delete and purge\n            manager.deleteSecretAndWait(\"my-secret\");\n            // Wait a bit before purging\n            Thread.sleep(5000);\n            manager.purgeDeletedSecret(\"my-secret\");\n\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## Key Features Implemented:\n\n1. **Soft-Delete with Polling** (`deleteSecretWithPolling`):\n   - Manual polling loop with status checks\n   - Custom wait intervals between polls\n   - Detailed status logging\n\n2. **Simplified Delete** (`deleteSecretAndWait`):\n   - Uses `waitForCompletion()` for blocking wait\n   - Cleaner code for simple use cases\n\n3. **Delete with Timeout** (`deleteSecretWithTimeout`):\n   - Prevents indefinite waiting\n   - Throws exception on timeout\n\n4. **List Deleted Secrets** (`listDeletedSecrets`):\n   - Iterates through all soft-deleted secrets\n   - Displays deletion metadata\n\n5. **Recover Deleted Secret** (`recoverDeletedSecret` and `recoverDeletedSecretAndWait`):\n   - Both polling and blocking approaches\n   - Restores soft-deleted secrets\n\n6. **Purge Support** (`purgeDeletedSecret`):\n   - Permanently removes deleted secrets\n\nThe code properly handles `SyncPoller` with status checking and completion waiting!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 354,
            "output_tokens": 2762,
            "cached": false
          },
          "with_skill": {
            "output": "Here's the complete implementation with soft-delete handling, listing deleted secrets, and recovery functionality:\n\n```java\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.azure.security.keyvault.secrets.models.DeletedSecret;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.core.util.polling.PollResponse;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport java.time.OffsetDateTime;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SecretManager {\n    private final SecretClient client;\n\n    public SecretManager(String vaultUrl) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n\n    public KeyVaultSecret createTaggedSecret(String name, String value, Map<String, String> tags) {\n        return client.setSecret(\n            new KeyVaultSecret(name, value)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusYears(1))\n                    .setTags(tags)\n                )\n        );\n    }\n\n    /**\n     * Soft-delete a secret with polling support\n     * @param secretName Name of the secret to delete\n     * @return DeletedSecret information\n     */\n    public DeletedSecret deleteSecretWithPolling(String secretName) {\n        System.out.printf(\"Starting deletion of secret: %s%n\", secretName);\n        \n        // Begin delete operation - returns a poller\n        SyncPoller<DeletedSecret, Void> deletePoller = client.beginDeleteSecret(secretName);\n        \n        // Get the deleted secret info immediately (available as soon as polling begins)\n        PollResponse<DeletedSecret> pollResponse = deletePoller.poll();\n        DeletedSecret deletedSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Delete initiated - Status: %s%n\", pollResponse.getStatus());\n        System.out.printf(\"Deleted Date: %s%n\", deletedSecret.getDeletedOn());\n        System.out.printf(\"Scheduled Purge Date: %s%n\", deletedSecret.getScheduledPurgeDate());\n        System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n        \n        // Wait for deletion to complete on the server\n        deletePoller.waitForCompletion();\n        System.out.printf(\"Secret '%s' deletion completed%n\", secretName);\n        \n        return deletedSecret;\n    }\n\n    /**\n     * List all deleted secrets in the vault\n     * @return List of deleted secret properties\n     */\n    public List<DeletedSecret> listDeletedSecrets() {\n        System.out.println(\"Listing all deleted secrets...\");\n        List<DeletedSecret> deletedSecrets = new ArrayList<>();\n        \n        for (DeletedSecret deletedSecret : client.listDeletedSecrets()) {\n            deletedSecrets.add(deletedSecret);\n            System.out.printf(\"Deleted Secret: %s%n\", deletedSecret.getName());\n            System.out.printf(\"  Deleted On: %s%n\", deletedSecret.getDeletedOn());\n            System.out.printf(\"  Scheduled Purge: %s%n\", deletedSecret.getScheduledPurgeDate());\n            System.out.printf(\"  Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n            System.out.println();\n        }\n        \n        System.out.printf(\"Found %d deleted secrets%n\", deletedSecrets.size());\n        return deletedSecrets;\n    }\n\n    /**\n     * Recover a specific deleted secret\n     * @param secretName Name of the deleted secret to recover\n     * @return Recovered KeyVaultSecret\n     */\n    public KeyVaultSecret recoverDeletedSecret(String secretName) {\n        System.out.printf(\"Starting recovery of deleted secret: %s%n\", secretName);\n        \n        try {\n            // Begin recovery operation - returns a poller\n            SyncPoller<KeyVaultSecret, Void> recoverPoller = \n                client.beginRecoverDeletedSecret(secretName);\n            \n            // Get the recovered secret info immediately\n            PollResponse<KeyVaultSecret> pollResponse = recoverPoller.poll();\n            KeyVaultSecret recoveredSecret = pollResponse.getValue();\n            \n            System.out.printf(\"Recovery initiated - Status: %s%n\", pollResponse.getStatus());\n            System.out.printf(\"Secret Name: %s%n\", recoveredSecret.getName());\n            System.out.printf(\"Secret ID: %s%n\", recoveredSecret.getId());\n            \n            // Wait for recovery to complete on the server\n            recoverPoller.waitForCompletion();\n            System.out.printf(\"Secret '%s' recovery completed%n\", secretName);\n            \n            // Get the final recovered secret with all properties\n            KeyVaultSecret finalSecret = client.getSecret(secretName);\n            System.out.printf(\"Recovered secret value length: %d characters%n\", \n                finalSecret.getValue().length());\n            \n            return finalSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            System.err.printf(\"Deleted secret '%s' not found. It may have been purged.%n\", \n                secretName);\n            throw e;\n        }\n    }\n\n    /**\n     * Get a specific deleted secret's information\n     * @param secretName Name of the deleted secret\n     * @return DeletedSecret information\n     */\n    public DeletedSecret getDeletedSecret(String secretName) {\n        try {\n            DeletedSecret deletedSecret = client.getDeletedSecret(secretName);\n            System.out.printf(\"Found deleted secret: %s%n\", deletedSecret.getName());\n            System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n            return deletedSecret;\n        } catch (ResourceNotFoundException e) {\n            System.err.printf(\"Deleted secret '%s' not found%n\", secretName);\n            throw e;\n        }\n    }\n\n    /**\n     * Permanently purge a deleted secret (cannot be recovered after this)\n     * @param secretName Name of the deleted secret to purge\n     */\n    public void purgeDeletedSecret(String secretName) {\n        System.out.printf(\"Permanently purging deleted secret: %s%n\", secretName);\n        client.purgeDeletedSecret(secretName);\n        System.out.printf(\"Secret '%s' has been permanently purged%n\", secretName);\n    }\n\n    /**\n     * Complete workflow demonstrating soft-delete operations\n     */\n    public void demonstrateSoftDeleteWorkflow(String secretName, String secretValue) {\n        System.out.println(\"=== Soft-Delete Workflow Demo ===\\n\");\n        \n        // 1. Create a secret\n        System.out.println(\"Step 1: Creating secret...\");\n        KeyVaultSecret secret = createTaggedSecret(\n            secretName, \n            secretValue,\n            Map.of(\"environment\", \"demo\", \"purpose\", \"soft-delete-test\")\n        );\n        System.out.printf(\"Created: %s%n%n\", secret.getName());\n        \n        // 2. Delete the secret (soft-delete)\n        System.out.println(\"Step 2: Soft-deleting secret...\");\n        DeletedSecret deleted = deleteSecretWithPolling(secretName);\n        System.out.println();\n        \n        // 3. List deleted secrets\n        System.out.println(\"Step 3: Listing deleted secrets...\");\n        listDeletedSecrets();\n        System.out.println();\n        \n        // 4. Get specific deleted secret info\n        System.out.println(\"Step 4: Getting deleted secret info...\");\n        getDeletedSecret(secretName);\n        System.out.println();\n        \n        // 5. Recover the deleted secret\n        System.out.println(\"Step 5: Recovering deleted secret...\");\n        KeyVaultSecret recovered = recoverDeletedSecret(secretName);\n        System.out.printf(\"Recovered secret value: %s%n%n\", recovered.getValue());\n        \n        // 6. Delete again for cleanup (optional)\n        System.out.println(\"Step 6: Cleaning up - deleting again...\");\n        deleteSecretWithPolling(secretName);\n        \n        // Note: Uncomment to permanently purge (use with caution!)\n        // System.out.println(\"Step 7: Permanently purging...\");\n        // purgeDeletedSecret(secretName);\n        \n        System.out.println(\"=== Workflow Complete ===\");\n    }\n\n    public static void main(String[] args) {\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        if (vaultUrl == null || vaultUrl.isEmpty()) {\n            System.err.println(\"Please set AZURE_KEYVAULT_URL environment variable\");\n            return;\n        }\n\n        SecretManager manager = new SecretManager(vaultUrl);\n        \n        // Run the complete workflow\n        manager.demonstrateSoftDeleteWorkflow(\"demo-secret\", \"demo-value-123\");\n    }\n}\n```\n\n**Key Implementation Details:**\n\n1. **`deleteSecretWithPolling()`**:\n   - Uses `beginDeleteSecret()` which returns a `SyncPoller<DeletedSecret, Void>`\n   - Calls `poll()` to get immediate access to `DeletedSecret` info\n   - Uses `waitForCompletion()` to block until server-side deletion completes\n   - Returns the `DeletedSecret` with deletion metadata\n\n2. **`listDeletedSecrets()`**:\n   - Iterates through all deleted secrets using `listDeletedSecrets()`\n   - Collects and displays information about each deleted secret\n   - Returns a list for further processing\n\n3. **`recoverDeletedSecret()`**:\n   - Uses `beginRecoverDeletedSecret()` which returns a `SyncPoller<KeyVaultSecret, Void>`\n   - Polls for immediate status and waits for completion\n   - Retrieves the final recovered secret with `getSecret()`\n   - Includes error handling for non-existent deleted secrets\n\n4. **Additional Methods**:\n   - `getDeletedSecret()`: Retrieves specific deleted secret info\n   - `purgeDeletedSecret()`: Permanently deletes (use with caution!)\n   - `demonstrateSoftDeleteWorkflow()`: Complete end-to-end demo\n\n**Usage Notes:**\n- Requires Key Vault with soft-delete enabled\n- The poller pattern allows monitoring long-running operations\n- Recovery ID is crucial for tracking deleted secrets\n- Purge is permanent and cannot be undone",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8423,
            "output_tokens": 2706,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "Here's the complete implementation with soft-delete handling, listing deleted secrets, and recovery:\n\n```java\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.azure.security.keyvault.secrets.models.DeletedSecret;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.core.util.polling.PollResponse;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport java.time.OffsetDateTime;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SecretManager {\n    private final SecretClient client;\n\n    public SecretManager(String vaultUrl) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n\n    public KeyVaultSecret createTaggedSecret(String name, String value, Map<String, String> tags) {\n        return client.setSecret(\n            new KeyVaultSecret(name, value)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusYears(1))\n                    .setTags(tags)\n                )\n        );\n    }\n\n    /**\n     * Soft-delete a secret with polling support.\n     * Returns the DeletedSecret once deletion begins (not necessarily complete).\n     */\n    public DeletedSecret deleteSecret(String secretName) {\n        // Begin delete operation - returns a poller\n        SyncPoller<DeletedSecret, Void> deletePoller = client.beginDeleteSecret(secretName);\n        \n        // Get the initial poll response - deleted secret is accessible immediately\n        PollResponse<DeletedSecret> pollResponse = deletePoller.poll();\n        DeletedSecret deletedSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Delete initiated for: %s%n\", deletedSecret.getName());\n        System.out.printf(\"Deleted on: %s%n\", deletedSecret.getDeletedOn());\n        System.out.printf(\"Scheduled purge date: %s%n\", deletedSecret.getScheduledPurgeDate());\n        System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n        \n        // Wait for deletion to complete on server\n        deletePoller.waitForCompletion();\n        System.out.printf(\"Deletion completed for: %s%n\", secretName);\n        \n        return deletedSecret;\n    }\n\n    /**\n     * List all deleted secrets in the vault.\n     * Returns a list of deleted secret properties.\n     */\n    public List<DeletedSecret> listDeletedSecrets() {\n        List<DeletedSecret> deletedSecrets = new ArrayList<>();\n        \n        for (DeletedSecret deletedSecret : client.listDeletedSecrets()) {\n            deletedSecrets.add(deletedSecret);\n            System.out.printf(\"Deleted secret: %s%n\", deletedSecret.getName());\n            System.out.printf(\"  Deleted on: %s%n\", deletedSecret.getDeletedOn());\n            System.out.printf(\"  Scheduled purge: %s%n\", deletedSecret.getScheduledPurgeDate());\n            System.out.printf(\"  Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n        }\n        \n        return deletedSecrets;\n    }\n\n    /**\n     * Recover a specific deleted secret by name.\n     * Returns the recovered secret once recovery begins.\n     */\n    public KeyVaultSecret recoverDeletedSecret(String secretName) {\n        try {\n            // Begin recovery operation - returns a poller\n            SyncPoller<KeyVaultSecret, Void> recoverPoller = \n                client.beginRecoverDeletedSecret(secretName);\n            \n            // Get the initial poll response - recovered secret is accessible immediately\n            PollResponse<KeyVaultSecret> pollResponse = recoverPoller.poll();\n            KeyVaultSecret recoveredSecret = pollResponse.getValue();\n            \n            System.out.printf(\"Recovery initiated for: %s%n\", recoveredSecret.getName());\n            System.out.printf(\"Secret ID: %s%n\", recoveredSecret.getId());\n            \n            // Wait for recovery to complete on server\n            recoverPoller.waitForCompletion();\n            System.out.printf(\"Recovery completed for: %s%n\", secretName);\n            \n            return recoveredSecret;\n            \n        } catch (ResourceNotFoundException e) {\n            System.err.printf(\"Deleted secret not found: %s%n\", secretName);\n            throw e;\n        }\n    }\n\n    /**\n     * Get a specific deleted secret's details without recovering it.\n     */\n    public DeletedSecret getDeletedSecret(String secretName) {\n        try {\n            DeletedSecret deletedSecret = client.getDeletedSecret(secretName);\n            System.out.printf(\"Found deleted secret: %s%n\", deletedSecret.getName());\n            System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n            return deletedSecret;\n        } catch (ResourceNotFoundException e) {\n            System.err.printf(\"Deleted secret not found: %s%n\", secretName);\n            throw e;\n        }\n    }\n\n    /**\n     * Permanently purge a deleted secret (cannot be recovered after this).\n     */\n    public void purgeDeletedSecret(String secretName) {\n        client.purgeDeletedSecret(secretName);\n        System.out.printf(\"Permanently purged secret: %s%n\", secretName);\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        SecretManager manager = new SecretManager(vaultUrl);\n\n        // Create a secret\n        KeyVaultSecret secret = manager.createTaggedSecret(\n            \"test-secret\",\n            \"test-value\",\n            Map.of(\"environment\", \"dev\", \"owner\", \"team-a\")\n        );\n        System.out.printf(\"Created secret: %s%n\", secret.getName());\n\n        // Delete the secret (soft-delete)\n        DeletedSecret deleted = manager.deleteSecret(\"test-secret\");\n\n        // List all deleted secrets\n        List<DeletedSecret> deletedSecrets = manager.listDeletedSecrets();\n        System.out.printf(\"Found %d deleted secrets%n\", deletedSecrets.size());\n\n        // Recover the deleted secret\n        KeyVaultSecret recovered = manager.recoverDeletedSecret(\"test-secret\");\n        System.out.printf(\"Recovered secret: %s%n\", recovered.getName());\n    }\n}\n```\n\n**Key points about the implementation:**\n\n1. **SyncPoller handling**: \n   - `beginDeleteSecret()` and `beginRecoverDeletedSecret()` return `SyncPoller` objects\n   - Call `.poll()` to get immediate access to the result (deletion/recovery starts immediately)\n   - Call `.waitForCompletion()` to block until the operation finishes on the server\n\n2. **DeletedSecret properties**:\n   - `getDeletedOn()` - when the secret was deleted\n   - `getScheduledPurgeDate()` - when it will be permanently deleted\n   - `getRecoveryId()` - unique identifier for recovery\n\n3. **Error handling**: Uses `ResourceNotFoundException` for missing deleted secrets\n\n4. **Soft-delete workflow**:\n   - Delete \u2192 secret enters \"deleted\" state (recoverable)\n   - List deleted secrets \u2192 see what can be recovered\n   - Recover \u2192 restore to active state\n   - Purge \u2192 permanently delete (optional, irreversible)",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8948,
            "output_tokens": 1943,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Complete Secret Manager with Soft-Delete Functionality\n\nHere's the enhanced `SecretManager` class with soft-delete handling, polling, listing deleted secrets, and recovery:\n\n```java\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.azure.security.keyvault.secrets.models.DeletedSecret;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.core.util.polling.PollResponse;\nimport com.azure.core.util.polling.LongRunningOperationStatus;\nimport java.time.OffsetDateTime;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SecretManager {\n    private final SecretClient client;\n\n    public SecretManager(String vaultUrl) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n\n    public KeyVaultSecret createTaggedSecret(String name, String value, Map<String, String> tags) {\n        return client.setSecret(\n            new KeyVaultSecret(name, value)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusYears(1))\n                    .setTags(tags)\n                )\n        );\n    }\n\n    /**\n     * Soft-delete a secret with polling until completion\n     * @param secretName Name of the secret to delete\n     * @return The deleted secret\n     * @throws RuntimeException if deletion fails\n     */\n    public DeletedSecret deleteSecretWithPolling(String secretName) {\n        System.out.println(\"Initiating deletion of secret: \" + secretName);\n        \n        // Begin the delete operation\n        SyncPoller<DeletedSecret, Void> poller = client.beginDeleteSecret(secretName);\n        \n        // Poll until completion\n        PollResponse<DeletedSecret> pollResponse;\n        do {\n            pollResponse = poller.poll();\n            System.out.println(\"Delete operation status: \" + pollResponse.getStatus());\n            \n            if (pollResponse.getStatus() == LongRunningOperationStatus.IN_PROGRESS) {\n                try {\n                    Thread.sleep(1000); // Wait 1 second between polls\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(\"Polling interrupted\", e);\n                }\n            }\n        } while (!pollResponse.getStatus().isComplete());\n        \n        // Check final status\n        if (pollResponse.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n            DeletedSecret deletedSecret = poller.getFinalResult();\n            System.out.println(\"Secret successfully deleted: \" + secretName);\n            return deletedSecret;\n        } else {\n            throw new RuntimeException(\"Failed to delete secret: \" + secretName);\n        }\n    }\n\n    /**\n     * Alternative: Delete with automatic waiting\n     * @param secretName Name of the secret to delete\n     * @return The deleted secret\n     */\n    public DeletedSecret deleteSecretAndWait(String secretName) {\n        System.out.println(\"Deleting secret and waiting for completion: \" + secretName);\n        \n        SyncPoller<DeletedSecret, Void> poller = client.beginDeleteSecret(secretName);\n        \n        // Wait for completion (blocks until done)\n        poller.waitForCompletion();\n        \n        DeletedSecret deletedSecret = poller.getFinalResult();\n        System.out.println(\"Secret deleted: \" + secretName);\n        \n        return deletedSecret;\n    }\n\n    /**\n     * Delete with timeout\n     * @param secretName Name of the secret to delete\n     * @param timeoutSeconds Maximum time to wait\n     * @return The deleted secret\n     */\n    public DeletedSecret deleteSecretWithTimeout(String secretName, long timeoutSeconds) {\n        System.out.println(\"Deleting secret with timeout: \" + secretName);\n        \n        SyncPoller<DeletedSecret, Void> poller = client.beginDeleteSecret(secretName);\n        \n        // Wait for completion with timeout\n        poller.waitForCompletion(Duration.ofSeconds(timeoutSeconds));\n        \n        return poller.getFinalResult();\n    }\n\n    /**\n     * List all deleted secrets\n     * @return List of deleted secrets\n     */\n    public List<DeletedSecret> listDeletedSecrets() {\n        System.out.println(\"Listing all deleted secrets...\");\n        \n        List<DeletedSecret> deletedSecrets = new ArrayList<>();\n        \n        client.listDeletedSecrets().forEach(deletedSecret -> {\n            System.out.println(\"Deleted Secret: \" + deletedSecret.getName());\n            System.out.println(\"  Deleted On: \" + deletedSecret.getDeletedOn());\n            System.out.println(\"  Scheduled Purge Date: \" + deletedSecret.getScheduledPurgeDate());\n            System.out.println(\"  Recovery ID: \" + deletedSecret.getRecoveryId());\n            \n            deletedSecrets.add(deletedSecret);\n        });\n        \n        System.out.println(\"Total deleted secrets: \" + deletedSecrets.size());\n        return deletedSecrets;\n    }\n\n    /**\n     * Get a specific deleted secret\n     * @param secretName Name of the deleted secret\n     * @return The deleted secret\n     */\n    public DeletedSecret getDeletedSecret(String secretName) {\n        System.out.println(\"Retrieving deleted secret: \" + secretName);\n        \n        DeletedSecret deletedSecret = client.getDeletedSecret(secretName);\n        \n        if (deletedSecret != null) {\n            System.out.println(\"Found deleted secret: \" + deletedSecret.getName());\n            System.out.println(\"  Value: \" + deletedSecret.getValue());\n            System.out.println(\"  Deleted On: \" + deletedSecret.getDeletedOn());\n        }\n        \n        return deletedSecret;\n    }\n\n    /**\n     * Recover a deleted secret with polling\n     * @param secretName Name of the secret to recover\n     * @return The recovered secret\n     */\n    public KeyVaultSecret recoverDeletedSecret(String secretName) {\n        System.out.println(\"Initiating recovery of secret: \" + secretName);\n        \n        SyncPoller<KeyVaultSecret, Void> poller = client.beginRecoverDeletedSecret(secretName);\n        \n        // Poll until completion\n        PollResponse<KeyVaultSecret> pollResponse;\n        do {\n            pollResponse = poller.poll();\n            System.out.println(\"Recovery operation status: \" + pollResponse.getStatus());\n            \n            if (pollResponse.getStatus() == LongRunningOperationStatus.IN_PROGRESS) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(\"Polling interrupted\", e);\n                }\n            }\n        } while (!pollResponse.getStatus().isComplete());\n        \n        if (pollResponse.getStatus() == LongRunningOperationStatus.SUCCESSFULLY_COMPLETED) {\n            KeyVaultSecret recoveredSecret = poller.getFinalResult();\n            System.out.println(\"Secret successfully recovered: \" + secretName);\n            return recoveredSecret;\n        } else {\n            throw new RuntimeException(\"Failed to recover secret: \" + secretName);\n        }\n    }\n\n    /**\n     * Recover a deleted secret and wait for completion\n     * @param secretName Name of the secret to recover\n     * @return The recovered secret\n     */\n    public KeyVaultSecret recoverDeletedSecretAndWait(String secretName) {\n        System.out.println(\"Recovering secret and waiting: \" + secretName);\n        \n        SyncPoller<KeyVaultSecret, Void> poller = client.beginRecoverDeletedSecret(secretName);\n        poller.waitForCompletion();\n        \n        KeyVaultSecret recoveredSecret = poller.getFinalResult();\n        System.out.println(\"Secret recovered: \" + secretName);\n        \n        return recoveredSecret;\n    }\n\n    /**\n     * Permanently delete a soft-deleted secret (purge)\n     * @param secretName Name of the secret to purge\n     */\n    public void purgeDeletedSecret(String secretName) {\n        System.out.println(\"Purging deleted secret: \" + secretName);\n        client.purgeDeletedSecret(secretName);\n        System.out.println(\"Secret purged permanently: \" + secretName);\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        String vaultUrl = \"https://your-vault-name.vault.azure.net/\";\n        SecretManager manager = new SecretManager(vaultUrl);\n\n        try {\n            // Create a secret with tags\n            Map<String, String> tags = Map.of(\n                \"environment\", \"production\",\n                \"department\", \"finance\"\n            );\n            \n            KeyVaultSecret secret = manager.createTaggedSecret(\n                \"test-secret\", \n                \"secret-value\", \n                tags\n            );\n            System.out.println(\"Created secret: \" + secret.getName());\n\n            // Soft-delete the secret with polling\n            DeletedSecret deleted = manager.deleteSecretWithPolling(\"test-secret\");\n            System.out.println(\"Deleted secret ID: \" + deleted.getId());\n\n            // List all deleted secrets\n            List<DeletedSecret> deletedSecrets = manager.listDeletedSecrets();\n\n            // Get specific deleted secret\n            DeletedSecret specificDeleted = manager.getDeletedSecret(\"test-secret\");\n\n            // Recover the deleted secret\n            KeyVaultSecret recovered = manager.recoverDeletedSecret(\"test-secret\");\n            System.out.println(\"Recovered secret: \" + recovered.getName());\n\n            // Optional: Purge permanently (use with caution!)\n            // manager.deleteSecretAndWait(\"test-secret\");\n            // manager.purgeDeletedSecret(\"test-secret\");\n\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## Key Features Implemented:\n\n1. **Soft-Delete with Polling** (`deleteSecretWithPolling`):\n   - Manual polling loop with status checks\n   - Sleep between polls\n   - Proper completion handling\n\n2. **Alternative Delete Methods**:\n   - `deleteSecretAndWait`: Blocks until completion\n   - `deleteSecretWithTimeout`: With timeout protection\n\n3. **List Deleted Secrets** (`listDeletedSecrets`):\n   - Iterates through all deleted secrets\n   - Displays metadata (deletion date, purge date, recovery ID)\n\n4. **Recover Deleted Secret** (`recoverDeletedSecret`):\n   - Polling-based recovery\n   - Alternative `recoverDeletedSecretAndWait` method\n\n5. **Additional Operations**:\n   - `getDeletedSecret`: Retrieve specific deleted secret\n   - `purgeDeletedSecret`: Permanent deletion\n\nThe code properly handles `SyncPoller` with status checking, completion waiting, and error handling.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 354,
            "output_tokens": 2824,
            "cached": false
          },
          "with_skill": {
            "output": "Here's the complete implementation with soft-delete handling, listing deleted secrets, and recovery functionality:\n\n```java\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.azure.security.keyvault.secrets.models.DeletedSecret;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.core.util.polling.PollResponse;\nimport com.azure.core.exception.ResourceNotFoundException;\nimport java.time.OffsetDateTime;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SecretManager {\n    private final SecretClient client;\n\n    public SecretManager(String vaultUrl) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n\n    public KeyVaultSecret createTaggedSecret(String name, String value, Map<String, String> tags) {\n        return client.setSecret(\n            new KeyVaultSecret(name, value)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusYears(1))\n                    .setTags(tags)\n                )\n        );\n    }\n\n    /**\n     * Soft-delete a secret with polling support.\n     * Returns the DeletedSecret once deletion begins (doesn't wait for completion).\n     */\n    public DeletedSecret deleteSecret(String secretName) {\n        System.out.printf(\"Starting deletion of secret: %s%n\", secretName);\n        \n        // Begin delete operation - returns a SyncPoller\n        SyncPoller<DeletedSecret, Void> deletePoller = client.beginDeleteSecret(secretName);\n        \n        // Get the initial poll response - deletion has started\n        PollResponse<DeletedSecret> pollResponse = deletePoller.poll();\n        DeletedSecret deletedSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Delete initiated - Status: %s%n\", pollResponse.getStatus());\n        System.out.printf(\"Deleted Date: %s%n\", deletedSecret.getDeletedOn());\n        System.out.printf(\"Scheduled Purge Date: %s%n\", deletedSecret.getScheduledPurgeDate());\n        System.out.printf(\"Recovery Id: %s%n\", deletedSecret.getRecoveryId());\n        \n        return deletedSecret;\n    }\n\n    /**\n     * Soft-delete a secret and wait for deletion to complete on the server.\n     */\n    public DeletedSecret deleteSecretAndWait(String secretName) {\n        System.out.printf(\"Starting deletion of secret: %s (with wait)%n\", secretName);\n        \n        SyncPoller<DeletedSecret, Void> deletePoller = client.beginDeleteSecret(secretName);\n        \n        // Get initial response\n        PollResponse<DeletedSecret> pollResponse = deletePoller.poll();\n        DeletedSecret deletedSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Waiting for deletion to complete...%n\");\n        \n        // Wait for the operation to complete on the server\n        deletePoller.waitForCompletion();\n        \n        System.out.printf(\"Deletion completed for: %s%n\", secretName);\n        \n        return deletedSecret;\n    }\n\n    /**\n     * List all deleted secrets in the vault.\n     */\n    public List<DeletedSecret> listDeletedSecrets() {\n        System.out.println(\"Listing all deleted secrets...\");\n        \n        List<DeletedSecret> deletedSecrets = new ArrayList<>();\n        \n        for (DeletedSecret deletedSecret : client.listDeletedSecrets()) {\n            deletedSecrets.add(deletedSecret);\n            \n            System.out.printf(\"Deleted Secret: %s%n\", deletedSecret.getName());\n            System.out.printf(\"  Deleted On: %s%n\", deletedSecret.getDeletedOn());\n            System.out.printf(\"  Scheduled Purge: %s%n\", deletedSecret.getScheduledPurgeDate());\n            System.out.printf(\"  Recovery Id: %s%n\", deletedSecret.getRecoveryId());\n            \n            // Access properties if needed\n            SecretProperties props = deletedSecret.getProperties();\n            if (props != null && props.getTags() != null) {\n                System.out.printf(\"  Tags: %s%n\", props.getTags());\n            }\n            System.out.println();\n        }\n        \n        System.out.printf(\"Found %d deleted secrets%n\", deletedSecrets.size());\n        return deletedSecrets;\n    }\n\n    /**\n     * Get a specific deleted secret by name.\n     */\n    public DeletedSecret getDeletedSecret(String secretName) {\n        try {\n            DeletedSecret deletedSecret = client.getDeletedSecret(secretName);\n            \n            System.out.printf(\"Retrieved deleted secret: %s%n\", deletedSecret.getName());\n            System.out.printf(\"  Recovery Id: %s%n\", deletedSecret.getRecoveryId());\n            System.out.printf(\"  Deleted On: %s%n\", deletedSecret.getDeletedOn());\n            \n            return deletedSecret;\n        } catch (ResourceNotFoundException e) {\n            System.err.printf(\"Deleted secret not found: %s%n\", secretName);\n            return null;\n        }\n    }\n\n    /**\n     * Recover a deleted secret with polling support.\n     * Returns the recovered secret once recovery begins.\n     */\n    public KeyVaultSecret recoverDeletedSecret(String secretName) {\n        System.out.printf(\"Starting recovery of deleted secret: %s%n\", secretName);\n        \n        // Begin recover operation - returns a SyncPoller\n        SyncPoller<KeyVaultSecret, Void> recoverPoller = client.beginRecoverDeletedSecret(secretName);\n        \n        // Get the initial poll response - recovery has started\n        PollResponse<KeyVaultSecret> pollResponse = recoverPoller.poll();\n        KeyVaultSecret recoveredSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Recovery initiated - Status: %s%n\", pollResponse.getStatus());\n        System.out.printf(\"Recovered secret name: %s%n\", recoveredSecret.getName());\n        System.out.printf(\"Secret ID: %s%n\", recoveredSecret.getId());\n        \n        return recoveredSecret;\n    }\n\n    /**\n     * Recover a deleted secret and wait for recovery to complete on the server.\n     */\n    public KeyVaultSecret recoverDeletedSecretAndWait(String secretName) {\n        System.out.printf(\"Starting recovery of deleted secret: %s (with wait)%n\", secretName);\n        \n        SyncPoller<KeyVaultSecret, Void> recoverPoller = client.beginRecoverDeletedSecret(secretName);\n        \n        // Get initial response\n        PollResponse<KeyVaultSecret> pollResponse = recoverPoller.poll();\n        KeyVaultSecret recoveredSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Waiting for recovery to complete...%n\");\n        \n        // Wait for the operation to complete on the server\n        recoverPoller.waitForCompletion();\n        \n        System.out.printf(\"Recovery completed for: %s%n\", secretName);\n        \n        // Get the final secret with all properties\n        KeyVaultSecret finalSecret = client.getSecret(secretName);\n        System.out.printf(\"Secret value: %s%n\", finalSecret.getValue());\n        \n        return finalSecret;\n    }\n\n    /**\n     * Permanently delete (purge) a deleted secret.\n     * This operation is irreversible.\n     */\n    public void purgeDeletedSecret(String secretName) {\n        System.out.printf(\"Purging deleted secret: %s (PERMANENT)%n\", secretName);\n        \n        try {\n            client.purgeDeletedSecret(secretName);\n            System.out.printf(\"Secret purged permanently: %s%n\", secretName);\n        } catch (ResourceNotFoundException e) {\n            System.err.printf(\"Deleted secret not found for purging: %s%n\", secretName);\n        }\n    }\n\n    // Example usage demonstrating the complete lifecycle\n    public static void main(String[] args) {\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        if (vaultUrl == null) {\n            System.err.println(\"Please set AZURE_KEYVAULT_URL environment variable\");\n            return;\n        }\n\n        SecretManager manager = new SecretManager(vaultUrl);\n\n        try {\n            // 1. Create a secret with tags\n            System.out.println(\"=== Creating Secret ===\");\n            KeyVaultSecret secret = manager.createTaggedSecret(\n                \"demo-secret\",\n                \"demo-value-123\",\n                Map.of(\n                    \"environment\", \"development\",\n                    \"owner\", \"team-alpha\"\n                )\n            );\n            System.out.printf(\"Created: %s%n%n\", secret.getName());\n\n            // Wait a moment for the secret to be fully created\n            Thread.sleep(2000);\n\n            // 2. Delete the secret (soft-delete)\n            System.out.println(\"=== Deleting Secret ===\");\n            DeletedSecret deleted = manager.deleteSecretAndWait(\"demo-secret\");\n            System.out.println();\n\n            // Wait for deletion to propagate\n            Thread.sleep(5000);\n\n            // 3. List all deleted secrets\n            System.out.println(\"=== Listing Deleted Secrets ===\");\n            List<DeletedSecret> deletedSecrets = manager.listDeletedSecrets();\n            System.out.println();\n\n            // 4. Get specific deleted secret\n            System.out.println(\"=== Getting Specific Deleted Secret ===\");\n            DeletedSecret specificDeleted = manager.getDeletedSecret(\"demo-secret\");\n            System.out.println();\n\n            // 5. Recover the deleted secret\n            System.out.println(\"=== Recovering Deleted Secret ===\");\n            KeyVaultSecret recovered = manager.recoverDeletedSecretAndWait(\"demo-secret\");\n            System.out.println();\n\n            // Wait for recovery to propagate\n            Thread.sleep(5000);\n\n            // 6. Delete again and purge (cleanup)\n            System.out.println(\"=== Cleanup: Delete and Purge ===\");\n            manager.deleteSecretAndWait(\"demo-secret\");\n            Thread.sleep(5000);\n            manager.purgeDeletedSecret(\"demo-secret\");\n\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            System.err.println(\"Operation interrupted: \" + e.getMessage());\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**Key Implementation Details:**\n\n1. **SyncPoller Handling:**\n   - `beginDeleteSecret()` returns `SyncPoller<DeletedSecret, Void>`\n   - `beginRecoverDeletedSecret()` returns `SyncPoller<KeyVaultSecret, Void>`\n   - Use `poll()` to get immediate status without waiting\n   - Use `waitForCompletion()` to block until operation completes on server\n\n2. **Soft-Delete Operations:**\n   - `deleteSecret()` - Initiates deletion, returns immediately\n   - `deleteSecretAndWait()` - Waits for deletion to complete\n   - Deleted secrets remain recoverable until purged or retention period expires\n\n3. **Listing Deleted Secrets:**\n   - `listDeletedSecrets()` returns all soft-deleted secrets\n   - Each `DeletedSecret` includes recovery ID, deletion date, and scheduled purge date\n\n4. **Recovery:**\n   - `recoverDeletedSecret()` - Initiates recovery, returns immediately\n   - `recoverDeletedSecretAndWait()` - Waits for recovery to complete\n   - After recovery, secret is accessible again with same name\n\n5. **Purging:**\n   - `purgeDeletedSecret()` permanently deletes (irreversible)\n   - Only works on already-deleted secrets\n   - Requires \"Purge\" permission on Key Vault\n\nThis implementation provides complete soft-delete lifecycle management with proper polling and error handling.",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8423,
            "output_tokens": 3091,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "Here's the complete implementation with soft-delete handling, listing deleted secrets, and recovery:\n\n```java\nimport com.azure.security.keyvault.secrets.SecretClient;\nimport com.azure.security.keyvault.secrets.SecretClientBuilder;\nimport com.azure.security.keyvault.secrets.models.KeyVaultSecret;\nimport com.azure.security.keyvault.secrets.models.SecretProperties;\nimport com.azure.security.keyvault.secrets.models.DeletedSecret;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.core.util.polling.PollResponse;\nimport java.time.OffsetDateTime;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class SecretManager {\n    private final SecretClient client;\n\n    public SecretManager(String vaultUrl) {\n        this.client = new SecretClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n\n    public KeyVaultSecret createTaggedSecret(String name, String value, Map<String, String> tags) {\n        return client.setSecret(\n            new KeyVaultSecret(name, value)\n                .setProperties(new SecretProperties()\n                    .setExpiresOn(OffsetDateTime.now().plusYears(1))\n                    .setTags(tags)\n                )\n        );\n    }\n\n    /**\n     * Soft-delete a secret with polling support.\n     * Returns the deleted secret information once deletion begins.\n     */\n    public DeletedSecret deleteSecret(String secretName) {\n        // Begin delete operation - returns a poller for soft-delete enabled vaults\n        SyncPoller<DeletedSecret, Void> deletePoller = client.beginDeleteSecret(secretName);\n        \n        // Get the initial poll response - deleted secret is accessible immediately\n        PollResponse<DeletedSecret> pollResponse = deletePoller.poll();\n        DeletedSecret deletedSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Delete initiated for secret: %s%n\", deletedSecret.getName());\n        System.out.printf(\"Deleted on: %s%n\", deletedSecret.getDeletedOn());\n        System.out.printf(\"Scheduled purge date: %s%n\", deletedSecret.getScheduledPurgeDate());\n        System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n        \n        // Wait for deletion to complete on the server\n        deletePoller.waitForCompletion();\n        System.out.printf(\"Secret '%s' deletion completed%n\", secretName);\n        \n        return deletedSecret;\n    }\n\n    /**\n     * List all deleted secrets in the vault.\n     * Returns a list of deleted secret properties.\n     */\n    public List<DeletedSecret> listDeletedSecrets() {\n        List<DeletedSecret> deletedSecrets = new ArrayList<>();\n        \n        System.out.println(\"Listing deleted secrets:\");\n        for (DeletedSecret deletedSecret : client.listDeletedSecrets()) {\n            deletedSecrets.add(deletedSecret);\n            \n            System.out.printf(\"  Name: %s%n\", deletedSecret.getName());\n            System.out.printf(\"  Deleted on: %s%n\", deletedSecret.getDeletedOn());\n            System.out.printf(\"  Scheduled purge: %s%n\", deletedSecret.getScheduledPurgeDate());\n            System.out.printf(\"  Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n            System.out.println(\"  ---\");\n        }\n        \n        return deletedSecrets;\n    }\n\n    /**\n     * Recover a specific deleted secret.\n     * Uses polling to wait for recovery completion.\n     */\n    public KeyVaultSecret recoverDeletedSecret(String secretName) {\n        // Begin recovery operation\n        SyncPoller<KeyVaultSecret, Void> recoverPoller = \n            client.beginRecoverDeletedSecret(secretName);\n        \n        // Get the initial poll response - recovered secret is accessible immediately\n        PollResponse<KeyVaultSecret> pollResponse = recoverPoller.poll();\n        KeyVaultSecret recoveredSecret = pollResponse.getValue();\n        \n        System.out.printf(\"Recovery initiated for secret: %s%n\", recoveredSecret.getName());\n        System.out.printf(\"Secret ID: %s%n\", recoveredSecret.getId());\n        \n        // Wait for recovery to complete on the server\n        recoverPoller.waitForCompletion();\n        System.out.printf(\"Secret '%s' recovery completed%n\", secretName);\n        \n        return recoveredSecret;\n    }\n\n    /**\n     * Get a specific deleted secret's information.\n     */\n    public DeletedSecret getDeletedSecret(String secretName) {\n        DeletedSecret deletedSecret = client.getDeletedSecret(secretName);\n        \n        System.out.printf(\"Deleted secret: %s%n\", deletedSecret.getName());\n        System.out.printf(\"Deleted on: %s%n\", deletedSecret.getDeletedOn());\n        System.out.printf(\"Recovery ID: %s%n\", deletedSecret.getRecoveryId());\n        \n        return deletedSecret;\n    }\n\n    /**\n     * Permanently delete (purge) a deleted secret.\n     * This cannot be undone.\n     */\n    public void purgeDeletedSecret(String secretName) {\n        client.purgeDeletedSecret(secretName);\n        System.out.printf(\"Secret '%s' permanently purged%n\", secretName);\n    }\n\n    // Example usage\n    public static void main(String[] args) {\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        SecretManager manager = new SecretManager(vaultUrl);\n\n        // Create a secret with tags\n        KeyVaultSecret secret = manager.createTaggedSecret(\n            \"test-secret\",\n            \"secret-value\",\n            Map.of(\"environment\", \"dev\", \"owner\", \"team-a\")\n        );\n        System.out.printf(\"Created secret: %s%n\", secret.getName());\n\n        // Delete the secret (soft-delete)\n        DeletedSecret deleted = manager.deleteSecret(\"test-secret\");\n\n        // List all deleted secrets\n        List<DeletedSecret> deletedSecrets = manager.listDeletedSecrets();\n        System.out.printf(\"Found %d deleted secrets%n\", deletedSecrets.size());\n\n        // Recover the deleted secret\n        KeyVaultSecret recovered = manager.recoverDeletedSecret(\"test-secret\");\n        System.out.printf(\"Recovered secret: %s%n\", recovered.getName());\n    }\n}\n```\n\n**Key implementation details:**\n\n1. **`deleteSecret()`**: Uses `beginDeleteSecret()` which returns a `SyncPoller<DeletedSecret, Void>`. The deleted secret info is available immediately via `poll()`, and `waitForCompletion()` ensures the server-side deletion finishes.\n\n2. **`listDeletedSecrets()`**: Iterates through all deleted secrets using `client.listDeletedSecrets()` and collects them into a list.\n\n3. **`recoverDeletedSecret()`**: Uses `beginRecoverDeletedSecret()` with polling. The recovered secret is accessible immediately, and `waitForCompletion()` waits for server-side recovery.\n\n4. **Additional methods**: \n   - `getDeletedSecret()` - retrieves a specific deleted secret's info\n   - `purgeDeletedSecret()` - permanently deletes (cannot be recovered)\n\nThe SyncPoller pattern allows you to:\n- Get immediate access to the operation result via `poll().getValue()`\n- Wait for server-side completion with `waitForCompletion()`\n- Check operation status with `poll().getStatus()`",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8948,
            "output_tokens": 1929,
            "cached": false
          }
        }
      ]
    },
    {
      "task_id": "azure-security-keyvault-secrets-java-05",
      "task_type": "adjacent_domain",
      "target_language": "java",
      "expected_patterns": [
        "KeyClient|KeyClientBuilder",
        "CryptographyClient|CryptographyClientBuilder",
        "createRsaKey|CreateRsaKeyOptions",
        "sign\\(|SignResult",
        "verify\\(|VerifyResult",
        "azure-security-keyvault-keys|keyvault\\.keys"
      ],
      "anti_patterns": [
        "SecretClient|SecretClientBuilder",
        "setSecret\\(",
        "getSecret\\(",
        "azure-security-keyvault-secrets|keyvault\\.secrets",
        "KeyVaultSecret"
      ],
      "pattern_sources": [
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.keys.keyclient",
          "description": "Java KeyClient: createRsaKey with CreateRsaKeyOptions"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.keys.cryptography.cryptographyclient",
          "description": "Java CryptographyClient: sign/verify methods returning SignResult/VerifyResult"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.keys.keyclientbuilder",
          "description": "Java KeyClientBuilder for key vault keys client creation"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclient",
          "description": "Anti-patterns: Java SecretClient, setSecret, getSecret from the secrets SDK"
        },
        {
          "url": "https://learn.microsoft.com/en-us/java/api/com.azure.security.keyvault.secrets.secretclientbuilder",
          "description": "Anti-patterns: Java SecretClientBuilder from the secrets SDK"
        }
      ],
      "runs": [
        {
          "run_index": 0,
          "baseline": {
            "output": "# Azure Key Vault Keys SDK - RSA Signing Example\n\nHere's a complete Java application that demonstrates creating an RSA key, signing a message digest, and verifying the signature using Azure Key Vault Keys SDK.\n\n## Prerequisites\n\nAdd these dependencies to your `pom.xml`:\n\n```xml\n<dependencies>\n    <!-- Azure Key Vault Keys SDK -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n        <version>4.6.0</version>\n    </dependency>\n    \n    <!-- Azure Identity for authentication -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.11.0</version>\n    </dependency>\n    \n    <!-- SLF4J for logging -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-simple</artifactId>\n        <version>2.0.9</version>\n    </dependency>\n</dependencies>\n```\n\n## Java Application\n\n```java\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class AzureKeyVaultSigningExample {\n\n    // Replace with your Key Vault URL\n    private static final String KEY_VAULT_URL = \"https://your-keyvault-name.vault.azure.net/\";\n    private static final String KEY_NAME = \"my-rsa-signing-key\";\n\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"=== Azure Key Vault Keys SDK - RSA Signing Example ===\\n\");\n\n            // Step 1: Create KeyClient\n            KeyClient keyClient = createKeyClient();\n\n            // Step 2: Create or retrieve RSA key\n            KeyVaultKey rsaKey = createOrGetRsaKey(keyClient);\n\n            // Step 3: Create CryptographyClient\n            CryptographyClient cryptoClient = createCryptographyClient(rsaKey);\n\n            // Step 4: Prepare message and compute digest\n            String message = \"Hello, Azure Key Vault! This message will be signed.\";\n            byte[] messageDigest = computeSha256Digest(message);\n\n            // Step 5: Sign the message digest\n            SignResult signResult = signMessageDigest(cryptoClient, messageDigest);\n\n            // Step 6: Verify the signature\n            VerifyResult verifyResult = verifySignature(cryptoClient, messageDigest, signResult);\n\n            // Step 7: Display results\n            displayResults(message, messageDigest, signResult, verifyResult);\n\n            // Optional: Clean up - delete the key\n            // cleanupKey(keyClient);\n\n        } catch (Exception e) {\n            System.err.println(\"Error occurred: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Creates a KeyClient using DefaultAzureCredential\n     */\n    private static KeyClient createKeyClient() {\n        System.out.println(\"1. Creating KeyClient...\");\n        \n        KeyClient keyClient = new KeyClientBuilder()\n                .vaultUrl(KEY_VAULT_URL)\n                .credential(new DefaultAzureCredentialBuilder().build())\n                .buildClient();\n        \n        System.out.println(\"   \u2713 KeyClient created successfully\\n\");\n        return keyClient;\n    }\n\n    /**\n     * Creates a new RSA key or retrieves existing one\n     */\n    private static KeyVaultKey createOrGetRsaKey(KeyClient keyClient) {\n        System.out.println(\"2. Creating RSA key...\");\n        \n        try {\n            // Try to get existing key first\n            KeyVaultKey existingKey = keyClient.getKey(KEY_NAME);\n            System.out.println(\"   \u2713 Using existing RSA key: \" + existingKey.getName());\n            System.out.println(\"   Key ID: \" + existingKey.getId());\n            System.out.println(\"   Key Type: \" + existingKey.getKeyType() + \"\\n\");\n            return existingKey;\n        } catch (Exception e) {\n            // Key doesn't exist, create new one\n            System.out.println(\"   Key not found, creating new one...\");\n        }\n\n        CreateRsaKeyOptions keyOptions = new CreateRsaKeyOptions(KEY_NAME)\n                .setKeySize(2048)\n                .setEnabled(true);\n\n        KeyVaultKey rsaKey = keyClient.createRsaKey(keyOptions);\n        \n        System.out.println(\"   \u2713 RSA key created successfully\");\n        System.out.println(\"   Key Name: \" + rsaKey.getName());\n        System.out.println(\"   Key ID: \" + rsaKey.getId());\n        System.out.println(\"   Key Type: \" + rsaKey.getKeyType());\n        System.out.println(\"   Key Size: \" + rsaKey.getKey().getN().length * 8 + \" bits\\n\");\n        \n        return rsaKey;\n    }\n\n    /**\n     * Creates a CryptographyClient for cryptographic operations\n     */\n    private static CryptographyClient createCryptographyClient(KeyVaultKey key) {\n        System.out.println(\"3. Creating CryptographyClient...\");\n        \n        CryptographyClient cryptoClient = new CryptographyClientBuilder()\n                .credential(new DefaultAzureCredentialBuilder().build())\n                .keyIdentifier(key.getId())\n                .buildClient();\n        \n        System.out.println(\"   \u2713 CryptographyClient created successfully\\n\");\n        return cryptoClient;\n    }\n\n    /**\n     * Computes SHA-256 digest of the message\n     */\n    private static byte[] computeSha256Digest(String message) throws NoSuchAlgorithmException {\n        System.out.println(\"4. Computing message digest...\");\n        System.out.println(\"   Original message: \\\"\" + message + \"\\\"\");\n        \n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n        \n        System.out.println(\"   \u2713 SHA-256 digest computed\");\n        System.out.println(\"   Digest (Base64): \" + Base64.getEncoder().encodeToString(hash) + \"\\n\");\n        \n        return hash;\n    }\n\n    /**\n     * Signs the message digest using the RSA key\n     */\n    private static SignResult signMessageDigest(CryptographyClient cryptoClient, byte[] digest) {\n        System.out.println(\"5. Signing message digest...\");\n        \n        // Use RS256 (RSA with SHA-256)\n        SignResult signResult = cryptoClient.sign(SignatureAlgorithm.RS256, digest);\n        \n        System.out.println(\"   \u2713 Message digest signed successfully\");\n        System.out.println(\"   Algorithm: \" + signResult.getAlgorithm());\n        System.out.println(\"   Signature (Base64): \" + \n                Base64.getEncoder().encodeToString(signResult.getSignature()) + \"\\n\");\n        \n        return signResult;\n    }\n\n    /**\n     * Verifies the signature\n     */\n    private static VerifyResult verifySignature(CryptographyClient cryptoClient, \n                                                 byte[] digest, \n                                                 SignResult signResult) {\n        System.out.println(\"6. Verifying signature...\");\n        \n        VerifyResult verifyResult = cryptoClient.verify(\n                SignatureAlgorithm.RS256,\n                digest,\n                signResult.getSignature()\n        );\n        \n        System.out.println(\"   \u2713 Signature verification completed\");\n        System.out.println(\"   Is Valid: \" + verifyResult.isValid());\n        System.out.println(\"   Algorithm: \" + verifyResult.getAlgorithm() + \"\\n\");\n        \n        return verifyResult;\n    }\n\n    /**\n     * Displays the final results\n     */\n    private static void displayResults(String message, \n                                       byte[] digest, \n                                       SignResult signResult, \n                                       VerifyResult verifyResult) {\n        System.out.println(\"=== RESULTS ===\");\n        System.out.println(\"Original Message: \" + message);\n        System.out.println(\"Message Digest (SHA-256): \" + \n                Base64.getEncoder().encodeToString(digest));\n        System.out.println(\"Signature Algorithm: \" + signResult.getAlgorithm());\n        System.out.println(\"Signature (Base64): \" + \n                Base64.getEncoder().encodeToString(signResult.getSignature()));\n        System.out.println(\"Signature Valid: \" + verifyResult.isValid());\n        \n        if (verifyResult.isValid()) {\n            System.out.println(\"\\n\u2713 SUCCESS: Signature is valid!\");\n        } else {\n            System.out.println(\"\\n\u2717 FAILURE: Signature is invalid!\");\n        }\n    }\n\n    /**\n     * Optional: Deletes the key from Key Vault\n     */\n    private static void cleanupKey(KeyClient keyClient) {\n        System.out.println(\"\\n7. Cleaning up - deleting key...\");\n        \n        try {\n            keyClient.beginDeleteKey(KEY_NAME).waitForCompletion();\n            System.out.println(\"   \u2713 Key deleted successfully\");\n        } catch (Exception e) {\n            System.err.println(\"   \u2717 Failed to delete key: \" + e.getMessage());\n        }\n    }\n}\n```\n\n## Advanced Example with Multiple Signature Algorithms\n\n```java\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.util.Base64;\n\npublic class AdvancedSigningExample {\n\n    private static final String KEY_VAULT_URL = \"https://your-keyvault-name.vault.azure.net/\";\n\n    public static void main(String[] args) {\n        try {\n            KeyClient keyClient = new KeyClientBuilder()\n                    .vaultUrl(KEY_VAULT_URL)\n                    .credential(new DefaultAzureCredentialBuilder().build())\n                    .buildClient();\n\n            // Create RSA key\n            KeyVaultKey rsaKey = keyClient.createRsaKey(\n                    new CreateRsaKeyOptions(\"advanced-rsa-key\")\n                            .setKeySize(4096)\n            );\n\n            CryptographyClient cryptoClient = new CryptographyClientBuilder()\n                    .credential(new DefaultAzureCredentialBuilder().build())\n                    .keyIdentifier(rsaKey.getId())\n                    .buildClient();\n\n            String message = \"Test message for multiple algorithms\";\n\n            // Test different signature algorithms\n            testSignatureAlgorithm(cryptoClient, message, SignatureAlgorithm.RS256, \"SHA-256\");\n            testSignatureAlgorithm(cryptoClient, message, SignatureAlgorithm.RS384, \"SHA-384\");\n            testSignatureAlgorithm(cryptoClient, message, SignatureAlgorithm.RS512, \"SHA-512\");\n            testSignatureAlgorithm(cryptoClient, message, SignatureAlgorithm.PS256, \"SHA-256\");\n            testSignatureAlgorithm(cryptoClient, message, SignatureAlgorithm.PS384, \"SHA-384\");\n            testSignatureAlgorithm(cryptoClient, message, SignatureAlgorithm.PS512, \"SHA-512\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void testSignatureAlgorithm(CryptographyClient cryptoClient,\n                                               String message,\n                                               SignatureAlgorithm algorithm,\n                                               String hashAlgorithm) throws Exception {\n        System.out.println(\"\\n=== Testing \" + algorithm + \" ===\");\n\n        // Compute digest\n        MessageDigest digest = MessageDigest.getInstance(hashAlgorithm);\n        byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n\n        // Sign\n        SignResult signResult = cryptoClient.sign(algorithm, hash);\n        System.out.println(\"Signed with \" + algorithm);\n        System.out.println(\"Signature length: \" + signResult.getSignature().length + \" bytes\");\n\n        // Verify\n        VerifyResult verifyResult = cryptoClient.verify(\n                algorithm,\n                hash,\n                signResult.getSignature()\n        );\n        System.out.println(\"Verification result: \" + verifyResult.isValid());\n\n        // Test with tampered data\n        byte[] tamperedHash = hash.clone();\n        tamperedHash[0] ^= 0x01; // Flip one bit\n        VerifyResult tamperedResult = cryptoClient.verify(\n                algorithm,\n                tamperedHash,\n                signResult.getSignature()\n        );\n        System.out.println(\"Tampered data verification: \" + tamperedResult.isValid());\n    }\n}\n```\n\n## Configuration and Setup\n\n### 1. Environment Variables (Recommended)\n\n```bash\n# For Azure CLI authentication\naz login\n\n# Or set service principal credentials\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\n```\n\n### 2. Application Properties (Optional)\n\n```properties\n# application.properties\nazure.keyvault.url=https://your-keyvault-name.vault.azure.net/\nazure.keyvault.key.name=my-rsa-signing-key\n```\n\n### 3. Required Azure Permissions\n\nYour identity needs these Key Vault permissions:\n- **Keys**: Get, Create, Sign, Verify\n\n## Expected Output\n\n```\n=== Azure Key Vault Keys SDK - RSA Signing Example ===\n\n1. Creating KeyClient...\n   \u2713 KeyClient created successfully\n\n2. Creating RSA key...\n   \u2713 RSA key created successfully\n   Key Name: my-rsa-signing-key\n   Key ID: https://your-keyvault.vault.azure.net/keys/my-rsa-signing-key/abc123...\n   Key Type: RSA\n   Key Size: 2048 bits\n\n3. Creating CryptographyClient...\n   \u2713 CryptographyClient created successfully\n\n4. Computing message digest...\n   Original message: \"Hello, Azure Key Vault! This message will be signed.\"\n   \u2713 SHA-256 digest computed\n   Digest (Base64): 5Z8f3g...\n\n5. Signing message digest...\n   \u2713 Message digest signed successfully\n   Algorithm: RS256\n   Signature (Base64): d",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 67,
            "output_tokens": 4096,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Keys - RSA Sign and Verify Application\n\nI'll create a complete Java application that demonstrates RSA key creation, signing, and verification using Azure Key Vault Keys SDK.\n\n## Project Structure\n\n```\nkeyvault-keys-demo/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/main/java/com/example/keyvault/\n\u2502   \u251c\u2500\u2500 KeyVaultKeysDemo.java\n\u2502   \u251c\u2500\u2500 SignatureService.java\n\u2502   \u2514\u2500\u2500 KeyVaultConfig.java\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.example</groupId>\n    <artifactId>keyvault-keys-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Key Vault Keys Demo</name>\n    <description>Demo of RSA signing and verification with Azure Key Vault Keys SDK</description>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <azure.version>1.2.19</azure.version>\n    </properties>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.azure</groupId>\n                <artifactId>azure-sdk-bom</artifactId>\n                <version>${azure.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <dependencies>\n        <!-- Azure Key Vault Keys SDK -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-keys</artifactId>\n        </dependency>\n\n        <!-- Azure Identity for authentication -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n        </dependency>\n\n        <!-- SLF4J for logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>2.0.9</version>\n        </dependency>\n\n        <!-- JUnit for testing -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter</artifactId>\n            <version>5.10.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.11.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.codehaus.mojo</groupId>\n                <artifactId>exec-maven-plugin</artifactId>\n                <version>3.1.0</version>\n                <configuration>\n                    <mainClass>com.example.keyvault.KeyVaultKeysDemo</mainClass>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## KeyVaultConfig.java\n\n```java\npackage com.example.keyvault;\n\n/**\n * Configuration class for Azure Key Vault settings.\n */\npublic class KeyVaultConfig {\n    private final String vaultUrl;\n    private final String keyName;\n\n    public KeyVaultConfig(String vaultUrl, String keyName) {\n        if (vaultUrl == null || vaultUrl.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Vault URL cannot be null or empty\");\n        }\n        if (keyName == null || keyName.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Key name cannot be null or empty\");\n        }\n        \n        this.vaultUrl = vaultUrl;\n        this.keyName = keyName;\n    }\n\n    /**\n     * Creates configuration from environment variables.\n     * Expects AZURE_KEYVAULT_URL and optionally KEY_NAME (defaults to \"demo-rsa-key\")\n     */\n    public static KeyVaultConfig fromEnvironment() {\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        if (vaultUrl == null || vaultUrl.trim().isEmpty()) {\n            throw new IllegalStateException(\n                \"AZURE_KEYVAULT_URL environment variable must be set. \" +\n                \"Example: https://your-vault-name.vault.azure.net\"\n            );\n        }\n\n        String keyName = System.getenv(\"KEY_NAME\");\n        if (keyName == null || keyName.trim().isEmpty()) {\n            keyName = \"demo-rsa-key\";\n        }\n\n        return new KeyVaultConfig(vaultUrl, keyName);\n    }\n\n    public String getVaultUrl() {\n        return vaultUrl;\n    }\n\n    public String getKeyName() {\n        return keyName;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"KeyVaultConfig{vaultUrl='%s', keyName='%s'}\", \n            vaultUrl, keyName);\n    }\n}\n```\n\n## SignatureService.java\n\n```java\npackage com.example.keyvault;\n\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.Base64;\n\n/**\n * Service for RSA key operations including creation, signing, and verification.\n */\npublic class SignatureService {\n    private static final Logger logger = LoggerFactory.getLogger(SignatureService.class);\n    \n    private final KeyClient keyClient;\n    private final String keyName;\n\n    public SignatureService(KeyVaultConfig config) {\n        logger.info(\"Initializing SignatureService with config: {}\", config);\n        \n        // Create KeyClient for key management operations\n        this.keyClient = new KeyClientBuilder()\n            .vaultUrl(config.getVaultUrl())\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        this.keyName = config.getKeyName();\n        \n        logger.info(\"SignatureService initialized successfully\");\n    }\n\n    /**\n     * Creates or retrieves an RSA key in Azure Key Vault.\n     * \n     * @return The created or existing KeyVaultKey\n     */\n    public KeyVaultKey createOrGetRsaKey() {\n        logger.info(\"Creating or retrieving RSA key: {}\", keyName);\n        \n        try {\n            // Try to get existing key first\n            KeyVaultKey existingKey = keyClient.getKey(keyName);\n            logger.info(\"Found existing key: {} (Type: {}, Size: {} bits)\", \n                existingKey.getName(),\n                existingKey.getKeyType(),\n                existingKey.getKey().getN() != null ? existingKey.getKey().getN().length * 8 : \"unknown\");\n            return existingKey;\n        } catch (Exception e) {\n            logger.info(\"Key not found, creating new RSA key: {}\", keyName);\n        }\n\n        // Create new RSA key with specific options\n        CreateRsaKeyOptions keyOptions = new CreateRsaKeyOptions(keyName)\n            .setKeySize(2048)  // 2048-bit RSA key\n            .setEnabled(true);\n\n        KeyVaultKey key = keyClient.createRsaKey(keyOptions);\n        \n        logger.info(\"Successfully created RSA key: {} (ID: {})\", \n            key.getName(), key.getId());\n        logger.info(\"Key properties - Type: {}, Enabled: {}, Created: {}\", \n            key.getKeyType(), \n            key.getProperties().isEnabled(),\n            key.getProperties().getCreatedOn());\n        \n        return key;\n    }\n\n    /**\n     * Computes SHA-256 digest of a message.\n     * \n     * @param message The message to hash\n     * @return The SHA-256 digest bytes\n     */\n    public byte[] computeDigest(String message) throws NoSuchAlgorithmException {\n        logger.debug(\"Computing SHA-256 digest for message of length: {}\", message.length());\n        \n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n        \n        logger.debug(\"Computed digest: {} (length: {} bytes)\", \n            Base64.getEncoder().encodeToString(hash), hash.length);\n        \n        return hash;\n    }\n\n    /**\n     * Signs a message digest using the RSA key in Key Vault.\n     * \n     * @param keyId The full key identifier\n     * @param digest The message digest to sign\n     * @return SignResult containing the signature\n     */\n    public SignResult signDigest(String keyId, byte[] digest) {\n        logger.info(\"Signing digest with key: {}\", keyId);\n        logger.debug(\"Digest to sign: {} (length: {} bytes)\", \n            Base64.getEncoder().encodeToString(digest), digest.length);\n        \n        // Create CryptographyClient for cryptographic operations\n        CryptographyClient cryptoClient = new CryptographyClientBuilder()\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .keyIdentifier(keyId)\n            .buildClient();\n\n        // Sign the digest using RS256 (RSA with SHA-256)\n        SignResult signResult = cryptoClient.sign(SignatureAlgorithm.RS256, digest);\n        \n        logger.info(\"Successfully signed digest\");\n        logger.debug(\"Signature: {} (length: {} bytes)\", \n            Base64.getEncoder().encodeToString(signResult.getSignature()),\n            signResult.getSignature().length);\n        logger.debug(\"Algorithm used: {}\", signResult.getAlgorithm());\n        logger.debug(\"Key ID: {}\", signResult.getKeyId());\n        \n        return signResult;\n    }\n\n    /**\n     * Verifies a signature against a message digest.\n     * \n     * @param keyId The full key identifier\n     * @param digest The original message digest\n     * @param signature The signature to verify\n     * @return VerifyResult indicating if signature is valid\n     */\n    public VerifyResult verifySignature(String keyId, byte[] digest, byte[] signature) {\n        logger.info(\"Verifying signature with key: {}\", keyId);\n        logger.debug(\"Digest: {} (length: {} bytes)\", \n            Base64.getEncoder().encodeToString(digest), digest.length);\n        logger.debug(\"Signature: {} (length: {} bytes)\", \n            Base64.getEncoder().encodeToString(signature), signature.length);\n        \n        // Create CryptographyClient for verification\n        CryptographyClient cryptoClient = new CryptographyClientBuilder()\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .keyIdentifier(keyId)\n            .buildClient();\n\n        // Verify the signature\n        VerifyResult verifyResult = cryptoClient.verify(\n            SignatureAlgorithm.RS256, \n            digest, \n            signature\n        );\n        \n        logger.info(\"Signature verification result: {}\", verifyResult.isValid());\n        logger.debug(\"Algorithm used: {}\", verifyResult.getAlgorithm());\n        logger.debug(\"Key ID: {}\", verifyResult.getKeyId());\n        \n        return verifyResult;\n    }\n\n    /**\n     * Demonstrates tampering detection by verifying with modified digest.\n     * \n     * @param keyId The full key identifier\n     * @param originalDigest The original message digest\n     * @param signature The signature to verify\n     * @return VerifyResult (should be invalid)\n     */\n    public VerifyResult verifyWithTamperedDigest(String keyId, byte[] originalDigest, byte[] signature) {\n        logger.info(\"Testing signature verification with tampered digest\");\n        \n        // Create a tampered digest by modifying the first byte\n        byte[] tamperedDigest = Arrays.copyOf(originalDigest, originalDigest.length);\n        tamperedDigest[0] = (byte) (tamperedDigest[0] ^ 0xFF); // Flip all bits in first byte\n        \n        logger.debug(\"Original digest: {}\", \n            Base64.getEncoder().encodeToString(originalDigest));\n        logger.debug(\"Tampered digest: {}\", \n            Base64.getEncoder().encodeToString(tamperedDigest));\n        \n        return verifySignature(keyId, tamperedDigest, signature);\n    }\n\n    /**\n     * Gets the KeyClient for additional key operations.\n     */\n    public KeyClient getKeyClient() {\n        return keyClient;\n    }\n\n    /**\n     * Gets the configured key name.\n     */\n    public String getKeyName() {\n        return keyName;\n    }\n}\n```\n\n## KeyVaultKeysDemo.java\n\n```java\npackage com.example.keyvault;\n\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\n/**\n * Demonstration application for Azure Key Vault Keys SDK.\n * Shows RSA key creation, message signing, and signature verification.\n */\npublic class KeyVaultKeysDemo {\n    private static final Logger logger = LoggerFactory.getLogger(KeyVaultKeysDemo.class);\n\n    public static void main(String[] args) {\n        logger.info(\"=== Azure Key Vault Keys Demo - RSA Sign & Verify ===\");\n        logger.info(\"\");\n\n        try {\n            // Step 1: Load configuration\n            logger.info(\"Step 1: Loading configuration from environment\");\n            KeyVaultConfig config = KeyVaultConfig.fromEnvironment();\n            logger.info(\"Configuration loaded: {}\", config);\n            logger.info(\"\");\n\n            // Step 2: Initialize service\n            logger.info(\"Step 2: Initializing SignatureService\");\n            SignatureService service = new SignatureService(config);\n            logger.info(\"\");\n\n            // Step 3: Create or get RSA key\n            logger.info(\"Step 3: Creating or retrieving RSA key\");\n            KeyVaultKey key = service.createOrGetRsaKey();\n            printKey",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8136,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses Azure Key Vault Keys SDK to create an RSA key, sign a message digest, and verify the signature.\n\nFirst, let me add the required Maven dependency:\n\n```xml\n<!-- pom.xml -->\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-security-keyvault-keys</artifactId>\n    <version>4.8.0</version>\n</dependency>\n```\n\nNow, here's the complete application:\n\n```java\n// src/main/java/com/example/app/keyvault/KeyVaultSignatureDemo.java\npackage com.example.app.keyvault;\n\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class KeyVaultSignatureDemo {\n    private static final Logger log = LoggerFactory.getLogger(KeyVaultSignatureDemo.class);\n    \n    private final KeyClient keyClient;\n    private final String vaultUrl;\n    \n    public KeyVaultSignatureDemo(String vaultUrl) {\n        this.vaultUrl = vaultUrl;\n        this.keyClient = new KeyClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n    }\n    \n    /**\n     * Creates an RSA key in Azure Key Vault\n     */\n    public KeyVaultKey createRsaKey(String keyName) {\n        log.info(\"Creating RSA key: {}\", keyName);\n        \n        CreateRsaKeyOptions keyOptions = new CreateRsaKeyOptions(keyName)\n            .setKeySize(2048)\n            .setEnabled(true);\n        \n        KeyVaultKey key = keyClient.createRsaKey(keyOptions);\n        \n        log.info(\"Created RSA key: {} with ID: {}\", key.getName(), key.getId());\n        log.info(\"Key type: {}, Key size: {}\", key.getKeyType(), key.getKey().getN().length * 8);\n        \n        return key;\n    }\n    \n    /**\n     * Computes SHA-256 digest of a message\n     */\n    public byte[] computeDigest(String message) throws NoSuchAlgorithmException {\n        log.info(\"Computing SHA-256 digest of message: {}\", message);\n        \n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n        \n        log.info(\"Digest computed: {} bytes\", hash.length);\n        return hash;\n    }\n    \n    /**\n     * Signs a message digest using the RSA key in Key Vault\n     */\n    public SignResult signDigest(String keyName, byte[] digest) {\n        log.info(\"Signing digest with key: {}\", keyName);\n        \n        // Create cryptography client for the key\n        CryptographyClient cryptoClient = new CryptographyClientBuilder()\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .keyIdentifier(vaultUrl + \"/keys/\" + keyName)\n            .buildClient();\n        \n        // Sign the digest using RS256 (RSA with SHA-256)\n        SignResult signResult = cryptoClient.sign(SignatureAlgorithm.RS256, digest);\n        \n        log.info(\"Signature created: {} bytes\", signResult.getSignature().length);\n        log.info(\"Algorithm used: {}\", signResult.getAlgorithm());\n        log.info(\"Key ID: {}\", signResult.getKeyId());\n        \n        return signResult;\n    }\n    \n    /**\n     * Verifies a signature against the original digest\n     */\n    public VerifyResult verifySignature(String keyName, byte[] digest, byte[] signature) {\n        log.info(\"Verifying signature with key: {}\", keyName);\n        \n        CryptographyClient cryptoClient = new CryptographyClientBuilder()\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .keyIdentifier(vaultUrl + \"/keys/\" + keyName)\n            .buildClient();\n        \n        // Verify the signature\n        VerifyResult verifyResult = cryptoClient.verify(SignatureAlgorithm.RS256, digest, signature);\n        \n        log.info(\"Signature verification result: {}\", verifyResult.isValid());\n        log.info(\"Algorithm used: {}\", verifyResult.getAlgorithm());\n        log.info(\"Key ID: {}\", verifyResult.getKeyId());\n        \n        return verifyResult;\n    }\n    \n    /**\n     * Complete workflow: create key, sign, and verify\n     */\n    public void demonstrateSignatureWorkflow(String keyName, String message) {\n        try {\n            log.info(\"=== Starting Key Vault Signature Demo ===\");\n            log.info(\"Vault URL: {}\", vaultUrl);\n            log.info(\"Key name: {}\", keyName);\n            log.info(\"Message: {}\", message);\n            \n            // Step 1: Create RSA key\n            KeyVaultKey key = createRsaKey(keyName);\n            \n            // Step 2: Compute message digest\n            byte[] digest = computeDigest(message);\n            \n            // Step 3: Sign the digest\n            SignResult signResult = signDigest(keyName, digest);\n            byte[] signature = signResult.getSignature();\n            \n            // Step 4: Verify the signature\n            VerifyResult verifyResult = verifySignature(keyName, digest, signature);\n            \n            // Step 5: Display results\n            log.info(\"=== Results ===\");\n            log.info(\"Key created: {}\", key.getName());\n            log.info(\"Message digest length: {} bytes\", digest.length);\n            log.info(\"Signature length: {} bytes\", signature.length);\n            log.info(\"Signature valid: {}\", verifyResult.isValid());\n            \n            if (verifyResult.isValid()) {\n                log.info(\"\u2713 Signature verification PASSED\");\n            } else {\n                log.error(\"\u2717 Signature verification FAILED\");\n            }\n            \n            // Step 6: Test with tampered digest (should fail)\n            log.info(\"=== Testing with tampered digest ===\");\n            byte[] tamperedDigest = computeDigest(message + \" TAMPERED\");\n            VerifyResult tamperedResult = verifySignature(keyName, tamperedDigest, signature);\n            log.info(\"Tampered signature valid: {}\", tamperedResult.isValid());\n            \n            if (!tamperedResult.isValid()) {\n                log.info(\"\u2713 Tampered signature correctly rejected\");\n            } else {\n                log.error(\"\u2717 Tampered signature incorrectly accepted\");\n            }\n            \n        } catch (Exception e) {\n            log.error(\"Error during signature workflow\", e);\n            throw new RuntimeException(\"Signature workflow failed\", e);\n        }\n    }\n    \n    /**\n     * Cleanup: delete the key\n     */\n    public void deleteKey(String keyName) {\n        log.info(\"Deleting key: {}\", keyName);\n        keyClient.beginDeleteKey(keyName).waitForCompletion();\n        log.info(\"Key deleted: {}\", keyName);\n    }\n    \n    public static void main(String[] args) {\n        // Get vault URL from environment variable\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        if (vaultUrl == null || vaultUrl.isEmpty()) {\n            throw new IllegalStateException(\"AZURE_KEYVAULT_URL environment variable not set\");\n        }\n        \n        KeyVaultSignatureDemo demo = new KeyVaultSignatureDemo(vaultUrl);\n        \n        String keyName = \"demo-rsa-key-\" + System.currentTimeMillis();\n        String message = \"Hello, Azure Key Vault! This message will be signed.\";\n        \n        try {\n            demo.demonstrateSignatureWorkflow(keyName, message);\n        } finally {\n            // Cleanup\n            try {\n                demo.deleteKey(keyName);\n            } catch (Exception e) {\n                log.warn(\"Failed to delete key during cleanup\", e);\n            }\n        }\n    }\n}\n```\n\nNow let's create a service class that can be used in a Spring Boot application:\n\n```java\n// src/main/java/com/example/app/service/KeyVaultSignatureService.java\npackage com.example.app.service;\n\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\n@Service\npublic class KeyVaultSignatureService {\n    private static final Logger log = LoggerFactory.getLogger(KeyVaultSignatureService.class);\n    \n    private final KeyClient keyClient;\n    private final String vaultUrl;\n    \n    public KeyVaultSignatureService(@Value(\"${azure.keyvault.url}\") String vaultUrl) {\n        this.vaultUrl = vaultUrl;\n        this.keyClient = new KeyClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        log.info(\"KeyVaultSignatureService initialized with vault: {}\", vaultUrl);\n    }\n    \n    public KeyVaultKey createSigningKey(String keyName, int keySize) {\n        log.info(\"Creating RSA signing key: {} with size: {}\", keyName, keySize);\n        \n        CreateRsaKeyOptions options = new CreateRsaKeyOptions(keyName)\n            .setKeySize(keySize)\n            .setEnabled(true);\n        \n        KeyVaultKey key = keyClient.createRsaKey(options);\n        log.info(\"Created key: {}\", key.getId());\n        \n        return key;\n    }\n    \n    public String signMessage(String keyName, String message) {\n        try {\n            // Compute digest\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n            \n            // Create crypto client\n            CryptographyClient cryptoClient = createCryptoClient(keyName);\n            \n            // Sign\n            SignResult signResult = cryptoClient.sign(SignatureAlgorithm.RS256, hash);\n            \n            // Return base64-encoded signature\n            String signature = Base64.getEncoder().encodeToString(signResult.getSignature());\n            log.info(\"Message signed successfully with key: {}\", keyName);\n            \n            return signature;\n            \n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"Failed to compute message digest\", e);\n            throw new RuntimeException(\"Digest computation failed\", e);\n        }\n    }\n    \n    public boolean verifySignature(String keyName, String message, String signatureBase64) {\n        try {\n            // Compute digest\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n            \n            // Decode signature\n            byte[] signature = Base64.getDecoder().decode(signatureBase64);\n            \n            // Create crypto client\n            CryptographyClient cryptoClient = createCryptoClient(keyName);\n            \n            // Verify\n            VerifyResult verifyResult = cryptoClient.verify(SignatureAlgorithm.RS256, hash, signature);\n            \n            log.info(\"Signature verification for key {}: {}\", keyName, verifyResult.isValid());\n            return verifyResult.isValid();\n            \n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"Failed to compute message digest\", e);\n            throw new RuntimeException(\"Digest computation failed\", e);\n        }\n    }\n    \n    private CryptographyClient createCryptoClient(String keyName) {\n        return new CryptographyClientBuilder()\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .keyIdentifier(vaultUrl + \"/keys/\" + keyName)\n            .buildClient();\n    }\n    \n    public void deleteKey(String keyName) {\n        log.info(\"Deleting key: {}\", keyName);\n        keyClient.beginDeleteKey(keyName).waitForCompletion();\n        log.info(\"Key deleted successfully: {}\", keyName);\n    }\n}\n```\n\nAnd a test class:\n\n```java\n// src/test/java/com/example/app/keyvault/KeyVaultSignatureDemoTest.java\npackage com.example.app.keyvault;\n\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n@EnabledIfEnvironmentVariable(named = \"AZURE_KEYVAULT_URL\", matches = \".+\")\nclass KeyVaultSignatureDemoTest {\n    \n    private KeyVaultSignatureDemo demo;\n    private String testKeyName;\n    \n    @BeforeEach\n    void setUp() {\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        demo = new KeyVaultSignatureDemo(vaultUrl);\n        testKeyName = \"test-rsa-key-\" + System.currentTimeMillis();\n    }\n    \n    @AfterEach\n    void tearDown() {\n        if (demo != null && testKeyName != null) {\n            try {\n                demo.deleteKey(testKeyName);\n            } catch (Exception e) {\n                // Ignore cleanup errors\n            }\n        }\n    }\n    \n    @Test\n    void testCreateRsaKey() {\n        KeyVaultKey key = demo.createRsaKey(testKeyName);\n        \n        assertNotNull(key);\n        assertEquals(testKeyName, key.getName());\n        assertNotNull(key.getId());\n        assertTrue(key.getProperties().isEnabled());\n    }\n    \n    @Test\n    void testComputeDigest() throws Exception {\n        String message = \"Test message\";\n        byte[] digest = demo.computeDig",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8661,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 1,
          "baseline": {
            "output": "# Azure Key Vault Keys SDK - RSA Sign and Verify Example\n\nHere's a complete Java application that demonstrates creating an RSA key, signing a message digest, and verifying the signature using Azure Key Vault Keys SDK.\n\n## Prerequisites\n\nAdd these dependencies to your `pom.xml`:\n\n```xml\n<dependencies>\n    <!-- Azure Key Vault Keys SDK -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n        <version>4.6.0</version>\n    </dependency>\n    \n    <!-- Azure Identity for authentication -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.11.0</version>\n    </dependency>\n    \n    <!-- SLF4J for logging (optional) -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-simple</artifactId>\n        <version>2.0.9</version>\n    </dependency>\n</dependencies>\n```\n\n## Java Application\n\n```java\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\n/**\n * Azure Key Vault Keys SDK Demo\n * Demonstrates RSA key creation, message signing, and signature verification\n */\npublic class AzureKeyVaultSignVerifyDemo {\n\n    // Configure these values for your Azure Key Vault\n    private static final String KEY_VAULT_URL = \"https://your-keyvault-name.vault.azure.net/\";\n    private static final String KEY_NAME = \"demo-rsa-key\";\n\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"=== Azure Key Vault Keys SDK Demo ===\\n\");\n\n            // Step 1: Create KeyClient\n            KeyClient keyClient = createKeyClient();\n            System.out.println(\"\u2713 KeyClient created successfully\");\n\n            // Step 2: Create or retrieve RSA key\n            KeyVaultKey rsaKey = createOrGetRsaKey(keyClient);\n            System.out.println(\"\u2713 RSA Key: \" + rsaKey.getName());\n            System.out.println(\"  Key ID: \" + rsaKey.getId());\n            System.out.println(\"  Key Type: \" + rsaKey.getKeyType());\n            System.out.println();\n\n            // Step 3: Create CryptographyClient\n            CryptographyClient cryptoClient = createCryptographyClient(rsaKey);\n            System.out.println(\"\u2713 CryptographyClient created successfully\\n\");\n\n            // Step 4: Prepare message and compute digest\n            String message = \"Hello, Azure Key Vault! This is a test message for signing.\";\n            byte[] messageDigest = computeSha256Digest(message);\n            \n            System.out.println(\"Message: \" + message);\n            System.out.println(\"SHA-256 Digest: \" + Base64.getEncoder().encodeToString(messageDigest));\n            System.out.println();\n\n            // Step 5: Sign the message digest\n            SignResult signResult = signDigest(cryptoClient, messageDigest);\n            System.out.println(\"\u2713 Message signed successfully\");\n            System.out.println(\"  Algorithm: \" + signResult.getAlgorithm());\n            System.out.println(\"  Signature (Base64): \" + \n                Base64.getEncoder().encodeToString(signResult.getSignature()));\n            System.out.println();\n\n            // Step 6: Verify the signature\n            boolean isValid = verifySignature(cryptoClient, messageDigest, signResult.getSignature());\n            System.out.println(\"\u2713 Signature verification: \" + (isValid ? \"VALID \u2713\" : \"INVALID \u2717\"));\n            System.out.println();\n\n            // Step 7: Test with tampered data\n            System.out.println(\"--- Testing with tampered message ---\");\n            String tamperedMessage = \"Hello, Azure Key Vault! This message has been tampered.\";\n            byte[] tamperedDigest = computeSha256Digest(tamperedMessage);\n            boolean isTamperedValid = verifySignature(cryptoClient, tamperedDigest, signResult.getSignature());\n            System.out.println(\"\u2713 Tampered signature verification: \" + \n                (isTamperedValid ? \"VALID \u2713\" : \"INVALID \u2717 (as expected)\"));\n            System.out.println();\n\n            // Optional: Clean up - delete the key\n            // deleteKey(keyClient, KEY_NAME);\n\n            System.out.println(\"=== Demo completed successfully ===\");\n\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Creates a KeyClient using DefaultAzureCredential\n     */\n    private static KeyClient createKeyClient() {\n        return new KeyClientBuilder()\n                .vaultUrl(KEY_VAULT_URL)\n                .credential(new DefaultAzureCredentialBuilder().build())\n                .buildClient();\n    }\n\n    /**\n     * Creates a new RSA key or retrieves existing one\n     */\n    private static KeyVaultKey createOrGetRsaKey(KeyClient keyClient) {\n        try {\n            // Try to get existing key\n            KeyVaultKey existingKey = keyClient.getKey(KEY_NAME);\n            System.out.println(\"Using existing RSA key\");\n            return existingKey;\n        } catch (Exception e) {\n            // Key doesn't exist, create new one\n            System.out.println(\"Creating new RSA key...\");\n            CreateRsaKeyOptions createKeyOptions = new CreateRsaKeyOptions(KEY_NAME)\n                    .setKeySize(2048)\n                    .setEnabled(true);\n            \n            return keyClient.createRsaKey(createKeyOptions);\n        }\n    }\n\n    /**\n     * Creates a CryptographyClient for cryptographic operations\n     */\n    private static CryptographyClient createCryptographyClient(KeyVaultKey key) {\n        return new CryptographyClientBuilder()\n                .credential(new DefaultAzureCredentialBuilder().build())\n                .keyIdentifier(key.getId())\n                .buildClient();\n    }\n\n    /**\n     * Computes SHA-256 digest of a message\n     */\n    private static byte[] computeSha256Digest(String message) throws NoSuchAlgorithmException {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        return digest.digest(message.getBytes(StandardCharsets.UTF_8));\n    }\n\n    /**\n     * Signs a message digest using RSA-SHA256\n     */\n    private static SignResult signDigest(CryptographyClient cryptoClient, byte[] digest) {\n        // Use RS256 (RSA with SHA-256) signature algorithm\n        return cryptoClient.sign(SignatureAlgorithm.RS256, digest);\n    }\n\n    /**\n     * Verifies a signature against a message digest\n     */\n    private static boolean verifySignature(CryptographyClient cryptoClient, \n                                          byte[] digest, \n                                          byte[] signature) {\n        VerifyResult verifyResult = cryptoClient.verify(\n                SignatureAlgorithm.RS256, \n                digest, \n                signature\n        );\n        return verifyResult.isValid();\n    }\n\n    /**\n     * Deletes a key from Key Vault (optional cleanup)\n     */\n    private static void deleteKey(KeyClient keyClient, String keyName) {\n        System.out.println(\"Deleting key: \" + keyName);\n        keyClient.beginDeleteKey(keyName).waitForCompletion();\n        System.out.println(\"Key deleted successfully\");\n    }\n}\n```\n\n## Alternative: Async Version\n\n```java\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyAsyncClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyAsyncClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\n\npublic class AzureKeyVaultSignVerifyAsyncDemo {\n\n    private static final String KEY_VAULT_URL = \"https://your-keyvault-name.vault.azure.net/\";\n    private static final String KEY_NAME = \"demo-rsa-key-async\";\n\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"=== Azure Key Vault Keys SDK Async Demo ===\\n\");\n\n        // Create async clients\n        KeyAsyncClient keyAsyncClient = new KeyClientBuilder()\n                .vaultUrl(KEY_VAULT_URL)\n                .credential(new DefaultAzureCredentialBuilder().build())\n                .buildAsyncClient();\n\n        String message = \"Hello, Azure Key Vault Async!\";\n        byte[] digest = MessageDigest.getInstance(\"SHA-256\")\n                .digest(message.getBytes(StandardCharsets.UTF_8));\n\n        // Chain async operations\n        keyAsyncClient.createRsaKey(new CreateRsaKeyOptions(KEY_NAME).setKeySize(2048))\n                .flatMap(key -> {\n                    System.out.println(\"\u2713 Created RSA key: \" + key.getName());\n                    \n                    CryptographyAsyncClient cryptoClient = new CryptographyClientBuilder()\n                            .credential(new DefaultAzureCredentialBuilder().build())\n                            .keyIdentifier(key.getId())\n                            .buildAsyncClient();\n                    \n                    return cryptoClient.sign(SignatureAlgorithm.RS256, digest)\n                            .flatMap(signResult -> {\n                                System.out.println(\"\u2713 Signed message\");\n                                return cryptoClient.verify(\n                                        SignatureAlgorithm.RS256, \n                                        digest, \n                                        signResult.getSignature()\n                                );\n                            });\n                })\n                .subscribe(\n                        verifyResult -> {\n                            System.out.println(\"\u2713 Signature verified: \" + verifyResult.isValid());\n                            System.out.println(\"\\n=== Async demo completed ===\");\n                        },\n                        error -> System.err.println(\"Error: \" + error.getMessage())\n                );\n\n        // Keep main thread alive for async operations\n        Thread.sleep(5000);\n    }\n}\n```\n\n## Configuration\n\n### Environment Variables (for DefaultAzureCredential)\n\n```bash\n# Option 1: Service Principal\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\n\n# Option 2: Use Azure CLI\naz login\n```\n\n### Key Vault Access Policy\n\nEnsure your identity has these permissions:\n- **Key permissions**: Create, Get, Sign, Verify\n\n```bash\n# Grant permissions using Azure CLI\naz keyvault set-policy \\\n  --name your-keyvault-name \\\n  --object-id <your-object-id> \\\n  --key-permissions create get sign verify delete\n```\n\n## Supported Signature Algorithms\n\n```java\n// RSA algorithms\nSignatureAlgorithm.RS256  // RSA with SHA-256\nSignatureAlgorithm.RS384  // RSA with SHA-384\nSignatureAlgorithm.RS512  // RSA with SHA-512\n\n// RSA-PSS algorithms\nSignatureAlgorithm.PS256  // RSA-PSS with SHA-256\nSignatureAlgorithm.PS384  // RSA-PSS with SHA-384\nSignatureAlgorithm.PS512  // RSA-PSS with SHA-512\n\n// ECDSA algorithms (for EC keys)\nSignatureAlgorithm.ES256  // ECDSA with SHA-256\nSignatureAlgorithm.ES384  // ECDSA with SHA-384\nSignatureAlgorithm.ES512  // ECDSA with SHA-512\n```\n\n## Output Example\n\n```\n=== Azure Key Vault Keys SDK Demo ===\n\n\u2713 KeyClient created successfully\nCreating new RSA key...\n\u2713 RSA Key: demo-rsa-key\n  Key ID: https://your-keyvault.vault.azure.net/keys/demo-rsa-key/abc123...\n  Key Type: RSA\n\n\u2713 CryptographyClient created successfully\n\nMessage: Hello, Azure Key Vault! This is a test message for signing.\nSHA-256 Digest: 5Z8f9g3h2j1k...\n\n\u2713 Message signed successfully\n  Algorithm: RS256\n  Signature (Base64): MEUCIQDx7y8z...\n\n\u2713 Signature verification: VALID \u2713\n\n--- Testing with tampered message ---\n\u2713 Tampered signature verification: INVALID \u2717 (as expected)\n\n=== Demo completed successfully ===\n```\n\nThis application demonstrates the complete workflow of using Azure Key Vault Keys SDK for cryptographic operations with RSA keys!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 67,
            "output_tokens": 3544,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Keys - RSA Sign and Verify Application\n\nI'll create a complete Java application that demonstrates creating an RSA key, signing a message digest, and verifying the signature using Azure Key Vault Keys SDK.\n\n## Project Structure\n\n```\nkeyvault-keys-demo/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u2514\u2500\u2500 java/\n\u2502           \u2514\u2500\u2500 com/\n\u2502               \u2514\u2500\u2500 azure/\n\u2502                   \u2514\u2500\u2500 keyvault/\n\u2502                       \u2514\u2500\u2500 demo/\n\u2502                           \u251c\u2500\u2500 KeyVaultSignVerifyApp.java\n\u2502                           \u251c\u2500\u2500 KeyManager.java\n\u2502                           \u251c\u2500\u2500 SignatureService.java\n\u2502                           \u2514\u2500\u2500 config/\n\u2502                               \u2514\u2500\u2500 KeyVaultConfig.java\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.keyvault</groupId>\n    <artifactId>keyvault-keys-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Key Vault Keys Demo</name>\n    <description>Demo application for Azure Key Vault Keys SDK - RSA sign and verify</description>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <azure.version>1.2.19</azure.version>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Key Vault Keys SDK -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-keys</artifactId>\n            <version>4.8.5</version>\n        </dependency>\n\n        <!-- Azure Identity for authentication -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>1.13.2</version>\n        </dependency>\n\n        <!-- SLF4J API -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.13</version>\n        </dependency>\n\n        <!-- Logback for logging -->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.5.6</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.13.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.6.0</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.keyvault.demo.KeyVaultSignVerifyApp</mainClass>\n                                </transformer>\n                            </transformers>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## KeyVaultConfig.java\n\n```java\npackage com.azure.keyvault.demo.config;\n\n/**\n * Configuration class for Azure Key Vault settings.\n * Loads configuration from environment variables.\n */\npublic class KeyVaultConfig {\n    private final String vaultUrl;\n    private final String keyName;\n\n    public KeyVaultConfig() {\n        this.vaultUrl = getRequiredEnvVar(\"AZURE_KEYVAULT_URL\");\n        this.keyName = getEnvVarOrDefault(\"KEY_NAME\", \"demo-rsa-key\");\n    }\n\n    public KeyVaultConfig(String vaultUrl, String keyName) {\n        this.vaultUrl = vaultUrl;\n        this.keyName = keyName;\n    }\n\n    public String getVaultUrl() {\n        return vaultUrl;\n    }\n\n    public String getKeyName() {\n        return keyName;\n    }\n\n    private String getRequiredEnvVar(String name) {\n        String value = System.getenv(name);\n        if (value == null || value.trim().isEmpty()) {\n            throw new IllegalStateException(\n                String.format(\"Required environment variable '%s' is not set\", name)\n            );\n        }\n        return value;\n    }\n\n    private String getEnvVarOrDefault(String name, String defaultValue) {\n        String value = System.getenv(name);\n        return (value != null && !value.trim().isEmpty()) ? value : defaultValue;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"KeyVaultConfig{vaultUrl='%s', keyName='%s'}\", \n            vaultUrl, keyName);\n    }\n}\n```\n\n## KeyManager.java\n\n```java\npackage com.azure.keyvault.demo;\n\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport com.azure.security.keyvault.keys.models.KeyOperation;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Arrays;\n\n/**\n * Manages Azure Key Vault key operations including creation and retrieval.\n */\npublic class KeyManager {\n    private static final Logger logger = LoggerFactory.getLogger(KeyManager.class);\n    private final KeyClient keyClient;\n\n    public KeyManager(String vaultUrl) {\n        logger.info(\"Initializing KeyManager with vault URL: {}\", vaultUrl);\n        \n        this.keyClient = new KeyClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        logger.info(\"KeyClient created successfully\");\n    }\n\n    /**\n     * Creates or retrieves an RSA key with sign and verify operations enabled.\n     *\n     * @param keyName the name of the key to create or retrieve\n     * @param keySize the size of the RSA key (2048, 3072, or 4096)\n     * @return the created or existing KeyVaultKey\n     */\n    public KeyVaultKey createOrGetRsaKey(String keyName, int keySize) {\n        logger.info(\"Creating or retrieving RSA key: {} with size: {}\", keyName, keySize);\n        \n        try {\n            // Try to get existing key first\n            KeyVaultKey existingKey = keyClient.getKey(keyName);\n            logger.info(\"Found existing key: {} (version: {})\", \n                existingKey.getName(), \n                existingKey.getProperties().getVersion());\n            return existingKey;\n        } catch (Exception e) {\n            logger.info(\"Key not found, creating new RSA key: {}\", keyName);\n            \n            // Create new RSA key with sign and verify operations\n            CreateRsaKeyOptions keyOptions = new CreateRsaKeyOptions(keyName)\n                .setKeySize(keySize)\n                .setKeyOperations(\n                    KeyOperation.SIGN,\n                    KeyOperation.VERIFY\n                );\n            \n            KeyVaultKey newKey = keyClient.createRsaKey(keyOptions);\n            \n            logger.info(\"Successfully created RSA key: {} (ID: {})\", \n                newKey.getName(), \n                newKey.getId());\n            logger.info(\"Key type: {}, Key size: {}\", \n                newKey.getKeyType(), \n                newKey.getKey().getN().length * 8);\n            logger.info(\"Enabled operations: {}\", \n                Arrays.toString(newKey.getKeyOperations().toArray()));\n            \n            return newKey;\n        }\n    }\n\n    /**\n     * Gets an existing key from the vault.\n     *\n     * @param keyName the name of the key to retrieve\n     * @return the KeyVaultKey\n     */\n    public KeyVaultKey getKey(String keyName) {\n        logger.info(\"Retrieving key: {}\", keyName);\n        KeyVaultKey key = keyClient.getKey(keyName);\n        logger.info(\"Retrieved key: {} (version: {})\", \n            key.getName(), \n            key.getProperties().getVersion());\n        return key;\n    }\n\n    /**\n     * Deletes a key from the vault (soft delete).\n     *\n     * @param keyName the name of the key to delete\n     */\n    public void deleteKey(String keyName) {\n        logger.info(\"Deleting key: {}\", keyName);\n        keyClient.beginDeleteKey(keyName).waitForCompletion();\n        logger.info(\"Key deleted successfully: {}\", keyName);\n    }\n\n    /**\n     * Gets the KeyClient instance.\n     *\n     * @return the KeyClient\n     */\n    public KeyClient getKeyClient() {\n        return keyClient;\n    }\n}\n```\n\n## SignatureService.java\n\n```java\npackage com.azure.keyvault.demo;\n\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\n/**\n * Service for signing and verifying messages using Azure Key Vault keys.\n */\npublic class SignatureService {\n    private static final Logger logger = LoggerFactory.getLogger(SignatureService.class);\n    private final CryptographyClient cryptoClient;\n\n    public SignatureService(KeyVaultKey key) {\n        logger.info(\"Initializing SignatureService for key: {}\", key.getName());\n        \n        this.cryptoClient = new CryptographyClientBuilder()\n            .keyIdentifier(key.getId())\n            .buildClient();\n        \n        logger.info(\"CryptographyClient created successfully\");\n    }\n\n    /**\n     * Computes SHA-256 hash of the input message.\n     *\n     * @param message the message to hash\n     * @return the SHA-256 digest\n     */\n    public byte[] computeDigest(String message) {\n        logger.info(\"Computing SHA-256 digest for message (length: {} chars)\", \n            message.length());\n        \n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n            \n            logger.info(\"Digest computed successfully (length: {} bytes)\", hash.length);\n            logger.debug(\"Digest (Base64): {}\", Base64.getEncoder().encodeToString(hash));\n            \n            return hash;\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"SHA-256 algorithm not available\", e);\n            throw new RuntimeException(\"Failed to compute digest\", e);\n        }\n    }\n\n    /**\n     * Signs a message digest using the RSA key in Key Vault.\n     *\n     * @param digest the message digest to sign\n     * @param algorithm the signature algorithm to use\n     * @return the signature result\n     */\n    public SignResult sign(byte[] digest, SignatureAlgorithm algorithm) {\n        logger.info(\"Signing digest with algorithm: {}\", algorithm);\n        logger.debug(\"Digest length: {} bytes\", digest.length);\n        \n        SignResult signResult = cryptoClient.sign(algorithm, digest);\n        \n        logger.info(\"Signature created successfully\");\n        logger.info(\"Signature length: {} bytes\", signResult.getSignature().length);\n        logger.info(\"Algorithm used: {}\", signResult.getAlgorithm());\n        logger.info(\"Key ID: {}\", signResult.getKeyId());\n        logger.debug(\"Signature (Base64): {}\", \n            Base64.getEncoder().encodeToString(signResult.getSignature()));\n        \n        return signResult;\n    }\n\n    /**\n     * Verifies a signature against a message digest.\n     *\n     * @param digest the original message digest\n     * @param signature the signature to verify\n     * @param algorithm the signature algorithm used\n     * @return the verification result\n     */\n    public VerifyResult verify(byte[] digest, byte[] signature, SignatureAlgorithm algorithm) {\n        logger.info(\"Verifying signature with algorithm: {}\", algorithm);\n        logger.debug(\"Digest length: {} bytes, Signature length: {} bytes\", \n            digest.length, signature.length);\n        \n        VerifyResult verifyResult = cryptoClient.verify(algorithm, digest, signature);\n        \n        logger.info(\"Verification completed\");\n        logger.info(\"Is valid: {}\", verifyResult.isValid());\n        logger.info(\"Algorithm used: {}\", verifyResult.getAlgorithm());\n        logger.info(\"Key ID: {}\", verifyResult.getKeyId());\n        \n        return verifyResult;\n    }\n\n    /**\n     * Signs a message (computes digest and signs it).\n     *\n     * @param message the message to sign\n     * @param algorithm the signature algorithm to use\n     * @return the signature result\n     */\n    public SignResult signMessage(String message, SignatureAlgorithm algorithm) {\n        logger.info(\"Signing message: '{}'\", \n            message.length() > 50 ? message.substring(0, 50) + \"...\" : message);\n        \n        byte[] digest = computeDigest(message);\n        return sign(digest, algorithm);\n    }\n\n    /**\n     * Verifies a message signature.\n     *\n     * @param message the original message\n     * @param signature the signature to verify\n     * @param algorithm the signature algorithm used\n     * @return the verification result\n     */\n    public VerifyResult verifyMessage(String message, byte[] signature, \n                                     SignatureAlgorithm algorithm) {\n        logger.info(\"Verifying message signature\");\n        \n        byte[] digest = computeDigest(message);\n        return verify(digest, signature, algorithm);\n    }\n\n    /**\n     * Gets the CryptographyClient instance.\n     *\n     * @return the CryptographyClient\n     */\n    public CryptographyClient getCryptoClient() {\n        return cryptoClient;\n    }\n}\n```\n\n## KeyVaultSignVerifyApp.java\n\n```java\npackage com.azure.keyvault.demo;\n\nimport com.azure.keyvault.demo.config.KeyVaultConfig;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8136,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses Azure Key Vault Keys SDK to create an RSA key, sign a message digest, and verify the signature.\n\nFirst, let me add the required dependencies to your `pom.xml`:\n\n```xml\n<!-- Add these dependencies to your pom.xml -->\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-security-keyvault-keys</artifactId>\n    <version>4.8.0</version>\n</dependency>\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-identity</artifactId>\n    <version>1.11.0</version>\n</dependency>\n```\n\nNow, let me create the application:\n\n```java\npackage com.example.app.keyvault;\n\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * Azure Key Vault Keys SDK example demonstrating:\n * 1. Creating an RSA key\n * 2. Signing a message digest\n * 3. Verifying the signature\n */\npublic class KeyVaultSignatureApp {\n    private static final Logger log = LoggerFactory.getLogger(KeyVaultSignatureApp.class);\n    \n    private final KeyClient keyClient;\n    private final String vaultUrl;\n    \n    public KeyVaultSignatureApp(String vaultUrl) {\n        this.vaultUrl = vaultUrl;\n        this.keyClient = new KeyClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        log.info(\"KeyClient initialized for vault: {}\", vaultUrl);\n    }\n    \n    /**\n     * Creates an RSA key in Azure Key Vault\n     */\n    public KeyVaultKey createRsaKey(String keyName, int keySize) {\n        log.info(\"Creating RSA key '{}' with size {} bits\", keyName, keySize);\n        \n        CreateRsaKeyOptions keyOptions = new CreateRsaKeyOptions(keyName)\n            .setKeySize(keySize)\n            .setEnabled(true);\n        \n        KeyVaultKey key = keyClient.createRsaKey(keyOptions);\n        \n        log.info(\"RSA key created successfully:\");\n        log.info(\"  Name: {}\", key.getName());\n        log.info(\"  ID: {}\", key.getId());\n        log.info(\"  Key Type: {}\", key.getKeyType());\n        log.info(\"  Key Size: {} bits\", key.getKey().getN().length * 8);\n        \n        return key;\n    }\n    \n    /**\n     * Computes SHA-256 digest of a message\n     */\n    public byte[] computeDigest(String message) throws NoSuchAlgorithmException {\n        log.info(\"Computing SHA-256 digest of message: '{}'\", message);\n        \n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n        \n        log.info(\"Digest computed: {} bytes\", hash.length);\n        return hash;\n    }\n    \n    /**\n     * Signs a message digest using the RSA key in Key Vault\n     */\n    public SignResult signDigest(String keyName, byte[] digest) {\n        log.info(\"Signing digest with key '{}'\", keyName);\n        \n        // Create CryptographyClient for the specific key\n        CryptographyClient cryptoClient = new CryptographyClientBuilder()\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .keyIdentifier(keyClient.getKey(keyName).getId())\n            .buildClient();\n        \n        // Sign the digest using RS256 (RSA with SHA-256)\n        SignResult signResult = cryptoClient.sign(SignatureAlgorithm.RS256, digest);\n        \n        log.info(\"Signature created:\");\n        log.info(\"  Algorithm: {}\", signResult.getAlgorithm());\n        log.info(\"  Signature length: {} bytes\", signResult.getSignature().length);\n        log.info(\"  Key ID: {}\", signResult.getKeyId());\n        \n        return signResult;\n    }\n    \n    /**\n     * Verifies a signature against the original digest\n     */\n    public VerifyResult verifySignature(String keyName, byte[] digest, byte[] signature) {\n        log.info(\"Verifying signature with key '{}'\", keyName);\n        \n        // Create CryptographyClient for the specific key\n        CryptographyClient cryptoClient = new CryptographyClientBuilder()\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .keyIdentifier(keyClient.getKey(keyName).getId())\n            .buildClient();\n        \n        // Verify the signature\n        VerifyResult verifyResult = cryptoClient.verify(\n            SignatureAlgorithm.RS256, \n            digest, \n            signature\n        );\n        \n        log.info(\"Signature verification result:\");\n        log.info(\"  Valid: {}\", verifyResult.isValid());\n        log.info(\"  Algorithm: {}\", verifyResult.getAlgorithm());\n        log.info(\"  Key ID: {}\", verifyResult.getKeyId());\n        \n        return verifyResult;\n    }\n    \n    /**\n     * Demonstrates the complete workflow\n     */\n    public void demonstrateSignAndVerify(String keyName, String message) {\n        try {\n            log.info(\"=== Starting Key Vault Signature Demo ===\");\n            \n            // Step 1: Create RSA key\n            KeyVaultKey key = createRsaKey(keyName, 2048);\n            \n            // Step 2: Compute message digest\n            byte[] digest = computeDigest(message);\n            \n            // Step 3: Sign the digest\n            SignResult signResult = signDigest(keyName, digest);\n            \n            // Step 4: Verify the signature\n            VerifyResult verifyResult = verifySignature(\n                keyName, \n                digest, \n                signResult.getSignature()\n            );\n            \n            // Step 5: Display results\n            log.info(\"=== Demo Complete ===\");\n            log.info(\"Original message: '{}'\", message);\n            log.info(\"Signature valid: {}\", verifyResult.isValid());\n            \n            if (verifyResult.isValid()) {\n                log.info(\"\u2713 Signature verification PASSED\");\n            } else {\n                log.error(\"\u2717 Signature verification FAILED\");\n            }\n            \n        } catch (Exception e) {\n            log.error(\"Error during signature demo\", e);\n            throw new RuntimeException(\"Signature demo failed\", e);\n        }\n    }\n    \n    /**\n     * Demonstrates signature verification failure with tampered data\n     */\n    public void demonstrateInvalidSignature(String keyName, String originalMessage, String tamperedMessage) {\n        try {\n            log.info(\"=== Demonstrating Invalid Signature Detection ===\");\n            \n            // Create digest and sign original message\n            byte[] originalDigest = computeDigest(originalMessage);\n            SignResult signResult = signDigest(keyName, originalDigest);\n            \n            // Try to verify with tampered message digest\n            byte[] tamperedDigest = computeDigest(tamperedMessage);\n            VerifyResult verifyResult = verifySignature(\n                keyName, \n                tamperedDigest, \n                signResult.getSignature()\n            );\n            \n            log.info(\"Original message: '{}'\", originalMessage);\n            log.info(\"Tampered message: '{}'\", tamperedMessage);\n            log.info(\"Signature valid: {}\", verifyResult.isValid());\n            \n            if (!verifyResult.isValid()) {\n                log.info(\"\u2713 Tampering detected successfully\");\n            } else {\n                log.warn(\"\u2717 Failed to detect tampering\");\n            }\n            \n        } catch (Exception e) {\n            log.error(\"Error during invalid signature demo\", e);\n            throw new RuntimeException(\"Invalid signature demo failed\", e);\n        }\n    }\n    \n    /**\n     * Cleans up by deleting the key\n     */\n    public void cleanup(String keyName) {\n        try {\n            log.info(\"Cleaning up: deleting key '{}'\", keyName);\n            keyClient.beginDeleteKey(keyName).waitForCompletion();\n            log.info(\"Key deleted successfully\");\n        } catch (Exception e) {\n            log.warn(\"Failed to delete key: {}\", e.getMessage());\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Get vault URL from environment variable\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        if (vaultUrl == null || vaultUrl.isEmpty()) {\n            throw new IllegalStateException(\n                \"AZURE_KEYVAULT_URL environment variable must be set\"\n            );\n        }\n        \n        KeyVaultSignatureApp app = new KeyVaultSignatureApp(vaultUrl);\n        String keyName = \"demo-rsa-key-\" + System.currentTimeMillis();\n        \n        try {\n            // Demo 1: Valid signature\n            app.demonstrateSignAndVerify(\n                keyName, \n                \"This is a secret message that needs to be signed\"\n            );\n            \n            System.out.println(\"\\n\" + \"=\".repeat(60) + \"\\n\");\n            \n            // Demo 2: Invalid signature (tampered data)\n            app.demonstrateInvalidSignature(\n                keyName,\n                \"Original message\",\n                \"Tampered message\"\n            );\n            \n        } finally {\n            // Cleanup\n            app.cleanup(keyName);\n        }\n    }\n}\n```\n\nNow let me create a test class for this application:\n\n```java\npackage com.example.app.keyvault;\n\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;\n\nimport java.security.NoSuchAlgorithmException;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * Integration tests for KeyVaultSignatureApp\n * Requires AZURE_KEYVAULT_URL environment variable to be set\n */\n@EnabledIfEnvironmentVariable(named = \"AZURE_KEYVAULT_URL\", matches = \".+\")\nclass KeyVaultSignatureAppTest {\n    \n    private KeyVaultSignatureApp app;\n    private String testKeyName;\n    \n    @BeforeEach\n    void setUp() {\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        app = new KeyVaultSignatureApp(vaultUrl);\n        testKeyName = \"test-rsa-key-\" + System.currentTimeMillis();\n    }\n    \n    @Test\n    void testCreateRsaKey() {\n        try {\n            KeyVaultKey key = app.createRsaKey(testKeyName, 2048);\n            \n            assertNotNull(key);\n            assertEquals(testKeyName, key.getName());\n            assertNotNull(key.getId());\n            assertNotNull(key.getKey());\n            \n        } finally {\n            app.cleanup(testKeyName);\n        }\n    }\n    \n    @Test\n    void testComputeDigest() throws NoSuchAlgorithmException {\n        String message = \"Test message\";\n        byte[] digest = app.computeDigest(message);\n        \n        assertNotNull(digest);\n        assertEquals(32, digest.length); // SHA-256 produces 32 bytes\n    }\n    \n    @Test\n    void testSignAndVerify() throws NoSuchAlgorithmException {\n        try {\n            // Create key\n            app.createRsaKey(testKeyName, 2048);\n            \n            // Compute digest\n            String message = \"Test message for signing\";\n            byte[] digest = app.computeDigest(message);\n            \n            // Sign\n            SignResult signResult = app.signDigest(testKeyName, digest);\n            assertNotNull(signResult);\n            assertNotNull(signResult.getSignature());\n            assertTrue(signResult.getSignature().length > 0);\n            \n            // Verify\n            VerifyResult verifyResult = app.verifySignature(\n                testKeyName, \n                digest, \n                signResult.getSignature()\n            );\n            assertNotNull(verifyResult);\n            assertTrue(verifyResult.isValid());\n            \n        } finally {\n            app.cleanup(testKeyName);\n        }\n    }\n    \n    @Test\n    void testInvalidSignatureDetection() throws NoSuchAlgorithmException {\n        try {\n            // Create key\n            app.createRsaKey(testKeyName, 2048);\n            \n            // Sign original message\n            String originalMessage = \"Original message\";\n            byte[] originalDigest = app.computeDigest(originalMessage);\n            SignResult signResult = app.signDigest(testKeyName, originalDigest);\n            \n            // Try to verify with different message\n            String tamperedMessage = \"Tampered message\";\n            byte[] tamperedDigest = app.computeDigest(tamperedMessage);\n            VerifyResult verifyResult = app.verifySignature(\n                testKeyName, \n                tamperedDigest, \n                signResult.getSignature()\n            );\n            \n            assertNotNull(verifyResult);\n            assertFalse(verifyResult.isValid(), \"Signature should be invalid for tampered data\");\n            \n        } finally {\n            app.cleanup(testKeyName);\n        }\n    }\n    \n    @Test\n    void testCompleteWorkflow() {\n        try {\n            String message = \"Complete workflow test message\";\n            app.demonstrateSignAndVerify(testKeyName, message);\n            \n            // If we get here without exception, the workflow succeeded\n            assertTrue(true);\n            \n        } finally {\n            app.cleanup(testKeyName);\n        }\n    }\n}\n```\n\nLet me also create a configuration class for Spring Boot integration:\n\n```java\npackage com.example.app.config;\n\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * Configuration for Azure Key Vault Keys SDK\n */\n@Configuration\npublic class KeyVaultKeysConfig {\n    \n    @Value(\"${azure.keyvault.url:#{environment.AZURE_KEYVAULT_URL}}\")\n    private String vaultUrl;\n    \n    @Bean\n    public KeyClient keyClient() {\n        if (vaultUrl == null || vaultUrl.isEmpty()) {\n            throw new IllegalStateException(\n                \"Azure Key Vault URL must be configured via azure.keyvault.url property \" +\n                \"or AZURE_KEYVAULT_URL environment variable\"\n            );\n        }\n        \n        return new KeyClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8661,
            "output_tokens": 4096,
            "cached": false
          }
        },
        {
          "run_index": 2,
          "baseline": {
            "output": "# Azure Key Vault Keys SDK - RSA Sign and Verify Example\n\nHere's a complete Java application that demonstrates creating an RSA key, signing a message digest, and verifying the signature using Azure Key Vault Keys SDK.\n\n## Prerequisites\n\nAdd these dependencies to your `pom.xml`:\n\n```xml\n<dependencies>\n    <!-- Azure Key Vault Keys SDK -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-security-keyvault-keys</artifactId>\n        <version>4.6.0</version>\n    </dependency>\n    \n    <!-- Azure Identity for authentication -->\n    <dependency>\n        <groupId>com.azure</groupId>\n        <artifactId>azure-identity</artifactId>\n        <version>1.10.0</version>\n    </dependency>\n    \n    <!-- SLF4J for logging (optional) -->\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-simple</artifactId>\n        <version>2.0.9</version>\n    </dependency>\n</dependencies>\n```\n\n## Java Application\n\n```java\nimport com.azure.identity.DefaultAzureCredential;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\n/**\n * Azure Key Vault Keys SDK Example\n * Demonstrates RSA key creation, message signing, and signature verification\n */\npublic class AzureKeyVaultSignVerifyExample {\n\n    // Replace with your Key Vault URL\n    private static final String KEY_VAULT_URL = \"https://your-keyvault-name.vault.azure.net/\";\n    private static final String KEY_NAME = \"my-rsa-signing-key\";\n\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"=== Azure Key Vault Keys SDK - Sign and Verify Example ===\\n\");\n\n            // Step 1: Create KeyClient\n            KeyClient keyClient = createKeyClient();\n            System.out.println(\"\u2713 KeyClient created successfully\");\n\n            // Step 2: Create or retrieve RSA key\n            KeyVaultKey rsaKey = createOrGetRsaKey(keyClient);\n            System.out.println(\"\u2713 RSA Key: \" + rsaKey.getName());\n            System.out.println(\"  Key ID: \" + rsaKey.getId());\n            System.out.println(\"  Key Type: \" + rsaKey.getKeyType());\n            System.out.println();\n\n            // Step 3: Create CryptographyClient\n            CryptographyClient cryptoClient = createCryptographyClient(rsaKey.getId());\n            System.out.println(\"\u2713 CryptographyClient created successfully\\n\");\n\n            // Step 4: Prepare message and compute digest\n            String message = \"Hello, Azure Key Vault! This is a test message for signing.\";\n            byte[] messageDigest = computeSha256Digest(message);\n            \n            System.out.println(\"Original Message: \" + message);\n            System.out.println(\"SHA-256 Digest: \" + Base64.getEncoder().encodeToString(messageDigest));\n            System.out.println();\n\n            // Step 5: Sign the message digest\n            SignResult signResult = signDigest(cryptoClient, messageDigest);\n            byte[] signature = signResult.getSignature();\n            \n            System.out.println(\"\u2713 Message signed successfully\");\n            System.out.println(\"  Algorithm: \" + signResult.getAlgorithm());\n            System.out.println(\"  Signature (Base64): \" + Base64.getEncoder().encodeToString(signature));\n            System.out.println();\n\n            // Step 6: Verify the signature\n            VerifyResult verifyResult = verifySignature(cryptoClient, messageDigest, signature);\n            \n            System.out.println(\"\u2713 Signature verification completed\");\n            System.out.println(\"  Is Valid: \" + verifyResult.isValid());\n            System.out.println(\"  Algorithm: \" + verifyResult.getAlgorithm());\n            System.out.println();\n\n            // Step 7: Test with tampered data\n            testTamperedData(cryptoClient, messageDigest, signature);\n\n            // Optional: Clean up (uncomment to delete the key)\n            // cleanUp(keyClient);\n\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Creates a KeyClient using DefaultAzureCredential\n     */\n    private static KeyClient createKeyClient() {\n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .build();\n\n        return new KeyClientBuilder()\n                .vaultUrl(KEY_VAULT_URL)\n                .credential(credential)\n                .buildClient();\n    }\n\n    /**\n     * Creates or retrieves an RSA key from Key Vault\n     */\n    private static KeyVaultKey createOrGetRsaKey(KeyClient keyClient) {\n        try {\n            // Try to get existing key\n            return keyClient.getKey(KEY_NAME);\n        } catch (Exception e) {\n            // Key doesn't exist, create new one\n            System.out.println(\"Creating new RSA key...\");\n            \n            CreateRsaKeyOptions keyOptions = new CreateRsaKeyOptions(KEY_NAME)\n                    .setKeySize(2048)  // 2048-bit RSA key\n                    .setEnabled(true);\n            \n            return keyClient.createRsaKey(keyOptions);\n        }\n    }\n\n    /**\n     * Creates a CryptographyClient for cryptographic operations\n     */\n    private static CryptographyClient createCryptographyClient(String keyId) {\n        DefaultAzureCredential credential = new DefaultAzureCredentialBuilder()\n                .build();\n\n        return new CryptographyClientBuilder()\n                .credential(credential)\n                .keyIdentifier(keyId)\n                .buildClient();\n    }\n\n    /**\n     * Computes SHA-256 digest of a message\n     */\n    private static byte[] computeSha256Digest(String message) throws NoSuchAlgorithmException {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        return digest.digest(message.getBytes(StandardCharsets.UTF_8));\n    }\n\n    /**\n     * Signs a message digest using RSA-SHA256\n     */\n    private static SignResult signDigest(CryptographyClient cryptoClient, byte[] messageDigest) {\n        // Use RS256 (RSA with SHA-256)\n        return cryptoClient.sign(SignatureAlgorithm.RS256, messageDigest);\n    }\n\n    /**\n     * Verifies a signature against a message digest\n     */\n    private static VerifyResult verifySignature(\n            CryptographyClient cryptoClient, \n            byte[] messageDigest, \n            byte[] signature) {\n        \n        return cryptoClient.verify(SignatureAlgorithm.RS256, messageDigest, signature);\n    }\n\n    /**\n     * Tests verification with tampered data\n     */\n    private static void testTamperedData(\n            CryptographyClient cryptoClient, \n            byte[] originalDigest, \n            byte[] signature) throws NoSuchAlgorithmException {\n        \n        System.out.println(\"--- Testing with Tampered Data ---\");\n        \n        // Create a different message\n        String tamperedMessage = \"This is a tampered message!\";\n        byte[] tamperedDigest = computeSha256Digest(tamperedMessage);\n        \n        // Try to verify with original signature\n        VerifyResult tamperedResult = cryptoClient.verify(\n                SignatureAlgorithm.RS256, \n                tamperedDigest, \n                signature);\n        \n        System.out.println(\"Tampered Message: \" + tamperedMessage);\n        System.out.println(\"Verification Result: \" + tamperedResult.isValid());\n        System.out.println(\"Expected: false (signature should NOT match)\\n\");\n    }\n\n    /**\n     * Cleans up by deleting the key (optional)\n     */\n    private static void cleanUp(KeyClient keyClient) {\n        System.out.println(\"--- Cleaning Up ---\");\n        \n        // Begin delete operation\n        keyClient.beginDeleteKey(KEY_NAME);\n        System.out.println(\"\u2713 Key deletion initiated: \" + KEY_NAME);\n        \n        // Note: The key goes into a \"deleted\" state and can be recovered\n        // To permanently delete, you need to purge it after deletion\n    }\n}\n```\n\n## Alternative Example with Different Signature Algorithms\n\n```java\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\n\npublic class SignatureAlgorithmExamples {\n    \n    /**\n     * Demonstrates different signature algorithms\n     */\n    public static void demonstrateAlgorithms(CryptographyClient cryptoClient, byte[] digest) {\n        System.out.println(\"=== Testing Different Signature Algorithms ===\\n\");\n        \n        // RS256 - RSA with SHA-256\n        testAlgorithm(cryptoClient, digest, SignatureAlgorithm.RS256, \"RS256 (RSA-SHA256)\");\n        \n        // RS384 - RSA with SHA-384\n        testAlgorithm(cryptoClient, digest, SignatureAlgorithm.RS384, \"RS384 (RSA-SHA384)\");\n        \n        // RS512 - RSA with SHA-512\n        testAlgorithm(cryptoClient, digest, SignatureAlgorithm.RS512, \"RS512 (RSA-SHA512)\");\n        \n        // PS256 - RSA PSS with SHA-256\n        testAlgorithm(cryptoClient, digest, SignatureAlgorithm.PS256, \"PS256 (RSA-PSS-SHA256)\");\n    }\n    \n    private static void testAlgorithm(\n            CryptographyClient cryptoClient, \n            byte[] digest, \n            SignatureAlgorithm algorithm,\n            String description) {\n        \n        try {\n            System.out.println(\"Testing: \" + description);\n            \n            // Sign\n            SignResult signResult = cryptoClient.sign(algorithm, digest);\n            \n            // Verify\n            VerifyResult verifyResult = cryptoClient.verify(\n                    algorithm, \n                    digest, \n                    signResult.getSignature());\n            \n            System.out.println(\"  Signed: \u2713\");\n            System.out.println(\"  Verified: \" + (verifyResult.isValid() ? \"\u2713\" : \"\u2717\"));\n            System.out.println();\n            \n        } catch (Exception e) {\n            System.out.println(\"  Error: \" + e.getMessage() + \"\\n\");\n        }\n    }\n}\n```\n\n## Configuration Options\n\n### Environment Variables for Authentication\n\nSet these environment variables for `DefaultAzureCredential`:\n\n```bash\n# Service Principal authentication\nexport AZURE_CLIENT_ID=\"your-client-id\"\nexport AZURE_CLIENT_SECRET=\"your-client-secret\"\nexport AZURE_TENANT_ID=\"your-tenant-id\"\n\n# Or use Azure CLI authentication\naz login\n```\n\n### Key Vault Access Policy\n\nEnsure your identity has these permissions:\n- **Key Permissions**: Get, Create, Sign, Verify\n\n## Running the Application\n\n```bash\n# Compile\njavac -cp \".:azure-security-keyvault-keys-4.6.0.jar:azure-identity-1.10.0.jar:...\" AzureKeyVaultSignVerifyExample.java\n\n# Run\njava -cp \".:azure-security-keyvault-keys-4.6.0.jar:azure-identity-1.10.0.jar:...\" AzureKeyVaultSignVerifyExample\n```\n\nOr with Maven:\n\n```bash\nmvn clean compile exec:java -Dexec.mainClass=\"AzureKeyVaultSignVerifyExample\"\n```\n\n## Expected Output\n\n```\n=== Azure Key Vault Keys SDK - Sign and Verify Example ===\n\n\u2713 KeyClient created successfully\n\u2713 RSA Key: my-rsa-signing-key\n  Key ID: https://your-keyvault-name.vault.azure.net/keys/my-rsa-signing-key/abc123...\n  Key Type: RSA\n\n\u2713 CryptographyClient created successfully\n\nOriginal Message: Hello, Azure Key Vault! This is a test message for signing.\nSHA-256 Digest: 5Fty8+...\n\n\u2713 Message signed successfully\n  Algorithm: RS256\n  Signature (Base64): MIIBIjANBg...\n\n\u2713 Signature verification completed\n  Is Valid: true\n  Algorithm: RS256\n\n--- Testing with Tampered Data ---\nTampered Message: This is a tampered message!\nVerification Result: false\nExpected: false (signature should NOT match)\n```\n\nThis example demonstrates the complete workflow of using Azure Key Vault Keys SDK for cryptographic signing operations!",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 67,
            "output_tokens": 3431,
            "cached": false
          },
          "with_skill": {
            "output": "# Azure Key Vault Keys - RSA Sign and Verify Application\n\nI'll create a complete Java application that demonstrates RSA key creation, signing, and verification using Azure Key Vault Keys SDK.\n\n## Project Structure\n\n```\nkeyvault-keys-demo/\n\u251c\u2500\u2500 pom.xml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u251c\u2500\u2500 java/\n\u2502       \u2502   \u2514\u2500\u2500 com/\n\u2502       \u2502       \u2514\u2500\u2500 azure/\n\u2502       \u2502           \u2514\u2500\u2500 keyvault/\n\u2502       \u2502               \u2514\u2500\u2500 demo/\n\u2502       \u2502                   \u251c\u2500\u2500 KeyVaultKeysDemo.java\n\u2502       \u2502                   \u251c\u2500\u2500 KeyVaultKeyManager.java\n\u2502       \u2502                   \u2514\u2500\u2500 SignatureVerifier.java\n\u2502       \u2514\u2500\u2500 resources/\n\u2502           \u2514\u2500\u2500 application.properties\n\u2514\u2500\u2500 README.md\n```\n\n## pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \n         http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.azure.keyvault</groupId>\n    <artifactId>keyvault-keys-demo</artifactId>\n    <version>1.0.0</version>\n    <packaging>jar</packaging>\n\n    <name>Azure Key Vault Keys Demo</name>\n    <description>Demo application for Azure Key Vault Keys SDK - RSA signing and verification</description>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <azure.keyvault.version>4.9.0</azure.keyvault.version>\n        <azure.identity.version>1.14.2</azure.identity.version>\n    </properties>\n\n    <dependencies>\n        <!-- Azure Key Vault Keys SDK -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-security-keyvault-keys</artifactId>\n            <version>${azure.keyvault.version}</version>\n        </dependency>\n\n        <!-- Azure Identity for authentication -->\n        <dependency>\n            <groupId>com.azure</groupId>\n            <artifactId>azure-identity</artifactId>\n            <version>${azure.identity.version}</version>\n        </dependency>\n\n        <!-- SLF4J API -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>2.0.16</version>\n        </dependency>\n\n        <!-- SLF4J Simple implementation for logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-simple</artifactId>\n            <version>2.0.16</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.13.0</version>\n                <configuration>\n                    <source>11</source>\n                    <target>11</target>\n                </configuration>\n            </plugin>\n            \n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.4.2</version>\n                <configuration>\n                    <archive>\n                        <manifest>\n                            <mainClass>com.azure.keyvault.demo.KeyVaultKeysDemo</mainClass>\n                        </manifest>\n                    </archive>\n                </configuration>\n            </plugin>\n\n            <!-- Maven Shade Plugin for creating fat JAR -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.6.0</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.azure.keyvault.demo.KeyVaultKeysDemo</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## KeyVaultKeyManager.java\n\n```java\npackage com.azure.keyvault.demo;\n\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.OffsetDateTime;\n\n/**\n * Manages Azure Key Vault key operations including creation and client initialization.\n */\npublic class KeyVaultKeyManager {\n    private static final Logger logger = LoggerFactory.getLogger(KeyVaultKeyManager.class);\n    \n    private final KeyClient keyClient;\n    private final String vaultUrl;\n\n    /**\n     * Creates a new KeyVaultKeyManager instance.\n     *\n     * @param vaultUrl The Azure Key Vault URL (e.g., https://myvault.vault.azure.net)\n     */\n    public KeyVaultKeyManager(String vaultUrl) {\n        if (vaultUrl == null || vaultUrl.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Vault URL cannot be null or empty\");\n        }\n        \n        this.vaultUrl = vaultUrl;\n        \n        logger.info(\"Initializing KeyClient for vault: {}\", vaultUrl);\n        \n        // Create KeyClient using DefaultAzureCredential\n        this.keyClient = new KeyClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        logger.info(\"KeyClient initialized successfully\");\n    }\n\n    /**\n     * Creates an RSA key in Azure Key Vault.\n     *\n     * @param keyName The name of the key to create\n     * @param keySize The size of the RSA key (2048, 3072, or 4096)\n     * @return The created KeyVaultKey\n     */\n    public KeyVaultKey createRsaKey(String keyName, int keySize) {\n        logger.info(\"Creating RSA key: {} with size: {}\", keyName, keySize);\n        \n        // Validate key size\n        if (keySize != 2048 && keySize != 3072 && keySize != 4096) {\n            throw new IllegalArgumentException(\n                \"Invalid key size. Must be 2048, 3072, or 4096. Got: \" + keySize\n            );\n        }\n        \n        try {\n            // Create RSA key options\n            CreateRsaKeyOptions keyOptions = new CreateRsaKeyOptions(keyName)\n                .setKeySize(keySize)\n                .setExpiresOn(OffsetDateTime.now().plusYears(1));\n            \n            // Create the key\n            KeyVaultKey key = keyClient.createRsaKey(keyOptions);\n            \n            logger.info(\"RSA key created successfully\");\n            logger.info(\"  Key ID: {}\", key.getId());\n            logger.info(\"  Key Name: {}\", key.getName());\n            logger.info(\"  Key Type: {}\", key.getKeyType());\n            logger.info(\"  Key Size: {} bits\", keySize);\n            \n            return key;\n        } catch (Exception e) {\n            logger.error(\"Failed to create RSA key: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Failed to create RSA key: \" + keyName, e);\n        }\n    }\n\n    /**\n     * Gets an existing key from Azure Key Vault.\n     *\n     * @param keyName The name of the key to retrieve\n     * @return The KeyVaultKey\n     */\n    public KeyVaultKey getKey(String keyName) {\n        logger.info(\"Retrieving key: {}\", keyName);\n        \n        try {\n            KeyVaultKey key = keyClient.getKey(keyName);\n            logger.info(\"Key retrieved successfully: {}\", key.getName());\n            return key;\n        } catch (Exception e) {\n            logger.error(\"Failed to retrieve key: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Failed to retrieve key: \" + keyName, e);\n        }\n    }\n\n    /**\n     * Creates a CryptographyClient for cryptographic operations.\n     *\n     * @param keyId The full key identifier (URL)\n     * @return A CryptographyClient instance\n     */\n    public CryptographyClient createCryptographyClient(String keyId) {\n        logger.info(\"Creating CryptographyClient for key: {}\", keyId);\n        \n        try {\n            CryptographyClient cryptoClient = new CryptographyClientBuilder()\n                .credential(new DefaultAzureCredentialBuilder().build())\n                .keyIdentifier(keyId)\n                .buildClient();\n            \n            logger.info(\"CryptographyClient created successfully\");\n            return cryptoClient;\n        } catch (Exception e) {\n            logger.error(\"Failed to create CryptographyClient: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Failed to create CryptographyClient\", e);\n        }\n    }\n\n    /**\n     * Deletes a key from Azure Key Vault.\n     *\n     * @param keyName The name of the key to delete\n     */\n    public void deleteKey(String keyName) {\n        logger.info(\"Deleting key: {}\", keyName);\n        \n        try {\n            keyClient.beginDeleteKey(keyName).waitForCompletion();\n            logger.info(\"Key deleted successfully: {}\", keyName);\n        } catch (Exception e) {\n            logger.error(\"Failed to delete key: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Failed to delete key: \" + keyName, e);\n        }\n    }\n\n    /**\n     * Purges a deleted key from Azure Key Vault (permanent deletion).\n     *\n     * @param keyName The name of the key to purge\n     */\n    public void purgeDeletedKey(String keyName) {\n        logger.info(\"Purging deleted key: {}\", keyName);\n        \n        try {\n            keyClient.purgeDeletedKey(keyName);\n            logger.info(\"Key purged successfully: {}\", keyName);\n        } catch (Exception e) {\n            logger.error(\"Failed to purge key: {}\", e.getMessage(), e);\n            // Don't throw - purge might fail if key doesn't exist\n            logger.warn(\"Continuing despite purge failure\");\n        }\n    }\n\n    /**\n     * Gets the KeyClient instance.\n     *\n     * @return The KeyClient\n     */\n    public KeyClient getKeyClient() {\n        return keyClient;\n    }\n\n    /**\n     * Gets the vault URL.\n     *\n     * @return The vault URL\n     */\n    public String getVaultUrl() {\n        return vaultUrl;\n    }\n}\n```\n\n## SignatureVerifier.java\n\n```java\npackage com.azure.keyvault.demo;\n\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\n/**\n * Handles message signing and signature verification using Azure Key Vault.\n */\npublic class SignatureVerifier {\n    private static final Logger logger = LoggerFactory.getLogger(SignatureVerifier.class);\n    \n    private final CryptographyClient cryptoClient;\n\n    /**\n     * Creates a new SignatureVerifier instance.\n     *\n     * @param cryptoClient The CryptographyClient to use for operations\n     */\n    public SignatureVerifier(CryptographyClient cryptoClient) {\n        if (cryptoClient == null) {\n            throw new IllegalArgumentException(\"CryptographyClient cannot be null\");\n        }\n        this.cryptoClient = cryptoClient;\n    }\n\n    /**\n     * Computes SHA-256 digest of a message.\n     *\n     * @param message The message to hash\n     * @return The SHA-256 digest as byte array\n     */\n    public byte[] computeDigest(String message) {\n        logger.info(\"Computing SHA-256 digest for message\");\n        \n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n            \n            logger.info(\"Digest computed successfully\");\n            logger.debug(\"Digest (Base64): {}\", Base64.getEncoder().encodeToString(hash));\n            \n            return hash;\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"SHA-256 algorithm not available\", e);\n            throw new RuntimeException(\"Failed to compute digest\", e);\n        }\n    }\n\n    /**\n     * Signs a message digest using the RSA key in Azure Key Vault.\n     *\n     * @param digest The message digest to sign\n     * @param algorithm The signature algorithm to use\n     * @return The SignResult containing the signature\n     */\n    public SignResult signDigest(byte[] digest, SignatureAlgorithm algorithm) {\n        logger.info(\"Signing digest with algorithm: {}\", algorithm);\n        \n        try {\n            SignResult signResult = cryptoClient.sign(algorithm, digest);\n            \n            logger.info(\"Digest signed successfully\");\n            logger.info(\"  Algorithm: {}\", signResult.getAlgorithm());\n            logger.info(\"  Key ID: {}\", signResult.getKeyId());\n            logger.info(\"  Signature length: {} bytes\", signResult.getSignature().length);\n            logger.debug(\"  Signature (Base64): {}\", \n                Base64.getEncoder().encodeToString(signResult.getSignature()));\n            \n            return signResult;\n        } catch (Exception e) {\n            logger.error(\"Failed to sign digest: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Failed to sign digest\", e);\n        }\n    }\n\n    /**\n     * Verifies a signature against a message digest.\n     *\n     * @param digest The original message digest\n     * @param signature The signature to verify\n     * @param algorithm The signature algorithm used\n     * @return The VerifyResult indicating if signature is valid\n     */\n    public VerifyResult verifySignature(byte[] digest, byte[] signature, SignatureAlgorithm algorithm) {\n        logger.info(\"Verifying signature with algorithm: {}\", algorithm);\n        \n        try {\n            ",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8136,
            "output_tokens": 4096,
            "cached": false
          },
          "skill_md_only": null,
          "realistic": {
            "output": "I'll create a Java application that uses Azure Key Vault Keys SDK to create an RSA key, sign a message, and verify the signature.\n\nFirst, let me add the required dependencies to your `pom.xml`:\n\n```xml\n<!-- Add these dependencies to your pom.xml -->\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-security-keyvault-keys</artifactId>\n    <version>4.8.0</version>\n</dependency>\n<dependency>\n    <groupId>com.azure</groupId>\n    <artifactId>azure-identity</artifactId>\n    <version>1.11.0</version>\n</dependency>\n```\n\nNow I'll create the application:\n\n```java\npackage com.example.app.keyvault;\n\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.keys.KeyClient;\nimport com.azure.security.keyvault.keys.KeyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClient;\nimport com.azure.security.keyvault.keys.cryptography.CryptographyClientBuilder;\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.SignatureAlgorithm;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport com.azure.security.keyvault.keys.models.CreateRsaKeyOptions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n/**\n * Application demonstrating Azure Key Vault Keys SDK usage for RSA key operations.\n * Creates an RSA key, signs a message digest, and verifies the signature.\n */\npublic class KeyVaultSignatureApp {\n    private static final Logger log = LoggerFactory.getLogger(KeyVaultSignatureApp.class);\n    \n    private final KeyClient keyClient;\n    private final String vaultUrl;\n    \n    public KeyVaultSignatureApp(String vaultUrl) {\n        this.vaultUrl = vaultUrl;\n        this.keyClient = new KeyClientBuilder()\n            .vaultUrl(vaultUrl)\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n        \n        log.info(\"Initialized KeyVaultSignatureApp with vault: {}\", vaultUrl);\n    }\n    \n    /**\n     * Creates an RSA key in Azure Key Vault.\n     * \n     * @param keyName Name of the key to create\n     * @param keySize Size of the RSA key (2048, 3072, or 4096)\n     * @return The created KeyVaultKey\n     */\n    public KeyVaultKey createRsaKey(String keyName, int keySize) {\n        log.info(\"Creating RSA key '{}' with size {}\", keyName, keySize);\n        \n        CreateRsaKeyOptions keyOptions = new CreateRsaKeyOptions(keyName)\n            .setKeySize(keySize);\n        \n        KeyVaultKey key = keyClient.createRsaKey(keyOptions);\n        \n        log.info(\"Created RSA key: {}\", key.getName());\n        log.info(\"Key ID: {}\", key.getId());\n        log.info(\"Key Type: {}\", key.getKeyType());\n        \n        return key;\n    }\n    \n    /**\n     * Computes SHA-256 digest of a message.\n     * \n     * @param message The message to hash\n     * @return The SHA-256 digest\n     */\n    public byte[] computeDigest(String message) throws NoSuchAlgorithmException {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = digest.digest(message.getBytes(StandardCharsets.UTF_8));\n        \n        log.info(\"Computed SHA-256 digest of message: '{}'\", message);\n        log.debug(\"Digest length: {} bytes\", hash.length);\n        \n        return hash;\n    }\n    \n    /**\n     * Signs a message digest using the RSA key in Key Vault.\n     * \n     * @param keyName Name of the key to use for signing\n     * @param digest The message digest to sign\n     * @return SignResult containing the signature\n     */\n    public SignResult signDigest(String keyName, byte[] digest) {\n        log.info(\"Signing digest with key '{}'\", keyName);\n        \n        // Create CryptographyClient for the specific key\n        CryptographyClient cryptoClient = new CryptographyClientBuilder()\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .keyIdentifier(vaultUrl + \"/keys/\" + keyName)\n            .buildClient();\n        \n        // Sign the digest using RS256 (RSA with SHA-256)\n        SignResult signResult = cryptoClient.sign(SignatureAlgorithm.RS256, digest);\n        \n        log.info(\"Successfully signed digest\");\n        log.info(\"Signature algorithm: {}\", signResult.getAlgorithm());\n        log.info(\"Signature length: {} bytes\", signResult.getSignature().length);\n        log.info(\"Key ID used: {}\", signResult.getKeyId());\n        \n        return signResult;\n    }\n    \n    /**\n     * Verifies a signature against a message digest.\n     * \n     * @param keyName Name of the key to use for verification\n     * @param digest The original message digest\n     * @param signature The signature to verify\n     * @return VerifyResult indicating if signature is valid\n     */\n    public VerifyResult verifySignature(String keyName, byte[] digest, byte[] signature) {\n        log.info(\"Verifying signature with key '{}'\", keyName);\n        \n        // Create CryptographyClient for the specific key\n        CryptographyClient cryptoClient = new CryptographyClientBuilder()\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .keyIdentifier(vaultUrl + \"/keys/\" + keyName)\n            .buildClient();\n        \n        // Verify the signature\n        VerifyResult verifyResult = cryptoClient.verify(\n            SignatureAlgorithm.RS256, \n            digest, \n            signature\n        );\n        \n        log.info(\"Signature verification result: {}\", verifyResult.isValid());\n        log.info(\"Algorithm used: {}\", verifyResult.getAlgorithm());\n        log.info(\"Key ID used: {}\", verifyResult.getKeyId());\n        \n        return verifyResult;\n    }\n    \n    /**\n     * Demonstrates the complete flow: create key, sign, and verify.\n     */\n    public void demonstrateSignatureFlow(String keyName, String message) {\n        try {\n            log.info(\"=== Starting Key Vault Signature Demonstration ===\");\n            log.info(\"Message to sign: '{}'\", message);\n            \n            // Step 1: Create RSA key\n            KeyVaultKey key = createRsaKey(keyName, 2048);\n            \n            // Step 2: Compute message digest\n            byte[] digest = computeDigest(message);\n            \n            // Step 3: Sign the digest\n            SignResult signResult = signDigest(keyName, digest);\n            byte[] signature = signResult.getSignature();\n            \n            // Step 4: Verify the signature\n            VerifyResult verifyResult = verifySignature(keyName, digest, signature);\n            \n            // Step 5: Display results\n            log.info(\"=== Signature Flow Complete ===\");\n            log.info(\"Key Name: {}\", key.getName());\n            log.info(\"Message: '{}'\", message);\n            log.info(\"Signature Valid: {}\", verifyResult.isValid());\n            \n            if (verifyResult.isValid()) {\n                log.info(\"\u2713 Signature verification PASSED\");\n            } else {\n                log.error(\"\u2717 Signature verification FAILED\");\n            }\n            \n            // Step 6: Test with tampered digest (should fail)\n            demonstrateTamperedVerification(keyName, digest, signature);\n            \n        } catch (Exception e) {\n            log.error(\"Error during signature flow: {}\", e.getMessage(), e);\n            throw new RuntimeException(\"Signature flow failed\", e);\n        }\n    }\n    \n    /**\n     * Demonstrates that verification fails with tampered data.\n     */\n    private void demonstrateTamperedVerification(String keyName, byte[] originalDigest, byte[] signature) {\n        try {\n            log.info(\"=== Testing Tampered Data ===\");\n            \n            // Create a tampered digest\n            byte[] tamperedDigest = originalDigest.clone();\n            tamperedDigest[0] = (byte) ~tamperedDigest[0]; // Flip bits in first byte\n            \n            VerifyResult tamperedResult = verifySignature(keyName, tamperedDigest, signature);\n            \n            log.info(\"Tampered digest verification result: {}\", tamperedResult.isValid());\n            \n            if (!tamperedResult.isValid()) {\n                log.info(\"\u2713 Correctly rejected tampered data\");\n            } else {\n                log.error(\"\u2717 SECURITY ISSUE: Accepted tampered data!\");\n            }\n            \n        } catch (Exception e) {\n            log.error(\"Error during tampered verification: {}\", e.getMessage());\n        }\n    }\n    \n    /**\n     * Cleans up by deleting the key (optional).\n     */\n    public void cleanup(String keyName) {\n        try {\n            log.info(\"Cleaning up: deleting key '{}'\", keyName);\n            keyClient.beginDeleteKey(keyName).waitForCompletion();\n            log.info(\"Key deleted successfully\");\n        } catch (Exception e) {\n            log.warn(\"Failed to delete key: {}\", e.getMessage());\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Get vault URL from environment variable\n        String vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        if (vaultUrl == null || vaultUrl.isEmpty()) {\n            System.err.println(\"ERROR: AZURE_KEYVAULT_URL environment variable not set\");\n            System.err.println(\"Set it to: https://<your-vault-name>.vault.azure.net\");\n            System.exit(1);\n        }\n        \n        // Create application instance\n        KeyVaultSignatureApp app = new KeyVaultSignatureApp(vaultUrl);\n        \n        // Run demonstration\n        String keyName = \"demo-rsa-key-\" + System.currentTimeMillis();\n        String message = \"This is a secret message that needs to be signed\";\n        \n        try {\n            app.demonstrateSignatureFlow(keyName, message);\n            \n            // Optional: Clean up the key\n            // app.cleanup(keyName);\n            \n        } catch (Exception e) {\n            log.error(\"Application failed: {}\", e.getMessage(), e);\n            System.exit(1);\n        }\n    }\n}\n```\n\nNow let me create a test class for this application:\n\n```java\npackage com.example.app.keyvault;\n\nimport com.azure.security.keyvault.keys.cryptography.models.SignResult;\nimport com.azure.security.keyvault.keys.cryptography.models.VerifyResult;\nimport com.azure.security.keyvault.keys.models.KeyVaultKey;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;\n\nimport java.security.NoSuchAlgorithmException;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * Integration tests for KeyVaultSignatureApp.\n * Requires AZURE_KEYVAULT_URL environment variable to be set.\n */\n@EnabledIfEnvironmentVariable(named = \"AZURE_KEYVAULT_URL\", matches = \".+\")\nclass KeyVaultSignatureAppTest {\n    \n    private KeyVaultSignatureApp app;\n    private String vaultUrl;\n    private String testKeyName;\n    \n    @BeforeEach\n    void setUp() {\n        vaultUrl = System.getenv(\"AZURE_KEYVAULT_URL\");\n        app = new KeyVaultSignatureApp(vaultUrl);\n        testKeyName = \"test-rsa-key-\" + System.currentTimeMillis();\n    }\n    \n    @Test\n    void testCreateRsaKey() {\n        // Create RSA key\n        KeyVaultKey key = app.createRsaKey(testKeyName, 2048);\n        \n        // Verify key properties\n        assertNotNull(key);\n        assertEquals(testKeyName, key.getName());\n        assertNotNull(key.getId());\n        assertEquals(\"RSA\", key.getKeyType().toString());\n        \n        // Cleanup\n        app.cleanup(testKeyName);\n    }\n    \n    @Test\n    void testComputeDigest() throws NoSuchAlgorithmException {\n        String message = \"Test message\";\n        \n        byte[] digest = app.computeDigest(message);\n        \n        assertNotNull(digest);\n        assertEquals(32, digest.length); // SHA-256 produces 32 bytes\n    }\n    \n    @Test\n    void testSignAndVerify() throws NoSuchAlgorithmException {\n        // Setup\n        app.createRsaKey(testKeyName, 2048);\n        String message = \"Test message for signing\";\n        byte[] digest = app.computeDigest(message);\n        \n        // Sign\n        SignResult signResult = app.signDigest(testKeyName, digest);\n        assertNotNull(signResult);\n        assertNotNull(signResult.getSignature());\n        assertTrue(signResult.getSignature().length > 0);\n        \n        // Verify\n        VerifyResult verifyResult = app.verifySignature(\n            testKeyName, \n            digest, \n            signResult.getSignature()\n        );\n        \n        assertNotNull(verifyResult);\n        assertTrue(verifyResult.isValid(), \"Signature should be valid\");\n        \n        // Cleanup\n        app.cleanup(testKeyName);\n    }\n    \n    @Test\n    void testVerifyFailsWithTamperedDigest() throws NoSuchAlgorithmException {\n        // Setup\n        app.createRsaKey(testKeyName, 2048);\n        String message = \"Test message\";\n        byte[] digest = app.computeDigest(message);\n        \n        // Sign\n        SignResult signResult = app.signDigest(testKeyName, digest);\n        \n        // Tamper with digest\n        byte[] tamperedDigest = digest.clone();\n        tamperedDigest[0] = (byte) ~tamperedDigest[0];\n        \n        // Verify should fail\n        VerifyResult verifyResult = app.verifySignature(\n            testKeyName, \n            tamperedDigest, \n            signResult.getSignature()\n        );\n        \n        assertNotNull(verifyResult);\n        assertFalse(verifyResult.isValid(), \"Signature should be invalid for tampered digest\");\n        \n        // Cleanup\n        app.cleanup(testKeyName);\n    }\n    \n    @Test\n    void testCompleteSignatureFlow() {\n        String message = \"Complete flow test message\";\n        \n        // Should not throw exception\n        assertDoesNotThrow(() -> {\n            app.demonstrateSignatureFlow(testKeyName, message);\n        });\n        \n        // Cleanup\n        app.cleanup(testKeyName);\n    }\n}\n```\n\nFinally, let me create a README with usage instructions:\n\n```markdown\n# Azure Key Vault Keys SDK - Signature Demo\n\nThis application demonstrates using Azure Key Vault Keys SDK to:\n1. Create an RSA key in Azure Key Vault\n2. Sign a message digest with the key\n3. Verify the signature\n\n## Prerequisites\n\n1. **Azure Key Vault**: Create a Key Vault in Azure\n2. **Authentication**: Configure Azure credentials (one of):\n   - Azure CLI: `az login`\n   - Environment variables: `AZURE_CLIENT_ID`, `AZURE_CLIENT_SECRET`, `AZURE_TENANT_ID`\n   - Managed Identity (when running in Azure)\n\n3. **Permissions**: Ensure your identity has these Key Vault permissions:\n   - Keys: Create",
            "model": "claude-sonnet-4-5-20250929",
            "input_tokens": 8661,
            "output_tokens": 4096,
            "cached": false
          }
        }
      ]
    }
  ]
}